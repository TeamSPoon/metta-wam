<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"
>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"
>
<title></title>
<style type="text/css"
>
.ansi2html-content { display: inline; white-space: pre-wrap; word-wrap: break-word; }
.body_foreground { color: #AAAAAA; }
.body_background { background-color: #000000; }
.inv_foreground { color: #000000; }
.inv_background { background-color: #AAAAAA; }
.ansi1 { font-weight: bold; }
.ansi31 { color: #aa0000; }
.ansi32 { color: #00aa00; }
.ansi36 { color: #00aaaa; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
</style>
</head>
<body class="body_foreground body_background" style="font-size: normal;" >
<pre class="ansi2html-content"
>
Script started on 2024-10-01 01:09:21+00:00 [TERM="xterm-256color" TTY="/dev/pts/0" COLUMNS="-1" LINES="-1"]
P;HTML|
;           (set_option_value  prolog false)

P;HTML|
;           (set_option_value  compat auto)

P;HTML|
;           (set_option_value  compatio true)
P;HTML|
;            (is_cmd_option  prescan halt --halt=true true)
P;HTML|
;            (set_option_value  halt true)
P;HTML|
;            (is_cmd_option  prescan stdin --stdin=tty tty)
P;HTML|
;             (set_option_value  stdin tty)
P;HTML|
;            (is_cmd_option  prescan stdout --stdout=tty tty)
P;HTML|
;             (set_option_value  stdout tty)
P;HTML|
;            (is_cmd_option  prescan stderr --stderr=tty tty)
P;HTML|
;             (set_option_value  stderr tty)
P;HTML|
;            (set_option_value  prolog false)
P;HTML|
;            (set_option_value  compat auto)
P;HTML|
;            (set_option_value  compatio true)
P;HTML|
;          (is_cmd_option  execute python --python=enable enable)
P;HTML|
;           (set_option_value  python enable)
P;HTML|
;          (is_cmd_option  execute timeout --timeout=40 40)
P;HTML|
;           (set_option_value  timeout 40)
P;HTML|
;           (is_cmd_option  execute output --output=./reports/tests_output/baseline-compat-2024-10-01T00:37:26/ ./reports/tests_output/baseline-compat-2024-10-01T00:37:26/)
P;HTML|
;           (set_option_value  output ./reports/tests_output/baseline-compat-2024-10-01T00:37:26/)
P;HTML|
;           (is_cmd_option  execute html --html true)
P;HTML|
;            (set_option_value  html true)
P;HTML|
;           (is_cmd_option  execute test --test true)
P;HTML|
;            (set_option_value  test true)

; (load_metta_file  &self tests/extended_compat/metta-examples/strips/strips-to-metta-improved/queries.metta)
P;HTML|
;                         (track_load_into_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/metta-examples/strips/strips-to-metta-improved/queries.metta)
P;HTML|
;                                          (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/metta-examples/strips/strips-to-metta-improved/queries.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/metta-examples/strips/strips-to-metta-improved/queries.metta)
P;HTML|
;                                           (= 1  "timeout: failed to run command 'time': No such file or directory")
P;HTML|
;                                          (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/metta-examples/strips/strips-to-metta-improved/queries.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/metta-examples/strips/strips-to-metta-improved/queries.metta)
P;HTML|
;                                           (= 1  "timeout: failed to run command 'time': No such file or directory")

;;; !(import! &self logistics-i-1)
;;; !(import! &self blocks-i-1)
<span class="ansi38-013099040"
>  !(import! &self blocks-i-0)

</span>[P;HTML|
;                                           (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/metta-examples/strips/strips-to-metta-improved/blocks-i-0.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/metta-examples/strips/strips-to-metta-improved/blocks-i-0.metta)
P;HTML|
;                                           (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/metta-examples/strips/strips-to-metta-improved/blocks-i-0.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/metta-examples/strips/strips-to-metta-improved/blocks-i-0.metta)
<span class="ansi38-255165000"
>  (domain BLOCKS)
</span><span class="ansi38-255165000"
>  (type object)
</span><span class="ansi38-255165000"
>  (predicate ontable)
</span><span class="ansi38-255165000"
>  (arity ontable 1)
</span><span class="ansi38-255165000"
>  (types ontable 
    (object))
</span><span class="ansi38-255165000"
>  (predicate holding)
</span><span class="ansi38-255165000"
>  (arity holding 1)
</span><span class="ansi38-255165000"
>  (types holding 
    (object))
</span><span class="ansi38-255165000"
>  (predicate clear)
</span><span class="ansi38-255165000"
>  (arity clear 1)
</span><span class="ansi38-255165000"
>  (types clear 
    (object))
</span><span class="ansi38-255165000"
>  (predicate on)
</span><span class="ansi38-255165000"
>  (arity on 2)
</span><span class="ansi38-255165000"
>  (types on 
    ('object,' object))
</span><span class="ansi38-255165000"
>  (predicate handempty)
</span><span class="ansi38-255165000"
>  (arity handempty 0)
</span><span class="ansi38-255165000"
>  (types handempty ())
</span><span class="ansi38-255165000"
>  (action pick-up)
</span><span class="ansi38-255165000"
>  (types pick-up 
    (object))
</span><span class="ansi38-255165000"
>  (= 
    (pre (pick-up $x)) 
    (superpose ((clear $x) (ontable $x) (handempty))))
</span><span class="ansi38-255165000"
>  (= 
    (eff-pos (pick-up $x)) 
    (superpose ((holding $x))))
</span><span class="ansi38-255165000"
>  (= 
    (eff-neg (pick-up $x)) 
    (superpose ((ontable $x) (clear $x) (handempty))))
</span><span class="ansi38-255165000"
>  (action put-down)
</span><span class="ansi38-255165000"
>  (types put-down 
    (object))
</span><span class="ansi38-255165000"
>  (= 
    (pre (put-down $x)) 
    (superpose ((holding $x))))
</span><span class="ansi38-255165000"
>  (= 
    (eff-pos (put-down $x)) 
    (superpose ((clear $x) (handempty) (ontable $x))))
</span><span class="ansi38-255165000"
>  (= 
    (eff-neg (put-down $x)) 
    (superpose ((holding $x))))
</span><span class="ansi38-255165000"
>  (action stack)
</span><span class="ansi38-255165000"
>  (types stack 
    (object object))
</span><span class="ansi38-255165000"
>  (= 
    (pre (stack $x $y)) 
    (superpose ((holding $x) (clear $y))))
</span><span class="ansi38-255165000"
>  (= 
    (eff-pos (stack $x $y)) 
    (superpose ((clear $x) (handempty) (on $x $y))))
</span><span class="ansi38-255165000"
>  (= 
    (eff-neg (stack $x $y)) 
    (superpose ((holding $x) (clear $y))))
</span><span class="ansi38-255165000"
>  (action unstack)
</span><span class="ansi38-255165000"
>  (types unstack 
    (object object))
</span><span class="ansi38-255165000"
>  (= 
    (pre (unstack $x $y)) 
    (superpose ((on $x $y) (clear $x) (handempty))))
</span><span class="ansi38-255165000"
>  (= 
    (eff-pos (unstack $x $y)) 
    (superpose ((holding $x) (clear $y))))
</span><span class="ansi38-255165000"
>  (= 
    (eff-neg (unstack $x $y)) 
    (superpose ((clear $x) (handempty) (on $x $y))))
</span><span class="ansi38-255165000"
>  (problem BLOCKS-3-0)
</span><span class="ansi38-255165000"
>  (object C)
</span><span class="ansi38-255165000"
>  (isa C object)
</span><span class="ansi38-255165000"
>  (object B)
</span><span class="ansi38-255165000"
>  (isa B object)
</span><span class="ansi38-255165000"
>  (object A)
</span><span class="ansi38-255165000"
>  (isa A object)
</span><span class="ansi38-255165000"
>  (init state 0)
</span><span class="ansi38-255165000"
>  (= 
    (valuation (state 0)) 
    (superpose ((ontable B) (clear B) (ontable C) (clear C) (ontable A) (handempty) (clear A))))
</span><span class="ansi38-255165000"
>  (goal (and (on C B) (on B A)))
</span>
Deterministic: ()
()]
;;; UTILITY FUNCTIONS
<span class="ansi38-255165000"
>  (= 
    (fmap $f 
      ($a $x $y)) 
    ($a 
      ($f $x) 
      ($f $y)))
</span>;;; return True if $subset ⊆ $set, otherwise False
<span class="ansi38-255165000"
>  (= 
    (subset $subset $set) 
    (if 
      (== 
        (collapse (subtraction (superpose $subset) (intersection (superpose $set) (superpose $subset)))) ()) True False))
</span><span class="ansi38-013099040"
>  !(assertEqual 
    (subset 
      (a b) 
      (a b c)) True)

</span>[

;<h3 id="STRIPS-TO-METTA-IMPROVED.QUERIES.01"
>;; STRIPS-TO-METTA-IMPROVED.QUERIES.01</h3>
; 
; EVAL TEST
; took 0.053 secs. (52.73 milliseconds) 

  !(assertEqual 
    (subset 
      (a b) 
      (a b c)) True)

<span class="ansi36"
>  (loonit_success  
    (equal_enough_for_test  
      (True) 
      (True)))
</span>
Deterministic: ()
()]
<span class="ansi38-013099040"
>  !(assertEqual 
    (subset 
      (a b c) 
      (a b d)) False)

</span>[

;<h3 id="STRIPS-TO-METTA-IMPROVED.QUERIES.02"
>;; STRIPS-TO-METTA-IMPROVED.QUERIES.02</h3>
; 
; EVAL TEST
; took 0.003 secs. (3.41 milliseconds) 

  !(assertEqual 
    (subset 
      (a b c) 
      (a b d)) False)

<span class="ansi36"
>  (loonit_success  
    (equal_enough_for_test  
      (False) 
      (False)))
</span>
Deterministic: ()
()]
<span class="ansi38-013099040"
>  !(assertEqual 
    (subset 
      (collapse (pre (pick-up A))) 
      (collapse (valuation (state 0)))) True)

</span>[

;<h3 id="STRIPS-TO-METTA-IMPROVED.QUERIES.03"
>;; STRIPS-TO-METTA-IMPROVED.QUERIES.03</h3>
; 
; EVAL TEST
; took 0.031 secs. (30.97 milliseconds) 

  !(assertEqual 
    (subset 
      (collapse (pre (pick-up A))) 
      (collapse (valuation (state 0)))) True)

<span class="ansi36"
>  (loonit_success  
    (equal_enough_for_test  
      (True) 
      (True)))
</span>
Deterministic: ()
()]
;;; equality of two sets, returns True iff s1 == s2
<span class="ansi38-255165000"
>  (= 
    (seteq $set1 $set2) 
    (and 
      (subset $set1 $set2) 
      (subset $set2 $set1)))
</span><span class="ansi38-013099040"
>  !(assertEqual 
    (seteq 
      (a b c) 
      (b c a)) True)

</span>[

;<h3 id="STRIPS-TO-METTA-IMPROVED.QUERIES.04"
>;; STRIPS-TO-METTA-IMPROVED.QUERIES.04</h3>
; 
; EVAL TEST
; took 0.006 secs. (6.17 milliseconds) 

  !(assertEqual 
    (seteq 
      (a b c) 
      (b c a)) True)

<span class="ansi36"
>  (loonit_success  
    (equal_enough_for_test  
      (True) 
      (True)))
</span>
Deterministic: ()
()]
<span class="ansi38-013099040"
>  !(assertEqual 
    (seteq 
      (a b c d) 
      (b c a)) False)

</span>[

;<h3 id="STRIPS-TO-METTA-IMPROVED.QUERIES.05"
>;; STRIPS-TO-METTA-IMPROVED.QUERIES.05</h3>
; 
; EVAL TEST
; took 0.005 secs. (4.64 milliseconds) 

  !(assertEqual 
    (seteq 
      (a b c d) 
      (b c a)) False)

<span class="ansi36"
>  (loonit_success  
    (equal_enough_for_test  
      (False) 
      (False)))
</span>
Deterministic: ()
()]
;;; GET PROPOSTITIONS THAT HOLD IN A STATE
<span class="ansi38-013099040"
>  !(assertEqual 
    (valuation (state 0)) 
    (superpose ((ontable A) (ontable B) (ontable C) (clear A) (clear B) (clear C) (handempty))))

</span>[

;<h3 id="STRIPS-TO-METTA-IMPROVED.QUERIES.06"
>;; STRIPS-TO-METTA-IMPROVED.QUERIES.06</h3>
; 
; EVAL TEST
; took 0.004 secs. (3.95 milliseconds) 

  !(assertEqual 
    (valuation (state 0)) 
    (superpose ((ontable A) (ontable B) (ontable C) (clear A) (clear B) (clear C) (handempty))))

<span class="ansi36"
>  (loonit_success  
    (equal_enough_for_test  
      ( (ontable B) 
        (clear B) 
        (ontable C) 
        (clear C) 
        (ontable A) 
        (handempty) 
        (clear A)) 
      ( (ontable A) 
        (ontable B) 
        (ontable C) 
        (clear A) 
        (clear B) 
        (clear C) 
        (handempty))))
</span>
Deterministic: ()
()]
;;; GET ARITY OF A PROPOSITION
<span class="ansi38-255165000"
>  (= 
    (arity $prop) 
    (match &self 
      (arity $prop $n) $n))
</span><span class="ansi38-013099040"
>  !(assertEqual 
    (arity on) 2)

</span>[

;<h3 id="STRIPS-TO-METTA-IMPROVED.QUERIES.07"
>;; STRIPS-TO-METTA-IMPROVED.QUERIES.07</h3>
; 
; EVAL TEST
; took 0.000485 secs. (485.45 microseconds) 

  !(assertEqual 
    (arity on) 2)

<span class="ansi36"
>  (loonit_success  
    (equal_enough_for_test  
      (2) 
      (2)))
</span>
Deterministic: ()
()]
;;; EXECUTE ACTION ON STATE
;;; apply an action on a state and get the resulting state
<span class="ansi38-255165000"
>  (= 
    (eval 
      (state $idx) $action) 
    (union 
      (subtraction 
        (valuation (state $idx)) 
        (eff-neg $action)) 
      (eff-pos $action)))
</span><span class="ansi38-013099040"
>  !(assertEqual 
    (eff-pos (pick-up A)) 
    (superpose ((holding A))))

</span>[

;<h3 id="STRIPS-TO-METTA-IMPROVED.QUERIES.08"
>;; STRIPS-TO-METTA-IMPROVED.QUERIES.08</h3>
; 
; EVAL TEST
; took 0.001 secs. (1.16 milliseconds) 

  !(assertEqual 
    (eff-pos (pick-up A)) 
    (superpose ((holding A))))

<span class="ansi36"
>  (loonit_success  
    (equal_enough_for_test  
      ( (holding A)) 
      ( (holding A))))
</span>
Deterministic: ()
()]
<span class="ansi38-013099040"
>  !(assertEqual 
    (eff-neg (pick-up A)) 
    (superpose ((ontable A) (clear A) (handempty))))

</span>[

;<h3 id="STRIPS-TO-METTA-IMPROVED.QUERIES.09"
>;; STRIPS-TO-METTA-IMPROVED.QUERIES.09</h3>
; 
; EVAL TEST
; took 0.002 secs. (1.96 milliseconds) 

  !(assertEqual 
    (eff-neg (pick-up A)) 
    (superpose ((ontable A) (clear A) (handempty))))

<span class="ansi36"
>  (loonit_success  
    (equal_enough_for_test  
      ( (ontable A) 
        (clear A) 
        (handempty)) 
      ( (ontable A) 
        (clear A) 
        (handempty))))
</span>
Deterministic: ()
()]
<span class="ansi38-013099040"
>  !(assertEqual 
    (eval 
      (state 0) 
      (pick-up A)) 
    (superpose ((holding A) (ontable C) (clear B) (ontable B) (clear C))))

</span>[

;<h3 id="STRIPS-TO-METTA-IMPROVED.QUERIES.10"
>;; STRIPS-TO-METTA-IMPROVED.QUERIES.10</h3>
; 
; EVAL TEST
; took 0.014 secs. (14.10 milliseconds) 

  !(assertEqual 
    (eval 
      (state 0) 
      (pick-up A)) 
    (superpose ((holding A) (ontable C) (clear B) (ontable B) (clear C))))

<span class="ansi36"
>  (loonit_success  
    (equal_enough_for_test  
      ( (ontable B) 
        (clear B) 
        (ontable C) 
        (clear C) 
        (holding A)) 
      ( (holding A) 
        (ontable C) 
        (clear B) 
        (ontable B) 
        (clear C))))
</span>
Deterministic: ()
()]
;;; SAVE NEW STATE
<span class="ansi38-013099040"
>  !(bind! state# 
    (new-state 1))

</span>

Deterministic: ()
[()]
<span class="ansi38-255165000"
>  (= 
    (idx) 
    (- 
      (get-state state#) 1))
</span>;;; adds the state atom to the atom space (also if it already exists)
<span class="ansi38-255165000"
>  (= 
    (save $conditions) 
    (let* 
      ( ($current_id (get-state state#)) 
        ($_1 (add-atom &self (= (valuation (state $current_id)) (superpose $conditions)))) 
        ($_2 (change-state! state# (+ (get-state state#) 1)))) $current_id))
</span><span class="ansi38-013099040"
>  !(save ((holding A) (ontable B) (ontable C) (clear B) (clear C)))

</span>
<no-results>

[]
;;;!(save ((test s2) (on smt smt)))
<span class="ansi38-013099040"
>  !(assertEqual 
    (valuation (state 1)) 
    (superpose ((holding A) (ontable B) (ontable C) (clear B) (clear C))))

</span>[

;<h3 id="STRIPS-TO-METTA-IMPROVED.QUERIES.11"
>;; STRIPS-TO-METTA-IMPROVED.QUERIES.11</h3>
; 
; EVAL TEST
; took 0.002 secs. (1.99 milliseconds) 

  !(assertEqual 
    (valuation (state 1)) 
    (superpose ((holding A) (ontable B) (ontable C) (clear B) (clear C))))

<span class="ansi31"
>  (loonit_failureR  
    (equal_enough_for_test  
      ( (valuation (state 1))) 
      ( (holding A) 
        (ontable B) 
        (ontable C) 
        (clear B) 
        (clear C))))
</span>
Deterministic: ((Error  (got  ((valuation (state 1)))) (expected  ((holding A) (ontable B) (ontable C) (clear B) (clear C)))))
((Error  (got  ((valuation (state 1)))) (expected  ((holding A) (ontable B) (ontable C) (clear B) (clear C)))))]
;;;!(assertEqual (valuation (state 2))
;;;              (superpose ((test s2) (on smt smt))))
<span class="ansi38-013099040"
>  !(assertEqual 
    (seteq 
      (collapse (valuation (state 0))) 
      ( (ontable A) 
        (ontable B) 
        (ontable C) 
        (clear A) 
        (clear B) 
        (clear C) 
        (handempty))) True)

</span>[

;<h3 id="STRIPS-TO-METTA-IMPROVED.QUERIES.12"
>;; STRIPS-TO-METTA-IMPROVED.QUERIES.12</h3>
; 
; EVAL TEST
; took 0.143 secs. (142.59 milliseconds) 

  !(assertEqual 
    (seteq 
      (collapse (valuation (state 0))) 
      ( (ontable A) 
        (ontable B) 
        (ontable C) 
        (clear A) 
        (clear B) 
        (clear C) 
        (handempty))) True)

<span class="ansi36"
>  (loonit_success  
    (equal_enough_for_test  
      (True) 
      (True)))
</span>
Deterministic: ()
()]
<span class="ansi38-013099040"
>  !(assertEqual 
    (match &self 
      (= 
        (valuation (state $idx)) $props) 
      (if 
        (seteq 
          (collapse $props) 
          (collapse (valuation (state 0)))) $idx 
        (empty))) 0)

</span>[

;<h3 id="STRIPS-TO-METTA-IMPROVED.QUERIES.13"
>;; STRIPS-TO-METTA-IMPROVED.QUERIES.13</h3>
; 
; EVAL TEST
; took 0.145 secs. (144.51 milliseconds) 

  !(assertEqual 
    (match &self 
      (= 
        (valuation (state $idx)) $props) 
      (if 
        (seteq 
          (collapse $props) 
          (collapse (valuation (state 0)))) $idx 
        (empty))) 0)

<span class="ansi36"
>  (loonit_success  
    (equal_enough_for_test  
      (0) 
      (0)))
</span>
Deterministic: ()
()]
;;; return index of the state in which certain propositions hold
<span class="ansi38-255165000"
>  (= 
    (find_state $props) 
    (match &self 
      (= 
        (valuation (state $idx)) $props2) 
      (if 
        (seteq $props 
          (collapse $props2)) $idx 
        (empty))))
</span><span class="ansi38-013099040"
>  !(assertEqual 
    (find_state (collapse (valuation (state 0)))) 0)

</span>[

;<h3 id="STRIPS-TO-METTA-IMPROVED.QUERIES.14"
>;; STRIPS-TO-METTA-IMPROVED.QUERIES.14</h3>
; 
; EVAL TEST
; took 0.147 secs. (146.80 milliseconds) 

  !(assertEqual 
    (find_state (collapse (valuation (state 0)))) 0)

<span class="ansi36"
>  (loonit_success  
    (equal_enough_for_test  
      (0) 
      (0)))
</span>
Deterministic: ()
()]
<span class="ansi38-013099040"
>  !(assertEqual 
    (find_state ((ontable A) (ontable B) (ontable C) (clear A) (clear B) (clear C) (handempty))) 0)

</span>[

;<h3 id="STRIPS-TO-METTA-IMPROVED.QUERIES.15"
>;; STRIPS-TO-METTA-IMPROVED.QUERIES.15</h3>
; 
; EVAL TEST
; took 0.144 secs. (143.82 milliseconds) 

  !(assertEqual 
    (find_state ((ontable A) (ontable B) (ontable C) (clear A) (clear B) (clear C) (handempty))) 0)

<span class="ansi36"
>  (loonit_success  
    (equal_enough_for_test  
      (0) 
      (0)))
</span>
Deterministic: ()
()]
;;; !(assertEqual (find_state (a b c))
;;;              (empty))
;;; !(==  (Empty (find_state (a b c))) True)
;;; only save a state if the it does not exist yet, otherwise return state index
<span class="ansi38-255165000"
>  (= 
    (save_if_new $conditions) 
    (case 
      (find_state $conditions) 
      ( ( (save $conditions)) ($idx $idx))))
</span>;;; !(assertEqual (save_if_new ((test s3)))
;;;               (- (get-state state#) 1))
;;; !(assertEqual (valuation (state (- (get-state state#) 1)))
;;;               (superpose ((test s3))))
<span class="ansi38-013099040"
>  !(assertEqual 
    (save_if_new ((ontable A) (ontable B) (ontable C) (clear A) (clear B) (clear C) (handempty))) 0)

</span>[

;<h3 id="STRIPS-TO-METTA-IMPROVED.QUERIES.16"
>;; STRIPS-TO-METTA-IMPROVED.QUERIES.16</h3>
; 
; EVAL TEST
; took 0.146 secs. (145.82 milliseconds) 

  !(assertEqual 
    (save_if_new ((ontable A) (ontable B) (ontable C) (clear A) (clear B) (clear C) (handempty))) 0)

<span class="ansi36"
>  (loonit_success  
    (equal_enough_for_test  
      (0) 
      (0)))
</span>
Deterministic: ()
()]
;;; GET ALL STATE NUMBERS AS SANITY CHECK
<span class="ansi38-013099040"
>  !(assertEqual 
    (match &self 
      (= 
        (valuation (state $n)) $r) $n) 
    (superpose (0 1)))

</span>[

;<h3 id="STRIPS-TO-METTA-IMPROVED.QUERIES.17"
>;; STRIPS-TO-METTA-IMPROVED.QUERIES.17</h3>
; 
; EVAL TEST
; took 0.000257 secs. (256.78 microseconds) 

  !(assertEqual 
    (match &self 
      (= 
        (valuation (state $n)) $r) $n) 
    (superpose (0 1)))

<span class="ansi31"
>  (loonit_failureR  
    (equal_enough_for_test  
      (0) 
      (0 1)))
</span>
Deterministic: ((Error  (got  (0)) (expected  (0 1))))
((Error  (got  (0)) (expected  (0 1))))]
;;; EXAMPLE: STACK BLOCKS A AND B
;;; in the initial state all blocks lie on the table
;;; pick up A
<span class="ansi38-013099040"
>  !(assertEqual 
    (valuation (state (save (collapse (eval (state 0) (pick-up A)))))) 
    (superpose ((holding A) (ontable B) (ontable C) (clear B) (clear C))))

</span>[

;<h3 id="STRIPS-TO-METTA-IMPROVED.QUERIES.18"
>;; STRIPS-TO-METTA-IMPROVED.QUERIES.18</h3>
; 
; EVAL TEST
; took 0.033 secs. (32.77 milliseconds) 

  !(assertEqual 
    (valuation (state (save (collapse (eval (state 0) (pick-up A)))))) 
    (superpose ((holding A) (ontable B) (ontable C) (clear B) (clear C))))

<span class="ansi31"
>  (loonit_failureR  
    (equal_enough_for_test  
      ( (valuation (state (save (collapse (eval (state 0) (pick-up A))))))) 
      ( (holding A) 
        (ontable B) 
        (ontable C) 
        (clear B) 
        (clear C))))
</span>
Deterministic: ((Error  (got  ((valuation (state (save (collapse (eval (state 0) (pick-up A)))))))) (expected  ((holding A) (ontable B) (ontable C) (clear B) (clear C)))))
((Error  (got  ((valuation (state (save (collapse (eval (state 0) (pick-up A)))))))) (expected  ((holding A) (ontable B) (ontable C) (clear B) (clear C)))))]
;;; stack A on B
<span class="ansi38-013099040"
>  !(assertEqual 
    (valuation (state (save (collapse (eval (state (idx)) (stack A B)))))) 
    (superpose ((on A B) (handempty) (clear A) (clear C) (ontable B) (ontable C))))

</span>[

;<h3 id="STRIPS-TO-METTA-IMPROVED.QUERIES.19"
>;; STRIPS-TO-METTA-IMPROVED.QUERIES.19</h3>


  (failed  once 
    (if_or_else  
      (eval  = $_9222 491 &self 
        (get-state state#) $_9236) 
      (call  eval 
        (get-state state#) $_9236)))




  (failed  once 
    (if_or_else  
      (eval  = $_9222 491 &self 
        (get-state state#) $_9236) 
      (call  eval 
        (get-state state#) $_9236)))


^  <span class="ansi1 ansi32"
>Call: </span>(380) [user] call(user:once, user:if_or_else(eval(=, _9222, 491, '&self', ['get-state', 'state#'], _9236), call(eval, ['get-state', 'state#'], _9236)))
^  <span class="ansi1 ansi32"
>Call: </span>(381) [user] once(user:if_or_else(eval(=, _9222, 491, '&self', ['get-state', 'state#'], _9236), call(eval, ['get-state', 'state#'], _9236)))
   <span class="ansi1 ansi32"
>Call: </span>(382) [user] if_or_else(eval(=, _9222, 491, '&self', ['get-state', 'state#'], _9236), call(eval, ['get-state', 'state#'], _9236))
^  <span class="ansi1 ansi32"
>Call: </span>(383) [user] eval(=, _9222, 491, '&self', ['get-state', 'state#'], _9236)
^  <span class="ansi1 ansi32"
>Call: </span>(384) [user] catch_metta_return(eval_args(=, _9222, 491, '&self', ['get-state', 'state#'], _9236), _9236)
^  <span class="ansi1 ansi32"
>Call: </span>(386) [user] eval_args(=, _9222, 491, '&self', ['get-state', 'state#'], _9236)
   <span class="ansi1 ansi32"
>Call: </span>(387) [system] var(['get-state', 'state#'])
^  <span class="ansi1 ansi32"
>Call: </span>(388) [system] setup_call_cleanup('$notrace'(_16854, _16856), once(user:self_eval(['get-state', 'state#'])), '$restore_trace'(_16854, _16856))
^  <span class="ansi1 ansi32"
>Call: </span>(389) [system] sig_atomic(system:'$notrace'(_16854, _16856))
^  <span class="ansi1 ansi32"
>Call: </span>(388) [system] setup_call_cleanup('$notrace'(_18766, _18768), once(user:nonvar(_9236)), '$restore_trace'(_18766, _18768))
^  <span class="ansi1 ansi32"
>Call: </span>(389) [system] sig_atomic(system:'$notrace'(_18766, _18768))
^  <span class="ansi1 ansi32"
>Call: </span>(388) [system] setup_call_cleanup('$notrace'(_20678, _20680), once(user:nonvar(_9236)), '$restore_trace'(_20678, _20680))
^  <span class="ansi1 ansi32"
>Call: </span>(389) [system] sig_atomic(system:'$notrace'(_20678, _20680))
   <span class="ansi1 ansi32"
>Call: </span>(387) [system] ['state#']==[]
   <span class="ansi1 ansi32"
>Call: </span>(387) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(387) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(387) [system] (=)\==(=)
^  <span class="ansi1 ansi32"
>Call: </span>(387) [user] self_eval(['get-state', 'state#'])
^  <span class="ansi1 ansi32"
>Call: </span>(389) [system] setup_call_cleanup('$notrace'(_27218, _27220), once(user:self_eval0(['get-state', 'state#'])), '$restore_trace'(_27218, _27220))
^  <span class="ansi1 ansi32"
>Call: </span>(390) [system] sig_atomic(system:'$notrace'(_27218, _27220))
^  <span class="ansi1 ansi31"
>Fail: </span>(387) [user] self_eval(['get-state', 'state#'])
^  <span class="ansi1 ansi32"
>Call: </span>(387) [user] eval_00(=, _9222, 491, '&self', ['get-state', 'state#'], _9236)
^  <span class="ansi1 ansi32"
>Call: </span>(388) [user] self_eval(['get-state', 'state#'])
^  <span class="ansi1 ansi32"
>Call: </span>(390) [system] setup_call_cleanup('$notrace'(_31922, _31924), once(user:self_eval0(['get-state', 'state#'])), '$restore_trace'(_31922, _31924))
^  <span class="ansi1 ansi32"
>Call: </span>(391) [system] sig_atomic(system:'$notrace'(_31922, _31924))
^  <span class="ansi1 ansi31"
>Fail: </span>(388) [user] self_eval(['get-state', 'state#'])
^  <span class="ansi1 ansi32"
>Call: </span>(388) [user] eval_01(=, _9222, 491, '&self', ['get-state', 'state#'], _9236)
^  <span class="ansi1 ansi32"
>Call: </span>(389) [user] if_t((491<1, trace_on_overflow), debug(metta(eval_args)))
   <span class="ansi1 ansi32"
>Call: </span>(391) [system] 491<1
   <span class="ansi1 ansi31"
>Fail: </span>(391) [system] 491<1
^  <span class="ansi1 ansi32"
>Exit: </span>(389) [user] if_t((491<1, trace_on_overflow), debug(metta(eval_args)))
^  <span class="ansi1 ansi32"
>Call: </span>(390) [system] setup_call_cleanup('$notrace'(_39454, _39456), once(user:(_39430 is 491-1, copy_term(['get-state', 'state#'], _39444))), '$restore_trace'(_39454, _39456))
^  <span class="ansi1 ansi32"
>Call: </span>(391) [system] sig_atomic(system:'$notrace'(_39454, _39456))
^  <span class="ansi1 ansi32"
>Exit: </span>(390) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(490 is 491-1, copy_term(['get-state', 'state#'], ['get-state', 'state#']))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(389) [user] trace_eval(eval_20(=, _9222), e, 490, '&self', ['get-state', 'state#'], _42300)
^  <span class="ansi1 ansi32"
>Call: </span>(390) [user] must_det_ll((notrace((flag(eval_num, _43266, _43266+1), _43284 is _43266 mod 500, _43302 is 99-490 mod 100, _43326=_43328, option_else('trace-length', _43340, 500), option_else('trace-depth', _43348, 30))), quietly(if_t((nop(stop_rtrace), _43284>_43340), (set_debug(eval, false), _43404 is _43340+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_43404])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_43456)))))
^  <span class="ansi1 ansi32"
>Call: </span>(391) [user] once(user:(notrace((flag(eval_num, _43266, _43266+1), _43284 is _43266 mod 500, _43302 is 99-490 mod 100, _43326=_43328, option_else('trace-length', _43340, 500), option_else('trace-depth', _43348, 30))), quietly(if_t((nop(stop_rtrace), _43284>_43340), (set_debug(eval, false), _43404 is _43340+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_43404])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_43456)))))
^  <span class="ansi1 ansi32"
>Call: </span>(394) [system] setup_call_cleanup('$notrace'(_45326, _45328), once(user:(flag(eval_num, _43266, _43266+1), _43284 is _43266 mod 500, _43302 is 99-490 mod 100, _43326=_43328, option_else('trace-length', _43340, 500), option_else('trace-depth', _43348, 30))), '$restore_trace'(_45326, _45328))
^  <span class="ansi1 ansi32"
>Call: </span>(395) [system] sig_atomic(system:'$notrace'(_45326, _45328))
^  <span class="ansi1 ansi32"
>Exit: </span>(394) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(flag(eval_num, 12, 12+1), 12 is 12 mod 500, 9 is 99-490 mod 100, _43326=_43326, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(394) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 12>500), (set_debug(eval, false), _43404 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_43404])), nop((start_rtrace, rtrace)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(394) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 12>500), (set_debug(eval, false), _43404 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_43404])), nop((start_rtrace, rtrace)))))
   <span class="ansi1 ansi32"
>Call: </span>(393) [user] nop(notrace(no_repeats_var(_43456)))
   <span class="ansi1 ansi32"
>Exit: </span>(393) [user] nop(notrace(no_repeats_var(_43456)))
^  <span class="ansi1 ansi32"
>Exit: </span>(391) [system] once(user:(notrace((flag(eval_num, 12, 12+1), 12 is 12 mod 500, 9 is 99-490 mod 100, _43326=_43326, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 12>500), (set_debug(eval, false), _43404 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_43404])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_43456)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(390) [user] must_det_ll(user:(notrace((flag(eval_num, 12, 12+1), 12 is 12 mod 500, 9 is 99-490 mod 100, _43326=_43326, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 12>500), (set_debug(eval, false), _43404 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_43404])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_43456)))))
   <span class="ansi1 ansi32"
>Call: </span>(390) [occurs] occurs:sub_term(_54010, e)
   <span class="ansi1 ansi32"
>Exit: </span>(390) [occurs] occurs:sub_term(e, e)
   <span class="ansi1 ansi32"
>Call: </span>(390) [system] e\=e
   <span class="ansi1 ansi31"
>Fail: </span>(390) [system] e\=e
   <span class="ansi1 ansi32"
>Call: </span>(391) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(391) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(390) [occurs] occurs:sub_term(_54010, e)
   <span class="ansi1 ansi32"
>Call: </span>(390) [system] _60500=e
   <span class="ansi1 ansi32"
>Exit: </span>(390) [system] e=e
^  <span class="ansi1 ansi32"
>Call: </span>(390) [user] if_trace((eval;e), (_43326=1, indentq(9, 12, -->, [e, ['get-state', 'state#']])))
^  <span class="ansi1 ansi32"
>Call: </span>(392) [system] setup_call_cleanup('$notrace'(_63376, _63378), once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _43326=1, indentq(9, 12, -->, [e, ['get-state', 'state#']]))), _63334, fbug((_63334-->if_trace((eval;e), (_43326=1, indentq(9, 12, -->, [e, ['get-state', 'state#']])))))))), '$restore_trace'(_63376, _63378))
^  <span class="ansi1 ansi32"
>Call: </span>(393) [system] sig_atomic(system:'$notrace'(_63376, _63378))
^  <span class="ansi1 ansi32"
>Exit: </span>(392) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _43326=1, indentq(9, 12, -->, [e, ['get-state', 'state#']]))), _63334, fbug((_63334-->if_trace((eval;e), (_43326=1, indentq(9, 12, -->, [e, ['get-state', 'state#']])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(390) [user] if_trace((eval;e), (_43326=1, indentq(9, 12, -->, [e, ['get-state', 'state#']])))
   <span class="ansi1 ansi32"
>Call: </span>(390) [system] _67220=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(390) [system] retval(fail)=retval(fail)
   <span class="ansi1 ansi32"
>Call: </span>(390) [system] _69082=(\+ \+ (flag(eval_num, _69102, _69102+1), (retval(fail)\=@=retval(fail), nonvar(_42300)->indentq(9, _69102, <--, [e, _42300]);indentq(9, _69102, <--, [e, retval(fail)]))))
   <span class="ansi1 ansi32"
>Exit: </span>(390) [system] (\+ \+ (flag(eval_num, _69102, _69102+1), (retval(fail)\=@=retval(fail), nonvar(_42300)->indentq(9, _69102, <--, [e, _42300]);indentq(9, _69102, <--, [e, retval(fail)]))))=(\+ \+ (flag(eval_num, _69102, _69102+1), (retval(fail)\=@=retval(fail), nonvar(_42300)->indentq(9, _69102, <--, [e, _42300]);indentq(9, _69102, <--, [e, retval(fail)]))))
^  <span class="ansi1 ansi32"
>Call: </span>(390) [user] call_cleanup(((call(eval_20(=, _9222), 490, '&self', ['get-state', 'state#'], _42300)*->nb_setarg(1, retval(fail), _42300);fail, trace, call(eval_20(=, _9222), 490, '&self', ['get-state', 'state#'], _42300)), ignore(notrace((\+_42300\=_43456, nb_setarg(1, retval(fail), _42300))))), ignore((_43326==1->ignore(\+ \+ (flag(eval_num, _69102, _69102+1), (retval(fail)\=@=retval(fail), nonvar(_42300)->indentq(9, _69102, <--, [e, _42300]);indentq(9, _69102, <--, [e, retval(fail)]))));notrace(ignore(if_t(9<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _69102, _69102+1), (retval(fail)\=@=retval(fail), nonvar(_42300)->indentq(9, _69102, <--, [e, _42300]);indentq(9, _69102, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi32"
>Call: </span>(392) [user] eval_20(=, _9222, 490, '&self', ['get-state', 'state#'], _42300)
   <span class="ansi1 ansi32"
>Call: </span>(393) [system] atom(['get-state', 'state#'])
^  <span class="ansi1 ansi32"
>Call: </span>(393) [user] no_eval(['get-state', 'state#'])
^  <span class="ansi1 ansi32"
>Call: </span>(394) [user] self_eval(['get-state', 'state#'])
^  <span class="ansi1 ansi32"
>Call: </span>(396) [system] setup_call_cleanup('$notrace'(_75874, _75876), once(user:self_eval0(['get-state', 'state#'])), '$restore_trace'(_75874, _75876))
^  <span class="ansi1 ansi32"
>Call: </span>(397) [system] sig_atomic(system:'$notrace'(_75874, _75876))
^  <span class="ansi1 ansi31"
>Fail: </span>(394) [user] self_eval(['get-state', 'state#'])
   <span class="ansi1 ansi32"
>Call: </span>(394) [system] atomic('get-state')
   <span class="ansi1 ansi32"
>Exit: </span>(394) [system] atomic('get-state')
^  <span class="ansi1 ansi32"
>Call: </span>(394) [user] is_sl('get-state')
   <span class="ansi1 ansi32"
>Call: </span>(395) [system] number('get-state')
   <span class="ansi1 ansi32"
>Call: </span>(393) [system] ['state#']==[]
   <span class="ansi1 ansi32"
>Call: </span>(393) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(393) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(393) [system] (=)\==(=)
   <span class="ansi1 ansi32"
>Call: </span>(393) [system] callable('get-state')
   <span class="ansi1 ansi32"
>Exit: </span>(393) [system] callable('get-state')
   <span class="ansi1 ansi32"
>Call: </span>(393) [system] is_list(['state#'])
   <span class="ansi1 ansi32"
>Exit: </span>(393) [system] is_list(['state#'])
   <span class="ansi1 ansi32"
>Call: </span>(393) [system] is_list(['get-state', 'state#'])
   <span class="ansi1 ansi32"
>Exit: </span>(393) [system] is_list(['get-state', 'state#'])
   <span class="ansi1 ansi32"
>Call: </span>(393) [system] var('get-state')
^  <span class="ansi1 ansi32"
>Call: </span>(393) [user] once(expand_eval(['get-state', 'state#'], _92576))
^  <span class="ansi1 ansi32"
>Call: </span>(394) [user] expand_eval(['get-state', 'state#'], _92576)
   <span class="ansi1 ansi32"
>Call: </span>(395) [system] is_list(['get-state', 'state#'])
   <span class="ansi1 ansi32"
>Exit: </span>(395) [system] is_list(['get-state', 'state#'])
   <span class="ansi1 ansi32"
>Call: </span>(395) [system] ground('get-state')
   <span class="ansi1 ansi32"
>Exit: </span>(395) [system] ground('get-state')
^  <span class="ansi1 ansi32"
>Call: </span>(395) [user] apply:maplist(expand_eval, ['state#'], _98148)
   <span class="ansi1 ansi32"
>Call: </span>(396) [apply] apply:maplist_(['state#'], _98148, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(397) [user] expand_eval('state#', _100028)
   <span class="ansi1 ansi32"
>Call: </span>(398) [system] is_list('state#')
   <span class="ansi1 ansi32"
>Call: </span>(398) [system] 'state#'=_100028
   <span class="ansi1 ansi32"
>Exit: </span>(398) [system] 'state#'='state#'
^  <span class="ansi1 ansi32"
>Exit: </span>(397) [user] expand_eval('state#', 'state#')
   <span class="ansi1 ansi32"
>Call: </span>(397) [apply] apply:maplist_([], _100030, user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(397) [apply] apply:maplist_([], [], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(396) [apply] apply:maplist_(['state#'], ['state#'], user:expand_eval)
^  <span class="ansi1 ansi32"
>Exit: </span>(395) [apply] apply:maplist(user:expand_eval, ['state#'], ['state#'])
^  <span class="ansi1 ansi32"
>Exit: </span>(394) [user] expand_eval(['get-state', 'state#'], ['get-state', 'state#'])
^  <span class="ansi1 ansi32"
>Exit: </span>(393) [system] once(user:expand_eval(['get-state', 'state#'], ['get-state', 'state#']))
   <span class="ansi1 ansi32"
>Call: </span>(393) [system] ['get-state', 'state#']\==['get-state', 'state#']
^  <span class="ansi1 ansi32"
>Call: </span>(393) [user] is_progn('get-state')
   <span class="ansi1 ansi32"
>Call: </span>(394) [system] var('get-state')
^  <span class="ansi1 ansi32"
>Call: </span>(393) [user] is_progn('get-state')
   <span class="ansi1 ansi32"
>Call: </span>(394) [system] var('get-state')
^  <span class="ansi1 ansi32"
>Call: </span>(393) [user] is_space_op('get-state')
   <span class="ansi1 ansi32"
>Call: </span>(393) [system] is_list('state#')
   <span class="ansi1 ansi32"
>Call: </span>(393) [system] 'state#'=='Nothing'
^  <span class="ansi1 ansi32"
>Call: </span>(393) [user] call_in_shared_space((eval_args(=, _9222, 490, '&self', 'state#', _117678), 'get-state'(_117678, _42300)))
^  <span class="ansi1 ansi32"
>Call: </span>(394) [user] call_in_thread(main, (eval_args(=, _9222, 490, '&self', 'state#', _117678), 'get-state'(_117678, _42300)))
   <span class="ansi1 ansi32"
>Call: </span>(395) [error] error:must_be(callable, user:(eval_args(=, _9222, 490, '&self', 'state#', _117678), 'get-state'(_117678, _42300)))
   <span class="ansi1 ansi32"
>Call: </span>(396) [system] nonvar(callable)
   <span class="ansi1 ansi32"
>Exit: </span>(396) [system] nonvar(callable)
   <span class="ansi1 ansi32"
>Call: </span>(396) [error] error:has_type(callable, user:(eval_args(=, _9222, 490, '&self', 'state#', _117678), 'get-state'(_117678, _42300)))
   <span class="ansi1 ansi32"
>Call: </span>(397) [system] callable(user:(eval_args(=, _9222, 490, '&self', 'state#', _117678), 'get-state'(_117678, _42300)))
   <span class="ansi1 ansi32"
>Exit: </span>(397) [system] callable(user:(eval_args(=, _9222, 490, '&self', 'state#', _117678), 'get-state'(_117678, _42300)))
   <span class="ansi1 ansi32"
>Exit: </span>(396) [error] error:has_type(callable, user:(eval_args(=, _9222, 490, '&self', 'state#', _117678), 'get-state'(_117678, _42300)))
   <span class="ansi1 ansi32"
>Exit: </span>(395) [error] error:must_be(callable, user:(eval_args(=, _9222, 490, '&self', 'state#', _117678), 'get-state'(_117678, _42300)))
   <span class="ansi1 ansi32"
>Call: </span>(395) [system] var(main)
   <span class="ansi1 ansi32"
>Call: </span>(395) [system] thread_self(main)
   <span class="ansi1 ansi32"
>Exit: </span>(395) [system] thread_self(main)
^  <span class="ansi1 ansi32"
>Call: </span>(395) [thread] once(user:(eval_args(=, _9222, 490, '&self', 'state#', _117678), 'get-state'(_117678, _42300)))
^  <span class="ansi1 ansi32"
>Call: </span>(397) [user] eval_args(=, _9222, 490, '&self', 'state#', _117678)
   <span class="ansi1 ansi32"
>Call: </span>(398) [system] var('state#')
^  <span class="ansi1 ansi32"
>Call: </span>(399) [system] setup_call_cleanup('$notrace'(_132568, _132570), once(user:self_eval('state#')), '$restore_trace'(_132568, _132570))
^  <span class="ansi1 ansi32"
>Call: </span>(400) [system] sig_atomic(system:'$notrace'(_132568, _132570))
^  <span class="ansi1 ansi32"
>Exit: </span>(399) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval('state#')), system:'$restore_trace'(3, -1))
   <span class="ansi1 ansi32"
>Call: </span>(398) [system] _117678='state#'
   <span class="ansi1 ansi32"
>Exit: </span>(398) [system] 'state#'='state#'
^  <span class="ansi1 ansi32"
>Exit: </span>(397) [user] eval_args(=, _9222, 490, '&self', 'state#', 'state#')
^  <span class="ansi1 ansi32"
>Call: </span>(397) [user] 'get-state'('state#', _42300)
^  <span class="ansi1 ansi32"
>Call: </span>(398) [user] fetch_or_create_state('state#', _139178)
^  <span class="ansi1 ansi32"
>Call: </span>(399) [user] is_valid_nb_state('state#')
   <span class="ansi1 ansi32"
>Call: </span>(400) [system] compound('state#')
   <span class="ansi1 ansi32"
>Call: </span>(399) [system] atom('state#')
   <span class="ansi1 ansi32"
>Exit: </span>(399) [system] atom('state#')
^  <span class="ansi1 ansi32"
>Call: </span>(399) [user] is_registered_state('state#')
^  <span class="ansi1 ansi32"
>Exit: </span>(399) [user] is_registered_state('state#')
^  <span class="ansi1 ansi32"
>Call: </span>(399) [user] nb_bound('state#', _139178)
   <span class="ansi1 ansi32"
>Call: </span>(400) [system] atom('state#')
   <span class="ansi1 ansi32"
>Exit: </span>(400) [system] atom('state#')
   <span class="ansi1 ansi32"
>Call: </span>(400) [system] atom_concat(&, _148504, 'state#')
   <span class="ansi1 ansi31"
>Fail: </span>(400) [system] atom_concat(&, _149436, 'state#')
^  <span class="ansi1 ansi31"
>Fail: </span>(399) [user] nb_bound('state#', _139178)
^  <span class="ansi1 ansi31"
>Fail: </span>(397) [user] 'get-state'('state#', _42300)
^  <span class="ansi1 ansi31"
>Fail: </span>(392) [user] eval_20(=, _9222, 490, '&self', ['get-state', 'state#'], _42300)
   <span class="ansi1 ansi32"
>Call: </span>(392) [system] fail
   <span class="ansi1 ansi31"
>Fail: </span>(392) [system] fail
^  <span class="ansi1 ansi32"
>Call: </span>(392) [user] ignore((_43326==1->ignore(\+ \+ (flag(eval_num, _69102, _69102+1), (retval(fail)\=@=retval(fail), nonvar(_42300)->indentq(9, _69102, <--, [e, _42300]);indentq(9, _69102, <--, [e, retval(fail)]))));notrace(ignore(if_t(9<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _69102, _69102+1), (retval(fail)\=@=retval(fail), nonvar(_42300)->indentq(9, _69102, <--, [e, _42300]);indentq(9, _69102, <--, [e, retval(fail)]))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(394) [system] _43326==1
   <span class="ansi1 ansi31"
>Fail: </span>(394) [system] _43326==1
^  <span class="ansi1 ansi32"
>Call: </span>(395) [system] setup_call_cleanup('$notrace'(_157724, _157726), once(user:ignore(if_t(9<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _69102, _69102+1), (retval(fail)\=@=retval(fail), nonvar(_42300)->indentq(9, _69102, <--, [e, _42300]);indentq(9, _69102, <--, [e, retval(fail)])))))))), '$restore_trace'(_157724, _157726))
^  <span class="ansi1 ansi32"
>Call: </span>(396) [system] sig_atomic(system:'$notrace'(_157724, _157726))
^  <span class="ansi1 ansi32"
>Exit: </span>(395) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:ignore(if_t(9<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _69102, _69102+1), (retval(fail)\=@=retval(fail), nonvar(_42300)->indentq(9, _69102, <--, [e, _42300]);indentq(9, _69102, <--, [e, retval(fail)])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(392) [system] ignore(user:(_43326==1->ignore(\+ \+ (flag(eval_num, _69102, _69102+1), (retval(fail)\=@=retval(fail), nonvar(_42300)->indentq(9, _69102, <--, [e, _42300]);indentq(9, _69102, <--, [e, retval(fail)]))));notrace(ignore(if_t(9<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _69102, _69102+1), (retval(fail)\=@=retval(fail), nonvar(_42300)->indentq(9, _69102, <--, [e, _42300]);indentq(9, _69102, <--, [e, retval(fail)]))))))))))
^  <span class="ansi1 ansi31"
>Fail: </span>(390) [system] call_cleanup(user:((call(eval_20(=, _9222), 490, '&self', ['get-state', 'state#'], _42300)*->nb_setarg(1, retval(fail), _42300);fail, trace, call(eval_20(=, _9222), 490, '&self', ['get-state', 'state#'], _42300)), ignore(notrace((\+_42300\=_43456, nb_setarg(1, retval(fail), _42300))))), user:ignore((_43326==1->ignore(\+ \+ (flag(eval_num, _69102, _69102+1), (retval(fail)\=@=retval(fail), nonvar(_42300)->indentq(9, _69102, <--, [e, _42300]);indentq(9, _69102, <--, [e, retval(fail)]))));notrace(ignore(if_t(9<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _69102, _69102+1), (retval(fail)\=@=retval(fail), nonvar(_42300)->indentq(9, _69102, <--, [e, _42300]);indentq(9, _69102, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi31"
>Fail: </span>(389) [user] trace_eval(eval_20(=, _9222), e, 490, '&self', ['get-state', 'state#'], _42300)
^  <span class="ansi1 ansi31"
>Fail: </span>(386) [user] eval_args(=, _9222, 491, '&self', ['get-state', 'state#'], _9236)
^  <span class="ansi1 ansi32"
>Call: </span>(383) [user] call(eval, ['get-state', 'state#'], _9236)
   <span class="ansi1 ansi32"
>Call: </span>(384) [user] eval(['get-state', 'state#'], _9236)
^  <span class="ansi1 ansi32"
>Call: </span>(385) [user] current_self(_166340)
   <span class="ansi1 ansi32"
>Call: </span>(386) [system] nb_current(self_space, _166340)
   <span class="ansi1 ansi32"
>Exit: </span>(386) [system] nb_current(self_space, '&self')
   <span class="ansi1 ansi32"
>Call: </span>(386) [system] '&self'\==[]
   <span class="ansi1 ansi32"
>Exit: </span>(386) [system] '&self'\==[]
^  <span class="ansi1 ansi32"
>Exit: </span>(385) [user] current_self('&self')
   <span class="ansi1 ansi32"
>Call: </span>(385) [user] eval('&self', ['get-state', 'state#'], _9236)
   <span class="ansi1 ansi32"
>Call: </span>(386) [user] eval_H(500, '&self', ['get-state', 'state#'], _9236)
^  <span class="ansi1 ansi32"
>Call: </span>(387) [user] catch_metta_return(eval_args(=, _173750, 500, '&self', ['get-state', 'state#'], _9236), _9236)
^  <span class="ansi1 ansi32"
>Call: </span>(389) [user] eval_args(=, _173750, 500, '&self', ['get-state', 'state#'], _9236)
   <span class="ansi1 ansi32"
>Call: </span>(390) [system] var(['get-state', 'state#'])
^  <span class="ansi1 ansi32"
>Call: </span>(391) [system] setup_call_cleanup('$notrace'(_176596, _176598), once(user:self_eval(['get-state', 'state#'])), '$restore_trace'(_176596, _176598))
^  <span class="ansi1 ansi32"
>Call: </span>(392) [system] sig_atomic(system:'$notrace'(_176596, _176598))
^  <span class="ansi1 ansi32"
>Call: </span>(391) [system] setup_call_cleanup('$notrace'(_178508, _178510), once(user:nonvar(_9236)), '$restore_trace'(_178508, _178510))
^  <span class="ansi1 ansi32"
>Call: </span>(392) [system] sig_atomic(system:'$notrace'(_178508, _178510))
^  <span class="ansi1 ansi32"
>Call: </span>(391) [system] setup_call_cleanup('$notrace'(_180420, _180422), once(user:nonvar(_9236)), '$restore_trace'(_180420, _180422))
^  <span class="ansi1 ansi32"
>Call: </span>(392) [system] sig_atomic(system:'$notrace'(_180420, _180422))
   <span class="ansi1 ansi32"
>Call: </span>(390) [system] ['state#']==[]
   <span class="ansi1 ansi32"
>Call: </span>(390) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(390) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(390) [system] (=)\==(=)
^  <span class="ansi1 ansi32"
>Call: </span>(390) [user] self_eval(['get-state', 'state#'])
^  <span class="ansi1 ansi32"
>Call: </span>(392) [system] setup_call_cleanup('$notrace'(_186960, _186962), once(user:self_eval0(['get-state', 'state#'])), '$restore_trace'(_186960, _186962))
^  <span class="ansi1 ansi32"
>Call: </span>(393) [system] sig_atomic(system:'$notrace'(_186960, _186962))
^  <span class="ansi1 ansi31"
>Fail: </span>(390) [user] self_eval(['get-state', 'state#'])
^  <span class="ansi1 ansi32"
>Call: </span>(390) [user] eval_00(=, _173750, 500, '&self', ['get-state', 'state#'], _9236)
^  <span class="ansi1 ansi32"
>Call: </span>(391) [user] self_eval(['get-state', 'state#'])
^  <span class="ansi1 ansi32"
>Call: </span>(393) [system] setup_call_cleanup('$notrace'(_191664, _191666), once(user:self_eval0(['get-state', 'state#'])), '$restore_trace'(_191664, _191666))
^  <span class="ansi1 ansi32"
>Call: </span>(394) [system] sig_atomic(system:'$notrace'(_191664, _191666))
^  <span class="ansi1 ansi31"
>Fail: </span>(391) [user] self_eval(['get-state', 'state#'])
^  <span class="ansi1 ansi32"
>Call: </span>(391) [user] eval_01(=, _173750, 500, '&self', ['get-state', 'state#'], _9236)
^  <span class="ansi1 ansi32"
>Call: </span>(392) [user] if_t((500<1, trace_on_overflow), debug(metta(eval_args)))
   <span class="ansi1 ansi32"
>Call: </span>(394) [system] 500<1
   <span class="ansi1 ansi31"
>Fail: </span>(394) [system] 500<1
^  <span class="ansi1 ansi32"
>Exit: </span>(392) [user] if_t((500<1, trace_on_overflow), debug(metta(eval_args)))
^  <span class="ansi1 ansi32"
>Call: </span>(393) [system] setup_call_cleanup('$notrace'(_199196, _199198), once(user:(_199172 is 500-1, copy_term(['get-state', 'state#'], _199186))), '$restore_trace'(_199196, _199198))
^  <span class="ansi1 ansi32"
>Call: </span>(394) [system] sig_atomic(system:'$notrace'(_199196, _199198))
^  <span class="ansi1 ansi32"
>Exit: </span>(393) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(499 is 500-1, copy_term(['get-state', 'state#'], ['get-state', 'state#']))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(392) [user] trace_eval(eval_20(=, _173750), e, 499, '&self', ['get-state', 'state#'], _202042)
^  <span class="ansi1 ansi32"
>Call: </span>(393) [user] must_det_ll((notrace((flag(eval_num, _203008, _203008+1), _203026 is _203008 mod 500, _203044 is 99-499 mod 100, _203068=_203070, option_else('trace-length', _203082, 500), option_else('trace-depth', _203090, 30))), quietly(if_t((nop(stop_rtrace), _203026>_203082), (set_debug(eval, false), _203146 is _203082+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_203146])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_203198)))))
^  <span class="ansi1 ansi32"
>Call: </span>(394) [user] once(user:(notrace((flag(eval_num, _203008, _203008+1), _203026 is _203008 mod 500, _203044 is 99-499 mod 100, _203068=_203070, option_else('trace-length', _203082, 500), option_else('trace-depth', _203090, 30))), quietly(if_t((nop(stop_rtrace), _203026>_203082), (set_debug(eval, false), _203146 is _203082+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_203146])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_203198)))))
^  <span class="ansi1 ansi32"
>Call: </span>(397) [system] setup_call_cleanup('$notrace'(_205068, _205070), once(user:(flag(eval_num, _203008, _203008+1), _203026 is _203008 mod 500, _203044 is 99-499 mod 100, _203068=_203070, option_else('trace-length', _203082, 500), option_else('trace-depth', _203090, 30))), '$restore_trace'(_205068, _205070))
^  <span class="ansi1 ansi32"
>Call: </span>(398) [system] sig_atomic(system:'$notrace'(_205068, _205070))
^  <span class="ansi1 ansi32"
>Exit: </span>(397) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(flag(eval_num, 13, 13+1), 13 is 13 mod 500, 0 is 99-499 mod 100, _203068=_203068, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(397) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 13>500), (set_debug(eval, false), _203146 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_203146])), nop((start_rtrace, rtrace)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(397) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 13>500), (set_debug(eval, false), _203146 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_203146])), nop((start_rtrace, rtrace)))))
   <span class="ansi1 ansi32"
>Call: </span>(396) [user] nop(notrace(no_repeats_var(_203198)))
   <span class="ansi1 ansi32"
>Exit: </span>(396) [user] nop(notrace(no_repeats_var(_203198)))
^  <span class="ansi1 ansi32"
>Exit: </span>(394) [system] once(user:(notrace((flag(eval_num, 13, 13+1), 13 is 13 mod 500, 0 is 99-499 mod 100, _203068=_203068, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 13>500), (set_debug(eval, false), _203146 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_203146])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_203198)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(393) [user] must_det_ll(user:(notrace((flag(eval_num, 13, 13+1), 13 is 13 mod 500, 0 is 99-499 mod 100, _203068=_203068, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 13>500), (set_debug(eval, false), _203146 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_203146])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_203198)))))
   <span class="ansi1 ansi32"
>Call: </span>(393) [occurs] occurs:sub_term(_213752, e)
   <span class="ansi1 ansi32"
>Exit: </span>(393) [occurs] occurs:sub_term(e, e)
   <span class="ansi1 ansi32"
>Call: </span>(393) [system] e\=e
   <span class="ansi1 ansi31"
>Fail: </span>(393) [system] e\=e
   <span class="ansi1 ansi32"
>Call: </span>(394) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(394) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(393) [occurs] occurs:sub_term(_213752, e)
   <span class="ansi1 ansi32"
>Call: </span>(393) [system] _220242=e
   <span class="ansi1 ansi32"
>Exit: </span>(393) [system] e=e
^  <span class="ansi1 ansi32"
>Call: </span>(393) [user] if_trace((eval;e), (_203068=1, indentq(0, 13, -->, [e, ['get-state', 'state#']])))
^  <span class="ansi1 ansi32"
>Call: </span>(395) [system] setup_call_cleanup('$notrace'(_223118, _223120), once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _203068=1, indentq(0, 13, -->, [e, ['get-state', 'state#']]))), _223076, fbug((_223076-->if_trace((eval;e), (_203068=1, indentq(0, 13, -->, [e, ['get-state', 'state#']])))))))), '$restore_trace'(_223118, _223120))
^  <span class="ansi1 ansi32"
>Call: </span>(396) [system] sig_atomic(system:'$notrace'(_223118, _223120))
^  <span class="ansi1 ansi32"
>Exit: </span>(395) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _203068=1, indentq(0, 13, -->, [e, ['get-state', 'state#']]))), _223076, fbug((_223076-->if_trace((eval;e), (_203068=1, indentq(0, 13, -->, [e, ['get-state', 'state#']])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(393) [user] if_trace((eval;e), (_203068=1, indentq(0, 13, -->, [e, ['get-state', 'state#']])))
   <span class="ansi1 ansi32"
>Call: </span>(393) [system] _226962=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(393) [system] retval(fail)=retval(fail)
   <span class="ansi1 ansi32"
>Call: </span>(393) [system] _228824=(\+ \+ (flag(eval_num, _228844, _228844+1), (retval(fail)\=@=retval(fail), nonvar(_202042)->indentq(0, _228844, <--, [e, _202042]);indentq(0, _228844, <--, [e, retval(fail)]))))
   <span class="ansi1 ansi32"
>Exit: </span>(393) [system] (\+ \+ (flag(eval_num, _228844, _228844+1), (retval(fail)\=@=retval(fail), nonvar(_202042)->indentq(0, _228844, <--, [e, _202042]);indentq(0, _228844, <--, [e, retval(fail)]))))=(\+ \+ (flag(eval_num, _228844, _228844+1), (retval(fail)\=@=retval(fail), nonvar(_202042)->indentq(0, _228844, <--, [e, _202042]);indentq(0, _228844, <--, [e, retval(fail)]))))
^  <span class="ansi1 ansi32"
>Call: </span>(393) [user] call_cleanup(((call(eval_20(=, _173750), 499, '&self', ['get-state', 'state#'], _202042)*->nb_setarg(1, retval(fail), _202042);fail, trace, call(eval_20(=, _173750), 499, '&self', ['get-state', 'state#'], _202042)), ignore(notrace((\+_202042\=_203198, nb_setarg(1, retval(fail), _202042))))), ignore((_203068==1->ignore(\+ \+ (flag(eval_num, _228844, _228844+1), (retval(fail)\=@=retval(fail), nonvar(_202042)->indentq(0, _228844, <--, [e, _202042]);indentq(0, _228844, <--, [e, retval(fail)]))));notrace(ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _228844, _228844+1), (retval(fail)\=@=retval(fail), nonvar(_202042)->indentq(0, _228844, <--, [e, _202042]);indentq(0, _228844, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi32"
>Call: </span>(395) [user] eval_20(=, _173750, 499, '&self', ['get-state', 'state#'], _202042)
   <span class="ansi1 ansi32"
>Call: </span>(396) [system] atom(['get-state', 'state#'])
^  <span class="ansi1 ansi32"
>Call: </span>(396) [user] no_eval(['get-state', 'state#'])
^  <span class="ansi1 ansi32"
>Call: </span>(397) [user] self_eval(['get-state', 'state#'])
^  <span class="ansi1 ansi32"
>Call: </span>(399) [system] setup_call_cleanup('$notrace'(_235616, _235618), once(user:self_eval0(['get-state', 'state#'])), '$restore_trace'(_235616, _235618))
^  <span class="ansi1 ansi32"
>Call: </span>(400) [system] sig_atomic(system:'$notrace'(_235616, _235618))
^  <span class="ansi1 ansi31"
>Fail: </span>(397) [user] self_eval(['get-state', 'state#'])
   <span class="ansi1 ansi32"
>Call: </span>(397) [system] atomic('get-state')
   <span class="ansi1 ansi32"
>Exit: </span>(397) [system] atomic('get-state')
^  <span class="ansi1 ansi32"
>Call: </span>(397) [user] is_sl('get-state')
   <span class="ansi1 ansi32"
>Call: </span>(398) [system] number('get-state')
   <span class="ansi1 ansi32"
>Call: </span>(396) [system] ['state#']==[]
   <span class="ansi1 ansi32"
>Call: </span>(396) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(396) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(396) [system] (=)\==(=)
   <span class="ansi1 ansi32"
>Call: </span>(396) [system] callable('get-state')
   <span class="ansi1 ansi32"
>Exit: </span>(396) [system] callable('get-state')
   <span class="ansi1 ansi32"
>Call: </span>(396) [system] is_list(['state#'])
   <span class="ansi1 ansi32"
>Exit: </span>(396) [system] is_list(['state#'])
   <span class="ansi1 ansi32"
>Call: </span>(396) [system] is_list(['get-state', 'state#'])
   <span class="ansi1 ansi32"
>Exit: </span>(396) [system] is_list(['get-state', 'state#'])
   <span class="ansi1 ansi32"
>Call: </span>(396) [system] var('get-state')
^  <span class="ansi1 ansi32"
>Call: </span>(396) [user] once(expand_eval(['get-state', 'state#'], _252318))
^  <span class="ansi1 ansi32"
>Call: </span>(397) [user] expand_eval(['get-state', 'state#'], _252318)
   <span class="ansi1 ansi32"
>Call: </span>(398) [system] is_list(['get-state', 'state#'])
   <span class="ansi1 ansi32"
>Exit: </span>(398) [system] is_list(['get-state', 'state#'])
   <span class="ansi1 ansi32"
>Call: </span>(398) [system] ground('get-state')
   <span class="ansi1 ansi32"
>Exit: </span>(398) [system] ground('get-state')
^  <span class="ansi1 ansi32"
>Call: </span>(398) [user] apply:maplist(expand_eval, ['state#'], _257890)
   <span class="ansi1 ansi32"
>Call: </span>(399) [apply] apply:maplist_(['state#'], _257890, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(400) [user] expand_eval('state#', _259770)
   <span class="ansi1 ansi32"
>Call: </span>(401) [system] is_list('state#')
   <span class="ansi1 ansi32"
>Call: </span>(401) [system] 'state#'=_259770
   <span class="ansi1 ansi32"
>Exit: </span>(401) [system] 'state#'='state#'
^  <span class="ansi1 ansi32"
>Exit: </span>(400) [user] expand_eval('state#', 'state#')
   <span class="ansi1 ansi32"
>Call: </span>(400) [apply] apply:maplist_([], _259772, user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(400) [apply] apply:maplist_([], [], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(399) [apply] apply:maplist_(['state#'], ['state#'], user:expand_eval)
^  <span class="ansi1 ansi32"
>Exit: </span>(398) [apply] apply:maplist(user:expand_eval, ['state#'], ['state#'])
^  <span class="ansi1 ansi32"
>Exit: </span>(397) [user] expand_eval(['get-state', 'state#'], ['get-state', 'state#'])
^  <span class="ansi1 ansi32"
>Exit: </span>(396) [system] once(user:expand_eval(['get-state', 'state#'], ['get-state', 'state#']))
   <span class="ansi1 ansi32"
>Call: </span>(396) [system] ['get-state', 'state#']\==['get-state', 'state#']
^  <span class="ansi1 ansi32"
>Call: </span>(396) [user] is_progn('get-state')
   <span class="ansi1 ansi32"
>Call: </span>(397) [system] var('get-state')
^  <span class="ansi1 ansi32"
>Call: </span>(396) [user] is_progn('get-state')
   <span class="ansi1 ansi32"
>Call: </span>(397) [system] var('get-state')
^  <span class="ansi1 ansi32"
>Call: </span>(396) [user] is_space_op('get-state')
   <span class="ansi1 ansi32"
>Call: </span>(396) [system] is_list('state#')
   <span class="ansi1 ansi32"
>Call: </span>(396) [system] 'state#'=='Nothing'
^  <span class="ansi1 ansi32"
>Call: </span>(396) [user] call_in_shared_space((eval_args(=, _173750, 499, '&self', 'state#', _277420), 'get-state'(_277420, _202042)))
^  <span class="ansi1 ansi32"
>Call: </span>(397) [user] call_in_thread(main, (eval_args(=, _173750, 499, '&self', 'state#', _277420), 'get-state'(_277420, _202042)))
   <span class="ansi1 ansi32"
>Call: </span>(398) [error] error:must_be(callable, user:(eval_args(=, _173750, 499, '&self', 'state#', _277420), 'get-state'(_277420, _202042)))
   <span class="ansi1 ansi32"
>Call: </span>(399) [system] nonvar(callable)
   <span class="ansi1 ansi32"
>Exit: </span>(399) [system] nonvar(callable)
   <span class="ansi1 ansi32"
>Call: </span>(399) [error] error:has_type(callable, user:(eval_args(=, _173750, 499, '&self', 'state#', _277420), 'get-state'(_277420, _202042)))
   <span class="ansi1 ansi32"
>Call: </span>(400) [system] callable(user:(eval_args(=, _173750, 499, '&self', 'state#', _277420), 'get-state'(_277420, _202042)))
   <span class="ansi1 ansi32"
>Exit: </span>(400) [system] callable(user:(eval_args(=, _173750, 499, '&self', 'state#', _277420), 'get-state'(_277420, _202042)))
   <span class="ansi1 ansi32"
>Exit: </span>(399) [error] error:has_type(callable, user:(eval_args(=, _173750, 499, '&self', 'state#', _277420), 'get-state'(_277420, _202042)))
   <span class="ansi1 ansi32"
>Exit: </span>(398) [error] error:must_be(callable, user:(eval_args(=, _173750, 499, '&self', 'state#', _277420), 'get-state'(_277420, _202042)))
   <span class="ansi1 ansi32"
>Call: </span>(398) [system] var(main)
   <span class="ansi1 ansi32"
>Call: </span>(398) [system] thread_self(main)
   <span class="ansi1 ansi32"
>Exit: </span>(398) [system] thread_self(main)
^  <span class="ansi1 ansi32"
>Call: </span>(398) [thread] once(user:(eval_args(=, _173750, 499, '&self', 'state#', _277420), 'get-state'(_277420, _202042)))
^  <span class="ansi1 ansi32"
>Call: </span>(400) [user] eval_args(=, _173750, 499, '&self', 'state#', _277420)
   <span class="ansi1 ansi32"
>Call: </span>(401) [system] var('state#')
^  <span class="ansi1 ansi32"
>Call: </span>(402) [system] setup_call_cleanup('$notrace'(_292310, _292312), once(user:self_eval('state#')), '$restore_trace'(_292310, _292312))
^  <span class="ansi1 ansi32"
>Call: </span>(403) [system] sig_atomic(system:'$notrace'(_292310, _292312))
^  <span class="ansi1 ansi32"
>Exit: </span>(402) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval('state#')), system:'$restore_trace'(3, -1))
   <span class="ansi1 ansi32"
>Call: </span>(401) [system] _277420='state#'
   <span class="ansi1 ansi32"
>Exit: </span>(401) [system] 'state#'='state#'
^  <span class="ansi1 ansi32"
>Exit: </span>(400) [user] eval_args(=, _173750, 499, '&self', 'state#', 'state#')
^  <span class="ansi1 ansi32"
>Call: </span>(400) [user] 'get-state'('state#', _202042)
^  <span class="ansi1 ansi32"
>Call: </span>(401) [user] fetch_or_create_state('state#', _298920)
^  <span class="ansi1 ansi32"
>Call: </span>(402) [user] is_valid_nb_state('state#')
   <span class="ansi1 ansi32"
>Call: </span>(403) [system] compound('state#')
   <span class="ansi1 ansi32"
>Call: </span>(402) [system] atom('state#')
   <span class="ansi1 ansi32"
>Exit: </span>(402) [system] atom('state#')
^  <span class="ansi1 ansi32"
>Call: </span>(402) [user] is_registered_state('state#')
^  <span class="ansi1 ansi32"
>Exit: </span>(402) [user] is_registered_state('state#')
^  <span class="ansi1 ansi32"
>Call: </span>(402) [user] nb_bound('state#', _298920)
   <span class="ansi1 ansi32"
>Call: </span>(403) [system] atom('state#')
   <span class="ansi1 ansi32"
>Exit: </span>(403) [system] atom('state#')
   <span class="ansi1 ansi32"
>Call: </span>(403) [system] atom_concat(&, _308246, 'state#')
   <span class="ansi1 ansi31"
>Fail: </span>(403) [system] atom_concat(&, _309178, 'state#')
^  <span class="ansi1 ansi31"
>Fail: </span>(402) [user] nb_bound('state#', _298920)
^  <span class="ansi1 ansi31"
>Fail: </span>(400) [user] 'get-state'('state#', _202042)
^  <span class="ansi1 ansi31"
>Fail: </span>(395) [user] eval_20(=, _173750, 499, '&self', ['get-state', 'state#'], _202042)
   <span class="ansi1 ansi32"
>Call: </span>(395) [system] fail
   <span class="ansi1 ansi31"
>Fail: </span>(395) [system] fail
^  <span class="ansi1 ansi32"
>Call: </span>(395) [user] ignore((_203068==1->ignore(\+ \+ (flag(eval_num, _228844, _228844+1), (retval(fail)\=@=retval(fail), nonvar(_202042)->indentq(0, _228844, <--, [e, _202042]);indentq(0, _228844, <--, [e, retval(fail)]))));notrace(ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _228844, _228844+1), (retval(fail)\=@=retval(fail), nonvar(_202042)->indentq(0, _228844, <--, [e, _202042]);indentq(0, _228844, <--, [e, retval(fail)]))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(397) [system] _203068==1
   <span class="ansi1 ansi31"
>Fail: </span>(397) [system] _203068==1
^  <span class="ansi1 ansi32"
>Call: </span>(398) [system] setup_call_cleanup('$notrace'(_317466, _317468), once(user:ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _228844, _228844+1), (retval(fail)\=@=retval(fail), nonvar(_202042)->indentq(0, _228844, <--, [e, _202042]);indentq(0, _228844, <--, [e, retval(fail)])))))))), '$restore_trace'(_317466, _317468))
^  <span class="ansi1 ansi32"
>Call: </span>(399) [system] sig_atomic(system:'$notrace'(_317466, _317468))
^  <span class="ansi1 ansi32"
>Exit: </span>(398) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _228844, _228844+1), (retval(fail)\=@=retval(fail), nonvar(_202042)->indentq(0, _228844, <--, [e, _202042]);indentq(0, _228844, <--, [e, retval(fail)])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(395) [system] ignore(user:(_203068==1->ignore(\+ \+ (flag(eval_num, _228844, _228844+1), (retval(fail)\=@=retval(fail), nonvar(_202042)->indentq(0, _228844, <--, [e, _202042]);indentq(0, _228844, <--, [e, retval(fail)]))));notrace(ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _228844, _228844+1), (retval(fail)\=@=retval(fail), nonvar(_202042)->indentq(0, _228844, <--, [e, _202042]);indentq(0, _228844, <--, [e, retval(fail)]))))))))))
^  <span class="ansi1 ansi31"
>Fail: </span>(393) [system] call_cleanup(user:((call(eval_20(=, _173750), 499, '&self', ['get-state', 'state#'], _202042)*->nb_setarg(1, retval(fail), _202042);fail, trace, call(eval_20(=, _173750), 499, '&self', ['get-state', 'state#'], _202042)), ignore(notrace((\+_202042\=_203198, nb_setarg(1, retval(fail), _202042))))), user:ignore((_203068==1->ignore(\+ \+ (flag(eval_num, _228844, _228844+1), (retval(fail)\=@=retval(fail), nonvar(_202042)->indentq(0, _228844, <--, [e, _202042]);indentq(0, _228844, <--, [e, retval(fail)]))));notrace(ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _228844, _228844+1), (retval(fail)\=@=retval(fail), nonvar(_202042)->indentq(0, _228844, <--, [e, _202042]);indentq(0, _228844, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi31"
>Fail: </span>(392) [user] trace_eval(eval_20(=, _173750), e, 499, '&self', ['get-state', 'state#'], _202042)
^  <span class="ansi1 ansi31"
>Fail: </span>(389) [user] eval_args(=, _173750, 500, '&self', ['get-state', 'state#'], _9236)
^  <span class="ansi1 ansi31"
>Fail: </span>(380) [system] call(user:once, user:if_or_else(eval(=, _9222, 491, '&self', ['get-state', 'state#'], _9236), call(eval, ['get-state', 'state#'], _9236)))
^  <span class="ansi1 ansi32"
>Call: </span>(380) [bugger] bugger:mquietly_if(true, rtrace:pop_tracer)
   <span class="ansi1 ansi32"
>Call: </span>(382) [system] var(rtrace:pop_tracer)
   <span class="ansi1 ansi31"
>Fail: </span>(382) [system] var(rtrace:pop_tracer)
^  <span class="ansi1 ansi32"
>Call: </span>(384) [system] setup_call_cleanup('$notrace'(_327960, _327962), once(rtrace:retract(t_l:tracer_reset(_327950))), '$restore_trace'(_327960, _327962))
^  <span class="ansi1 ansi32"
>Call: </span>(385) [system] sig_atomic(system:'$notrace'(_327960, _327962))
^  <span class="ansi1 ansi32"
>Exit: </span>(384) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(rtrace:retract(t_l:tracer_reset(tAt_normal))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(384) [rtrace] tAt(false, 271, 271, false)


  (failed  once 
    (if_or_else  
      (eval  = $_17270 491 &self 
        (get-state state#) $_17284) 
      (call  eval 
        (get-state state#) $_17284)))




  (failed  once 
    (if_or_else  
      (eval  = $_17270 491 &self 
        (get-state state#) $_17284) 
      (call  eval 
        (get-state state#) $_17284)))


^  <span class="ansi1 ansi32"
>Call: </span>(380) [user] call(user:once, user:if_or_else(eval(=, _17270, 491, '&self', ['get-state', 'state#'], _17284), call(eval, ['get-state', 'state#'], _17284)))
^  <span class="ansi1 ansi32"
>Call: </span>(381) [user] once(user:if_or_else(eval(=, _17270, 491, '&self', ['get-state', 'state#'], _17284), call(eval, ['get-state', 'state#'], _17284)))
   <span class="ansi1 ansi32"
>Call: </span>(382) [user] if_or_else(eval(=, _17270, 491, '&self', ['get-state', 'state#'], _17284), call(eval, ['get-state', 'state#'], _17284))
^  <span class="ansi1 ansi32"
>Call: </span>(383) [user] eval(=, _17270, 491, '&self', ['get-state', 'state#'], _17284)
^  <span class="ansi1 ansi32"
>Call: </span>(384) [user] catch_metta_return(eval_args(=, _17270, 491, '&self', ['get-state', 'state#'], _17284), _17284)
^  <span class="ansi1 ansi32"
>Call: </span>(386) [user] eval_args(=, _17270, 491, '&self', ['get-state', 'state#'], _17284)
   <span class="ansi1 ansi32"
>Call: </span>(387) [system] var(['get-state', 'state#'])
^  <span class="ansi1 ansi32"
>Call: </span>(388) [system] setup_call_cleanup('$notrace'(_24902, _24904), once(user:self_eval(['get-state', 'state#'])), '$restore_trace'(_24902, _24904))
^  <span class="ansi1 ansi32"
>Call: </span>(389) [system] sig_atomic(system:'$notrace'(_24902, _24904))
^  <span class="ansi1 ansi32"
>Call: </span>(388) [system] setup_call_cleanup('$notrace'(_26814, _26816), once(user:nonvar(_17284)), '$restore_trace'(_26814, _26816))
^  <span class="ansi1 ansi32"
>Call: </span>(389) [system] sig_atomic(system:'$notrace'(_26814, _26816))
^  <span class="ansi1 ansi32"
>Call: </span>(388) [system] setup_call_cleanup('$notrace'(_28726, _28728), once(user:nonvar(_17284)), '$restore_trace'(_28726, _28728))
^  <span class="ansi1 ansi32"
>Call: </span>(389) [system] sig_atomic(system:'$notrace'(_28726, _28728))
   <span class="ansi1 ansi32"
>Call: </span>(387) [system] ['state#']==[]
   <span class="ansi1 ansi32"
>Call: </span>(387) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(387) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(387) [system] (=)\==(=)
^  <span class="ansi1 ansi32"
>Call: </span>(387) [user] self_eval(['get-state', 'state#'])
^  <span class="ansi1 ansi32"
>Call: </span>(389) [system] setup_call_cleanup('$notrace'(_35266, _35268), once(user:self_eval0(['get-state', 'state#'])), '$restore_trace'(_35266, _35268))
^  <span class="ansi1 ansi32"
>Call: </span>(390) [system] sig_atomic(system:'$notrace'(_35266, _35268))
^  <span class="ansi1 ansi31"
>Fail: </span>(387) [user] self_eval(['get-state', 'state#'])
^  <span class="ansi1 ansi32"
>Call: </span>(387) [user] eval_00(=, _17270, 491, '&self', ['get-state', 'state#'], _17284)
^  <span class="ansi1 ansi32"
>Call: </span>(388) [user] self_eval(['get-state', 'state#'])
^  <span class="ansi1 ansi32"
>Call: </span>(390) [system] setup_call_cleanup('$notrace'(_39970, _39972), once(user:self_eval0(['get-state', 'state#'])), '$restore_trace'(_39970, _39972))
^  <span class="ansi1 ansi32"
>Call: </span>(391) [system] sig_atomic(system:'$notrace'(_39970, _39972))
^  <span class="ansi1 ansi31"
>Fail: </span>(388) [user] self_eval(['get-state', 'state#'])
^  <span class="ansi1 ansi32"
>Call: </span>(388) [user] eval_01(=, _17270, 491, '&self', ['get-state', 'state#'], _17284)
^  <span class="ansi1 ansi32"
>Call: </span>(389) [user] if_t((491<1, trace_on_overflow), debug(metta(eval_args)))
   <span class="ansi1 ansi32"
>Call: </span>(391) [system] 491<1
   <span class="ansi1 ansi31"
>Fail: </span>(391) [system] 491<1
^  <span class="ansi1 ansi32"
>Exit: </span>(389) [user] if_t((491<1, trace_on_overflow), debug(metta(eval_args)))
^  <span class="ansi1 ansi32"
>Call: </span>(390) [system] setup_call_cleanup('$notrace'(_47502, _47504), once(user:(_47478 is 491-1, copy_term(['get-state', 'state#'], _47492))), '$restore_trace'(_47502, _47504))
^  <span class="ansi1 ansi32"
>Call: </span>(391) [system] sig_atomic(system:'$notrace'(_47502, _47504))
^  <span class="ansi1 ansi32"
>Exit: </span>(390) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(490 is 491-1, copy_term(['get-state', 'state#'], ['get-state', 'state#']))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(389) [user] trace_eval(eval_20(=, _17270), e, 490, '&self', ['get-state', 'state#'], _50348)
^  <span class="ansi1 ansi32"
>Call: </span>(390) [user] must_det_ll((notrace((flag(eval_num, _51314, _51314+1), _51332 is _51314 mod 500, _51350 is 99-490 mod 100, _51374=_51376, option_else('trace-length', _51388, 500), option_else('trace-depth', _51396, 30))), quietly(if_t((nop(stop_rtrace), _51332>_51388), (set_debug(eval, false), _51452 is _51388+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_51452])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_51504)))))
^  <span class="ansi1 ansi32"
>Call: </span>(391) [user] once(user:(notrace((flag(eval_num, _51314, _51314+1), _51332 is _51314 mod 500, _51350 is 99-490 mod 100, _51374=_51376, option_else('trace-length', _51388, 500), option_else('trace-depth', _51396, 30))), quietly(if_t((nop(stop_rtrace), _51332>_51388), (set_debug(eval, false), _51452 is _51388+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_51452])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_51504)))))
^  <span class="ansi1 ansi32"
>Call: </span>(394) [system] setup_call_cleanup('$notrace'(_53374, _53376), once(user:(flag(eval_num, _51314, _51314+1), _51332 is _51314 mod 500, _51350 is 99-490 mod 100, _51374=_51376, option_else('trace-length', _51388, 500), option_else('trace-depth', _51396, 30))), '$restore_trace'(_53374, _53376))
^  <span class="ansi1 ansi32"
>Call: </span>(395) [system] sig_atomic(system:'$notrace'(_53374, _53376))
^  <span class="ansi1 ansi32"
>Exit: </span>(394) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(flag(eval_num, 26, 26+1), 26 is 26 mod 500, 9 is 99-490 mod 100, _51374=_51374, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(394) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 26>500), (set_debug(eval, false), _51452 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_51452])), nop((start_rtrace, rtrace)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(394) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 26>500), (set_debug(eval, false), _51452 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_51452])), nop((start_rtrace, rtrace)))))
   <span class="ansi1 ansi32"
>Call: </span>(393) [user] nop(notrace(no_repeats_var(_51504)))
   <span class="ansi1 ansi32"
>Exit: </span>(393) [user] nop(notrace(no_repeats_var(_51504)))
^  <span class="ansi1 ansi32"
>Exit: </span>(391) [system] once(user:(notrace((flag(eval_num, 26, 26+1), 26 is 26 mod 500, 9 is 99-490 mod 100, _51374=_51374, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 26>500), (set_debug(eval, false), _51452 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_51452])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_51504)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(390) [user] must_det_ll(user:(notrace((flag(eval_num, 26, 26+1), 26 is 26 mod 500, 9 is 99-490 mod 100, _51374=_51374, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 26>500), (set_debug(eval, false), _51452 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_51452])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_51504)))))
   <span class="ansi1 ansi32"
>Call: </span>(390) [occurs] occurs:sub_term(_62058, e)
   <span class="ansi1 ansi32"
>Exit: </span>(390) [occurs] occurs:sub_term(e, e)
   <span class="ansi1 ansi32"
>Call: </span>(390) [system] e\=e
   <span class="ansi1 ansi31"
>Fail: </span>(390) [system] e\=e
   <span class="ansi1 ansi32"
>Call: </span>(391) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(391) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(390) [occurs] occurs:sub_term(_62058, e)
   <span class="ansi1 ansi32"
>Call: </span>(390) [system] _68548=e
   <span class="ansi1 ansi32"
>Exit: </span>(390) [system] e=e
^  <span class="ansi1 ansi32"
>Call: </span>(390) [user] if_trace((eval;e), (_51374=1, indentq(9, 26, -->, [e, ['get-state', 'state#']])))
^  <span class="ansi1 ansi32"
>Call: </span>(392) [system] setup_call_cleanup('$notrace'(_71424, _71426), once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _51374=1, indentq(9, 26, -->, [e, ['get-state', 'state#']]))), _71382, fbug((_71382-->if_trace((eval;e), (_51374=1, indentq(9, 26, -->, [e, ['get-state', 'state#']])))))))), '$restore_trace'(_71424, _71426))
^  <span class="ansi1 ansi32"
>Call: </span>(393) [system] sig_atomic(system:'$notrace'(_71424, _71426))
^  <span class="ansi1 ansi32"
>Exit: </span>(392) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _51374=1, indentq(9, 26, -->, [e, ['get-state', 'state#']]))), _71382, fbug((_71382-->if_trace((eval;e), (_51374=1, indentq(9, 26, -->, [e, ['get-state', 'state#']])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(390) [user] if_trace((eval;e), (_51374=1, indentq(9, 26, -->, [e, ['get-state', 'state#']])))
   <span class="ansi1 ansi32"
>Call: </span>(390) [system] _75268=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(390) [system] retval(fail)=retval(fail)
   <span class="ansi1 ansi32"
>Call: </span>(390) [system] _77130=(\+ \+ (flag(eval_num, _77150, _77150+1), (retval(fail)\=@=retval(fail), nonvar(_50348)->indentq(9, _77150, <--, [e, _50348]);indentq(9, _77150, <--, [e, retval(fail)]))))
   <span class="ansi1 ansi32"
>Exit: </span>(390) [system] (\+ \+ (flag(eval_num, _77150, _77150+1), (retval(fail)\=@=retval(fail), nonvar(_50348)->indentq(9, _77150, <--, [e, _50348]);indentq(9, _77150, <--, [e, retval(fail)]))))=(\+ \+ (flag(eval_num, _77150, _77150+1), (retval(fail)\=@=retval(fail), nonvar(_50348)->indentq(9, _77150, <--, [e, _50348]);indentq(9, _77150, <--, [e, retval(fail)]))))
^  <span class="ansi1 ansi32"
>Call: </span>(390) [user] call_cleanup(((call(eval_20(=, _17270), 490, '&self', ['get-state', 'state#'], _50348)*->nb_setarg(1, retval(fail), _50348);fail, trace, call(eval_20(=, _17270), 490, '&self', ['get-state', 'state#'], _50348)), ignore(notrace((\+_50348\=_51504, nb_setarg(1, retval(fail), _50348))))), ignore((_51374==1->ignore(\+ \+ (flag(eval_num, _77150, _77150+1), (retval(fail)\=@=retval(fail), nonvar(_50348)->indentq(9, _77150, <--, [e, _50348]);indentq(9, _77150, <--, [e, retval(fail)]))));notrace(ignore(if_t(9<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _77150, _77150+1), (retval(fail)\=@=retval(fail), nonvar(_50348)->indentq(9, _77150, <--, [e, _50348]);indentq(9, _77150, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi32"
>Call: </span>(392) [user] eval_20(=, _17270, 490, '&self', ['get-state', 'state#'], _50348)
   <span class="ansi1 ansi32"
>Call: </span>(393) [system] atom(['get-state', 'state#'])
^  <span class="ansi1 ansi32"
>Call: </span>(393) [user] no_eval(['get-state', 'state#'])
^  <span class="ansi1 ansi32"
>Call: </span>(394) [user] self_eval(['get-state', 'state#'])
^  <span class="ansi1 ansi32"
>Call: </span>(396) [system] setup_call_cleanup('$notrace'(_83922, _83924), once(user:self_eval0(['get-state', 'state#'])), '$restore_trace'(_83922, _83924))
^  <span class="ansi1 ansi32"
>Call: </span>(397) [system] sig_atomic(system:'$notrace'(_83922, _83924))
^  <span class="ansi1 ansi31"
>Fail: </span>(394) [user] self_eval(['get-state', 'state#'])
   <span class="ansi1 ansi32"
>Call: </span>(394) [system] atomic('get-state')
   <span class="ansi1 ansi32"
>Exit: </span>(394) [system] atomic('get-state')
^  <span class="ansi1 ansi32"
>Call: </span>(394) [user] is_sl('get-state')
   <span class="ansi1 ansi32"
>Call: </span>(395) [system] number('get-state')
   <span class="ansi1 ansi32"
>Call: </span>(393) [system] ['state#']==[]
   <span class="ansi1 ansi32"
>Call: </span>(393) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(393) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(393) [system] (=)\==(=)
   <span class="ansi1 ansi32"
>Call: </span>(393) [system] callable('get-state')
   <span class="ansi1 ansi32"
>Exit: </span>(393) [system] callable('get-state')
   <span class="ansi1 ansi32"
>Call: </span>(393) [system] is_list(['state#'])
   <span class="ansi1 ansi32"
>Exit: </span>(393) [system] is_list(['state#'])
   <span class="ansi1 ansi32"
>Call: </span>(393) [system] is_list(['get-state', 'state#'])
   <span class="ansi1 ansi32"
>Exit: </span>(393) [system] is_list(['get-state', 'state#'])
   <span class="ansi1 ansi32"
>Call: </span>(393) [system] var('get-state')
^  <span class="ansi1 ansi32"
>Call: </span>(393) [user] once(expand_eval(['get-state', 'state#'], _100624))
^  <span class="ansi1 ansi32"
>Call: </span>(394) [user] expand_eval(['get-state', 'state#'], _100624)
   <span class="ansi1 ansi32"
>Call: </span>(395) [system] is_list(['get-state', 'state#'])
   <span class="ansi1 ansi32"
>Exit: </span>(395) [system] is_list(['get-state', 'state#'])
   <span class="ansi1 ansi32"
>Call: </span>(395) [system] ground('get-state')
   <span class="ansi1 ansi32"
>Exit: </span>(395) [system] ground('get-state')
^  <span class="ansi1 ansi32"
>Call: </span>(395) [user] apply:maplist(expand_eval, ['state#'], _106196)
   <span class="ansi1 ansi32"
>Call: </span>(396) [apply] apply:maplist_(['state#'], _106196, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(397) [user] expand_eval('state#', _108076)
   <span class="ansi1 ansi32"
>Call: </span>(398) [system] is_list('state#')
   <span class="ansi1 ansi32"
>Call: </span>(398) [system] 'state#'=_108076
   <span class="ansi1 ansi32"
>Exit: </span>(398) [system] 'state#'='state#'
^  <span class="ansi1 ansi32"
>Exit: </span>(397) [user] expand_eval('state#', 'state#')
   <span class="ansi1 ansi32"
>Call: </span>(397) [apply] apply:maplist_([], _108078, user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(397) [apply] apply:maplist_([], [], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(396) [apply] apply:maplist_(['state#'], ['state#'], user:expand_eval)
^  <span class="ansi1 ansi32"
>Exit: </span>(395) [apply] apply:maplist(user:expand_eval, ['state#'], ['state#'])
^  <span class="ansi1 ansi32"
>Exit: </span>(394) [user] expand_eval(['get-state', 'state#'], ['get-state', 'state#'])
^  <span class="ansi1 ansi32"
>Exit: </span>(393) [system] once(user:expand_eval(['get-state', 'state#'], ['get-state', 'state#']))
   <span class="ansi1 ansi32"
>Call: </span>(393) [system] ['get-state', 'state#']\==['get-state', 'state#']
^  <span class="ansi1 ansi32"
>Call: </span>(393) [user] is_progn('get-state')
   <span class="ansi1 ansi32"
>Call: </span>(394) [system] var('get-state')
^  <span class="ansi1 ansi32"
>Call: </span>(393) [user] is_progn('get-state')
   <span class="ansi1 ansi32"
>Call: </span>(394) [system] var('get-state')
^  <span class="ansi1 ansi32"
>Call: </span>(393) [user] is_space_op('get-state')
   <span class="ansi1 ansi32"
>Call: </span>(393) [system] is_list('state#')
   <span class="ansi1 ansi32"
>Call: </span>(393) [system] 'state#'=='Nothing'
^  <span class="ansi1 ansi32"
>Call: </span>(393) [user] call_in_shared_space((eval_args(=, _17270, 490, '&self', 'state#', _125726), 'get-state'(_125726, _50348)))
^  <span class="ansi1 ansi32"
>Call: </span>(394) [user] call_in_thread(main, (eval_args(=, _17270, 490, '&self', 'state#', _125726), 'get-state'(_125726, _50348)))
   <span class="ansi1 ansi32"
>Call: </span>(395) [error] error:must_be(callable, user:(eval_args(=, _17270, 490, '&self', 'state#', _125726), 'get-state'(_125726, _50348)))
   <span class="ansi1 ansi32"
>Call: </span>(396) [system] nonvar(callable)
   <span class="ansi1 ansi32"
>Exit: </span>(396) [system] nonvar(callable)
   <span class="ansi1 ansi32"
>Call: </span>(396) [error] error:has_type(callable, user:(eval_args(=, _17270, 490, '&self', 'state#', _125726), 'get-state'(_125726, _50348)))
   <span class="ansi1 ansi32"
>Call: </span>(397) [system] callable(user:(eval_args(=, _17270, 490, '&self', 'state#', _125726), 'get-state'(_125726, _50348)))
   <span class="ansi1 ansi32"
>Exit: </span>(397) [system] callable(user:(eval_args(=, _17270, 490, '&self', 'state#', _125726), 'get-state'(_125726, _50348)))
   <span class="ansi1 ansi32"
>Exit: </span>(396) [error] error:has_type(callable, user:(eval_args(=, _17270, 490, '&self', 'state#', _125726), 'get-state'(_125726, _50348)))
   <span class="ansi1 ansi32"
>Exit: </span>(395) [error] error:must_be(callable, user:(eval_args(=, _17270, 490, '&self', 'state#', _125726), 'get-state'(_125726, _50348)))
   <span class="ansi1 ansi32"
>Call: </span>(395) [system] var(main)
   <span class="ansi1 ansi32"
>Call: </span>(395) [system] thread_self(main)
   <span class="ansi1 ansi32"
>Exit: </span>(395) [system] thread_self(main)
^  <span class="ansi1 ansi32"
>Call: </span>(395) [thread] once(user:(eval_args(=, _17270, 490, '&self', 'state#', _125726), 'get-state'(_125726, _50348)))
^  <span class="ansi1 ansi32"
>Call: </span>(397) [user] eval_args(=, _17270, 490, '&self', 'state#', _125726)
   <span class="ansi1 ansi32"
>Call: </span>(398) [system] var('state#')
^  <span class="ansi1 ansi32"
>Call: </span>(399) [system] setup_call_cleanup('$notrace'(_140616, _140618), once(user:self_eval('state#')), '$restore_trace'(_140616, _140618))
^  <span class="ansi1 ansi32"
>Call: </span>(400) [system] sig_atomic(system:'$notrace'(_140616, _140618))
^  <span class="ansi1 ansi32"
>Exit: </span>(399) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval('state#')), system:'$restore_trace'(3, -1))
   <span class="ansi1 ansi32"
>Call: </span>(398) [system] _125726='state#'
   <span class="ansi1 ansi32"
>Exit: </span>(398) [system] 'state#'='state#'
^  <span class="ansi1 ansi32"
>Exit: </span>(397) [user] eval_args(=, _17270, 490, '&self', 'state#', 'state#')
^  <span class="ansi1 ansi32"
>Call: </span>(397) [user] 'get-state'('state#', _50348)
^  <span class="ansi1 ansi32"
>Call: </span>(398) [user] fetch_or_create_state('state#', _147226)
^  <span class="ansi1 ansi32"
>Call: </span>(399) [user] is_valid_nb_state('state#')
   <span class="ansi1 ansi32"
>Call: </span>(400) [system] compound('state#')
   <span class="ansi1 ansi32"
>Call: </span>(399) [system] atom('state#')
   <span class="ansi1 ansi32"
>Exit: </span>(399) [system] atom('state#')
^  <span class="ansi1 ansi32"
>Call: </span>(399) [user] is_registered_state('state#')
^  <span class="ansi1 ansi32"
>Exit: </span>(399) [user] is_registered_state('state#')
^  <span class="ansi1 ansi32"
>Call: </span>(399) [user] nb_bound('state#', _147226)
   <span class="ansi1 ansi32"
>Call: </span>(400) [system] atom('state#')
   <span class="ansi1 ansi32"
>Exit: </span>(400) [system] atom('state#')
   <span class="ansi1 ansi32"
>Call: </span>(400) [system] atom_concat(&, _156552, 'state#')
   <span class="ansi1 ansi31"
>Fail: </span>(400) [system] atom_concat(&, _157484, 'state#')
^  <span class="ansi1 ansi31"
>Fail: </span>(399) [user] nb_bound('state#', _147226)
^  <span class="ansi1 ansi31"
>Fail: </span>(397) [user] 'get-state'('state#', _50348)
^  <span class="ansi1 ansi31"
>Fail: </span>(392) [user] eval_20(=, _17270, 490, '&self', ['get-state', 'state#'], _50348)
   <span class="ansi1 ansi32"
>Call: </span>(392) [system] fail
   <span class="ansi1 ansi31"
>Fail: </span>(392) [system] fail
^  <span class="ansi1 ansi32"
>Call: </span>(392) [user] ignore((_51374==1->ignore(\+ \+ (flag(eval_num, _77150, _77150+1), (retval(fail)\=@=retval(fail), nonvar(_50348)->indentq(9, _77150, <--, [e, _50348]);indentq(9, _77150, <--, [e, retval(fail)]))));notrace(ignore(if_t(9<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _77150, _77150+1), (retval(fail)\=@=retval(fail), nonvar(_50348)->indentq(9, _77150, <--, [e, _50348]);indentq(9, _77150, <--, [e, retval(fail)]))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(394) [system] _51374==1
   <span class="ansi1 ansi31"
>Fail: </span>(394) [system] _51374==1
^  <span class="ansi1 ansi32"
>Call: </span>(395) [system] setup_call_cleanup('$notrace'(_165772, _165774), once(user:ignore(if_t(9<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _77150, _77150+1), (retval(fail)\=@=retval(fail), nonvar(_50348)->indentq(9, _77150, <--, [e, _50348]);indentq(9, _77150, <--, [e, retval(fail)])))))))), '$restore_trace'(_165772, _165774))
^  <span class="ansi1 ansi32"
>Call: </span>(396) [system] sig_atomic(system:'$notrace'(_165772, _165774))
^  <span class="ansi1 ansi32"
>Exit: </span>(395) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:ignore(if_t(9<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _77150, _77150+1), (retval(fail)\=@=retval(fail), nonvar(_50348)->indentq(9, _77150, <--, [e, _50348]);indentq(9, _77150, <--, [e, retval(fail)])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(392) [system] ignore(user:(_51374==1->ignore(\+ \+ (flag(eval_num, _77150, _77150+1), (retval(fail)\=@=retval(fail), nonvar(_50348)->indentq(9, _77150, <--, [e, _50348]);indentq(9, _77150, <--, [e, retval(fail)]))));notrace(ignore(if_t(9<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _77150, _77150+1), (retval(fail)\=@=retval(fail), nonvar(_50348)->indentq(9, _77150, <--, [e, _50348]);indentq(9, _77150, <--, [e, retval(fail)]))))))))))
^  <span class="ansi1 ansi31"
>Fail: </span>(390) [system] call_cleanup(user:((call(eval_20(=, _17270), 490, '&self', ['get-state', 'state#'], _50348)*->nb_setarg(1, retval(fail), _50348);fail, trace, call(eval_20(=, _17270), 490, '&self', ['get-state', 'state#'], _50348)), ignore(notrace((\+_50348\=_51504, nb_setarg(1, retval(fail), _50348))))), user:ignore((_51374==1->ignore(\+ \+ (flag(eval_num, _77150, _77150+1), (retval(fail)\=@=retval(fail), nonvar(_50348)->indentq(9, _77150, <--, [e, _50348]);indentq(9, _77150, <--, [e, retval(fail)]))));notrace(ignore(if_t(9<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _77150, _77150+1), (retval(fail)\=@=retval(fail), nonvar(_50348)->indentq(9, _77150, <--, [e, _50348]);indentq(9, _77150, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi31"
>Fail: </span>(389) [user] trace_eval(eval_20(=, _17270), e, 490, '&self', ['get-state', 'state#'], _50348)
^  <span class="ansi1 ansi31"
>Fail: </span>(386) [user] eval_args(=, _17270, 491, '&self', ['get-state', 'state#'], _17284)
^  <span class="ansi1 ansi32"
>Call: </span>(383) [user] call(eval, ['get-state', 'state#'], _17284)
   <span class="ansi1 ansi32"
>Call: </span>(384) [user] eval(['get-state', 'state#'], _17284)
^  <span class="ansi1 ansi32"
>Call: </span>(385) [user] current_self(_174388)
   <span class="ansi1 ansi32"
>Call: </span>(386) [system] nb_current(self_space, _174388)
   <span class="ansi1 ansi32"
>Exit: </span>(386) [system] nb_current(self_space, '&self')
   <span class="ansi1 ansi32"
>Call: </span>(386) [system] '&self'\==[]
   <span class="ansi1 ansi32"
>Exit: </span>(386) [system] '&self'\==[]
^  <span class="ansi1 ansi32"
>Exit: </span>(385) [user] current_self('&self')
   <span class="ansi1 ansi32"
>Call: </span>(385) [user] eval('&self', ['get-state', 'state#'], _17284)
   <span class="ansi1 ansi32"
>Call: </span>(386) [user] eval_H(500, '&self', ['get-state', 'state#'], _17284)
^  <span class="ansi1 ansi32"
>Call: </span>(387) [user] catch_metta_return(eval_args(=, _181798, 500, '&self', ['get-state', 'state#'], _17284), _17284)
^  <span class="ansi1 ansi32"
>Call: </span>(389) [user] eval_args(=, _181798, 500, '&self', ['get-state', 'state#'], _17284)
   <span class="ansi1 ansi32"
>Call: </span>(390) [system] var(['get-state', 'state#'])
^  <span class="ansi1 ansi32"
>Call: </span>(391) [system] setup_call_cleanup('$notrace'(_184644, _184646), once(user:self_eval(['get-state', 'state#'])), '$restore_trace'(_184644, _184646))
^  <span class="ansi1 ansi32"
>Call: </span>(392) [system] sig_atomic(system:'$notrace'(_184644, _184646))
^  <span class="ansi1 ansi32"
>Call: </span>(391) [system] setup_call_cleanup('$notrace'(_186556, _186558), once(user:nonvar(_17284)), '$restore_trace'(_186556, _186558))
^  <span class="ansi1 ansi32"
>Call: </span>(392) [system] sig_atomic(system:'$notrace'(_186556, _186558))
^  <span class="ansi1 ansi32"
>Call: </span>(391) [system] setup_call_cleanup('$notrace'(_188468, _188470), once(user:nonvar(_17284)), '$restore_trace'(_188468, _188470))
^  <span class="ansi1 ansi32"
>Call: </span>(392) [system] sig_atomic(system:'$notrace'(_188468, _188470))
   <span class="ansi1 ansi32"
>Call: </span>(390) [system] ['state#']==[]
   <span class="ansi1 ansi32"
>Call: </span>(390) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(390) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(390) [system] (=)\==(=)
^  <span class="ansi1 ansi32"
>Call: </span>(390) [user] self_eval(['get-state', 'state#'])
^  <span class="ansi1 ansi32"
>Call: </span>(392) [system] setup_call_cleanup('$notrace'(_195008, _195010), once(user:self_eval0(['get-state', 'state#'])), '$restore_trace'(_195008, _195010))
^  <span class="ansi1 ansi32"
>Call: </span>(393) [system] sig_atomic(system:'$notrace'(_195008, _195010))
^  <span class="ansi1 ansi31"
>Fail: </span>(390) [user] self_eval(['get-state', 'state#'])
^  <span class="ansi1 ansi32"
>Call: </span>(390) [user] eval_00(=, _181798, 500, '&self', ['get-state', 'state#'], _17284)
^  <span class="ansi1 ansi32"
>Call: </span>(391) [user] self_eval(['get-state', 'state#'])
^  <span class="ansi1 ansi32"
>Call: </span>(393) [system] setup_call_cleanup('$notrace'(_199712, _199714), once(user:self_eval0(['get-state', 'state#'])), '$restore_trace'(_199712, _199714))
^  <span class="ansi1 ansi32"
>Call: </span>(394) [system] sig_atomic(system:'$notrace'(_199712, _199714))
^  <span class="ansi1 ansi31"
>Fail: </span>(391) [user] self_eval(['get-state', 'state#'])
^  <span class="ansi1 ansi32"
>Call: </span>(391) [user] eval_01(=, _181798, 500, '&self', ['get-state', 'state#'], _17284)
^  <span class="ansi1 ansi32"
>Call: </span>(392) [user] if_t((500<1, trace_on_overflow), debug(metta(eval_args)))
   <span class="ansi1 ansi32"
>Call: </span>(394) [system] 500<1
   <span class="ansi1 ansi31"
>Fail: </span>(394) [system] 500<1
^  <span class="ansi1 ansi32"
>Exit: </span>(392) [user] if_t((500<1, trace_on_overflow), debug(metta(eval_args)))
^  <span class="ansi1 ansi32"
>Call: </span>(393) [system] setup_call_cleanup('$notrace'(_207244, _207246), once(user:(_207220 is 500-1, copy_term(['get-state', 'state#'], _207234))), '$restore_trace'(_207244, _207246))
^  <span class="ansi1 ansi32"
>Call: </span>(394) [system] sig_atomic(system:'$notrace'(_207244, _207246))
^  <span class="ansi1 ansi32"
>Exit: </span>(393) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(499 is 500-1, copy_term(['get-state', 'state#'], ['get-state', 'state#']))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(392) [user] trace_eval(eval_20(=, _181798), e, 499, '&self', ['get-state', 'state#'], _210090)
^  <span class="ansi1 ansi32"
>Call: </span>(393) [user] must_det_ll((notrace((flag(eval_num, _211056, _211056+1), _211074 is _211056 mod 500, _211092 is 99-499 mod 100, _211116=_211118, option_else('trace-length', _211130, 500), option_else('trace-depth', _211138, 30))), quietly(if_t((nop(stop_rtrace), _211074>_211130), (set_debug(eval, false), _211194 is _211130+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_211194])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_211246)))))
^  <span class="ansi1 ansi32"
>Call: </span>(394) [user] once(user:(notrace((flag(eval_num, _211056, _211056+1), _211074 is _211056 mod 500, _211092 is 99-499 mod 100, _211116=_211118, option_else('trace-length', _211130, 500), option_else('trace-depth', _211138, 30))), quietly(if_t((nop(stop_rtrace), _211074>_211130), (set_debug(eval, false), _211194 is _211130+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_211194])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_211246)))))
^  <span class="ansi1 ansi32"
>Call: </span>(397) [system] setup_call_cleanup('$notrace'(_213116, _213118), once(user:(flag(eval_num, _211056, _211056+1), _211074 is _211056 mod 500, _211092 is 99-499 mod 100, _211116=_211118, option_else('trace-length', _211130, 500), option_else('trace-depth', _211138, 30))), '$restore_trace'(_213116, _213118))
^  <span class="ansi1 ansi32"
>Call: </span>(398) [system] sig_atomic(system:'$notrace'(_213116, _213118))
^  <span class="ansi1 ansi32"
>Exit: </span>(397) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(flag(eval_num, 27, 27+1), 27 is 27 mod 500, 0 is 99-499 mod 100, _211116=_211116, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(397) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 27>500), (set_debug(eval, false), _211194 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_211194])), nop((start_rtrace, rtrace)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(397) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 27>500), (set_debug(eval, false), _211194 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_211194])), nop((start_rtrace, rtrace)))))
   <span class="ansi1 ansi32"
>Call: </span>(396) [user] nop(notrace(no_repeats_var(_211246)))
   <span class="ansi1 ansi32"
>Exit: </span>(396) [user] nop(notrace(no_repeats_var(_211246)))
^  <span class="ansi1 ansi32"
>Exit: </span>(394) [system] once(user:(notrace((flag(eval_num, 27, 27+1), 27 is 27 mod 500, 0 is 99-499 mod 100, _211116=_211116, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 27>500), (set_debug(eval, false), _211194 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_211194])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_211246)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(393) [user] must_det_ll(user:(notrace((flag(eval_num, 27, 27+1), 27 is 27 mod 500, 0 is 99-499 mod 100, _211116=_211116, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 27>500), (set_debug(eval, false), _211194 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_211194])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_211246)))))
   <span class="ansi1 ansi32"
>Call: </span>(393) [occurs] occurs:sub_term(_221800, e)
   <span class="ansi1 ansi32"
>Exit: </span>(393) [occurs] occurs:sub_term(e, e)
   <span class="ansi1 ansi32"
>Call: </span>(393) [system] e\=e
   <span class="ansi1 ansi31"
>Fail: </span>(393) [system] e\=e
   <span class="ansi1 ansi32"
>Call: </span>(394) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(394) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(393) [occurs] occurs:sub_term(_221800, e)
   <span class="ansi1 ansi32"
>Call: </span>(393) [system] _228290=e
   <span class="ansi1 ansi32"
>Exit: </span>(393) [system] e=e
^  <span class="ansi1 ansi32"
>Call: </span>(393) [user] if_trace((eval;e), (_211116=1, indentq(0, 27, -->, [e, ['get-state', 'state#']])))
^  <span class="ansi1 ansi32"
>Call: </span>(395) [system] setup_call_cleanup('$notrace'(_231166, _231168), once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _211116=1, indentq(0, 27, -->, [e, ['get-state', 'state#']]))), _231124, fbug((_231124-->if_trace((eval;e), (_211116=1, indentq(0, 27, -->, [e, ['get-state', 'state#']])))))))), '$restore_trace'(_231166, _231168))
^  <span class="ansi1 ansi32"
>Call: </span>(396) [system] sig_atomic(system:'$notrace'(_231166, _231168))
^  <span class="ansi1 ansi32"
>Exit: </span>(395) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _211116=1, indentq(0, 27, -->, [e, ['get-state', 'state#']]))), _231124, fbug((_231124-->if_trace((eval;e), (_211116=1, indentq(0, 27, -->, [e, ['get-state', 'state#']])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(393) [user] if_trace((eval;e), (_211116=1, indentq(0, 27, -->, [e, ['get-state', 'state#']])))
   <span class="ansi1 ansi32"
>Call: </span>(393) [system] _235010=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(393) [system] retval(fail)=retval(fail)
   <span class="ansi1 ansi32"
>Call: </span>(393) [system] _236872=(\+ \+ (flag(eval_num, _236892, _236892+1), (retval(fail)\=@=retval(fail), nonvar(_210090)->indentq(0, _236892, <--, [e, _210090]);indentq(0, _236892, <--, [e, retval(fail)]))))
   <span class="ansi1 ansi32"
>Exit: </span>(393) [system] (\+ \+ (flag(eval_num, _236892, _236892+1), (retval(fail)\=@=retval(fail), nonvar(_210090)->indentq(0, _236892, <--, [e, _210090]);indentq(0, _236892, <--, [e, retval(fail)]))))=(\+ \+ (flag(eval_num, _236892, _236892+1), (retval(fail)\=@=retval(fail), nonvar(_210090)->indentq(0, _236892, <--, [e, _210090]);indentq(0, _236892, <--, [e, retval(fail)]))))
^  <span class="ansi1 ansi32"
>Call: </span>(393) [user] call_cleanup(((call(eval_20(=, _181798), 499, '&self', ['get-state', 'state#'], _210090)*->nb_setarg(1, retval(fail), _210090);fail, trace, call(eval_20(=, _181798), 499, '&self', ['get-state', 'state#'], _210090)), ignore(notrace((\+_210090\=_211246, nb_setarg(1, retval(fail), _210090))))), ignore((_211116==1->ignore(\+ \+ (flag(eval_num, _236892, _236892+1), (retval(fail)\=@=retval(fail), nonvar(_210090)->indentq(0, _236892, <--, [e, _210090]);indentq(0, _236892, <--, [e, retval(fail)]))));notrace(ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _236892, _236892+1), (retval(fail)\=@=retval(fail), nonvar(_210090)->indentq(0, _236892, <--, [e, _210090]);indentq(0, _236892, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi32"
>Call: </span>(395) [user] eval_20(=, _181798, 499, '&self', ['get-state', 'state#'], _210090)
   <span class="ansi1 ansi32"
>Call: </span>(396) [system] atom(['get-state', 'state#'])
^  <span class="ansi1 ansi32"
>Call: </span>(396) [user] no_eval(['get-state', 'state#'])
^  <span class="ansi1 ansi32"
>Call: </span>(397) [user] self_eval(['get-state', 'state#'])
^  <span class="ansi1 ansi32"
>Call: </span>(399) [system] setup_call_cleanup('$notrace'(_243664, _243666), once(user:self_eval0(['get-state', 'state#'])), '$restore_trace'(_243664, _243666))
^  <span class="ansi1 ansi32"
>Call: </span>(400) [system] sig_atomic(system:'$notrace'(_243664, _243666))
^  <span class="ansi1 ansi31"
>Fail: </span>(397) [user] self_eval(['get-state', 'state#'])
   <span class="ansi1 ansi32"
>Call: </span>(397) [system] atomic('get-state')
   <span class="ansi1 ansi32"
>Exit: </span>(397) [system] atomic('get-state')
^  <span class="ansi1 ansi32"
>Call: </span>(397) [user] is_sl('get-state')
   <span class="ansi1 ansi32"
>Call: </span>(398) [system] number('get-state')
   <span class="ansi1 ansi32"
>Call: </span>(396) [system] ['state#']==[]
   <span class="ansi1 ansi32"
>Call: </span>(396) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(396) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(396) [system] (=)\==(=)
   <span class="ansi1 ansi32"
>Call: </span>(396) [system] callable('get-state')
   <span class="ansi1 ansi32"
>Exit: </span>(396) [system] callable('get-state')
   <span class="ansi1 ansi32"
>Call: </span>(396) [system] is_list(['state#'])
   <span class="ansi1 ansi32"
>Exit: </span>(396) [system] is_list(['state#'])
   <span class="ansi1 ansi32"
>Call: </span>(396) [system] is_list(['get-state', 'state#'])
   <span class="ansi1 ansi32"
>Exit: </span>(396) [system] is_list(['get-state', 'state#'])
   <span class="ansi1 ansi32"
>Call: </span>(396) [system] var('get-state')
^  <span class="ansi1 ansi32"
>Call: </span>(396) [user] once(expand_eval(['get-state', 'state#'], _260366))
^  <span class="ansi1 ansi32"
>Call: </span>(397) [user] expand_eval(['get-state', 'state#'], _260366)
   <span class="ansi1 ansi32"
>Call: </span>(398) [system] is_list(['get-state', 'state#'])
   <span class="ansi1 ansi32"
>Exit: </span>(398) [system] is_list(['get-state', 'state#'])
   <span class="ansi1 ansi32"
>Call: </span>(398) [system] ground('get-state')
   <span class="ansi1 ansi32"
>Exit: </span>(398) [system] ground('get-state')
^  <span class="ansi1 ansi32"
>Call: </span>(398) [user] apply:maplist(expand_eval, ['state#'], _265938)
   <span class="ansi1 ansi32"
>Call: </span>(399) [apply] apply:maplist_(['state#'], _265938, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(400) [user] expand_eval('state#', _267818)
   <span class="ansi1 ansi32"
>Call: </span>(401) [system] is_list('state#')
   <span class="ansi1 ansi32"
>Call: </span>(401) [system] 'state#'=_267818
   <span class="ansi1 ansi32"
>Exit: </span>(401) [system] 'state#'='state#'
^  <span class="ansi1 ansi32"
>Exit: </span>(400) [user] expand_eval('state#', 'state#')
   <span class="ansi1 ansi32"
>Call: </span>(400) [apply] apply:maplist_([], _267820, user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(400) [apply] apply:maplist_([], [], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(399) [apply] apply:maplist_(['state#'], ['state#'], user:expand_eval)
^  <span class="ansi1 ansi32"
>Exit: </span>(398) [apply] apply:maplist(user:expand_eval, ['state#'], ['state#'])
^  <span class="ansi1 ansi32"
>Exit: </span>(397) [user] expand_eval(['get-state', 'state#'], ['get-state', 'state#'])
^  <span class="ansi1 ansi32"
>Exit: </span>(396) [system] once(user:expand_eval(['get-state', 'state#'], ['get-state', 'state#']))
   <span class="ansi1 ansi32"
>Call: </span>(396) [system] ['get-state', 'state#']\==['get-state', 'state#']
^  <span class="ansi1 ansi32"
>Call: </span>(396) [user] is_progn('get-state')
   <span class="ansi1 ansi32"
>Call: </span>(397) [system] var('get-state')
^  <span class="ansi1 ansi32"
>Call: </span>(396) [user] is_progn('get-state')
   <span class="ansi1 ansi32"
>Call: </span>(397) [system] var('get-state')
^  <span class="ansi1 ansi32"
>Call: </span>(396) [user] is_space_op('get-state')
   <span class="ansi1 ansi32"
>Call: </span>(396) [system] is_list('state#')
   <span class="ansi1 ansi32"
>Call: </span>(396) [system] 'state#'=='Nothing'
^  <span class="ansi1 ansi32"
>Call: </span>(396) [user] call_in_shared_space((eval_args(=, _181798, 499, '&self', 'state#', _285468), 'get-state'(_285468, _210090)))
^  <span class="ansi1 ansi32"
>Call: </span>(397) [user] call_in_thread(main, (eval_args(=, _181798, 499, '&self', 'state#', _285468), 'get-state'(_285468, _210090)))
   <span class="ansi1 ansi32"
>Call: </span>(398) [error] error:must_be(callable, user:(eval_args(=, _181798, 499, '&self', 'state#', _285468), 'get-state'(_285468, _210090)))
   <span class="ansi1 ansi32"
>Call: </span>(399) [system] nonvar(callable)
   <span class="ansi1 ansi32"
>Exit: </span>(399) [system] nonvar(callable)
   <span class="ansi1 ansi32"
>Call: </span>(399) [error] error:has_type(callable, user:(eval_args(=, _181798, 499, '&self', 'state#', _285468), 'get-state'(_285468, _210090)))
   <span class="ansi1 ansi32"
>Call: </span>(400) [system] callable(user:(eval_args(=, _181798, 499, '&self', 'state#', _285468), 'get-state'(_285468, _210090)))
   <span class="ansi1 ansi32"
>Exit: </span>(400) [system] callable(user:(eval_args(=, _181798, 499, '&self', 'state#', _285468), 'get-state'(_285468, _210090)))
   <span class="ansi1 ansi32"
>Exit: </span>(399) [error] error:has_type(callable, user:(eval_args(=, _181798, 499, '&self', 'state#', _285468), 'get-state'(_285468, _210090)))
   <span class="ansi1 ansi32"
>Exit: </span>(398) [error] error:must_be(callable, user:(eval_args(=, _181798, 499, '&self', 'state#', _285468), 'get-state'(_285468, _210090)))
   <span class="ansi1 ansi32"
>Call: </span>(398) [system] var(main)
   <span class="ansi1 ansi32"
>Call: </span>(398) [system] thread_self(main)
   <span class="ansi1 ansi32"
>Exit: </span>(398) [system] thread_self(main)
^  <span class="ansi1 ansi32"
>Call: </span>(398) [thread] once(user:(eval_args(=, _181798, 499, '&self', 'state#', _285468), 'get-state'(_285468, _210090)))
^  <span class="ansi1 ansi32"
>Call: </span>(400) [user] eval_args(=, _181798, 499, '&self', 'state#', _285468)
   <span class="ansi1 ansi32"
>Call: </span>(401) [system] var('state#')
^  <span class="ansi1 ansi32"
>Call: </span>(402) [system] setup_call_cleanup('$notrace'(_300358, _300360), once(user:self_eval('state#')), '$restore_trace'(_300358, _300360))
^  <span class="ansi1 ansi32"
>Call: </span>(403) [system] sig_atomic(system:'$notrace'(_300358, _300360))
^  <span class="ansi1 ansi32"
>Exit: </span>(402) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval('state#')), system:'$restore_trace'(3, -1))
   <span class="ansi1 ansi32"
>Call: </span>(401) [system] _285468='state#'
   <span class="ansi1 ansi32"
>Exit: </span>(401) [system] 'state#'='state#'
^  <span class="ansi1 ansi32"
>Exit: </span>(400) [user] eval_args(=, _181798, 499, '&self', 'state#', 'state#')
^  <span class="ansi1 ansi32"
>Call: </span>(400) [user] 'get-state'('state#', _210090)
^  <span class="ansi1 ansi32"
>Call: </span>(401) [user] fetch_or_create_state('state#', _306968)
^  <span class="ansi1 ansi32"
>Call: </span>(402) [user] is_valid_nb_state('state#')
   <span class="ansi1 ansi32"
>Call: </span>(403) [system] compound('state#')
   <span class="ansi1 ansi32"
>Call: </span>(402) [system] atom('state#')
   <span class="ansi1 ansi32"
>Exit: </span>(402) [system] atom('state#')
^  <span class="ansi1 ansi32"
>Call: </span>(402) [user] is_registered_state('state#')
^  <span class="ansi1 ansi32"
>Exit: </span>(402) [user] is_registered_state('state#')
^  <span class="ansi1 ansi32"
>Call: </span>(402) [user] nb_bound('state#', _306968)
   <span class="ansi1 ansi32"
>Call: </span>(403) [system] atom('state#')
   <span class="ansi1 ansi32"
>Exit: </span>(403) [system] atom('state#')
   <span class="ansi1 ansi32"
>Call: </span>(403) [system] atom_concat(&, _316294, 'state#')
   <span class="ansi1 ansi31"
>Fail: </span>(403) [system] atom_concat(&, _317226, 'state#')
^  <span class="ansi1 ansi31"
>Fail: </span>(402) [user] nb_bound('state#', _306968)
^  <span class="ansi1 ansi31"
>Fail: </span>(400) [user] 'get-state'('state#', _210090)
^  <span class="ansi1 ansi31"
>Fail: </span>(395) [user] eval_20(=, _181798, 499, '&self', ['get-state', 'state#'], _210090)
   <span class="ansi1 ansi32"
>Call: </span>(395) [system] fail
   <span class="ansi1 ansi31"
>Fail: </span>(395) [system] fail
^  <span class="ansi1 ansi32"
>Call: </span>(395) [user] ignore((_211116==1->ignore(\+ \+ (flag(eval_num, _236892, _236892+1), (retval(fail)\=@=retval(fail), nonvar(_210090)->indentq(0, _236892, <--, [e, _210090]);indentq(0, _236892, <--, [e, retval(fail)]))));notrace(ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _236892, _236892+1), (retval(fail)\=@=retval(fail), nonvar(_210090)->indentq(0, _236892, <--, [e, _210090]);indentq(0, _236892, <--, [e, retval(fail)]))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(397) [system] _211116==1
   <span class="ansi1 ansi31"
>Fail: </span>(397) [system] _211116==1
^  <span class="ansi1 ansi32"
>Call: </span>(398) [system] setup_call_cleanup('$notrace'(_325514, _325516), once(user:ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _236892, _236892+1), (retval(fail)\=@=retval(fail), nonvar(_210090)->indentq(0, _236892, <--, [e, _210090]);indentq(0, _236892, <--, [e, retval(fail)])))))))), '$restore_trace'(_325514, _325516))
^  <span class="ansi1 ansi32"
>Call: </span>(399) [system] sig_atomic(system:'$notrace'(_325514, _325516))
^  <span class="ansi1 ansi32"
>Exit: </span>(398) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _236892, _236892+1), (retval(fail)\=@=retval(fail), nonvar(_210090)->indentq(0, _236892, <--, [e, _210090]);indentq(0, _236892, <--, [e, retval(fail)])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(395) [system] ignore(user:(_211116==1->ignore(\+ \+ (flag(eval_num, _236892, _236892+1), (retval(fail)\=@=retval(fail), nonvar(_210090)->indentq(0, _236892, <--, [e, _210090]);indentq(0, _236892, <--, [e, retval(fail)]))));notrace(ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _236892, _236892+1), (retval(fail)\=@=retval(fail), nonvar(_210090)->indentq(0, _236892, <--, [e, _210090]);indentq(0, _236892, <--, [e, retval(fail)]))))))))))
^  <span class="ansi1 ansi31"
>Fail: </span>(393) [system] call_cleanup(user:((call(eval_20(=, _181798), 499, '&self', ['get-state', 'state#'], _210090)*->nb_setarg(1, retval(fail), _210090);fail, trace, call(eval_20(=, _181798), 499, '&self', ['get-state', 'state#'], _210090)), ignore(notrace((\+_210090\=_211246, nb_setarg(1, retval(fail), _210090))))), user:ignore((_211116==1->ignore(\+ \+ (flag(eval_num, _236892, _236892+1), (retval(fail)\=@=retval(fail), nonvar(_210090)->indentq(0, _236892, <--, [e, _210090]);indentq(0, _236892, <--, [e, retval(fail)]))));notrace(ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _236892, _236892+1), (retval(fail)\=@=retval(fail), nonvar(_210090)->indentq(0, _236892, <--, [e, _210090]);indentq(0, _236892, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi31"
>Fail: </span>(392) [user] trace_eval(eval_20(=, _181798), e, 499, '&self', ['get-state', 'state#'], _210090)
^  <span class="ansi1 ansi31"
>Fail: </span>(389) [user] eval_args(=, _181798, 500, '&self', ['get-state', 'state#'], _17284)
^  <span class="ansi1 ansi31"
>Fail: </span>(380) [system] call(user:once, user:if_or_else(eval(=, _17270, 491, '&self', ['get-state', 'state#'], _17284), call(eval, ['get-state', 'state#'], _17284)))
^  <span class="ansi1 ansi32"
>Call: </span>(380) [bugger] bugger:mquietly_if(true, rtrace:pop_tracer)
   <span class="ansi1 ansi32"
>Call: </span>(382) [system] var(rtrace:pop_tracer)
   <span class="ansi1 ansi31"
>Fail: </span>(382) [system] var(rtrace:pop_tracer)
^  <span class="ansi1 ansi32"
>Call: </span>(384) [system] setup_call_cleanup('$notrace'(_336008, _336010), once(rtrace:retract(t_l:tracer_reset(_335998))), '$restore_trace'(_336008, _336010))
^  <span class="ansi1 ansi32"
>Call: </span>(385) [system] sig_atomic(system:'$notrace'(_336008, _336010))
^  <span class="ansi1 ansi32"
>Exit: </span>(384) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(rtrace:retract(t_l:tracer_reset(tAt_normal))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(384) [rtrace] tAt(false, 271, 271, false)

Script done on 2024-10-01 01:10:01+00:00 [COMMAND_EXIT_CODE="143"]

</pre>
</body>

</html>
\033[1;33mCompleted (EXITCODE=143) Under 40 seconds: ./mettalog '--output=./reports/tests_output/baseline-compat-2024-10-01T00:37:26/' --timeout=40 --html --repl=false  --test "tests/extended_compat/metta-examples/strips/strips-to-metta-improved/queries.metta" --halt=true\033[0m

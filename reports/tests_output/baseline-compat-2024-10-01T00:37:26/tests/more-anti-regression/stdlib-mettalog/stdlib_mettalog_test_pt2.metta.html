<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"
>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"
>
<title></title>
<style type="text/css"
>
.ansi2html-content { display: inline; white-space: pre-wrap; word-wrap: break-word; }
.body_foreground { color: #AAAAAA; }
.body_background { background-color: #000000; }
.inv_foreground { color: #000000; }
.inv_background { background-color: #AAAAAA; }
.ansi1 { font-weight: bold; }
.ansi31 { color: #aa0000; }
.ansi32 { color: #00aa00; }
.ansi36 { color: #00aaaa; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
</style>
</head>
<body class="body_foreground body_background" style="font-size: normal;" >
<pre class="ansi2html-content"
>
Script started on 2024-10-01 00:56:47+00:00 [TERM="xterm-256color" TTY="/dev/pts/0" COLUMNS="-1" LINES="-1"]
P;HTML|
;           (set_option_value  prolog false)

P;HTML|
;           (set_option_value  compat auto)

P;HTML|
;           (set_option_value  compatio true)
P;HTML|
;            (is_cmd_option  prescan halt --halt=true true)
P;HTML|
;            (set_option_value  halt true)
P;HTML|
;            (is_cmd_option  prescan stdin --stdin=tty tty)
P;HTML|
;             (set_option_value  stdin tty)
P;HTML|
;            (is_cmd_option  prescan stdout --stdout=tty tty)
P;HTML|
;             (set_option_value  stdout tty)
P;HTML|
;            (is_cmd_option  prescan stderr --stderr=tty tty)
P;HTML|
;             (set_option_value  stderr tty)
P;HTML|
;            (set_option_value  prolog false)
P;HTML|
;            (set_option_value  compat auto)
P;HTML|
;            (set_option_value  compatio true)
P;HTML|
;          (is_cmd_option  execute python --python=enable enable)
P;HTML|
;           (set_option_value  python enable)
P;HTML|
;          (is_cmd_option  execute timeout --timeout=40 40)
P;HTML|
;           (set_option_value  timeout 40)
P;HTML|
;           (is_cmd_option  execute output --output=./reports/tests_output/baseline-compat-2024-10-01T00:37:26/ ./reports/tests_output/baseline-compat-2024-10-01T00:37:26/)
P;HTML|
;           (set_option_value  output ./reports/tests_output/baseline-compat-2024-10-01T00:37:26/)
P;HTML|
;           (is_cmd_option  execute html --html true)
P;HTML|
;            (set_option_value  html true)
P;HTML|
;           (is_cmd_option  execute test --test true)
P;HTML|
;            (set_option_value  test true)

; (load_metta_file  &self tests/more-anti-regression/stdlib-mettalog/stdlib_mettalog_test_pt2.metta)
P;HTML|
;                         (track_load_into_file  /home/runner/work/metta-wam/metta-wam/tests/more-anti-regression/stdlib-mettalog/stdlib_mettalog_test_pt2.metta)
P;HTML|
;                                          (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/more-anti-regression/stdlib-mettalog/stdlib_mettalog_test_pt2.metta.answers /home/runner/work/metta-wam/metta-wam/tests/more-anti-regression/stdlib-mettalog/stdlib_mettalog_test_pt2.metta)
P;HTML|
;                                           (= 1  "[(Error (assertEqual (eval) (\"Error\" (eval) \"expected: (eval <atom>), found: (eval)\")) ")
P;HTML|
;                                           (= 1  "Expected: [(\"Error\" (Error (eval) IncorrectNumberOfArguments) \"expected: (eval <atom>), found: (eval)\")]")
P;HTML|
;                                           (= 1  "Got: [(Error (eval) IncorrectNumberOfArguments)]")
P;HTML|
;                                           (= 2  "Missed result: (\"Error\" (Error (eval) IncorrectNumberOfArguments) \"expected: (eval <atom>), found: (eval)\"))]")
P;HTML|
;                                           (= 2  "0.03user 0.01system 0:00.05elapsed 100%CPU (0avgtext+0avgdata 26144maxresident)k")
P;HTML|
;                                           (= 2  "0inputs+0outputs (0major+3023minor)pagefaults 0swaps")
P;HTML|
;                                          (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/more-anti-regression/stdlib-mettalog/stdlib_mettalog_test_pt2.metta.answers /home/runner/work/metta-wam/metta-wam/tests/more-anti-regression/stdlib-mettalog/stdlib_mettalog_test_pt2.metta)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Converted Rust Tests with Original Source
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; Original:
;;;; #[test]
;;;; fn interpret_atom_evaluate_incorrect_args() {
;;;;     assert_eq!(call_interpret(&space(""), &metta_atom("(eval)")),
;;;;         vec![expr!("Error" ("eval") "expected: (eval <atom>), found: (eval)")]);
;;;;     assert_eq!(call_interpret(&space(""), &metta_atom("(eval a b)")),
;;;;         vec![expr!("Error" ("eval" "a" "b") "expected: (eval <atom>), found: (eval a b)")]);
;;;; }
;;;; Converted:
<span class="ansi38-013099040"
>  !(assertEqual 
    (eval) 
    ("Error" 
      (eval) "expected: (eval <atom>), found: (eval)"))

</span>[

;<h3 id="STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.01"
>;; STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.01</h3>
; 
; EVAL TEST
; took 0.000828 secs. (827.93 microseconds) 

  !(assertEqual 
    (eval) 
    ("Error" 
      (eval) "expected: (eval <atom>), found: (eval)"))

<span class="ansi31"
>  (loonit_failureR  
    (equal_enough_for_test  
      ( (eval)) 
      ( ("Error" 
          (eval) "expected: (eval <atom>), found: (eval)"))))
</span>
Deterministic: ((Error  (got  ((eval))) (expected  (("Error" (eval) "expected: (eval <atom>), found: (eval)")))))
((Error  (got  ((eval))) (expected  (("Error" (eval) "expected: (eval <atom>), found: (eval)")))))]
<span class="ansi38-013099040"
>  !(assertEqual 
    (eval a b) 
    ("Error" 
      (eval a b) "expected: (eval <atom>), found: (eval a b)"))

</span>[

;<h3 id="STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.02"
>;; STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.02</h3>
; 
; EVAL TEST
; took 0.000789 secs. (789.45 microseconds) 

  !(assertEqual 
    (eval a b) 
    ("Error" 
      (eval a b) "expected: (eval <atom>), found: (eval a b)"))

<span class="ansi31"
>  (loonit_failureR  
    (equal_enough_for_test  
      ( (eval a b)) 
      ( ("Error" 
          (eval a b) "expected: (eval <atom>), found: (eval a b)"))))
</span>
Deterministic: ((Error  (got  ((eval a b))) (expected  (("Error" (eval a b) "expected: (eval <atom>), found: (eval a b)")))))
((Error  (got  ((eval a b))) (expected  (("Error" (eval a b) "expected: (eval <atom>), found: (eval a b)")))))]
;;;; Original:
;;;; #[test]
;;;; fn interpret_atom_evaluate_atom() {
;;;;     let result = call_interpret(&space("(= a b)"), &metta_atom("(eval a)"));
;;;;     assert_eq!(result, vec![metta_atom("b")]);
;;;; }
;;;; Converted:
<span class="ansi38-255165000"
>  (= a b)
</span><span class="ansi38-013099040"
>  !(assertEqual 
    (eval a) b)

</span>[

;<h3 id="STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.03"
>;; STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.03</h3>
; 
; EVAL TEST
; took 0.000016 secs. (15.69 microseconds) 

  !(assertEqual 
    (eval a) b)

<span class="ansi31"
>  (loonit_failureR  
    (equal_enough_for_test  
      (a) 
      (b)))
</span>
Deterministic: ((Error  (got  (a)) (expected  (b))))
((Error  (got  (a)) (expected  (b))))]
;;;; Original:
;;;; #[test]
;;;; fn interpret_atom_evaluate_atom_no_definition() {
;;;;     let result = call_interpret(&space(""), &metta_atom("(eval a)"));
;;;;     assert_eq!(result, vec![metta_atom("NotReducible")]);
;;;; }
;;;; Converted:
<span class="ansi38-013099040"
>  !(assertEqual 
    (eval a) NotReducible)

</span>[

;<h3 id="STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.04"
>;; STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.04</h3>
; 
; EVAL TEST
; took 0.000024 secs. (23.84 microseconds) 

  !(assertEqual 
    (eval a) NotReducible)

<span class="ansi31"
>  (loonit_failureR  
    (equal_enough_for_test  
      (a) 
      (NotReducible)))
</span>
Deterministic: ((Error  (got  (a)) (expected  (NotReducible))))
((Error  (got  (a)) (expected  (NotReducible))))]
;;;; Original:
;;;; #[test]
;;;; fn interpret_atom_evaluate_empty_expression() {
;;;;     let result = call_interpret(&space(""), &metta_atom("(eval ())"));
;;;;     assert_eq!(result, vec![metta_atom("NotReducible")]);
;;;; }
;;;; Converted:
<span class="ansi38-013099040"
>  !(assertEqual 
    (eval ()) NotReducible)

</span>[

;<h3 id="STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.05"
>;; STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.05</h3>
; 
; EVAL TEST
; took 0.000022 secs. (22.37 microseconds) 

  !(assertEqual 
    (eval ()) NotReducible)

<span class="ansi31"
>  (loonit_failureR  
    (equal_enough_for_test  
      (()) 
      (NotReducible)))
</span>
Deterministic: ((Error  (got  (())) (expected  (NotReducible))))
((Error  (got  (())) (expected  (NotReducible))))]
;;;; Original:
;;;; #[test]
;;;; fn interpret_atom_evaluate_grounded_value() {
;;;;     let result = call_interpret(&space(""), &expr!("eval" {6}));
;;;;     assert_eq!(result, vec![metta_atom("NotReducible")]);
;;;; }
;;;; Converted:
<span class="ansi38-013099040"
>  !(assertEqual 
    (eval {(6) }) NotReducible)

</span>[

;<h3 id="STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.06"
>;; STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.06</h3>
; 
; EVAL TEST
; took 0.000027 secs. (26.97 microseconds) 

  !(assertEqual 
    (eval {(6) }) NotReducible)

<span class="ansi31"
>  (loonit_failureR  
    (equal_enough_for_test  
      ( { (6) }) 
      (NotReducible)))
</span>
Deterministic: ((Error  (got  ({(6) })) (expected  (NotReducible))))
((Error  (got  ({(6) })) (expected  (NotReducible))))]
;;;; Original:
;;;; #[test]
;;;; fn interpret_atom_evaluate_pure_expression() {
;;;;     let space = space("(= (foo $a B) $a)");
;;;;     let result = call_interpret(&space, &metta_atom("(eval (foo A $b))"));
;;;;     assert_eq!(result, vec![metta_atom("A")]);
;;;; }
;;;; Converted:
<span class="ansi38-255165000"
>  (= 
    (foo $a B) $a)
</span><span class="ansi38-013099040"
>  !(assertEqual 
    (eval (foo A $b)) A)

</span>[

;<h3 id="STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.07"
>;; STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.07</h3>
; 
; EVAL TEST
; took 0.000023 secs. (22.85 microseconds) 

  !(assertEqual 
    (eval (foo A $b)) A)

<span class="ansi36"
>  (loonit_success  
    (equal_enough_for_test  
      (A) 
      (A)))
</span>
Deterministic: ()
$b = B
()]
;;;; Original:
;;;; #[test]
;;;; fn interpret_atom_evaluate_pure_expression_non_determinism() {
;;;;     let space = space("
;;;;         (= color red)
;;;;         (= color green)
;;;;         (= color blue)
;;;;     ");
;;;;     let result = call_interpret(&space, &metta_atom("(eval color)"));
;;;;     assert_eq_no_order!(result, vec![
;;;;         metta_atom("red"),
;;;;         metta_atom("green"),
;;;;         metta_atom("blue"),
;;;;     ]);
;;;; }
;;;; Converted:
<span class="ansi38-255165000"
>  (= color red)
</span><span class="ansi38-255165000"
>  (= color green)
</span><span class="ansi38-255165000"
>  (= color blue)
</span><span class="ansi38-013099040"
>  !(assertEqualNoOrder 
    (eval color) 
    (red green blue))

</span>

Deterministic: (assertEqualNoOrder color (red green blue))[
  (assertEqualNoOrder color 

    (red green blue))]
;;;; Original:
;;;; #[test]
;;;; fn interpret_atom_evaluate_pure_expression_no_definition() {
;;;;     let result = call_interpret(&space(""), &metta_atom("(eval (foo A))"));
;;;;     assert_eq!(result, vec![metta_atom("NotReducible")]);
;;;; }
;;;; Converted:
<span class="ansi38-013099040"
>  !(assertEqual 
    (eval (foo A)) NotReducible)

</span>[

;<h3 id="STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.08"
>;; STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.08</h3>
; 
; EVAL TEST
; took 0.000252 secs. (251.92 microseconds) 

  !(assertEqual 
    (eval (foo A)) NotReducible)

<span class="ansi31"
>  (loonit_failureR  
    (equal_enough_for_test  
      ( (foo A)) 
      (NotReducible)))
</span>
Deterministic: ((Error  (got  ((foo A))) (expected  (NotReducible))))
((Error  (got  ((foo A))) (expected  (NotReducible))))]
;;;; Original:
;;;; #[test]
;;;; fn interpret_atom_evaluate_pure_expression_variable_in_space() {
;;;;     let space = space("$t (= (foo $a B) $a)");
;;;;     let result = call_interpret(&space, &metta_atom("(eval (foo A $b))"));
;;;;     assert_eq!(result, vec![metta_atom("A")]);
;;;; }
;;;; Converted:
<span class="ansi38-255165000"
> $t
</span><span class="ansi38-255165000"
>  (= 
    (foo $a B) $a)
</span><span class="ansi38-013099040"
>  !(assertEqual 
    (eval (foo A $b)) A)

</span>[

;<h3 id="STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.09"
>;; STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.09</h3>
; 
; EVAL TEST
; took 0.000025 secs. (24.72 microseconds) 

  !(assertEqual 
    (eval (foo A $b)) A)

<span class="ansi36"
>  (loonit_success  
    (equal_enough_for_test  
      (A) 
      (A)))
</span>
Deterministic: ()
$b = B
()]
;;;; Original:
;;;; #[test]
;;;; fn interpret_atom_evaluate_pure_expression_variable_name_conflict() {
;;;;     let space = space("(= (foo ($W)) True)");
;;;;     let result = call_interpret(&space, &metta_atom("(eval (foo $W))"));
;;;;     assert_eq!(result[0], sym!("True"));
;;;; }
;;;; Converted:
<span class="ansi38-255165000"
>  (= 
    (foo ($W)) True)
</span><span class="ansi38-013099040"
>  !(assertEqual 
    (eval (foo $W)) True)

</span>[

;<h3 id="STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.10"
>;; STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.10</h3>
; 
; EVAL TEST
; took 0.000199 secs. (198.71 microseconds) 

  !(assertEqual 
    (eval (foo $W)) True)

<span class="ansi31"
>  (loonit_failureR  
    (equal_enough_for_test  
      ( (foo $_423662)) 
      (True)))
</span>
Deterministic: ((Error  (got  ((foo $_423662))) (expected  (True))))
  ( (Error  
      (got  
        ( (foo $_423662))) 
      (expected  

        (True))))]
;;;; Original:
;;;; #[test]
;;;; fn interpret_atom_evaluate_grounded_expression() {
;;;;     let result = call_interpret(&space(""), &expr!("eval" ({MulXUndefinedType(7)} {6})));
;;;;     assert_eq!(result, vec![expr!({42})]);
;;;; }
;;;; Converted:
<span class="ansi38-013099040"
>  !(assertEqual 
    (eval 
      (MulXUndefinedType 7) 6) 42)

</span>[

;<h3 id="STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.11"
>;; STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.11</h3>
; 
; EVAL TEST
; took 0.000617 secs. (616.65 microseconds) 

  !(assertEqual 
    (eval 
      (MulXUndefinedType 7) 6) 42)

<span class="ansi31"
>  (loonit_failureR  
    (equal_enough_for_test  
      ( (eval 
          (MulXUndefinedType 7) 6)) 
      (42)))
</span>
Deterministic: ((Error  (got  ((eval (MulXUndefinedType 7) 6))) (expected  (42))))
((Error  (got  ((eval (MulXUndefinedType 7) 6))) (expected  (42))))]
;;;; Original:
;;;; #[test]
;;;; fn interpret_atom_evaluate_grounded_expression_empty() {
;;;;     let result = call_interpret(&space(""), &expr!("eval" ({ReturnNothing()} {6})));
;;;;     assert_eq!(result, vec![]);
;;;; }
;;;; Converted:
<span class="ansi38-013099040"
>  !(assertEqual 
    (eval (ReturnNothing 6)) ())

</span>[

;<h3 id="STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.12"
>;; STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.12</h3>
; 
; EVAL TEST
; took 0.000416 secs. (415.96 microseconds) 

  !(assertEqual 
    (eval (ReturnNothing 6)) ())

<span class="ansi31"
>  (loonit_failureR  
    (equal_enough_for_test  
      ( (ReturnNothing 6)) 
      (())))
</span>
Deterministic: ((Error  (got  ((ReturnNothing 6))) (expected  (()))))
((Error  (got  ((ReturnNothing 6))) (expected  (()))))]
;;;; Original:
;;;; #[test]
;;;; fn interpret_atom_evaluate_grounded_expression_noreduce() {
;;;;     let result = call_interpret(&space(""), &expr!("eval" ({NonReducible()} {6})));
;;;;     assert_eq!(result, vec![expr!("NotReducible")]);
;;;; }
;;;; Converted:
<span class="ansi38-013099040"
>  !(assertEqual 
    (eval (NonReducible 6)) NotReducible)

</span>[

;<h3 id="STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.13"
>;; STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.13</h3>
; 
; EVAL TEST
; took 0.000410 secs. (409.61 microseconds) 

  !(assertEqual 
    (eval (NonReducible 6)) NotReducible)

<span class="ansi31"
>  (loonit_failureR  
    (equal_enough_for_test  
      ( (NonReducible 6)) 
      (NotReducible)))
</span>
Deterministic: ((Error  (got  ((NonReducible 6))) (expected  (NotReducible))))
((Error  (got  ((NonReducible 6))) (expected  (NotReducible))))]
;;;; Original:
;;;; #[test]
;;;; fn interpret_atom_evaluate_grounded_expression_error() {
;;;;     let result = call_interpret(&space(""), &expr!("eval" ({ThrowError()} {"Test error"})));
;;;;     assert_eq!(result, vec![expr!("Error" ({ThrowError()} {"Test error"}) "Test error")]);
;;;; }
;;;; Converted:
<span class="ansi38-013099040"
>  !(assertEqual 
    (eval (Error ThrowError "Test error")) 
    (Error 
      (Error ThrowError "Test error") "Test error"))

</span>[

;<h3 id="STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.14"
>;; STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.14</h3>
; 
; EVAL TEST
; took 0.000026 secs. (25.60 microseconds) 

  !(assertEqual 
    (eval (Error ThrowError "Test error")) 
    (Error 
      (Error ThrowError "Test error") "Test error"))

<span class="ansi36"
>  (loonit_success  
    (equal_enough_for_test  
      ( (Error ThrowError "Test error")) 
      ( (Error 
          (Error ThrowError "Test error") "Test error"))))
</span>
Deterministic: ()
()]
;;;; Original:
;;;; #[test]
;;;; fn interpret_atom_evaluate_variable_operation() {
;;;;     let space = space("(= (foo $a B) $a)");
;;;;     let result = call_interpret(&space, &metta_atom("(eval ($a A $b))"));
;;;;     #[cfg(feature = "variable_operation")]
;;;;     assert_eq!(result, vec![metta_atom("A")]);
;;;;     #[cfg(not(feature = "variable_operation"))]
;;;;     assert_eq!(result, vec![NOT_REDUCIBLE_SYMBOL]);
;;;; }
;;;; Converted:
<span class="ansi38-255165000"
>  (= 
    (foo $a B) $a)
</span><span class="ansi38-013099040"
>  !(assertEqual 
    (eval ($a A $b)) A)

</span>[

;<h3 id="STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.15"
>;; STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.15</h3>
; 
; EVAL TEST
; took 0.000219 secs. (219.18 microseconds) 

  !(assertEqual 
    (eval ($a A $b)) A)

<span class="ansi31"
>  (loonit_failureR  
    (equal_enough_for_test  
      ( ($_89070 A $_89082)) 
      (A)))
</span>
Deterministic: ((Error  (got  (($_89070 A $_89082))) (expected  (A))))
  ( (Error  
      (got  
        ( ($_89070 A $_89082))) 
      (expected  

        (A))))]
;;;; Original:
;;;; #[test]
;;;; fn interpret_atom_evaluate_variable_via_call_direct_equality() {
;;;;     let space = space("
;;;;         (= (bar) (function (return ())))
;;;;         (= (foo $b) (function
;;;;           (chain (eval (bar)) $_
;;;;           (unify $b value
;;;;             (return ())
;;;;             (return (Error () \"Unexpected error\")) ))))");
;;;;     let result = call_interpret(&space,
;;;;         &metta_atom("(chain (eval (foo $a)) $_ $a)"));
;;;;     assert_eq!(result[0], sym!("value"));
;;;; }
;;;; Converted:
<span class="ansi38-255165000"
>  (= 
    (bar) 
    (function (return ())))
</span><span class="ansi38-255165000"
>  (= 
    (foo $b) 
    (function (chain (eval (bar)) $ (unify $b value (return ()) (return (Error () "Unexpected error"))))))
</span><span class="ansi38-013099040"
>  !(assertEqual 
    (chain 
      (eval (foo $a)) $ $a) value)

</span>[

;<h3 id="STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.16"
>;; STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.16</h3>
; 
; EVAL TEST
; took 0.000513 secs. (513.16 microseconds) 

  !(assertEqual 
    (chain 
      (eval (foo $a)) $ $a) value)

<span class="ansi31"
>  (loonit_failureR  
    (equal_enough_for_test  
      ($_139658) 
      (value)))
</span>
Deterministic: ((Error  (got  ($_139658)) (expected  (value))))
  ( (Error  
      (got  
        ($_139658)) 
      (expected  

        (value))))]
;;;; Original:
;;;; #[test]
;;;; fn interpret_atom_evaluate_variable_via_call_struct_equality() {
;;;;     let formal_arg_struct = space("
;;;;         (= (bar) (function (return ())))
;;;;         (= (foo ($b)) (function
;;;;           (chain (eval (bar)) $_
;;;;           (unify $b value
;;;;             (return ())
;;;;             (return (Error () \"Unexpected error\")) ))))");
;;;;     let result = call_interpret(&formal_arg_struct,
;;;;         &metta_atom("(chain (eval (foo $a)) $_ $a)"));
;;;;     assert_eq!(result[0], expr!(("value")));
;;;;
;;;;     let actual_arg_struct = space("
;;;;         (= (bar) (function (return ())))
;;;;         (= (foo $b) (function
;;;;           (chain (eval (bar)) $_
;;;;           (unify $b (value)
;;;;             (return ())
;;;;             (return (Error () \"Unexpected error\")) ))))");
;;;;     let result = call_interpret(&actual_arg_struct,
;;;;         &metta_atom("(chain (eval (foo ($a))) $_ $a)"));
;;;;     assert_eq!(result[0], sym!("value"));
;;;; }
;;;; Converted:
<span class="ansi38-255165000"
>  (= 
    (bar) 
    (function (return ())))
</span><span class="ansi38-255165000"
>  (= 
    (foo ($b)) 
    (function (chain (eval (bar)) $ (unify $b value (return ()) (return (Error () "Unexpected error"))))))
</span><span class="ansi38-013099040"
>  !(assertEqual 
    (chain 
      (eval (foo $a)) $ $a) 
    ("value"))

</span>[

;<h3 id="STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.17"
>;; STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.17</h3>
; 
; EVAL TEST
; took 0.000560 secs. (560.13 microseconds) 

  !(assertEqual 
    (chain 
      (eval (foo $a)) $ $a) 
    ("value"))

<span class="ansi31"
>  (loonit_failureR  
    (equal_enough_for_test  
      ($_179586) 
      ( ("value"))))
</span>
Deterministic: ((Error  (got  ($_179586)) (expected  (("value")))))
  ( (Error  
      (got  
        ($_179586)) 
      (expected  

        ( ("value")))))]
<span class="ansi38-255165000"
>  (= 
    (bar) 
    (function (return ())))
</span><span class="ansi38-255165000"
>  (= 
    (foo $b) 
    (function (chain (eval (bar)) $ (unify $b (value) (return ()) (return (Error () "Unexpected error"))))))
</span><span class="ansi38-013099040"
>  !(assertEqual 
    (chain 
      (eval (foo ($a))) $ $a) value)

</span>[

;<h3 id="STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.18"
>;; STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.18</h3>
; 
; EVAL TEST
; took 0.000638 secs. (637.89 microseconds) 

  !(assertEqual 
    (chain 
      (eval (foo ($a))) $ $a) value)

<span class="ansi31"
>  (loonit_failureR  
    (equal_enough_for_test  
      ($_223694) 
      (value)))
</span>
Deterministic: ((Error  (got  ($_223694)) (expected  (value))))
  ( (Error  
      (got  
        ($_223694)) 
      (expected  

        (value))))]
;;;; Original:
;;;; #[test]
;;;; fn interpret_atom_evaluate_variable_operation_nested() {
;;;;     let space = space("(= ((baz $a) $b) ($a $b))");
;;;;     let result = call_interpret(&space, &metta_atom("(eval (($a A) B))"));
;;;;     #[cfg(feature = "variable_operation")]
;;;;     assert_eq!(result, vec![metta_atom("(A B)")]);
;;;;     #[cfg(not(feature = "variable_operation"))]
;;;;     assert_eq!(result, vec![NOT_REDUCIBLE_SYMBOL]);
;;;; }
;;;; Converted:
<span class="ansi38-255165000"
>  (= 
    ( (baz $a) $b) 
    ($a $b))
</span><span class="ansi38-013099040"
>  !(assertEqual 
    (eval (($a A) B)) 
    (A B))

</span>[

;<h3 id="STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.19"
>;; STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.19</h3>
; 
; EVAL TEST
; took 0.000340 secs. (339.91 microseconds) 

  !(assertEqual 
    (eval (($a A) B)) 
    (A B))

<span class="ansi36"
>  (loonit_success  
    (equal_enough_for_test  
      ( (A B)) 
      ( (A B))))
</span>
NDet Result(1): ()
$a = baz
()

;<h3 id="STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.20"
>;; STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.20</h3>
; 
; EVAL TEST
; took 0.010 secs. (9.71 milliseconds) 

  !(assertEqual 
    (eval (($a A) B)) 
    (A B))

<span class="ansi31"
>  (loonit_failureR  
    (equal_enough_for_test  
      ( ( (function (chain (eval (function (return ()))) $_513944 (unify A value (return ()) (return (Error () "Unexpected error"))))) B)) 
      ( (A B))))
</span>

NDet Result(2): ((Error  (got  (((function (chain (eval (function (return ()))) $_10424 (unify A value (return ()) (return (Error () "Unexpected error"))))) B))) (expected  ((A B))))), 
  ( (Error  
      (got  
        ( ( (function (chain (eval (function (return ()))) $_10424 (unify A value (return ()) (return (Error () "Unexpected error"))))) B))) 
      (expected  

$a = foo
        ( (A B)))))

;<h3 id="STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.21"
>;; STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.21</h3>
; 
; EVAL TEST
; took 0.011 secs. (11.11 milliseconds) 

  !(assertEqual 
    (eval (($a A) B)) 
    (A B))

<span class="ansi31"
>  (loonit_failureR  
    (equal_enough_for_test  
      ( ( (function (chain (eval (function (return ()))) $_383280 (unify A (value) (return ()) (return (Error () "Unexpected error"))))) B)) 
      ( (A B))))
</span>

NDet Result(3): ((Error  (got  (((function (chain (eval (function (return ()))) $_383280 (unify A (value) (return ()) (return (Error () "Unexpected error"))))) B))) (expected  ((A B))))), 
  ( (Error  
      (got  
        ( ( (function (chain (eval (function (return ()))) $_383280 (unify A (value) (return ()) (return (Error () "Unexpected error"))))) B))) 
      (expected  

$a = foo
        ( (A B)))))

;<h3 id="STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.22"
>;; STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.22</h3>
; 
; EVAL TEST
; took 0.087 secs. (87.44 milliseconds) 

  !(assertEqual 
    (eval (($a A) B)) 
    (A B))

<span class="ansi31"
>  (loonit_failureR  
    (equal_enough_for_test  
      ( (A B) 
        ( (function (chain (eval (function (return ()))) $_187158 (unify A value (return ()) (return (Error () "Unexpected error"))))) B) 
        ( (function (chain (eval (function (return ()))) $_186980 (unify A (value) (return ()) (return (Error () "Unexpected error"))))) B) 
        ( ($_186890 A) B)) 
      ( (A B))))
</span>

Last Result(4): ((Error  (got  ((A B) ((function (chain (eval (function (return ()))) $_187158 (unify A value (return ()) (return (Error () "Unexpected error"))))) B) ((function (chain (eval (function (return ()))) $_186980 (unify A (value) (return ()) (return (Error () "Unexpected error"))))) B) (($_186890 A) B))) (expected  ((A B))))), 
  ( (Error  
      (got  
        ( (A B) 
          ( (function (chain (eval (function (return ()))) $_187158 (unify A value (return ()) (return (Error () "Unexpected error"))))) B) 
          ( (function (chain (eval (function (return ()))) $_186980 (unify A (value) (return ()) (return (Error () "Unexpected error"))))) B) 
          ( ($_186890 A) B))) 
      (expected  

$a = 
  (baz $_5494)
        ( (A B)))))]
;;;; Original:
;;;; #[test]
;;;; fn interpret_atom_chain_incorrect_args() {
;;;;     assert_eq!(call_interpret(&space(""), &metta_atom("(chain n $v t o)")),
;;;;         vec![expr!("Error" ("chain" "n" v "t" "o") "expected: (chain <nested> (: <var> Variable) <templ>), found: (chain n $v t o)")]);
;;;;     assert_eq!(call_interpret(&space(""), &metta_atom("(chain n v t)")),
;;;;         vec![expr!("Error" ("chain" "n" "v" "t") "expected: (chain <nested> (: <var> Variable) <templ>), found: (chain n v t)")]);
;;;;     assert_eq!(call_interpret(&space(""), &metta_atom("(chain n $v)")),
;;;;         vec![expr!("Error" ("chain" "n" v) "expected: (chain <nested> (: <var> Variable) <templ>), found: (chain n $v)")]);
;;;; }
;;;; Converted:
<span class="ansi38-013099040"
>  !(assertEqual 
    (chain n $v t o) 
    ("Error" 
      (chain n v t o) "expected: (chain <nested> (: <var> Variable) <templ>), found: (chain n $v t o)"))

</span>[

;<h3 id="STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.23"
>;; STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.23</h3>
; 
; EVAL TEST
; took 0.000483 secs. (482.66 microseconds) 

  !(assertEqual 
    (chain n $v t o) 
    ("Error" 
      (chain n v t o) "expected: (chain <nested> (: <var> Variable) <templ>), found: (chain n $v t o)"))

<span class="ansi31"
>  (loonit_failureR  
    (equal_enough_for_test  
      (o) ()))
</span>
Deterministic: ((Error  (got  (o)) (expected  ())))
((Error  (got  (o)) (expected  ())))]
<span class="ansi38-013099040"
>  !(assertEqual 
    (chain n v t) 
    ("Error" 
      (chain n v t) "expected: (chain <nested> (: <var> Variable) <templ>), found: (chain n v t)"))

</span>[

;<h3 id="STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.24"
>;; STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.24</h3>
; 
; EVAL TEST
; took 0.000304 secs. (304.48 microseconds) 

  !(assertEqual 
    (chain n v t) 
    ("Error" 
      (chain n v t) "expected: (chain <nested> (: <var> Variable) <templ>), found: (chain n v t)"))

<span class="ansi36"
>  (loonit_success  
    (equal_enough_for_test  () ()))
</span>
Deterministic: ()
()]
<span class="ansi38-013099040"
>  !(assertEqual 
    (chain n $v) 
    ("Error" 
      (chain n v) "expected: (chain <nested> (: <var> Variable) <templ>), found: (chain n $v)"))

</span>[

;<h3 id="STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.25"
>;; STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.25</h3>
; 
; EVAL TEST
; took 0.000573 secs. (572.65 microseconds) 

  !(assertEqual 
    (chain n $v) 
    ("Error" 
      (chain n v) "expected: (chain <nested> (: <var> Variable) <templ>), found: (chain n $v)"))

<span class="ansi31"
>  (loonit_failureR  
    (equal_enough_for_test  
      ( (chain-body)) ()))
</span>
Deterministic: ((Error  (got  ((chain-body))) (expected  ())))
((Error  (got  ((chain-body))) (expected  ())))]
;;;; Original:
;;;; #[test]
;;;; fn interpret_atom_chain_atom() {
;;;;     let result = call_interpret(&space(""), &expr!("chain" ("A" () {6} y) x ("bar" x)));
;;;;     assert_eq!(result, vec![expr!("bar" ("A" () {6} y))]);
;;;; }
;;;; Converted:
<span class="ansi38-013099040"
>  !(assertEqual 
    (chain 
      (A () 
        { (6) } y) x 
      (bar x)) 
    (bar (A () {(6) } y)))

</span>[

;<h3 id="STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.26"
>;; STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.26</h3>
; 
; EVAL TEST
; took 0.000741 secs. (741.40 microseconds) 

  !(assertEqual 
    (chain 
      (A () 
        { (6) } y) x 
      (bar x)) 
    (bar (A () {(6) } y)))

<span class="ansi31"
>  (loonit_failureR  
    (equal_enough_for_test  () 
      ( (bar (A () {(6) } y)))))
</span>
Deterministic: ((Error  (got  ()) (expected  ((bar (A () {(6) } y))))))
((Error  (got  ()) (expected  ((bar (A () {(6) } y))))))]
;;;; Original:
;;;; #[test]
;;;; fn interpret_atom_chain_evaluation() {
;;;;     let space = space("(= (foo $a B) $a)");
;;;;     let result = call_interpret(&space, &metta_atom("(chain (eval (foo A $b)) $x (bar $x))"));
;;;;     assert_eq!(result, vec![metta_atom("(bar A)")]);
;;;; }
;;;; Converted:
<span class="ansi38-255165000"
>  (= 
    (foo $a B) $a)
</span><span class="ansi38-013099040"
>  !(assertEqual 
    (chain 
      (eval (foo A $b)) $x 
      (bar $x)) 
    (bar A))

</span>[

;<h3 id="STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.27"
>;; STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.27</h3>
; 
; EVAL TEST
; took 0.001 secs. (1.02 milliseconds) 

  !(assertEqual 
    (chain 
      (eval (foo A $b)) $x 
      (bar $x)) 
    (bar A))

<span class="ansi36"
>  (loonit_success  
    (equal_enough_for_test  
      ( (bar A)) 
      ( (bar A))))
</span>
Deterministic: ()
()]
;;;; Original:
;;;; #[test]
;;;; fn interpret_atom_chain_nested_evaluation() {
;;;;     let space = space("(= (foo $a B) $a)");
;;;;     let result = call_interpret(&space, &metta_atom("(chain (chain (eval (foo A $b)) $x (bar $x)) $y (baz $y))"));
;;;;     assert_eq!(result, vec![metta_atom("(baz (bar A))")]);
;;;; }
;;;; Converted:
<span class="ansi38-255165000"
>  (= 
    (foo $a B) $a)
</span><span class="ansi38-013099040"
>  !(assertEqual 
    (chain 
      (chain 
        (eval (foo A $b)) $x 
        (bar $x)) $y 
      (baz $y)) 
    (baz (bar A)))

</span>[

;<h3 id="STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.28"
>;; STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.28</h3>
; 
; EVAL TEST
; took 0.002 secs. (1.94 milliseconds) 

  !(assertEqual 
    (chain 
      (chain 
        (eval (foo A $b)) $x 
        (bar $x)) $y 
      (baz $y)) 
    (baz (bar A)))

<span class="ansi36"
>  (loonit_success  
    (equal_enough_for_test  
      ( (baz (bar A))) 
      ( (baz (bar A)))))
</span>
Deterministic: ()
()]
;;;; Original:
;;;; #[test]
;;;; fn interpret_atom_chain_nested_value() {
;;;;     let result = call_interpret(&space(""), &metta_atom("(chain (chain A $x (bar $x)) $y (baz $y))"));
;;;;     assert_eq!(result, vec![metta_atom("(baz (bar A))")]);
;;;; }
;;;; Converted:
<span class="ansi38-013099040"
>  !(assertEqual 
    (chain 
      (chain A $x 
        (bar $x)) $y 
      (baz $y)) 
    (baz (bar A)))

</span>[

;<h3 id="STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.29"
>;; STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.29</h3>
; 
; EVAL TEST
; took 0.002 secs. (1.54 milliseconds) 

  !(assertEqual 
    (chain 
      (chain A $x 
        (bar $x)) $y 
      (baz $y)) 
    (baz (bar A)))

<span class="ansi36"
>  (loonit_success  
    (equal_enough_for_test  
      ( (baz (bar A))) 
      ( (baz (bar A)))))
</span>
Deterministic: ()
()]
;;;; Original:
;;;; #[test]
;;;; fn interpret_atom_chain_expression_non_determinism() {
;;;;     let space = space("
;;;;         (= (color) red)
;;;;         (= (color) green)
;;;;         (= (color) blue)
;;;;     ");
;;;;     let result = call_interpret(&space, &metta_atom("(chain (eval (color)) $x (bar $x))"));
;;;;     assert_eq_no_order!(result, vec![
;;;;         metta_atom("(bar red)"),
;;;;         metta_atom("(bar green)"),
;;;;         metta_atom("(bar blue))"),
;;;;     ]);
;;;; }
;;;; Converted:
<span class="ansi38-255165000"
>  (= 
    (color) red)
</span><span class="ansi38-255165000"
>  (= 
    (color) green)
</span><span class="ansi38-255165000"
>  (= 
    (color) blue)
</span><span class="ansi38-013099040"
>  !(assertEqualNoOrder 
    (chain 
      (eval (color)) $x 
      (bar $x)) 
    ( (bar red) 
      (bar green) 
      (bar blue)))

</span>

NDet Result(1): (assertEqualNoOrder (bar red) ((bar red) (bar green) (bar blue)))[
  (assertEqualNoOrder 
    (bar red) 
    ( (bar red) 
      (bar green) 

$x = red
      (bar blue)))


NDet Result(2): (assertEqualNoOrder (bar green) ((bar red) (bar green) (bar blue))), 
  (assertEqualNoOrder 
    (bar green) 
    ( (bar red) 
      (bar green) 

$x = green
      (bar blue)))


Last Result(3): (assertEqualNoOrder (bar blue) ((bar red) (bar green) (bar blue))), 
  (assertEqualNoOrder 
    (bar blue) 
    ( (bar red) 
      (bar green) 

$x = blue
      (bar blue)))]
;;;; Original:
;;;; #[test]
;;;; fn interpret_atom_chain_return() {
;;;;     let result = call_interpret(&space(""), &metta_atom("(chain Empty $x (bar $x))"));
;;;;     assert_eq!(result, vec![metta_atom("(bar Empty)")]);
;;;; }
;;;; Converted:
<span class="ansi38-013099040"
>  !(assertEqual 
    (chain  $x 
      (bar $x)) 
    (bar ))

</span>[

;<h3 id="STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.30"
>;; STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.30</h3>
; 
; EVAL TEST
; took 0.000764 secs. (764.29 microseconds) 

  !(assertEqual 
    (chain  $x 
      (bar $x)) 
    (bar ))

<span class="ansi36"
>  (loonit_success  
    (equal_enough_for_test  () ()))
</span>
Deterministic: ()
()]
;;;; Original:
;;;; #[test]
;;;; fn interpret_atom_chain_keep_var_from_evaluated_part() {
;;;;     let result = call_interpret(&space("(= (even 4) True)"), &metta_atom("(chain (eval (even $x)) $res (= (is-even $x) $res))"));
;;;;     assert_eq!(result, vec![metta_atom("(= (is-even 4) True)")]);
;;;; }
;;;; Converted:
<span class="ansi38-255165000"
>  (= 
    (even 4) True)
</span><span class="ansi38-013099040"
>  !(assertEqual 
    (chain 
      (eval (even $x)) $res 
      (= 
        (is-even $x) $res)) 
    (= 
      (is-even 4) True))

</span>[

;<h3 id="STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.31"
>;; STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.31</h3>
; 
; EVAL TEST
; took 0.000615 secs. (614.75 microseconds) 

  !(assertEqual 
    (chain 
      (eval (even $x)) $res 
      (= 
        (is-even $x) $res)) 
    (= 
      (is-even 4) True))

<span class="ansi36"
>  (loonit_success  
    (equal_enough_for_test  
      ( (= 
          (is-even 4) True)) 
      ( (= 
          (is-even 4) True))))
</span>
Deterministic: ()
()]
;;;; Original:
;;;; #[test]
;;;; fn interpret_atom_unify_incorrect_args() {
;;;;     assert_eq!(call_interpret(&space(""), &metta_atom("(unify a p t e o)")),
;;;;         vec![expr!("Error" ("unify" "a" "p" "t" "e" "o") "expected: (unify <atom> <pattern> <then> <else>), found: (unify a p t e o)")]);
;;;;     assert_eq!(call_interpret(&space(""), &metta_atom("(unify a p t)")),
;;;;         vec![expr!("Error" ("unify" "a" "p" "t") "expected: (unify <atom> <pattern> <then> <else>), found: (unify a p t)")]);
;;;; }
;;;; Converted:
<span class="ansi38-013099040"
>  !(assertEqual 
    (unify a p t e o) 
    ("Error" 
      (unify a p t e o) "expected: (unify <atom> <pattern> <then> <else>), found: (unify a p t e o)"))

</span>[

;<h3 id="STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.32"
>;; STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.32</h3>
; 
; EVAL TEST
; took 0.000259 secs. (258.90 microseconds) 

  !(assertEqual 
    (unify a p t e o) 
    ("Error" 
      (unify a p t e o) "expected: (unify <atom> <pattern> <then> <else>), found: (unify a p t e o)"))

<span class="ansi36"
>  (loonit_success  
    (equal_enough_for_test  () ()))
</span>
Deterministic: ()
()]
<span class="ansi38-013099040"
>  !(assertEqual 
    (unify a p t) 
    ("Error" 
      (unify a p t) "expected: (unify <atom> <pattern> <then> <else>), found: (unify a p t)"))

</span>[

;<h3 id="STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.33"
>;; STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.33</h3>
; 
; EVAL TEST
; took 0.000382 secs. (381.86 microseconds) 

  !(assertEqual 
    (unify a p t) 
    ("Error" 
      (unify a p t) "expected: (unify <atom> <pattern> <then> <else>), found: (unify a p t)"))

<span class="ansi36"
>  (loonit_success  
    (equal_enough_for_test  () ()))
</span>
Deterministic: ()
()]
;;;; Original:
;;;; #[test]
;;;; fn interpret_atom_unify_then() {
;;;;     let result = call_interpret(&space(""), &metta_atom("(unify (A $b) ($a B) ($a $b) Empty)"));
;;;;     assert_eq!(result, vec![metta_atom("(A B)")]);
;;;; }
;;;; Converted:
<span class="ansi38-013099040"
>  !(assertEqual 
    (unify 
      (A $b) 
      ($a B) 
      ($a $b) ) 
    (A B))

</span>[

;<h3 id="STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.34"
>;; STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.34</h3>
; 
; EVAL TEST
; took 0.000539 secs. (539.20 microseconds) 

  !(assertEqual 
    (unify 
      (A $b) 
      ($a B) 
      ($a $b) ) 
    (A B))

<span class="ansi31"
>  (loonit_failureR  
    (equal_enough_for_test  () 
      ( (A B))))
</span>
Deterministic: ((Error  (got  ()) (expected  ((A B)))))
((Error  (got  ()) (expected  ((A B)))))]
;;;; Original:
;;;; #[test]
;;;; fn interpret_atom_unify_else() {
;;;;     let result = call_interpret(&space(""), &metta_atom("(unify (A $b C) ($a B D) ($a $b) Empty)"));
;;;;     assert_eq!(result, vec![]);
;;;; }
;;;; Converted:
<span class="ansi38-013099040"
>  !(assertEqual 
    (unify 
      (A $b C) 
      ($a B D) 
      ($a $b) ) ())

</span>[

;<h3 id="STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.35"
>;; STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.35</h3>
; 
; EVAL TEST
; took 0.000496 secs. (495.90 microseconds) 

  !(assertEqual 
    (unify 
      (A $b C) 
      ($a B D) 
      ($a $b) ) ())

<span class="ansi36"
>  (loonit_success  
    (equal_enough_for_test  () 
      (())))
</span>
Deterministic: ()
()]
;;;; Original:
;;;; #[test]
;;;; fn interpret_atom_decons_atom_incorrect_args() {
;;;;     assert_eq!(call_interpret(&space(""), &metta_atom("(decons-atom a)")),
;;;;         vec![expr!("Error" ("decons-atom" "a") "expected: (decons-atom (: <expr> Expression)), found: (decons-atom a)")]);
;;;;     assert_eq!(call_interpret(&space(""), &metta_atom("(decons-atom (a) (b))")),
;;;;         vec![expr!("Error" ("decons-atom" ("a") ("b")) "expected: (decons-atom (: <expr> Expression)), found: (decons-atom (a) (b))")]);
;;;;     assert_eq!(call_interpret(&space(""), &metta_atom("(decons-atom)")),
;;;;         vec![expr!("Error" ("decons-atom") "expected: (decons-atom (: <expr> Expression)), found: (decons-atom)")]);
;;;; }
;;;; Converted:
<span class="ansi38-013099040"
>  !(assertEqual 
    (decons-atom a) 
    ("Error" 
      (decons-atom a) "expected: (decons-atom (: <expr> Expression)), found: (decons-atom a)"))

</span>[

;<h3 id="STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.36"
>;; STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.36</h3>
; 
; EVAL TEST
; took 0.000237 secs. (237.47 microseconds) 

  !(assertEqual 
    (decons-atom a) 
    ("Error" 
      (decons-atom a) "expected: (decons-atom (: <expr> Expression)), found: (decons-atom a)"))

<span class="ansi36"
>  (loonit_success  
    (equal_enough_for_test  () ()))
</span>
Deterministic: ()
()]
<span class="ansi38-013099040"
>  !(assertEqual 
    (decons-atom 
      (a) 
      (b)) 
    ("Error" 
      (decons-atom 
        (a) 
        (b)) "expected: (decons-atom (: <expr> Expression)), found: (decons-atom (a) (b))"))

</span>[

;<h3 id="STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.37"
>;; STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.37</h3>
; 
; EVAL TEST
; took 0.002 secs. (1.66 milliseconds) 

  !(assertEqual 
    (decons-atom 
      (a) 
      (b)) 
    ("Error" 
      (decons-atom 
        (a) 
        (b)) "expected: (decons-atom (: <expr> Expression)), found: (decons-atom (a) (b))"))

<span class="ansi31"
>  (loonit_failureR  
    (equal_enough_for_test  
      ( (decons-atom 
          (a) 
          (b))) 
      ( ("Error" 
          (decons-atom 
            (a) 
            (b)) "expected: (decons-atom (: <expr> Expression)), found: (decons-atom (a) (b))"))))
</span>
Deterministic: ((Error  (got  ((decons-atom (a) (b)))) (expected  (("Error" (decons-atom (a) (b)) "expected: (decons-atom (: <expr> Expression)), found: (decons-atom (a) (b))")))))
((Error  (got  ((decons-atom (a) (b)))) (expected  (("Error" (decons-atom (a) (b)) "expected: (decons-atom (: <expr> Expression)), found: (decons-atom (a) (b))")))))]
<span class="ansi38-013099040"
>  !(assertEqual 
    (decons-atom) 
    ("Error" 
      (decons-atom) "expected: (decons-atom (: <expr> Expression)), found: (decons-atom)"))

</span>[

;<h3 id="STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.38"
>;; STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.38</h3>
; 
; EVAL TEST
; took 0.000748 secs. (747.51 microseconds) 

  !(assertEqual 
    (decons-atom) 
    ("Error" 
      (decons-atom) "expected: (decons-atom (: <expr> Expression)), found: (decons-atom)"))

<span class="ansi31"
>  (loonit_failureR  
    (equal_enough_for_test  
      ( (decons-atom)) 
      ( ("Error" 
          (decons-atom) "expected: (decons-atom (: <expr> Expression)), found: (decons-atom)"))))
</span>
Deterministic: ((Error  (got  ((decons-atom))) (expected  (("Error" (decons-atom) "expected: (decons-atom (: <expr> Expression)), found: (decons-atom)")))))
((Error  (got  ((decons-atom))) (expected  (("Error" (decons-atom) "expected: (decons-atom (: <expr> Expression)), found: (decons-atom)")))))]
;;;; Original:
;;;; #[test]
;;;; fn interpret_atom_decons_atom_empty() {
;;;;     let result = call_interpret(&space(""), &metta_atom("(decons-atom ())"));
;;;;     assert_eq!(result, vec![expr!("Error" ("decons-atom" ()) "expected: (decons-atom (: <expr> Expression)), found: (decons-atom ())")]);
;;;; }
;;;; Converted:
<span class="ansi38-013099040"
>  !(assertEqual 
    (decons-atom ()) 
    ("Error" 
      (decons-atom ()) "expected: (decons-atom (: <expr> Expression)), found: (decons-atom ())"))

</span>[

;<h3 id="STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.39"
>;; STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.39</h3>
; 
; EVAL TEST
; took 0.000274 secs. (273.71 microseconds) 

  !(assertEqual 
    (decons-atom ()) 
    ("Error" 
      (decons-atom ()) "expected: (decons-atom (: <expr> Expression)), found: (decons-atom ())"))

<span class="ansi36"
>  (loonit_success  
    (equal_enough_for_test  () ()))
</span>
Deterministic: ()
()]
;;;; Original:
;;;; #[test]
;;;; fn interpret_atom_decons_atom_single() {
;;;;     let result = call_interpret(&space(""), &metta_atom("(decons-atom (a))"));
;;;;     assert_eq!(result, vec![metta_atom("(a ())")]);
;;;; }
;;;; Converted:
<span class="ansi38-013099040"
>  !(assertEqual 
    (decons-atom (a)) 
    (a ()))

</span>[

;<h3 id="STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.40"
>;; STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.40</h3>
; 
; EVAL TEST
; took 0.000539 secs. (538.76 microseconds) 

  !(assertEqual 
    (decons-atom (a)) 
    (a ()))

<span class="ansi36"
>  (loonit_success  
    (equal_enough_for_test  
      ( (a ())) 
      ( (a ()))))
</span>
Deterministic: ()
()]
;;;; Original:
;;;; #[test]
;;;; fn interpret_atom_decons_atom_list() {
;;;;     let result = call_interpret(&space(""), &metta_atom("(decons-atom (a b c))"));
;;;;     assert_eq!(result, vec![metta_atom("(a (b c))")]);
;;;; }
;;;; Converted:
<span class="ansi38-013099040"
>  !(assertEqual 
    (decons-atom (a b c)) 
    (a (b c)))

</span>[

;<h3 id="STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.41"
>;; STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.41</h3>
; 
; EVAL TEST
; took 0.000784 secs. (784.08 microseconds) 

  !(assertEqual 
    (decons-atom (a b c)) 
    (a (b c)))

<span class="ansi36"
>  (loonit_success  
    (equal_enough_for_test  
      ( (a (b c))) 
      ( (a (b c)))))
</span>
Deterministic: ()
()]
;;;; Original:
;;;; #[test]
;;;; fn interpret_atom_cons_atom_incorrect_args() {
;;;;     assert_eq!(call_interpret(&space(""), &metta_atom("(cons-atom a (e) o)")),
;;;;         vec![expr!("Error" ("cons-atom" "a" ("e") "o") "expected: (cons-atom <head> (: <tail> Expression)), found: (cons-atom a (e) o)")]);
;;;;     assert_eq!(call_interpret(&space(""), &metta_atom("(cons-atom a e)")),
;;;;         vec![expr!("Error" ("cons-atom" "a" "e") "expected: (cons-atom <head> (: <tail> Expression)), found: (cons-atom a e)")]);
;;;;     assert_eq!(call_interpret(&space(""), &metta_atom("(cons-atom a)")),
;;;;         vec![expr!("Error" ("cons-atom" "a") "expected: (cons-atom <head> (: <tail> Expression)), found: (cons-atom a)")]);
;;;; }
;;;; Converted:
<span class="ansi38-013099040"
>  !(assertEqual 
    (cons-atom a 
      (e) o) 
    ("Error" 
      (cons-atom a 
        (e) o) "expected: (cons-atom <head> (: <tail> Expression)), found: (cons-atom a (e) o)"))

</span>[

;<h3 id="STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.42"
>;; STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.42</h3>
; 
; EVAL TEST
; took 0.000283 secs. (283.13 microseconds) 

  !(assertEqual 
    (cons-atom a 
      (e) o) 
    ("Error" 
      (cons-atom a 
        (e) o) "expected: (cons-atom <head> (: <tail> Expression)), found: (cons-atom a (e) o)"))

<span class="ansi36"
>  (loonit_success  
    (equal_enough_for_test  () ()))
</span>
Deterministic: ()
()]
<span class="ansi38-013099040"
>  !(assertEqual 
    (cons-atom a e) 
    ("Error" 
      (cons-atom a e) "expected: (cons-atom <head> (: <tail> Expression)), found: (cons-atom a e)"))

</span>[

;<h3 id="STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.43"
>;; STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.43</h3>
; 
; EVAL TEST
; took 0.000782 secs. (782.11 microseconds) 

  !(assertEqual 
    (cons-atom a e) 
    ("Error" 
      (cons-atom a e) "expected: (cons-atom <head> (: <tail> Expression)), found: (cons-atom a e)"))

<span class="ansi31"
>  (loonit_failureR  
    (equal_enough_for_test  
      ( ([|]  a e)) 
      ( ("Error" 
          ([|]  a e) "expected: (cons-atom <head> (: <tail> Expression)), found: (cons-atom a e)"))))
</span>
Deterministic: ((Error  (got  (([|]  a e))) (expected  (("Error" ([|]  a e) "expected: (cons-atom <head> (: <tail> Expression)), found: (cons-atom a e)")))))
((Error  (got  (([|]  a e))) (expected  (("Error" ([|]  a e) "expected: (cons-atom <head> (: <tail> Expression)), found: (cons-atom a e)")))))]
<span class="ansi38-013099040"
>  !(assertEqual 
    (cons-atom a) 
    ("Error" 
      (cons-atom a) "expected: (cons-atom <head> (: <tail> Expression)), found: (cons-atom a)"))

</span>[

;<h3 id="STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.44"
>;; STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.44</h3>
; 
; EVAL TEST
; took 0.000254 secs. (254.46 microseconds) 

  !(assertEqual 
    (cons-atom a) 
    ("Error" 
      (cons-atom a) "expected: (cons-atom <head> (: <tail> Expression)), found: (cons-atom a)"))

<span class="ansi36"
>  (loonit_success  
    (equal_enough_for_test  () ()))
</span>
Deterministic: ()
()]
;;;; Original:
;;;; #[test]
;;;; fn interpret_atom_cons_atom_empty() {
;;;;     let result = call_interpret(&space(""), &metta_atom("(cons-atom a ())"));
;;;;     assert_eq!(result, vec![metta_atom("(a)")]);
;;;; }
;;;; Converted:
<span class="ansi38-013099040"
>  !(assertEqual 
    (cons-atom a ()) 
    (a))

</span>[

;<h3 id="STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.45"
>;; STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.45</h3>
; 
; EVAL TEST
; took 0.000462 secs. (461.98 microseconds) 

  !(assertEqual 
    (cons-atom a ()) 
    (a))

<span class="ansi36"
>  (loonit_success  
    (equal_enough_for_test  
      ( (a)) 
      ( (a))))
</span>
Deterministic: ()
()]
;;;; Original:
;;;; #[test]
;;;; fn interpret_atom_cons_atom_single() {
;;;;     let result = call_interpret(&space(""), &metta_atom("(cons-atom a (b))"));
;;;;     assert_eq!(result, vec![metta_atom("(a b)")]);
;;;; }
;;;; Converted:
<span class="ansi38-013099040"
>  !(assertEqual 
    (cons-atom a 
      (b)) 
    (a b))

</span>[

;<h3 id="STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.46"
>;; STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.46</h3>
; 
; EVAL TEST
; took 0.000486 secs. (486.14 microseconds) 

  !(assertEqual 
    (cons-atom a 
      (b)) 
    (a b))

<span class="ansi36"
>  (loonit_success  
    (equal_enough_for_test  
      ( (a b)) 
      ( (a b))))
</span>
Deterministic: ()
()]
;;;; Original:
;;;; #[test]
;;;; fn interpret_atom_cons_atom_list() {
;;;;     let result = call_interpret(&space(""), &metta_atom("(cons-atom a (b c))"));
;;;;     assert_eq!(result, vec![metta_atom("(a b c)")]);
;;;; }
;;;; Converted:
<span class="ansi38-013099040"
>  !(assertEqual 
    (cons-atom a 
      (b c)) 
    (a b c))

</span>[

;<h3 id="STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.47"
>;; STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.47</h3>
; 
; EVAL TEST
; took 0.000478 secs. (478.22 microseconds) 

  !(assertEqual 
    (cons-atom a 
      (b c)) 
    (a b c))

<span class="ansi36"
>  (loonit_success  
    (equal_enough_for_test  
      ( (a b c)) 
      ( (a b c))))
</span>
Deterministic: ()
()]
;;;; Original:
;;;; #[test]
;;;; fn test_superpose_bind() {
;;;;     let vars: Variables = [ "a", "b", "c" ].into_iter().map(VariableAtom::new).collect();
;;;;     let atom = Atom::expr([Atom::sym("superpose-bind"),
;;;;         Atom::expr([atom_bindings_into_atom(expr!("foo" a b), bind!{ a: expr!("A"), c: expr!("C") })])]);
;;;;     let stack = Stack{ prev: None, atom, ret: no_handler, finished: false, vars: vars.clone() };
;;;;
;;;;     let result = superpose_bind(stack, bind!{ b: expr!("B"), d: expr!("D") });
;;;;
;;;;     assert_eq!(result, vec![InterpretedAtom(
;;;;             Stack{ prev: None, atom: expr!("foo" a b), ret: no_handler, finished: true, vars: Variables::new() },
;;;;             bind!{ a: expr!("A"), b: expr!("B"), c: expr!("C"), d: expr!("D") }
;;;;     )]);
;;;; }
;;;; Converted:
<span class="ansi38-013099040"
>  !(assertEqual 
    (superpose-bind 
      (foo A B) 
      (bind b: B d: D)) 
    (InterpretedAtom 
      (foo A B) 
      (bind a: A b: B c: C d: D)))

</span>[

;<h3 id="STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.48"
>;; STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.48</h3>
; 
; EVAL TEST
; took 0.002 secs. (1.73 milliseconds) 

  !(assertEqual 
    (superpose-bind 
      (foo A B) 
      (bind b: B d: D)) 
    (InterpretedAtom 
      (foo A B) 
      (bind a: A b: B c: C d: D)))

<span class="ansi31"
>  (loonit_failureR  
    (equal_enough_for_test  
      ( (superpose-bind A 
          (bind b: B d: D))) 
      ( (InterpretedAtom A 
          (bind a: A b: B c: C d: D)))))
</span>
Deterministic: ((Error  (got  ((superpose-bind A (bind b: B d: D)))) (expected  ((InterpretedAtom A (bind a: A b: B c: C d: D))))))
((Error  (got  ((superpose-bind A (bind b: B d: D)))) (expected  ((InterpretedAtom A (bind a: A b: B c: C d: D))))))]
;;;; Original:
;;;; #[test]
;;;; fn metta_turing_machine() {
;;;;     let space = space("
;;;;         (= (tm $rule $state $tape)
;;;;           (function (eval (tm-body $rule $state $tape))) )
;;;;
;;;;         (= (tm-body $rule $state $tape)
;;;;           (unify $state HALT
;;;;             (return $tape)
;;;;             (chain (eval (read $tape)) $char
;;;;               (chain (eval ($rule $state $char)) $res
;;;;                 (unify $res ($next-state $next-char $dir)
;;;;                   (chain (eval (move $tape $next-char $dir)) $next-tape
;;;;                     (eval (tm-body $rule $next-state $next-tape)) )
;;;;                   (return (Error (tm-body $rule $state $tape) \"Incorrect state\")) )))))
;;;;
;;;;         (= (read ($head $hole $tail)) $hole)
;;;;
;;;;         (= (move ($head $hole $tail) $char N) ($head $char $tail))
;;;;         (= (move ($head $hole $tail) $char L) (function
;;;;           (chain (cons-atom $char $head) $next-head
;;;;             (chain (decons-atom $tail) $list
;;;;               (unify $list ($next-hole $next-tail)
;;;;                 (return ($next-head $next-hole $next-tail))
;;;;                 (return ($next-head 0 ())) )))))
;;;;         (= (move ($head $hole $tail) $char R) (function
;;;;           (chain (cons-atom $char $tail) $next-tail
;;;;             (chain (decons-atom $head) $list
;;;;               (unify $list ($next-hole $next-head)
;;;;                 (return ($next-head $next-hole $next-tail))
;;;;                 (return (() 0 $next-tail)) )))))
;;;;
;;;;         (= (busy-beaver A 0) (B 1 R))
;;;;         (= (busy-beaver A 1) (C 1 L))
;;;;
;;;;         (= (busy-beaver B 0) (A 1 L))
;;;;         (= (busy-beaver B 1) (B 1 R))
;;;;
;;;;         (= (busy-beaver C 0) (B 1 L))
;;;;         (= (busy-beaver C 1) (HALT 1 N))
;;;;
;;;;     ");
;;;;     let result = interpret(space, &metta_atom("(eval (tm busy-beaver A (() 0 ())))"));
;;;;     assert_eq!(result, Ok(vec![metta_atom("((1 1) 1 (1 1 1))")]));
;;;; }
;;;; Converted:
<span class="ansi38-255165000"
>  (= 
    (tm $rule $state $tape) 
    (function (eval (tm-body $rule $state $tape))))
</span><span class="ansi38-255165000"
>  (= 
    (tm-body $rule $state $tape) 
    (unify $state HALT 
      (return $tape) 
      (chain 
        (eval (read $tape)) $char 
        (chain 
          (eval ($rule $state $char)) $res 
          (unify $res 
            ($next-state $next-char $dir) 
            (chain 
              (eval (move $tape $next-char $dir)) $next-tape 
              (eval (tm-body $rule $next-state $next-tape))) 
            (return (Error (tm-body $rule $state $tape) "Incorrect state")))))))
</span><span class="ansi38-255165000"
>  (= 
    (read ($head $hole $tail)) $hole)
</span><span class="ansi38-255165000"
>  (= 
    (move 
      ($head $hole $tail) $char N) 
    ($head $char $tail))
</span><span class="ansi38-255165000"
>  (= 
    (move 
      ($head $hole $tail) $char L) 
    (function (chain (cons-atom $char $head) $next-head (chain (decons-atom $tail) $list (unify $list ($next-hole $next-tail) (return ($next-head $next-hole $next-tail)) (return ($next-head 0 ())))))))
</span><span class="ansi38-255165000"
>  (= 
    (move 
      ($head $hole $tail) $char R) 
    (function (chain (cons-atom $char $tail) $next-tail (chain (decons-atom $head) $list (unify $list ($next-hole $next-head) (return ($next-head $next-hole $next-tail)) (return (() 0 $next-tail)))))))
</span><span class="ansi38-255165000"
>  (= 
    (busy-beaver A 0) 
    (B 1 R))
</span><span class="ansi38-255165000"
>  (= 
    (busy-beaver A 1) 
    (C 1 L))
</span><span class="ansi38-255165000"
>  (= 
    (busy-beaver B 0) 
    (A 1 L))
</span><span class="ansi38-255165000"
>  (= 
    (busy-beaver B 1) 
    (B 1 R))
</span><span class="ansi38-255165000"
>  (= 
    (busy-beaver C 0) 
    (B 1 L))
</span><span class="ansi38-255165000"
>  (= 
    (busy-beaver C 1) 
    (HALT 1 N))
</span><span class="ansi38-013099040"
>  !(assertEqual 
    (eval (tm busy-beaver A (() 0 ()))) 
    ( (1 1) 1 
      (1 1 1)))

</span>[

;<h3 id="STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.49"
>;; STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.49</h3>
; 
; EVAL TEST
; took 0.002 secs. (1.95 milliseconds) 

  !(assertEqual 
    (eval (tm busy-beaver A (() 0 ()))) 
    ( (1 1) 1 
      (1 1 1)))

<span class="ansi31"
>  (loonit_failureR  
    (equal_enough_for_test  () 
      ( ( (1 1) 1 
          (1 1 1)))))
</span>
Deterministic: ((Error  (got  ()) (expected  (((1 1) 1 (1 1 1))))))
((Error  (got  ()) (expected  (((1 1) 1 (1 1 1))))))]
;;;; Original:
;;;; #[test]
;;;; fn interpret_minimal_metta_smoketest() {
;;;;     let space = space("
;;;;         (= (foo $a B) $a)
;;;;         (= (fu $x) (function (chain (eval (foo $x B)) $r (return $r))))
;;;;         (= (color) red)
;;;;         (= (color) green)
;;;;         (= (color) blue)
;;;;     ");
;;;;     let result = interpret(&space, &metta_atom("(chain (chain A $x $x) $y $y)"));
;;;;     assert_eq!(result, Ok(vec![metta_atom("A")]));
;;;;     let result = interpret(&space, &metta_atom("(chain (chain (eval (foo A $b)) $x (bar $x)) $y (baz $y))"));
;;;;     assert_eq!(result, Ok(vec![metta_atom("(baz (bar A))")]));
;;;;     let result = interpret(&space, &metta_atom("(chain (chain (eval (fu A)) $x (bar $x)) $y (baz $y))"));
;;;;     assert_eq!(result, Ok(vec![metta_atom("(baz (bar A))")]));
;;;;     let result = interpret(&space, &metta_atom("(unify (A $b) ($a B) ($a $b) Empty)"));
;;;;     assert_eq!(result, Ok(vec![metta_atom("(A B)")]));
;;;;     let result = interpret(&space, &metta_atom("(decons-atom (a b c))"));
;;;;     assert_eq!(result, Ok(vec![metta_atom("(a (b c))")]));
;;;;     let result = interpret(&space, &metta_atom("(cons-atom a (b c))"));
;;;;     assert_eq!(result, Ok(vec![metta_atom("(a b c)")]));
;;;;     let result = interpret(&space, &metta_atom("(chain (collapse-bind (eval (color))) $collapsed (superpose-bind $collapsed))")).unwrap();
;;;;     assert_eq_no_order!(result, vec![metta_atom("red"), metta_atom("green"), metta_atom("blue")]);
;;;;     let result = interpret(&space, &metta_atom("((P $a B) $a)"));
;;;;     assert_eq!(result, Ok(vec![metta_atom("((P $a B) $a)")]));
;;;;     let result = interpret(&space, &metta_atom("(collapse-bind (eval (color)))")).unwrap();
;;;;     assert_eq!(result.len(), 1);
;;;;     assert_eq_no_order!(atom_as_slice(&result[0]).unwrap(), [
;;;;         atom_bindings_into_atom(expr!("red"), bind!{}),
;;;;         atom_bindings_into_atom(expr!("green"), bind!{}),
;;;;         atom_bindings_into_atom(expr!("blue"), bind!{})
;;;;     ]);
;;;; }
;;;; Converted:
<span class="ansi38-255165000"
>  (= 
    (foo $a B) $a)
</span><span class="ansi38-255165000"
>  (= 
    (fu $x) 
    (function (chain (eval (foo $x B)) $r (return $r))))
</span><span class="ansi38-255165000"
>  (= 
    (color) red)
</span><span class="ansi38-255165000"
>  (= 
    (color) green)
</span><span class="ansi38-255165000"
>  (= 
    (color) blue)
</span><span class="ansi38-013099040"
>  !(assertEqual 
    (chain 
      (chain A $x $x) $y $y) A)

</span>[

;<h3 id="STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.50"
>;; STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.50</h3>
; 
; EVAL TEST
; took 0.000304 secs. (304.45 microseconds) 

  !(assertEqual 
    (chain 
      (chain A $x $x) $y $y) A)

<span class="ansi36"
>  (loonit_success  
    (equal_enough_for_test  
      (A) 
      (A)))
</span>
Deterministic: ()
()]
<span class="ansi38-013099040"
>  !(assertEqual 
    (chain 
      (chain 
        (eval (foo A $b)) $x 
        (bar $x)) $y 
      (baz $y)) 
    (baz (bar A)))

</span>[

;<h3 id="STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.51"
>;; STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.51</h3>
; 
; EVAL TEST
; took 0.002 secs. (1.90 milliseconds) 

  !(assertEqual 
    (chain 
      (chain 
        (eval (foo A $b)) $x 
        (bar $x)) $y 
      (baz $y)) 
    (baz (bar A)))

<span class="ansi36"
>  (loonit_success  
    (equal_enough_for_test  
      ( (baz (bar A))) 
      ( (baz (bar A)))))
</span>
Deterministic: ()
()]
<span class="ansi38-013099040"
>  !(assertEqual 
    (chain 
      (chain 
        (eval (fu A)) $x 
        (bar $x)) $y 
      (baz $y)) 
    (baz (bar A)))

</span>[

;<h3 id="STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.52"
>;; STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.52</h3>
; 
; EVAL TEST
; took 0.003 secs. (2.62 milliseconds) 

  !(assertEqual 
    (chain 
      (chain 
        (eval (fu A)) $x 
        (bar $x)) $y 
      (baz $y)) 
    (baz (bar A)))

<span class="ansi36"
>  (loonit_success  
    (equal_enough_for_test  
      ( (baz (bar A))) 
      ( (baz (bar A)))))
</span>
Deterministic: ()
()]
<span class="ansi38-013099040"
>  !(assertEqual 
    (unify 
      (A $b) 
      ($a B) 
      ($a $b) ) 
    (A B))

</span>[

;<h3 id="STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.53"
>;; STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.53</h3>
; 
; EVAL TEST
; took 0.000549 secs. (548.55 microseconds) 

  !(assertEqual 
    (unify 
      (A $b) 
      ($a B) 
      ($a $b) ) 
    (A B))

<span class="ansi31"
>  (loonit_failureR  
    (equal_enough_for_test  () 
      ( (A B))))
</span>
Deterministic: ((Error  (got  ()) (expected  ((A B)))))
((Error  (got  ()) (expected  ((A B)))))]
<span class="ansi38-013099040"
>  !(assertEqual 
    (decons-atom (a b c)) 
    (a (b c)))

</span>[

;<h3 id="STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.54"
>;; STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.54</h3>
; 
; EVAL TEST
; took 0.000650 secs. (650.14 microseconds) 

  !(assertEqual 
    (decons-atom (a b c)) 
    (a (b c)))

<span class="ansi36"
>  (loonit_success  
    (equal_enough_for_test  
      ( (a (b c))) 
      ( (a (b c)))))
</span>
Deterministic: ()
()]
<span class="ansi38-013099040"
>  !(assertEqual 
    (cons-atom a 
      (b c)) 
    (a b c))

</span>[

;<h3 id="STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.55"
>;; STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.55</h3>
; 
; EVAL TEST
; took 0.000420 secs. (420.18 microseconds) 

  !(assertEqual 
    (cons-atom a 
      (b c)) 
    (a b c))

<span class="ansi36"
>  (loonit_success  
    (equal_enough_for_test  
      ( (a b c)) 
      ( (a b c))))
</span>
Deterministic: ()
()]
<span class="ansi38-013099040"
>  !(assertEqualNoOrder 
    (chain 
      (collapse-bind (eval (color))) $collapsed 
      (superpose-bind $collapsed)) 
    (red green blue))

</span>

Deterministic: (assertEqualNoOrder (chain (collapse-bind (eval (color))) $collapsed (superpose-bind $collapsed)) (red green blue))[
  (assertEqualNoOrder 
    (chain 
      (collapse-bind (eval (color))) $_131532 
      (superpose-bind $_131532)) 

    (red green blue))]
<span class="ansi38-013099040"
>  !(assertEqual 
    ( (P $a B) $a) 
    ( (P $a B) $a))

</span>[

;<h3 id="STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.56"
>;; STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.56</h3>
; 
; EVAL TEST
; took 0.001 secs. (1.15 milliseconds) 

  !(assertEqual 
    ( (P $a B) $a) 
    ( (P $a B) $a))

<span class="ansi36"
>  (loonit_success  
    (equal_enough_for_test  
      ( ( (P $_158262 B) $_158262)) 
      ( ( (P $_165802 B) $_165802))))
</span>
Deterministic: ()
()]
<span class="ansi38-013099040"
>  !(assertEqualNoOrder 
    (collapse-bind (eval (color))) 
    (red green blue))

</span>

Deterministic: (assertEqualNoOrder (collapse-bind (eval (color))) (red green blue))[
  (assertEqualNoOrder 
    (collapse-bind (eval (color))) 

    (red green blue))]
;;;; Original:
;;;; #[test]
;;;; fn interpret_duplicated_types() {
;;;;     let space = DynSpace::new(space("
;;;;         (: foo (-> A A))
;;;;         (: foo (-> A A))
;;;;         (: foo (-> Atom A))
;;;;         (: a A)
;;;;         (= (foo $x) a)
;;;;     "));
;;;;     let result = interpret(&space, &Atom::expr([METTA_SYMBOL, expr!("foo" "a"), ATOM_TYPE_UNDEFINED, Atom::gnd(space.clone())]));
;;;;     assert_eq!(result, Ok(vec![metta_atom("a")]));
;;;; }
;;;; Converted:
<span class="ansi38-255165000"
>  (: foo 
    (-> A A))
</span><span class="ansi38-255165000"
>  (: foo 
    (-> A A))
</span><span class="ansi38-255165000"
>  (: foo 
    (-> Atom A))
</span><span class="ansi38-255165000"
>  (: a A)
</span><span class="ansi38-255165000"
>  (= 
    (foo $x) a)
</span><span class="ansi38-013099040"
>  !(assertEqual 
    (eval 
      (foo a) %Undefined% &self) a)

</span>[

;<h3 id="STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.57"
>;; STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.57</h3>
; 
; EVAL TEST
; took 0.000424 secs. (424.27 microseconds) 

  !(assertEqual 
    (eval 
      (foo a) %Undefined% &self) a)

<span class="ansi31"
>  (loonit_failureR  
    (equal_enough_for_test  
      ( (eval 
          (foo a) %Undefined% &self)) 
      (a)))
</span>
Deterministic: ((Error  (got  ((eval (foo a) %Undefined% &self))) (expected  (a))))
((Error  (got  ((eval (foo a) %Undefined% &self))) (expected  (a))))]
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Converted Rust Tests with Original Source
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;    #[test]
;;;;    fn case_op_internal_variables_has_priority_in_template() {
;;;;        let space = DynSpace::new(GroundingSpace::new());
;;;;        let case_op = CaseOp::new(space.clone());
;;;;
;;;;        assert_eq!(case_op.execute(&mut vec![expr!(x "A"), expr!(((x x)))]),
;;;;            Ok(vec![expr!(x "A")]));
;;;;    }
;;;; Converted:
<span class="ansi38-255165000"
>  (let space 
    (new-space))
</span><span class="ansi38-013099040"
>  !(assertEqual 
    (case! space 
      (x "A") 
      ( ( (x x)))) 
    (x "A"))

</span>[

;<h3 id="STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.58"
>;; STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.58</h3>
; 
; EVAL TEST
; took 0.001 secs. (1.36 milliseconds) 

  !(assertEqual 
    (case! space 
      (x "A") 
      ( ( (x x)))) 
    (x "A"))

<span class="ansi31"
>  (loonit_failureR  
    (equal_enough_for_test  
      ( (case! space 
          (x "A") 
          ( ( (x x))))) 
      ( (x "A"))))
</span>
Deterministic: ((Error  (got  ((case! space (x "A") (((x x)))))) (expected  ((x "A")))))
((Error  (got  ((case! space (x "A") (((x x)))))) (expected  ((x "A")))))]
;;;;    fn assert_runtime_error(actual: Result<Vec<Atom>, ExecError>, expected: Regex) {
;;;;        match actual {
;;;;            Err(ExecError::Runtime(msg)) => assert!(expected.is_match(msg.as_str()),
;;;;                "Incorrect error message:\nexpected: {:?}\n  actual: {:?}", expected.to_string(), msg),
;;;;            _ => assert!(false, "Error is expected as result, {:?} returned", actual),
;;;;        }
;;;;    }
;;;; Converted:
<span class="ansi38-255165000"
>  (let assert-runtime-error 
    (actual expected) 
    (match actual 
      (Err (ExecError::Runtime msg)) 
      (assert (expected.is_match msg)) _ 
      (assert False)))
</span>;;;;    #[test]
;;;;    fn assert_equal_op() {
;;;;        let space = DynSpace::new(metta_space("
;;;;            (= (foo) (A B))
;;;;            (= (foo) (B C))
;;;;            (= (bar) (B C))
;;;;            (= (bar) (A B))
;;;;            (= (err) (A B))
;;;;        "));
;;;;
;;;;        let assert_equal_op = AssertEqualOp::new(space);
;;;;
;;;;        assert_eq!(assert_equal_op.execute(&mut vec![expr!(("foo")), expr!(("bar"))]), unit_result());
;;;;
;;;;        let actual = assert_equal_op.execute(&mut vec![expr!(("foo")), expr!(("err"))]);
;;;;        let expected = Regex::new("\nExpected: \\[(A B)\\]\nGot: \\[\\((B C)|, |(A B)\\){3}\\]\nExcessive result: (B C)").unwrap();
;;;;        assert_runtime_error(actual, expected);
;;;;
;;;;        let actual = assert_equal_op.execute(&mut vec![expr!(("err")), expr!(("foo"))]);
;;;;        let expected = Regex::new("\nExpected: \\[\\((B C)|, |(A B)\\){3}\\]\nGot: \\[(A B)\\]\nMissed result: (B C)").unwrap();
;;;;        assert_runtime_error(actual, expected);
;;;;    }
;;;; Converted:
<span class="ansi38-255165000"
>  (let space 
    (new-space))
</span><span class="ansi38-255165000"
>  (= 
    (foo) 
    (A B))
</span><span class="ansi38-255165000"
>  (= 
    (foo) 
    (B C))
</span><span class="ansi38-255165000"
>  (= 
    (bar) 
    (B C))
</span><span class="ansi38-255165000"
>  (= 
    (bar) 
    (A B))
</span><span class="ansi38-255165000"
>  (= 
    (err) 
    (A B))
</span><span class="ansi38-013099040"
>  !(assertEqual 
    (assert-equal! space 
      ("foo") 
      ("bar")) 
    (unit-result))

</span>[

;<h3 id="STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.59"
>;; STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.59</h3>
; 
; EVAL TEST
; took 0.000623 secs. (623.30 microseconds) 

  !(assertEqual 
    (assert-equal! space 
      ("foo") 
      ("bar")) 
    (unit-result))

<span class="ansi31"
>  (loonit_failureR  
    (equal_enough_for_test  
      ( (assert-equal! space 
          ("foo") 
          ("bar"))) 
      ( (unit-result))))
</span>
Deterministic: ((Error  (got  ((assert-equal! space ("foo") ("bar")))) (expected  ((unit-result)))))
((Error  (got  ((assert-equal! space ("foo") ("bar")))) (expected  ((unit-result)))))]
<span class="ansi38-255165000"
>  (let actual 
    (assert-equal! space 
      ("foo") 
      ("err")))
</span><span class="ansi38-255165000"
>  (let expected 
    (Regex::new "nExpected: \\[(A B)\\]nGot: \\[\\((B C)|, |(A B)\\){3}\\]nExcessive result: (B C)"))
</span><span class="ansi38-013099040"
>  !(assert-runtime-error actual expected)

</span>

Deterministic: (assert-runtime-error actual expected)
[(assert-runtime-error actual expected)]
<span class="ansi38-255165000"
>  (let actual 
    (assert-equal! space 
      ("err") 
      ("foo")))
</span><span class="ansi38-255165000"
>  (let expected 
    (Regex::new "nExpected: \\[\\((B C)|, |(A B)\\){3}\\]nGot: \\[(A B)\\]nMissed result: (B C)"))
</span><span class="ansi38-013099040"
>  !(assert-runtime-error actual expected)

</span>

Deterministic: (assert-runtime-error actual expected)
[(assert-runtime-error actual expected)]
;;;;    #[test]
;;;;    fn assert_equal_to_result_op() {
;;;;        let space = DynSpace::new(metta_space("
;;;;            (= (foo) (A B))
;;;;            (= (foo) (B C))
;;;;        "));
;;;;        let assert_equal_to_result_op = AssertEqualToResultOp::new(space);
;;;;
;;;;        assert_eq!(assert_equal_to_result_op.execute(&mut vec![
;;;;                expr!(("foo")), expr!(("B" "C") ("A" "B"))]),
;;;;                unit_result());
;;;;    }
;;;; Converted:
<span class="ansi38-255165000"
>  (let space 
    (new-space))
</span><span class="ansi38-255165000"
>  (= 
    (foo) 
    (A B))
</span><span class="ansi38-255165000"
>  (= 
    (foo) 
    (B C))
</span><span class="ansi38-013099040"
>  !(assertEqual 
    (assert-equal-to-result! space 
      ("foo") 
      ( ("B" "C") ("A" "B"))) 
    (unit-result))

</span>[

;<h3 id="STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.60"
>;; STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.60</h3>
; 
; EVAL TEST
; took 0.001 secs. (1.16 milliseconds) 

  !(assertEqual 
    (assert-equal-to-result! space 
      ("foo") 
      ( ("B" "C") ("A" "B"))) 
    (unit-result))

<span class="ansi31"
>  (loonit_failureR  
    (equal_enough_for_test  
      ( (assert-equal-to-result! space 
          ("foo") 
          ( ("B" "C") ("A" "B")))) 
      ( (unit-result))))
</span>
Deterministic: ((Error  (got  ((assert-equal-to-result! space ("foo") (("B" "C") ("A" "B"))))) (expected  ((unit-result)))))
((Error  (got  ((assert-equal-to-result! space ("foo") (("B" "C") ("A" "B"))))) (expected  ((unit-result)))))]
;;;;    #[test]
;;;;    fn collapse_op() {
;;;;        let space = DynSpace::new(metta_space("
;;;;            (= (foo) (A B))
;;;;            (= (foo) (B C))
;;;;        "));
;;;;        let collapse_op = CollapseOp::new(space);
;;;;
;;;;        let actual = collapse_op.execute(&mut vec![expr!(("foo"))]).unwrap();
;;;;        assert_eq!(actual.len(), 1);
;;;;        assert_eq_no_order!(
;;;;            *atom_as_expr(&actual[0]).unwrap().children(),
;;;;            vec![expr!("B" "C"), expr!("A" "B")]);
;;;;    }
;;;; Converted:
<span class="ansi38-255165000"
>  (let space 
    (new-space))
</span><span class="ansi38-255165000"
>  (= 
    (foo) 
    (A B))
</span><span class="ansi38-255165000"
>  (= 
    (foo) 
    (B C))
</span><span class="ansi38-255165000"
>  (let actual 
    (collapse! space 
      ("foo")))
</span><span class="ansi38-013099040"
>  !(assertEqual 
    (length actual) 1)

</span>[

;<h3 id="STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.61"
>;; STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.61</h3>
; 
; EVAL TEST
; took 0.000133 secs. (133.46 microseconds) 

  !(assertEqual 
    (length actual) 1)

<span class="ansi36"
>  (loonit_success  
    (equal_enough_for_test  
      (1) 
      (1)))
</span>
Deterministic: ()
()]
<span class="ansi38-013099040"
>  !(assertEqualNoOrder 
    (children (first actual)) 
    ( (B C) (A B)))

</span>

Deterministic: (assertEqualNoOrder (children (first actual)) ((B C) (A B)))[
  (assertEqualNoOrder 
    (children (first actual)) 

    ( (B C) (A B)))]
;;;;    #[test]
;;;;    fn superpose_op() {
;;;;        let space = DynSpace::new(GroundingSpace::new());
;;;;        let superpose_op = SuperposeOp::new(space);
;;;;        assert_eq!(superpose_op.execute(&mut vec![expr!("A" ("B" "C"))]),
;;;;            Ok(vec![sym!("A"), expr!("B" "C")]));
;;;;    }
;;;; Converted:
<span class="ansi38-255165000"
>  (let space 
    (new-space))
</span><span class="ansi38-013099040"
>  !(assertEqual 
    (superpose! space 
      ("A" ("B" "C"))) 
    ( ("A") ("B" "C")))

</span>[

;<h3 id="STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.62"
>;; STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.62</h3>
; 
; EVAL TEST
; took 0.001 secs. (1.24 milliseconds) 

  !(assertEqual 
    (superpose! space 
      ("A" ("B" "C"))) 
    ( ("A") ("B" "C")))

<span class="ansi31"
>  (loonit_failureR  
    (equal_enough_for_test  
      ( (superpose! space 
          ("A" ("B" "C")))) 
      ( ( ("A") ("B" "C")))))
</span>
Deterministic: ((Error  (got  ((superpose! space ("A" ("B" "C"))))) (expected  ((("A") ("B" "C"))))))
((Error  (got  ((superpose! space ("A" ("B" "C"))))) (expected  ((("A") ("B" "C"))))))]
;;;;    #[test]
;;;;    fn unique_op() {
;;;;        let space = DynSpace::new(metta_space("
;;;;            (= (foo) (A (B C)))
;;;;            (= (foo) (A (B C)))
;;;;            (= (foo) (f g))
;;;;            (= (foo) (f g))
;;;;            (= (foo) (f g))
;;;;            (= (foo) Z)
;;;;        "));
;;;;        let unique_op = UniqueOp::new(space);
;;;;        let actual = unique_op.execute(&mut vec![expr!(("foo"))]).unwrap();
;;;;        assert_eq_no_order!(actual,
;;;;                   vec![expr!("A" ("B" "C")), expr!("f" "g"), expr!("Z")]);
;;;;    }
;;;; Converted:
<span class="ansi38-255165000"
>  (let space 
    (new-space))
</span><span class="ansi38-255165000"
>  (= 
    (foo) 
    (A (B C)))
</span><span class="ansi38-255165000"
>  (= 
    (foo) 
    (A (B C)))
</span><span class="ansi38-255165000"
>  (= 
    (foo) 
    (f g))
</span><span class="ansi38-255165000"
>  (= 
    (foo) 
    (f g))
</span><span class="ansi38-255165000"
>  (= 
    (foo) 
    (f g))
</span><span class="ansi38-255165000"
>  (= 
    (foo) Z)
</span><span class="ansi38-255165000"
>  (let actual 
    (unique! space 
      ("foo")))
</span><span class="ansi38-013099040"
>  !(assertEqualNoOrder actual 
    ( (A (B C)) 
      (f g) 
      (Z)))

</span>

Deterministic: (assertEqualNoOrder actual ((A (B C)) (f g) (Z)))[
  (assertEqualNoOrder actual 
    ( (A (B C)) 
      (f g) 

      (Z)))]
;;;;    #[test]
;;;;    fn union_op() {
;;;;        let space = DynSpace::new(metta_space("
;;;;            (= (foo) (A (B C)))
;;;;            (= (foo) (A (B C)))
;;;;            (= (foo) (f g))
;;;;            (= (foo) (f g))
;;;;            (= (foo) (f g))
;;;;            (= (foo) Z)
;;;;            (= (bar) (A (B C)))
;;;;            (= (bar) p)
;;;;            (= (bar) p)
;;;;            (= (bar) (Q a))
;;;;        "));
;;;;        let union_op = UnionOp::new(space);
;;;;        let actual = union_op.execute(&mut vec![expr!(("foo")), expr!(("bar"))]).unwrap();
;;;;        assert_eq_no_order!(actual,
;;;;                   vec![expr!("A" ("B" "C")), expr!("A" ("B" "C")), expr!("f" "g"), expr!("f" "g"), expr!("f" "g"), expr!("Z"),
;;;;                        expr!("A" ("B" "C")), expr!("p"), expr!("p"), expr!("Q" "a")]);
;;;;    }
;;;; Converted:
<span class="ansi38-255165000"
>  (let space 
    (new-space))
</span><span class="ansi38-255165000"
>  (= 
    (foo) 
    (A (B C)))
</span><span class="ansi38-255165000"
>  (= 
    (foo) 
    (A (B C)))
</span><span class="ansi38-255165000"
>  (= 
    (foo) 
    (f g))
</span><span class="ansi38-255165000"
>  (= 
    (foo) 
    (f g))
</span><span class="ansi38-255165000"
>  (= 
    (foo) 
    (f g))
</span><span class="ansi38-255165000"
>  (= 
    (foo) Z)
</span><span class="ansi38-255165000"
>  (= 
    (bar) 
    (A (B C)))
</span><span class="ansi38-255165000"
>  (= 
    (bar) p)
</span><span class="ansi38-255165000"
>  (= 
    (bar) p)
</span><span class="ansi38-255165000"
>  (= 
    (bar) 
    (Q a))
</span><span class="ansi38-255165000"
>  (let actual 
    (union! space 
      ("foo") 
      ("bar")))
</span><span class="ansi38-013099040"
>  !(assertEqualNoOrder actual 
    ( (A (B C)) 
      (A (B C)) 
      (f g) 
      (f g) 
      (f g) 
      (Z) 
      (A (B C)) 
      (p) 
      (p) 
      (Q a)))

</span>

Deterministic: (assertEqualNoOrder actual ((A (B C)) (A (B C)) (f g) (f g) (f g) (Z) (A (B C)) (p) (p) (Q a)))[
  (assertEqualNoOrder actual 
    ( (A (B C)) 
      (A (B C)) 
      (f g) 
      (f g) 
      (f g) 
      (Z) 
      (A (B C)) 
      (p) 
      (p) 

      (Q a)))]
;;;;    #[test]
;;;;    fn intersection_op() {
;;;;        let space = DynSpace::new(metta_space("
;;;;            (= (foo) Z)
;;;;            (= (foo) (A (B C)))
;;;;            (= (foo) (A (B C)))
;;;;            (= (foo) (f g))
;;;;            (= (foo) (f g))
;;;;            (= (foo) (f g))
;;;;            (= (foo) (P b))
;;;;            (= (bar) (f g))
;;;;            (= (bar) (f g))
;;;;            (= (bar) (A (B C)))
;;;;            (= (bar) p)
;;;;            (= (bar) p)
;;;;            (= (bar) (Q a))
;;;;            (= (bar) Z)
;;;;
;;;;            (= (nsl) 5)
;;;;            (= (nsl) 4)
;;;;            (= (nsl) 3)
;;;;            (= (nsl) 2)
;;;;            (= (nsr) 5)
;;;;            (= (nsr) 3)
;;;;        "));
;;;;        let intersection_op = IntersectionOp::new(space);
;;;;        let actual = intersection_op.execute(&mut vec![expr!(("foo")), expr!(("bar"))]).unwrap();
;;;;        assert_eq_no_order!(actual,
;;;;                   vec![expr!("A" ("B" "C")), expr!("f" "g"), expr!("f" "g"), expr!("Z")]);
;;;;
;;;;        assert_eq_no_order!(intersection_op.execute(&mut vec![expr!(("nsl")), expr!(("nsr"))]).unwrap(),
;;;;                   vec![expr!("5"), expr!("3")]);
;;;;    }
;;;; Converted:
<span class="ansi38-255165000"
>  (let space 
    (new-space))
</span><span class="ansi38-255165000"
>  (= 
    (foo) Z)
</span><span class="ansi38-255165000"
>  (= 
    (foo) 
    (A (B C)))
</span><span class="ansi38-255165000"
>  (= 
    (foo) 
    (A (B C)))
</span><span class="ansi38-255165000"
>  (= 
    (foo) 
    (f g))
</span><span class="ansi38-255165000"
>  (= 
    (foo) 
    (f g))
</span><span class="ansi38-255165000"
>  (= 
    (foo) 
    (f g))
</span><span class="ansi38-255165000"
>  (= 
    (foo) 
    (P b))
</span><span class="ansi38-255165000"
>  (= 
    (bar) 
    (f g))
</span><span class="ansi38-255165000"
>  (= 
    (bar) 
    (f g))
</span><span class="ansi38-255165000"
>  (= 
    (bar) 
    (A (B C)))
</span><span class="ansi38-255165000"
>  (= 
    (bar) p)
</span><span class="ansi38-255165000"
>  (= 
    (bar) p)
</span><span class="ansi38-255165000"
>  (= 
    (bar) 
    (Q a))
</span><span class="ansi38-255165000"
>  (= 
    (bar) Z)
</span><span class="ansi38-255165000"
>  (= 
    (nsl) 5)
</span><span class="ansi38-255165000"
>  (= 
    (nsl) 4)
</span><span class="ansi38-255165000"
>  (= 
    (nsl) 3)
</span><span class="ansi38-255165000"
>  (= 
    (nsl) 2)
</span><span class="ansi38-255165000"
>  (= 
    (nsr) 5)
</span><span class="ansi38-255165000"
>  (= 
    (nsr) 3)
</span><span class="ansi38-255165000"
>  (let actual 
    (intersection! space 
      ("foo") 
      ("bar")))
</span><span class="ansi38-013099040"
>  !(assertEqualNoOrder actual 
    ( (A (B C)) 
      (f g) 
      (f g) 
      (Z)))

</span>

Deterministic: (assertEqualNoOrder actual ((A (B C)) (f g) (f g) (Z)))[
  (assertEqualNoOrder actual 
    ( (A (B C)) 
      (f g) 
      (f g) 

      (Z)))]
<span class="ansi38-013099040"
>  !(assertEqualNoOrder 
    (intersection! space 
      ("nsl") 
      ("nsr")) 
    (5 3))

</span>[P;HTML|
;                                           (eval_call
;                                             (apply  intersection
;                                               (space
;                                                 ("nsl")
;                                                 ("nsr"))) $TF)


Deterministic: (assertEqualNoOrder (intersection! space ("nsl") ("nsr")) (5 3))
  (assertEqualNoOrder 
    (intersection! space 
      ("nsl") 
      ("nsr")) 

    (5 3))]
;;;;    #[test]
;;;;    fn subtraction_op() {
;;;;        let space = DynSpace::new(metta_space("
;;;;            (= (foo) Z)
;;;;            (= (foo) S)
;;;;            (= (foo) S)
;;;;            (= (foo) (A (B C)))
;;;;            (= (foo) (A (B C)))
;;;;            (= (foo) (f g))
;;;;            (= (foo) (f g))
;;;;            (= (foo) (f g))
;;;;            (= (foo) (P b))
;;;;            (= (bar) (f g))
;;;;            (= (bar) (A (B C)))
;;;;            (= (bar) p)
;;;;            (= (bar) p)
;;;;            (= (bar) (Q a))
;;;;            (= (bar) Z)
;;;;            (= (bar) S)
;;;;            (= (bar) S)
;;;;            (= (bar) S)
;;;;        "));
;;;;        let subtraction_op = SubtractionOp::new(space);
;;;;        let actual = subtraction_op.execute(&mut vec![expr!(("foo")), expr!(("bar"))]).unwrap();
;;;;        assert_eq_no_order!(actual,
;;;;                   vec![expr!("A" ("B" "C")), expr!("f" "g"), expr!("f" "g"), expr!("P" "b")]);
;;;;    }
;;;; Converted:
<span class="ansi38-255165000"
>  (let space 
    (new-space))
</span><span class="ansi38-255165000"
>  (= 
    (foo) Z)
</span><span class="ansi38-255165000"
>  (= 
    (foo) S)
</span><span class="ansi38-255165000"
>  (= 
    (foo) S)
</span><span class="ansi38-255165000"
>  (= 
    (foo) 
    (A (B C)))
</span><span class="ansi38-255165000"
>  (= 
    (foo) 
    (A (B C)))
</span><span class="ansi38-255165000"
>  (= 
    (foo) 
    (f g))
</span><span class="ansi38-255165000"
>  (= 
    (foo) 
    (f g))
</span><span class="ansi38-255165000"
>  (= 
    (foo) 
    (f g))
</span><span class="ansi38-255165000"
>  (= 
    (foo) 
    (P b))
</span><span class="ansi38-255165000"
>  (= 
    (bar) 
    (f g))
</span><span class="ansi38-255165000"
>  (= 
    (bar) 
    (A (B C)))
</span><span class="ansi38-255165000"
>  (= 
    (bar) p)
</span><span class="ansi38-255165000"
>  (= 
    (bar) p)
</span><span class="ansi38-255165000"
>  (= 
    (bar) 
    (Q a))
</span><span class="ansi38-255165000"
>  (= 
    (bar) Z)
</span><span class="ansi38-255165000"
>  (= 
    (bar) S)
</span><span class="ansi38-255165000"
>  (= 
    (bar) S)
</span><span class="ansi38-255165000"
>  (= 
    (bar) S)
</span><span class="ansi38-255165000"
>  (let actual 
    (subtraction! space 
      ("foo") 
      ("bar")))
</span><span class="ansi38-013099040"
>  !(assertEqualNoOrder actual 
    ( (A (B C)) 
      (f g) 
      (f g) 
      (P b)))

</span>

Deterministic: (assertEqualNoOrder actual ((A (B C)) (f g) (f g) (P b)))[
  (assertEqualNoOrder actual 
    ( (A (B C)) 
      (f g) 
      (f g) 

      (P b)))]
;;;;    #[test]
;;;;    fn superpose_op_type() {
;;;;        let space = DynSpace::new(GroundingSpace::new());
;;;;        assert!(validate_atom(space.borrow().as_space(), &expr!({SumOp{}}
;;;;            ({SuperposeOp::new(space.clone())} ({Number::Integer(1)} {Number::Integer(2)} {Number::Integer(3)}))
;;;;            {Number::Integer(1)})));
;;;;    }
;;;; Converted:
<span class="ansi38-255165000"
>  (let space 
    (new-space))
</span><span class="ansi38-013099040"
>  !(assert (validate-atom space (sum! (superpose! space (1 2 3)) 1)))

</span>[P;HTML|
;                                           (-->
;                                             (catch_warn
;                                               (apply  sum
;                                                 ( (superpose! space
;                                                     (1 2 3)) 1 $_6150)))
;                                             (error
;                                               (type_error  integer superpose!) $_6308))


Deterministic: (assert (validate-atom space (sum! (superpose! space (1 2 3)) 1)))

  (assert (validate-atom space (sum! (superpose! space (1 2 3)) 1)))]
;;;;    #[test]
;;;;    fn superpose_op_multiple_interpretations() {
;;;;        let metta = Metta::new(Some(EnvBuilder::test_env()));
;;;;        let parser = SExprParser::new("
;;;;            (= (f) A)
;;;;            (= (f) B)
;;;;            (= (g) C)
;;;;            (= (g) D)
;;;;
;;;;            !(superpose ((f) (g)))
;;;;        ");
;;;;
;;;;        assert_eq_metta_results!(metta.run(parser),
;;;;            Ok(vec![vec![expr!("A"), expr!("B"), expr!("C"), expr!("D")]]));
;;;;    }
;;;; Converted:
<span class="ansi38-255165000"
>  (= 
    (f) A)
</span><span class="ansi38-255165000"
>  (= 
    (f) B)
</span><span class="ansi38-255165000"
>  (= 
    (g) C)
</span><span class="ansi38-255165000"
>  (= 
    (g) D)
</span><span class="ansi38-013099040"
>  !(assertEqualToResult 
    (superpose ((f) (g))) 
    (A B C D))

</span>[

;<h3 id="STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.63"
>;; STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.63</h3>
; 
; EVAL TEST
; took 0.000573 secs. (573.33 microseconds) 

  !(assertEqualToResult 
    (superpose ((f) (g))) 
    (A B C D))

<span class="ansi36"
>  (loonit_success  
    (equal_enough_for_test  
      (A B C D) 
      (A B C D)))
</span>
Deterministic: ()
()]
;;;;    #[test]
;;;;    fn superpose_op_superposed_with_collapse() {
;;;;        let metta = Metta::new(Some(EnvBuilder::test_env()));
;;;;        let parser = SExprParser::new("
;;;;            (= (f) A)
;;;;            (= (f) B)
;;;;
;;;;            !(let $x (collapse (f)) (superpose $x))
;;;;        ");
;;;;
;;;;        assert_eq_metta_results!(metta.run(parser),
;;;;            Ok(vec![vec![expr!("A"), expr!("B")]]));
;;;;    }
;;;; Converted:
<span class="ansi38-255165000"
>  (= 
    (f) A)
</span><span class="ansi38-255165000"
>  (= 
    (f) B)
</span><span class="ansi38-013099040"
>  !(assertEqualToResult 
    (let $x 
      (collapse (f)) 
      (superpose $x)) 
    (A B))

</span>[

;<h3 id="STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.64"
>;; STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.64</h3>
; 
; EVAL TEST
; took 0.000642 secs. (642.16 microseconds) 

  !(assertEqualToResult 
    (let $x 
      (collapse (f)) 
      (superpose $x)) 
    (A B))

<span class="ansi36"
>  (loonit_success  
    (equal_enough_for_test  
      (A B) 
      (A B)))
</span>
Deterministic: ()
()]
;;;;    #[test]
;;;;    fn superpose_op_consumes_interpreter_errors() {
;;;;        let metta = Metta::new(Some(EnvBuilder::test_env()));
;;;;        let parser = SExprParser::new("
;;;;            (: f (-> A B))
;;;;            (= (f $x) $x)
;;;;
;;;;            (: a A)
;;;;            (: b B)
;;;;
;;;;            !(superpose ((f (superpose ())) (f a) (f b)))
;;;;        ");
;;;;
;;;;        assert_eq!(metta.run(parser), Ok(vec![vec![
;;;;                expr!("Error" ("f" ({SuperposeOp{space:metta.space().clone()}} ())) "NoValidAlternatives"),
;;;;                expr!("a"), expr!("Error" "b" "BadType")]]));
;;;;    }
;;;; Converted:
<span class="ansi38-255165000"
>  (: f 
    (-> A B))
</span><span class="ansi38-255165000"
>  (= 
    (f $x) $x)
</span><span class="ansi38-255165000"
>  (: a A)
</span><span class="ansi38-255165000"
>  (: b B)
</span><span class="ansi38-013099040"
>  !(assertEqual 
    (superpose ((f (superpose ())) (f a) (f b))) 
    (Error 
      (f (superpose ())) "NoValidAlternatives") 
    (a) 
    (Error b "BadType"))

</span>[


  (failed  once 
    (if_or_else  
      (eval  = $_161812 497 &self 
        (superpose ()) $_161826) 
      (call  eval 
        (superpose ()) $_161826)))




  (failed  once 
    (if_or_else  
      (eval  = $_161812 497 &self 
        (superpose ()) $_161826) 
      (call  eval 
        (superpose ()) $_161826)))


^  <span class="ansi1 ansi32"
>Call: </span>(270) [user] call(user:once, user:if_or_else(eval(=, _161812, 497, '&self', [superpose, []], _161826), call(eval, [superpose, []], _161826)))
^  <span class="ansi1 ansi32"
>Call: </span>(271) [user] once(user:if_or_else(eval(=, _161812, 497, '&self', [superpose, []], _161826), call(eval, [superpose, []], _161826)))
   <span class="ansi1 ansi32"
>Call: </span>(272) [user] if_or_else(eval(=, _161812, 497, '&self', [superpose, []], _161826), call(eval, [superpose, []], _161826))
^  <span class="ansi1 ansi32"
>Call: </span>(273) [user] eval(=, _161812, 497, '&self', [superpose, []], _161826)
^  <span class="ansi1 ansi32"
>Call: </span>(274) [user] catch_metta_return(eval_args(=, _161812, 497, '&self', [superpose, []], _161826), _161826)
^  <span class="ansi1 ansi32"
>Call: </span>(276) [user] eval_args(=, _161812, 497, '&self', [superpose, []], _161826)
   <span class="ansi1 ansi32"
>Call: </span>(277) [system] var([superpose, []])
^  <span class="ansi1 ansi32"
>Call: </span>(278) [system] setup_call_cleanup('$notrace'(_169444, _169446), once(user:self_eval([superpose, []])), '$restore_trace'(_169444, _169446))
^  <span class="ansi1 ansi32"
>Call: </span>(279) [system] sig_atomic(system:'$notrace'(_169444, _169446))
^  <span class="ansi1 ansi32"
>Call: </span>(278) [system] setup_call_cleanup('$notrace'(_171356, _171358), once(user:nonvar(_161826)), '$restore_trace'(_171356, _171358))
^  <span class="ansi1 ansi32"
>Call: </span>(279) [system] sig_atomic(system:'$notrace'(_171356, _171358))
^  <span class="ansi1 ansi32"
>Call: </span>(278) [system] setup_call_cleanup('$notrace'(_173268, _173270), once(user:nonvar(_161826)), '$restore_trace'(_173268, _173270))
^  <span class="ansi1 ansi32"
>Call: </span>(279) [system] sig_atomic(system:'$notrace'(_173268, _173270))
   <span class="ansi1 ansi32"
>Call: </span>(277) [system] [[]]==[]
   <span class="ansi1 ansi32"
>Call: </span>(277) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(277) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(277) [system] (=)\==(=)
^  <span class="ansi1 ansi32"
>Call: </span>(277) [user] self_eval([superpose, []])
^  <span class="ansi1 ansi32"
>Call: </span>(279) [system] setup_call_cleanup('$notrace'(_179808, _179810), once(user:self_eval0([superpose, []])), '$restore_trace'(_179808, _179810))
^  <span class="ansi1 ansi32"
>Call: </span>(280) [system] sig_atomic(system:'$notrace'(_179808, _179810))
^  <span class="ansi1 ansi31"
>Fail: </span>(277) [user] self_eval([superpose, []])
^  <span class="ansi1 ansi32"
>Call: </span>(277) [user] eval_00(=, _161812, 497, '&self', [superpose, []], _161826)
^  <span class="ansi1 ansi32"
>Call: </span>(278) [user] self_eval([superpose, []])
^  <span class="ansi1 ansi32"
>Call: </span>(280) [system] setup_call_cleanup('$notrace'(_184512, _184514), once(user:self_eval0([superpose, []])), '$restore_trace'(_184512, _184514))
^  <span class="ansi1 ansi32"
>Call: </span>(281) [system] sig_atomic(system:'$notrace'(_184512, _184514))
^  <span class="ansi1 ansi31"
>Fail: </span>(278) [user] self_eval([superpose, []])
^  <span class="ansi1 ansi32"
>Call: </span>(278) [user] eval_01(=, _161812, 497, '&self', [superpose, []], _161826)
^  <span class="ansi1 ansi32"
>Call: </span>(279) [user] if_t((497<1, trace_on_overflow), debug(metta(eval_args)))
   <span class="ansi1 ansi32"
>Call: </span>(281) [system] 497<1
   <span class="ansi1 ansi31"
>Fail: </span>(281) [system] 497<1
^  <span class="ansi1 ansi32"
>Exit: </span>(279) [user] if_t((497<1, trace_on_overflow), debug(metta(eval_args)))
^  <span class="ansi1 ansi32"
>Call: </span>(280) [system] setup_call_cleanup('$notrace'(_192044, _192046), once(user:(_192020 is 497-1, copy_term([superpose, []], _192034))), '$restore_trace'(_192044, _192046))
^  <span class="ansi1 ansi32"
>Call: </span>(281) [system] sig_atomic(system:'$notrace'(_192044, _192046))
^  <span class="ansi1 ansi32"
>Exit: </span>(280) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(496 is 497-1, copy_term([superpose, []], [superpose, []]))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(279) [user] trace_eval(eval_20(=, _161812), e, 496, '&self', [superpose, []], _194890)
^  <span class="ansi1 ansi32"
>Call: </span>(280) [user] must_det_ll((notrace((flag(eval_num, _195856, _195856+1), _195874 is _195856 mod 500, _195892 is 99-496 mod 100, _195916=_195918, option_else('trace-length', _195930, 500), option_else('trace-depth', _195938, 30))), quietly(if_t((nop(stop_rtrace), _195874>_195930), (set_debug(eval, false), _195994 is _195930+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_195994])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_196046)))))
^  <span class="ansi1 ansi32"
>Call: </span>(281) [user] once(user:(notrace((flag(eval_num, _195856, _195856+1), _195874 is _195856 mod 500, _195892 is 99-496 mod 100, _195916=_195918, option_else('trace-length', _195930, 500), option_else('trace-depth', _195938, 30))), quietly(if_t((nop(stop_rtrace), _195874>_195930), (set_debug(eval, false), _195994 is _195930+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_195994])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_196046)))))
^  <span class="ansi1 ansi32"
>Call: </span>(284) [system] setup_call_cleanup('$notrace'(_197916, _197918), once(user:(flag(eval_num, _195856, _195856+1), _195874 is _195856 mod 500, _195892 is 99-496 mod 100, _195916=_195918, option_else('trace-length', _195930, 500), option_else('trace-depth', _195938, 30))), '$restore_trace'(_197916, _197918))
^  <span class="ansi1 ansi32"
>Call: </span>(285) [system] sig_atomic(system:'$notrace'(_197916, _197918))
^  <span class="ansi1 ansi32"
>Exit: </span>(284) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(flag(eval_num, 6, 6+1), 6 is 6 mod 500, 3 is 99-496 mod 100, _195916=_195916, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(284) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 6>500), (set_debug(eval, false), _195994 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_195994])), nop((start_rtrace, rtrace)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(284) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 6>500), (set_debug(eval, false), _195994 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_195994])), nop((start_rtrace, rtrace)))))
   <span class="ansi1 ansi32"
>Call: </span>(283) [user] nop(notrace(no_repeats_var(_196046)))
   <span class="ansi1 ansi32"
>Exit: </span>(283) [user] nop(notrace(no_repeats_var(_196046)))
^  <span class="ansi1 ansi32"
>Exit: </span>(281) [system] once(user:(notrace((flag(eval_num, 6, 6+1), 6 is 6 mod 500, 3 is 99-496 mod 100, _195916=_195916, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 6>500), (set_debug(eval, false), _195994 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_195994])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_196046)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(280) [user] must_det_ll(user:(notrace((flag(eval_num, 6, 6+1), 6 is 6 mod 500, 3 is 99-496 mod 100, _195916=_195916, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 6>500), (set_debug(eval, false), _195994 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_195994])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_196046)))))
   <span class="ansi1 ansi32"
>Call: </span>(280) [occurs] occurs:sub_term(_206600, e)
   <span class="ansi1 ansi32"
>Exit: </span>(280) [occurs] occurs:sub_term(e, e)
   <span class="ansi1 ansi32"
>Call: </span>(280) [system] e\=e
   <span class="ansi1 ansi31"
>Fail: </span>(280) [system] e\=e
   <span class="ansi1 ansi32"
>Call: </span>(281) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(281) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(280) [occurs] occurs:sub_term(_206600, e)
   <span class="ansi1 ansi32"
>Call: </span>(280) [system] _213090=e
   <span class="ansi1 ansi32"
>Exit: </span>(280) [system] e=e
^  <span class="ansi1 ansi32"
>Call: </span>(280) [user] if_trace((eval;e), (_195916=1, indentq(3, 6, -->, [e, [superpose, []]])))
^  <span class="ansi1 ansi32"
>Call: </span>(282) [system] setup_call_cleanup('$notrace'(_215966, _215968), once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _195916=1, indentq(3, 6, -->, [e, [superpose, []]]))), _215924, fbug((_215924-->if_trace((eval;e), (_195916=1, indentq(3, 6, -->, [e, [superpose, []]])))))))), '$restore_trace'(_215966, _215968))
^  <span class="ansi1 ansi32"
>Call: </span>(283) [system] sig_atomic(system:'$notrace'(_215966, _215968))
^  <span class="ansi1 ansi32"
>Exit: </span>(282) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _195916=1, indentq(3, 6, -->, [e, [superpose, []]]))), _215924, fbug((_215924-->if_trace((eval;e), (_195916=1, indentq(3, 6, -->, [e, [superpose, []]])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(280) [user] if_trace((eval;e), (_195916=1, indentq(3, 6, -->, [e, [superpose, []]])))
   <span class="ansi1 ansi32"
>Call: </span>(280) [system] _219810=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(280) [system] retval(fail)=retval(fail)
   <span class="ansi1 ansi32"
>Call: </span>(280) [system] _221672=(\+ \+ (flag(eval_num, _221692, _221692+1), (retval(fail)\=@=retval(fail), nonvar(_194890)->indentq(3, _221692, <--, [e, _194890]);indentq(3, _221692, <--, [e, retval(fail)]))))
   <span class="ansi1 ansi32"
>Exit: </span>(280) [system] (\+ \+ (flag(eval_num, _221692, _221692+1), (retval(fail)\=@=retval(fail), nonvar(_194890)->indentq(3, _221692, <--, [e, _194890]);indentq(3, _221692, <--, [e, retval(fail)]))))=(\+ \+ (flag(eval_num, _221692, _221692+1), (retval(fail)\=@=retval(fail), nonvar(_194890)->indentq(3, _221692, <--, [e, _194890]);indentq(3, _221692, <--, [e, retval(fail)]))))
^  <span class="ansi1 ansi32"
>Call: </span>(280) [user] call_cleanup(((call(eval_20(=, _161812), 496, '&self', [superpose, []], _194890)*->nb_setarg(1, retval(fail), _194890);fail, trace, call(eval_20(=, _161812), 496, '&self', [superpose, []], _194890)), ignore(notrace((\+_194890\=_196046, nb_setarg(1, retval(fail), _194890))))), ignore((_195916==1->ignore(\+ \+ (flag(eval_num, _221692, _221692+1), (retval(fail)\=@=retval(fail), nonvar(_194890)->indentq(3, _221692, <--, [e, _194890]);indentq(3, _221692, <--, [e, retval(fail)]))));notrace(ignore(if_t(3<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _221692, _221692+1), (retval(fail)\=@=retval(fail), nonvar(_194890)->indentq(3, _221692, <--, [e, _194890]);indentq(3, _221692, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi32"
>Call: </span>(282) [user] eval_20(=, _161812, 496, '&self', [superpose, []], _194890)
   <span class="ansi1 ansi32"
>Call: </span>(283) [system] atom([superpose, []])
^  <span class="ansi1 ansi32"
>Call: </span>(283) [user] no_eval([superpose, []])
^  <span class="ansi1 ansi32"
>Call: </span>(284) [user] self_eval([superpose, []])
^  <span class="ansi1 ansi32"
>Call: </span>(286) [system] setup_call_cleanup('$notrace'(_228464, _228466), once(user:self_eval0([superpose, []])), '$restore_trace'(_228464, _228466))
^  <span class="ansi1 ansi32"
>Call: </span>(287) [system] sig_atomic(system:'$notrace'(_228464, _228466))
^  <span class="ansi1 ansi31"
>Fail: </span>(284) [user] self_eval([superpose, []])
   <span class="ansi1 ansi32"
>Call: </span>(284) [system] atomic(superpose)
   <span class="ansi1 ansi32"
>Exit: </span>(284) [system] atomic(superpose)
^  <span class="ansi1 ansi32"
>Call: </span>(284) [user] is_sl(superpose)
   <span class="ansi1 ansi32"
>Call: </span>(285) [system] number(superpose)
   <span class="ansi1 ansi32"
>Call: </span>(283) [system] [[]]==[]
   <span class="ansi1 ansi32"
>Call: </span>(283) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(283) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(283) [system] (=)\==(=)
   <span class="ansi1 ansi32"
>Call: </span>(283) [system] callable(superpose)
   <span class="ansi1 ansi32"
>Exit: </span>(283) [system] callable(superpose)
   <span class="ansi1 ansi32"
>Call: </span>(283) [system] is_list([[]])
   <span class="ansi1 ansi32"
>Exit: </span>(283) [system] is_list([[]])
   <span class="ansi1 ansi32"
>Call: </span>(283) [system] is_list([superpose, []])
   <span class="ansi1 ansi32"
>Exit: </span>(283) [system] is_list([superpose, []])
   <span class="ansi1 ansi32"
>Call: </span>(283) [system] var(superpose)
^  <span class="ansi1 ansi32"
>Call: </span>(283) [user] once(expand_eval([superpose, []], _245166))
^  <span class="ansi1 ansi32"
>Call: </span>(284) [user] expand_eval([superpose, []], _245166)
   <span class="ansi1 ansi32"
>Call: </span>(285) [system] is_list([superpose, []])
   <span class="ansi1 ansi32"
>Exit: </span>(285) [system] is_list([superpose, []])
   <span class="ansi1 ansi32"
>Call: </span>(285) [system] ground(superpose)
   <span class="ansi1 ansi32"
>Exit: </span>(285) [system] ground(superpose)
^  <span class="ansi1 ansi32"
>Call: </span>(285) [user] apply:maplist(expand_eval, [[]], _250738)
   <span class="ansi1 ansi32"
>Call: </span>(286) [apply] apply:maplist_([[]], _250738, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(287) [user] expand_eval([], _252618)
   <span class="ansi1 ansi32"
>Call: </span>(288) [system] is_list([])
   <span class="ansi1 ansi32"
>Exit: </span>(288) [system] is_list([])
^  <span class="ansi1 ansi32"
>Call: </span>(283) [user] is_progn(superpose)
   <span class="ansi1 ansi32"
>Call: </span>(284) [system] var(superpose)
^  <span class="ansi1 ansi32"
>Call: </span>(283) [user] is_progn(superpose)
   <span class="ansi1 ansi32"
>Call: </span>(284) [system] var(superpose)
^  <span class="ansi1 ansi32"
>Call: </span>(283) [user] is_space_op(superpose)
   <span class="ansi1 ansi32"
>Call: </span>(283) [system] is_list([])
   <span class="ansi1 ansi32"
>Exit: </span>(283) [system] is_list([])
   <span class="ansi1 ansi32"
>Call: </span>(283) [system] []=[_261868, _261874, _261880]
   <span class="ansi1 ansi32"
>Call: </span>(283) [lists] lists:member(_262812, [])
^  <span class="ansi1 ansi31"
>Fail: </span>(282) [user] eval_20(=, _161812, 496, '&self', [superpose, []], _194890)
   <span class="ansi1 ansi32"
>Call: </span>(282) [system] fail
   <span class="ansi1 ansi31"
>Fail: </span>(282) [system] fail
^  <span class="ansi1 ansi32"
>Call: </span>(282) [user] ignore((_195916==1->ignore(\+ \+ (flag(eval_num, _221692, _221692+1), (retval(fail)\=@=retval(fail), nonvar(_194890)->indentq(3, _221692, <--, [e, _194890]);indentq(3, _221692, <--, [e, retval(fail)]))));notrace(ignore(if_t(3<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _221692, _221692+1), (retval(fail)\=@=retval(fail), nonvar(_194890)->indentq(3, _221692, <--, [e, _194890]);indentq(3, _221692, <--, [e, retval(fail)]))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(284) [system] _195916==1
   <span class="ansi1 ansi31"
>Fail: </span>(284) [system] _195916==1
^  <span class="ansi1 ansi32"
>Call: </span>(285) [system] setup_call_cleanup('$notrace'(_269318, _269320), once(user:ignore(if_t(3<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _221692, _221692+1), (retval(fail)\=@=retval(fail), nonvar(_194890)->indentq(3, _221692, <--, [e, _194890]);indentq(3, _221692, <--, [e, retval(fail)])))))))), '$restore_trace'(_269318, _269320))
^  <span class="ansi1 ansi32"
>Call: </span>(286) [system] sig_atomic(system:'$notrace'(_269318, _269320))
^  <span class="ansi1 ansi32"
>Exit: </span>(285) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:ignore(if_t(3<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _221692, _221692+1), (retval(fail)\=@=retval(fail), nonvar(_194890)->indentq(3, _221692, <--, [e, _194890]);indentq(3, _221692, <--, [e, retval(fail)])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(282) [system] ignore(user:(_195916==1->ignore(\+ \+ (flag(eval_num, _221692, _221692+1), (retval(fail)\=@=retval(fail), nonvar(_194890)->indentq(3, _221692, <--, [e, _194890]);indentq(3, _221692, <--, [e, retval(fail)]))));notrace(ignore(if_t(3<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _221692, _221692+1), (retval(fail)\=@=retval(fail), nonvar(_194890)->indentq(3, _221692, <--, [e, _194890]);indentq(3, _221692, <--, [e, retval(fail)]))))))))))
^  <span class="ansi1 ansi31"
>Fail: </span>(280) [system] call_cleanup(user:((call(eval_20(=, _161812), 496, '&self', [superpose, []], _194890)*->nb_setarg(1, retval(fail), _194890);fail, trace, call(eval_20(=, _161812), 496, '&self', [superpose, []], _194890)), ignore(notrace((\+_194890\=_196046, nb_setarg(1, retval(fail), _194890))))), user:ignore((_195916==1->ignore(\+ \+ (flag(eval_num, _221692, _221692+1), (retval(fail)\=@=retval(fail), nonvar(_194890)->indentq(3, _221692, <--, [e, _194890]);indentq(3, _221692, <--, [e, retval(fail)]))));notrace(ignore(if_t(3<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _221692, _221692+1), (retval(fail)\=@=retval(fail), nonvar(_194890)->indentq(3, _221692, <--, [e, _194890]);indentq(3, _221692, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi31"
>Fail: </span>(279) [user] trace_eval(eval_20(=, _161812), e, 496, '&self', [superpose, []], _194890)
^  <span class="ansi1 ansi31"
>Fail: </span>(276) [user] eval_args(=, _161812, 497, '&self', [superpose, []], _161826)
^  <span class="ansi1 ansi32"
>Call: </span>(273) [user] call(eval, [superpose, []], _161826)
   <span class="ansi1 ansi32"
>Call: </span>(274) [user] eval([superpose, []], _161826)
^  <span class="ansi1 ansi32"
>Call: </span>(275) [user] current_self(_277934)
   <span class="ansi1 ansi32"
>Call: </span>(276) [system] nb_current(self_space, _277934)
   <span class="ansi1 ansi32"
>Exit: </span>(276) [system] nb_current(self_space, '&self')
   <span class="ansi1 ansi32"
>Call: </span>(276) [system] '&self'\==[]
   <span class="ansi1 ansi32"
>Exit: </span>(276) [system] '&self'\==[]
^  <span class="ansi1 ansi32"
>Exit: </span>(275) [user] current_self('&self')
   <span class="ansi1 ansi32"
>Call: </span>(275) [user] eval('&self', [superpose, []], _161826)
   <span class="ansi1 ansi32"
>Call: </span>(276) [user] eval_H(500, '&self', [superpose, []], _161826)
^  <span class="ansi1 ansi32"
>Call: </span>(277) [user] catch_metta_return(eval_args(=, _285344, 500, '&self', [superpose, []], _161826), _161826)
^  <span class="ansi1 ansi32"
>Call: </span>(279) [user] eval_args(=, _285344, 500, '&self', [superpose, []], _161826)
   <span class="ansi1 ansi32"
>Call: </span>(280) [system] var([superpose, []])
^  <span class="ansi1 ansi32"
>Call: </span>(281) [system] setup_call_cleanup('$notrace'(_288190, _288192), once(user:self_eval([superpose, []])), '$restore_trace'(_288190, _288192))
^  <span class="ansi1 ansi32"
>Call: </span>(282) [system] sig_atomic(system:'$notrace'(_288190, _288192))
^  <span class="ansi1 ansi32"
>Call: </span>(281) [system] setup_call_cleanup('$notrace'(_290102, _290104), once(user:nonvar(_161826)), '$restore_trace'(_290102, _290104))
^  <span class="ansi1 ansi32"
>Call: </span>(282) [system] sig_atomic(system:'$notrace'(_290102, _290104))
^  <span class="ansi1 ansi32"
>Call: </span>(281) [system] setup_call_cleanup('$notrace'(_292014, _292016), once(user:nonvar(_161826)), '$restore_trace'(_292014, _292016))
^  <span class="ansi1 ansi32"
>Call: </span>(282) [system] sig_atomic(system:'$notrace'(_292014, _292016))
   <span class="ansi1 ansi32"
>Call: </span>(280) [system] [[]]==[]
   <span class="ansi1 ansi32"
>Call: </span>(280) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(280) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(280) [system] (=)\==(=)
^  <span class="ansi1 ansi32"
>Call: </span>(280) [user] self_eval([superpose, []])
^  <span class="ansi1 ansi32"
>Call: </span>(282) [system] setup_call_cleanup('$notrace'(_298554, _298556), once(user:self_eval0([superpose, []])), '$restore_trace'(_298554, _298556))
^  <span class="ansi1 ansi32"
>Call: </span>(283) [system] sig_atomic(system:'$notrace'(_298554, _298556))
^  <span class="ansi1 ansi31"
>Fail: </span>(280) [user] self_eval([superpose, []])
^  <span class="ansi1 ansi32"
>Call: </span>(280) [user] eval_00(=, _285344, 500, '&self', [superpose, []], _161826)
^  <span class="ansi1 ansi32"
>Call: </span>(281) [user] self_eval([superpose, []])
^  <span class="ansi1 ansi32"
>Call: </span>(283) [system] setup_call_cleanup('$notrace'(_303258, _303260), once(user:self_eval0([superpose, []])), '$restore_trace'(_303258, _303260))
^  <span class="ansi1 ansi32"
>Call: </span>(284) [system] sig_atomic(system:'$notrace'(_303258, _303260))
^  <span class="ansi1 ansi31"
>Fail: </span>(281) [user] self_eval([superpose, []])
^  <span class="ansi1 ansi32"
>Call: </span>(281) [user] eval_01(=, _285344, 500, '&self', [superpose, []], _161826)
^  <span class="ansi1 ansi32"
>Call: </span>(282) [user] if_t((500<1, trace_on_overflow), debug(metta(eval_args)))
   <span class="ansi1 ansi32"
>Call: </span>(284) [system] 500<1
   <span class="ansi1 ansi31"
>Fail: </span>(284) [system] 500<1
^  <span class="ansi1 ansi32"
>Exit: </span>(282) [user] if_t((500<1, trace_on_overflow), debug(metta(eval_args)))
^  <span class="ansi1 ansi32"
>Call: </span>(283) [system] setup_call_cleanup('$notrace'(_310790, _310792), once(user:(_310766 is 500-1, copy_term([superpose, []], _310780))), '$restore_trace'(_310790, _310792))
^  <span class="ansi1 ansi32"
>Call: </span>(284) [system] sig_atomic(system:'$notrace'(_310790, _310792))
^  <span class="ansi1 ansi32"
>Exit: </span>(283) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(499 is 500-1, copy_term([superpose, []], [superpose, []]))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(282) [user] trace_eval(eval_20(=, _285344), e, 499, '&self', [superpose, []], _313636)
^  <span class="ansi1 ansi32"
>Call: </span>(283) [user] must_det_ll((notrace((flag(eval_num, _314602, _314602+1), _314620 is _314602 mod 500, _314638 is 99-499 mod 100, _314662=_314664, option_else('trace-length', _314676, 500), option_else('trace-depth', _314684, 30))), quietly(if_t((nop(stop_rtrace), _314620>_314676), (set_debug(eval, false), _314740 is _314676+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_314740])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_314792)))))
^  <span class="ansi1 ansi32"
>Call: </span>(284) [user] once(user:(notrace((flag(eval_num, _314602, _314602+1), _314620 is _314602 mod 500, _314638 is 99-499 mod 100, _314662=_314664, option_else('trace-length', _314676, 500), option_else('trace-depth', _314684, 30))), quietly(if_t((nop(stop_rtrace), _314620>_314676), (set_debug(eval, false), _314740 is _314676+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_314740])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_314792)))))
^  <span class="ansi1 ansi32"
>Call: </span>(287) [system] setup_call_cleanup('$notrace'(_316662, _316664), once(user:(flag(eval_num, _314602, _314602+1), _314620 is _314602 mod 500, _314638 is 99-499 mod 100, _314662=_314664, option_else('trace-length', _314676, 500), option_else('trace-depth', _314684, 30))), '$restore_trace'(_316662, _316664))
^  <span class="ansi1 ansi32"
>Call: </span>(288) [system] sig_atomic(system:'$notrace'(_316662, _316664))
^  <span class="ansi1 ansi32"
>Exit: </span>(287) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(flag(eval_num, 7, 7+1), 7 is 7 mod 500, 0 is 99-499 mod 100, _314662=_314662, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(287) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 7>500), (set_debug(eval, false), _314740 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_314740])), nop((start_rtrace, rtrace)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(287) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 7>500), (set_debug(eval, false), _314740 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_314740])), nop((start_rtrace, rtrace)))))
   <span class="ansi1 ansi32"
>Call: </span>(286) [user] nop(notrace(no_repeats_var(_314792)))
   <span class="ansi1 ansi32"
>Exit: </span>(286) [user] nop(notrace(no_repeats_var(_314792)))
^  <span class="ansi1 ansi32"
>Exit: </span>(284) [system] once(user:(notrace((flag(eval_num, 7, 7+1), 7 is 7 mod 500, 0 is 99-499 mod 100, _314662=_314662, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 7>500), (set_debug(eval, false), _314740 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_314740])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_314792)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(283) [user] must_det_ll(user:(notrace((flag(eval_num, 7, 7+1), 7 is 7 mod 500, 0 is 99-499 mod 100, _314662=_314662, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 7>500), (set_debug(eval, false), _314740 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_314740])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_314792)))))
   <span class="ansi1 ansi32"
>Call: </span>(283) [occurs] occurs:sub_term(_325346, e)
   <span class="ansi1 ansi32"
>Exit: </span>(283) [occurs] occurs:sub_term(e, e)
   <span class="ansi1 ansi32"
>Call: </span>(283) [system] e\=e
   <span class="ansi1 ansi31"
>Fail: </span>(283) [system] e\=e
   <span class="ansi1 ansi32"
>Call: </span>(284) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(284) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(283) [occurs] occurs:sub_term(_325346, e)
   <span class="ansi1 ansi32"
>Call: </span>(283) [system] _331836=e
   <span class="ansi1 ansi32"
>Exit: </span>(283) [system] e=e
^  <span class="ansi1 ansi32"
>Call: </span>(283) [user] if_trace((eval;e), (_314662=1, indentq(0, 7, -->, [e, [superpose, []]])))
^  <span class="ansi1 ansi32"
>Call: </span>(285) [system] setup_call_cleanup('$notrace'(_334712, _334714), once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _314662=1, indentq(0, 7, -->, [e, [superpose, []]]))), _334670, fbug((_334670-->if_trace((eval;e), (_314662=1, indentq(0, 7, -->, [e, [superpose, []]])))))))), '$restore_trace'(_334712, _334714))
^  <span class="ansi1 ansi32"
>Call: </span>(286) [system] sig_atomic(system:'$notrace'(_334712, _334714))
^  <span class="ansi1 ansi32"
>Exit: </span>(285) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _314662=1, indentq(0, 7, -->, [e, [superpose, []]]))), _334670, fbug((_334670-->if_trace((eval;e), (_314662=1, indentq(0, 7, -->, [e, [superpose, []]])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(283) [user] if_trace((eval;e), (_314662=1, indentq(0, 7, -->, [e, [superpose, []]])))
   <span class="ansi1 ansi32"
>Call: </span>(283) [system] _338556=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(283) [system] retval(fail)=retval(fail)
   <span class="ansi1 ansi32"
>Call: </span>(283) [system] _340418=(\+ \+ (flag(eval_num, _340438, _340438+1), (retval(fail)\=@=retval(fail), nonvar(_313636)->indentq(0, _340438, <--, [e, _313636]);indentq(0, _340438, <--, [e, retval(fail)]))))
   <span class="ansi1 ansi32"
>Exit: </span>(283) [system] (\+ \+ (flag(eval_num, _340438, _340438+1), (retval(fail)\=@=retval(fail), nonvar(_313636)->indentq(0, _340438, <--, [e, _313636]);indentq(0, _340438, <--, [e, retval(fail)]))))=(\+ \+ (flag(eval_num, _340438, _340438+1), (retval(fail)\=@=retval(fail), nonvar(_313636)->indentq(0, _340438, <--, [e, _313636]);indentq(0, _340438, <--, [e, retval(fail)]))))
^  <span class="ansi1 ansi32"
>Call: </span>(283) [user] call_cleanup(((call(eval_20(=, _285344), 499, '&self', [superpose, []], _313636)*->nb_setarg(1, retval(fail), _313636);fail, trace, call(eval_20(=, _285344), 499, '&self', [superpose, []], _313636)), ignore(notrace((\+_313636\=_314792, nb_setarg(1, retval(fail), _313636))))), ignore((_314662==1->ignore(\+ \+ (flag(eval_num, _340438, _340438+1), (retval(fail)\=@=retval(fail), nonvar(_313636)->indentq(0, _340438, <--, [e, _313636]);indentq(0, _340438, <--, [e, retval(fail)]))));notrace(ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _340438, _340438+1), (retval(fail)\=@=retval(fail), nonvar(_313636)->indentq(0, _340438, <--, [e, _313636]);indentq(0, _340438, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi32"
>Call: </span>(285) [user] eval_20(=, _285344, 499, '&self', [superpose, []], _313636)
   <span class="ansi1 ansi32"
>Call: </span>(286) [system] atom([superpose, []])
^  <span class="ansi1 ansi32"
>Call: </span>(286) [user] no_eval([superpose, []])
^  <span class="ansi1 ansi32"
>Call: </span>(287) [user] self_eval([superpose, []])
^  <span class="ansi1 ansi32"
>Call: </span>(289) [system] setup_call_cleanup('$notrace'(_347210, _347212), once(user:self_eval0([superpose, []])), '$restore_trace'(_347210, _347212))
^  <span class="ansi1 ansi32"
>Call: </span>(290) [system] sig_atomic(system:'$notrace'(_347210, _347212))
^  <span class="ansi1 ansi31"
>Fail: </span>(287) [user] self_eval([superpose, []])
   <span class="ansi1 ansi32"
>Call: </span>(287) [system] atomic(superpose)
   <span class="ansi1 ansi32"
>Exit: </span>(287) [system] atomic(superpose)
^  <span class="ansi1 ansi32"
>Call: </span>(287) [user] is_sl(superpose)
   <span class="ansi1 ansi32"
>Call: </span>(288) [system] number(superpose)
   <span class="ansi1 ansi32"
>Call: </span>(286) [system] [[]]==[]
   <span class="ansi1 ansi32"
>Call: </span>(286) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(286) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(286) [system] (=)\==(=)
   <span class="ansi1 ansi32"
>Call: </span>(286) [system] callable(superpose)
   <span class="ansi1 ansi32"
>Exit: </span>(286) [system] callable(superpose)
   <span class="ansi1 ansi32"
>Call: </span>(286) [system] is_list([[]])
   <span class="ansi1 ansi32"
>Exit: </span>(286) [system] is_list([[]])
   <span class="ansi1 ansi32"
>Call: </span>(286) [system] is_list([superpose, []])
   <span class="ansi1 ansi32"
>Exit: </span>(286) [system] is_list([superpose, []])
   <span class="ansi1 ansi32"
>Call: </span>(286) [system] var(superpose)
^  <span class="ansi1 ansi32"
>Call: </span>(286) [user] once(expand_eval([superpose, []], _363912))
^  <span class="ansi1 ansi32"
>Call: </span>(287) [user] expand_eval([superpose, []], _363912)
   <span class="ansi1 ansi32"
>Call: </span>(288) [system] is_list([superpose, []])
   <span class="ansi1 ansi32"
>Exit: </span>(288) [system] is_list([superpose, []])
   <span class="ansi1 ansi32"
>Call: </span>(288) [system] ground(superpose)
   <span class="ansi1 ansi32"
>Exit: </span>(288) [system] ground(superpose)
^  <span class="ansi1 ansi32"
>Call: </span>(288) [user] apply:maplist(expand_eval, [[]], _369484)
   <span class="ansi1 ansi32"
>Call: </span>(289) [apply] apply:maplist_([[]], _369484, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(290) [user] expand_eval([], _371364)
   <span class="ansi1 ansi32"
>Call: </span>(291) [system] is_list([])
   <span class="ansi1 ansi32"
>Exit: </span>(291) [system] is_list([])
^  <span class="ansi1 ansi32"
>Call: </span>(286) [user] is_progn(superpose)
   <span class="ansi1 ansi32"
>Call: </span>(287) [system] var(superpose)
^  <span class="ansi1 ansi32"
>Call: </span>(286) [user] is_progn(superpose)
   <span class="ansi1 ansi32"
>Call: </span>(287) [system] var(superpose)
^  <span class="ansi1 ansi32"
>Call: </span>(286) [user] is_space_op(superpose)
   <span class="ansi1 ansi32"
>Call: </span>(286) [system] is_list([])
   <span class="ansi1 ansi32"
>Exit: </span>(286) [system] is_list([])
   <span class="ansi1 ansi32"
>Call: </span>(286) [system] []=[_380614, _380620, _380626]
   <span class="ansi1 ansi32"
>Call: </span>(286) [lists] lists:member(_381558, [])
^  <span class="ansi1 ansi31"
>Fail: </span>(285) [user] eval_20(=, _285344, 499, '&self', [superpose, []], _313636)
   <span class="ansi1 ansi32"
>Call: </span>(285) [system] fail
   <span class="ansi1 ansi31"
>Fail: </span>(285) [system] fail
^  <span class="ansi1 ansi32"
>Call: </span>(285) [user] ignore((_314662==1->ignore(\+ \+ (flag(eval_num, _340438, _340438+1), (retval(fail)\=@=retval(fail), nonvar(_313636)->indentq(0, _340438, <--, [e, _313636]);indentq(0, _340438, <--, [e, retval(fail)]))));notrace(ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _340438, _340438+1), (retval(fail)\=@=retval(fail), nonvar(_313636)->indentq(0, _340438, <--, [e, _313636]);indentq(0, _340438, <--, [e, retval(fail)]))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(287) [system] _314662==1
   <span class="ansi1 ansi31"
>Fail: </span>(287) [system] _314662==1
^  <span class="ansi1 ansi32"
>Call: </span>(288) [system] setup_call_cleanup('$notrace'(_388064, _388066), once(user:ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _340438, _340438+1), (retval(fail)\=@=retval(fail), nonvar(_313636)->indentq(0, _340438, <--, [e, _313636]);indentq(0, _340438, <--, [e, retval(fail)])))))))), '$restore_trace'(_388064, _388066))
^  <span class="ansi1 ansi32"
>Call: </span>(289) [system] sig_atomic(system:'$notrace'(_388064, _388066))
^  <span class="ansi1 ansi32"
>Exit: </span>(288) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _340438, _340438+1), (retval(fail)\=@=retval(fail), nonvar(_313636)->indentq(0, _340438, <--, [e, _313636]);indentq(0, _340438, <--, [e, retval(fail)])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(285) [system] ignore(user:(_314662==1->ignore(\+ \+ (flag(eval_num, _340438, _340438+1), (retval(fail)\=@=retval(fail), nonvar(_313636)->indentq(0, _340438, <--, [e, _313636]);indentq(0, _340438, <--, [e, retval(fail)]))));notrace(ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _340438, _340438+1), (retval(fail)\=@=retval(fail), nonvar(_313636)->indentq(0, _340438, <--, [e, _313636]);indentq(0, _340438, <--, [e, retval(fail)]))))))))))
^  <span class="ansi1 ansi31"
>Fail: </span>(283) [system] call_cleanup(user:((call(eval_20(=, _285344), 499, '&self', [superpose, []], _313636)*->nb_setarg(1, retval(fail), _313636);fail, trace, call(eval_20(=, _285344), 499, '&self', [superpose, []], _313636)), ignore(notrace((\+_313636\=_314792, nb_setarg(1, retval(fail), _313636))))), user:ignore((_314662==1->ignore(\+ \+ (flag(eval_num, _340438, _340438+1), (retval(fail)\=@=retval(fail), nonvar(_313636)->indentq(0, _340438, <--, [e, _313636]);indentq(0, _340438, <--, [e, retval(fail)]))));notrace(ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _340438, _340438+1), (retval(fail)\=@=retval(fail), nonvar(_313636)->indentq(0, _340438, <--, [e, _313636]);indentq(0, _340438, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi31"
>Fail: </span>(282) [user] trace_eval(eval_20(=, _285344), e, 499, '&self', [superpose, []], _313636)
^  <span class="ansi1 ansi31"
>Fail: </span>(279) [user] eval_args(=, _285344, 500, '&self', [superpose, []], _161826)
^  <span class="ansi1 ansi31"
>Fail: </span>(270) [system] call(user:once, user:if_or_else(eval(=, _161812, 497, '&self', [superpose, []], _161826), call(eval, [superpose, []], _161826)))
^  <span class="ansi1 ansi32"
>Call: </span>(270) [bugger] bugger:mquietly_if(true, rtrace:pop_tracer)
   <span class="ansi1 ansi32"
>Call: </span>(272) [system] var(rtrace:pop_tracer)
   <span class="ansi1 ansi31"
>Fail: </span>(272) [system] var(rtrace:pop_tracer)
^  <span class="ansi1 ansi32"
>Call: </span>(274) [system] setup_call_cleanup('$notrace'(_398558, _398560), once(rtrace:retract(t_l:tracer_reset(_398548))), '$restore_trace'(_398558, _398560))
^  <span class="ansi1 ansi32"
>Call: </span>(275) [system] sig_atomic(system:'$notrace'(_398558, _398560))
^  <span class="ansi1 ansi32"
>Exit: </span>(274) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(rtrace:retract(t_l:tracer_reset(tAt_normal))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(274) [rtrace] tAt(false, 271, 271, false)


  (failed  once 
    (if_or_else  
      (eval  = $_404158 497 &self 
        (superpose ()) $_404172) 
      (call  eval 
        (superpose ()) $_404172)))




  (failed  once 
    (if_or_else  
      (eval  = $_404158 497 &self 
        (superpose ()) $_404172) 
      (call  eval 
        (superpose ()) $_404172)))


^  <span class="ansi1 ansi32"
>Call: </span>(264) [user] call(user:once, user:if_or_else(eval(=, _404158, 497, '&self', [superpose, []], _404172), call(eval, [superpose, []], _404172)))
^  <span class="ansi1 ansi32"
>Call: </span>(265) [user] once(user:if_or_else(eval(=, _404158, 497, '&self', [superpose, []], _404172), call(eval, [superpose, []], _404172)))
   <span class="ansi1 ansi32"
>Call: </span>(266) [user] if_or_else(eval(=, _404158, 497, '&self', [superpose, []], _404172), call(eval, [superpose, []], _404172))
^  <span class="ansi1 ansi32"
>Call: </span>(267) [user] eval(=, _404158, 497, '&self', [superpose, []], _404172)
^  <span class="ansi1 ansi32"
>Call: </span>(268) [user] catch_metta_return(eval_args(=, _404158, 497, '&self', [superpose, []], _404172), _404172)
^  <span class="ansi1 ansi32"
>Call: </span>(270) [user] eval_args(=, _404158, 497, '&self', [superpose, []], _404172)
   <span class="ansi1 ansi32"
>Call: </span>(271) [system] var([superpose, []])
^  <span class="ansi1 ansi32"
>Call: </span>(272) [system] setup_call_cleanup('$notrace'(_411790, _411792), once(user:self_eval([superpose, []])), '$restore_trace'(_411790, _411792))
^  <span class="ansi1 ansi32"
>Call: </span>(273) [system] sig_atomic(system:'$notrace'(_411790, _411792))
^  <span class="ansi1 ansi32"
>Call: </span>(272) [system] setup_call_cleanup('$notrace'(_413702, _413704), once(user:nonvar(_404172)), '$restore_trace'(_413702, _413704))
^  <span class="ansi1 ansi32"
>Call: </span>(273) [system] sig_atomic(system:'$notrace'(_413702, _413704))
^  <span class="ansi1 ansi32"
>Call: </span>(272) [system] setup_call_cleanup('$notrace'(_415614, _415616), once(user:nonvar(_404172)), '$restore_trace'(_415614, _415616))
^  <span class="ansi1 ansi32"
>Call: </span>(273) [system] sig_atomic(system:'$notrace'(_415614, _415616))
   <span class="ansi1 ansi32"
>Call: </span>(271) [system] [[]]==[]
   <span class="ansi1 ansi32"
>Call: </span>(271) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(271) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(271) [system] (=)\==(=)
^  <span class="ansi1 ansi32"
>Call: </span>(271) [user] self_eval([superpose, []])
^  <span class="ansi1 ansi32"
>Call: </span>(273) [system] setup_call_cleanup('$notrace'(_422154, _422156), once(user:self_eval0([superpose, []])), '$restore_trace'(_422154, _422156))
^  <span class="ansi1 ansi32"
>Call: </span>(274) [system] sig_atomic(system:'$notrace'(_422154, _422156))
^  <span class="ansi1 ansi31"
>Fail: </span>(271) [user] self_eval([superpose, []])
^  <span class="ansi1 ansi32"
>Call: </span>(271) [user] eval_00(=, _404158, 497, '&self', [superpose, []], _404172)
^  <span class="ansi1 ansi32"
>Call: </span>(272) [user] self_eval([superpose, []])
^  <span class="ansi1 ansi32"
>Call: </span>(274) [system] setup_call_cleanup('$notrace'(_426858, _426860), once(user:self_eval0([superpose, []])), '$restore_trace'(_426858, _426860))
^  <span class="ansi1 ansi32"
>Call: </span>(275) [system] sig_atomic(system:'$notrace'(_426858, _426860))
^  <span class="ansi1 ansi31"
>Fail: </span>(272) [user] self_eval([superpose, []])
^  <span class="ansi1 ansi32"
>Call: </span>(272) [user] eval_01(=, _404158, 497, '&self', [superpose, []], _404172)
^  <span class="ansi1 ansi32"
>Call: </span>(273) [user] if_t((497<1, trace_on_overflow), debug(metta(eval_args)))
   <span class="ansi1 ansi32"
>Call: </span>(275) [system] 497<1
   <span class="ansi1 ansi31"
>Fail: </span>(275) [system] 497<1
^  <span class="ansi1 ansi32"
>Exit: </span>(273) [user] if_t((497<1, trace_on_overflow), debug(metta(eval_args)))
^  <span class="ansi1 ansi32"
>Call: </span>(274) [system] setup_call_cleanup('$notrace'(_434390, _434392), once(user:(_434366 is 497-1, copy_term([superpose, []], _434380))), '$restore_trace'(_434390, _434392))
^  <span class="ansi1 ansi32"
>Call: </span>(275) [system] sig_atomic(system:'$notrace'(_434390, _434392))
^  <span class="ansi1 ansi32"
>Exit: </span>(274) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(496 is 497-1, copy_term([superpose, []], [superpose, []]))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(273) [user] trace_eval(eval_20(=, _404158), e, 496, '&self', [superpose, []], _437236)
^  <span class="ansi1 ansi32"
>Call: </span>(274) [user] must_det_ll((notrace((flag(eval_num, _438202, _438202+1), _438220 is _438202 mod 500, _438238 is 99-496 mod 100, _438262=_438264, option_else('trace-length', _438276, 500), option_else('trace-depth', _438284, 30))), quietly(if_t((nop(stop_rtrace), _438220>_438276), (set_debug(eval, false), _438340 is _438276+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_438340])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_438392)))))
^  <span class="ansi1 ansi32"
>Call: </span>(275) [user] once(user:(notrace((flag(eval_num, _438202, _438202+1), _438220 is _438202 mod 500, _438238 is 99-496 mod 100, _438262=_438264, option_else('trace-length', _438276, 500), option_else('trace-depth', _438284, 30))), quietly(if_t((nop(stop_rtrace), _438220>_438276), (set_debug(eval, false), _438340 is _438276+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_438340])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_438392)))))
^  <span class="ansi1 ansi32"
>Call: </span>(278) [system] setup_call_cleanup('$notrace'(_440262, _440264), once(user:(flag(eval_num, _438202, _438202+1), _438220 is _438202 mod 500, _438238 is 99-496 mod 100, _438262=_438264, option_else('trace-length', _438276, 500), option_else('trace-depth', _438284, 30))), '$restore_trace'(_440262, _440264))
^  <span class="ansi1 ansi32"
>Call: </span>(279) [system] sig_atomic(system:'$notrace'(_440262, _440264))
^  <span class="ansi1 ansi32"
>Exit: </span>(278) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(flag(eval_num, 13, 13+1), 13 is 13 mod 500, 3 is 99-496 mod 100, _438262=_438262, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(278) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 13>500), (set_debug(eval, false), _438340 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_438340])), nop((start_rtrace, rtrace)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(278) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 13>500), (set_debug(eval, false), _438340 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_438340])), nop((start_rtrace, rtrace)))))
   <span class="ansi1 ansi32"
>Call: </span>(277) [user] nop(notrace(no_repeats_var(_438392)))
   <span class="ansi1 ansi32"
>Exit: </span>(277) [user] nop(notrace(no_repeats_var(_438392)))
^  <span class="ansi1 ansi32"
>Exit: </span>(275) [system] once(user:(notrace((flag(eval_num, 13, 13+1), 13 is 13 mod 500, 3 is 99-496 mod 100, _438262=_438262, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 13>500), (set_debug(eval, false), _438340 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_438340])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_438392)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(274) [user] must_det_ll(user:(notrace((flag(eval_num, 13, 13+1), 13 is 13 mod 500, 3 is 99-496 mod 100, _438262=_438262, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 13>500), (set_debug(eval, false), _438340 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_438340])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_438392)))))
   <span class="ansi1 ansi32"
>Call: </span>(274) [occurs] occurs:sub_term(_448946, e)
   <span class="ansi1 ansi32"
>Exit: </span>(274) [occurs] occurs:sub_term(e, e)
   <span class="ansi1 ansi32"
>Call: </span>(274) [system] e\=e
   <span class="ansi1 ansi31"
>Fail: </span>(274) [system] e\=e
   <span class="ansi1 ansi32"
>Call: </span>(275) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(275) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(274) [occurs] occurs:sub_term(_448946, e)
   <span class="ansi1 ansi32"
>Call: </span>(274) [system] _455436=e
   <span class="ansi1 ansi32"
>Exit: </span>(274) [system] e=e
^  <span class="ansi1 ansi32"
>Call: </span>(274) [user] if_trace((eval;e), (_438262=1, indentq(3, 13, -->, [e, [superpose, []]])))
^  <span class="ansi1 ansi32"
>Call: </span>(276) [system] setup_call_cleanup('$notrace'(_458312, _458314), once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _438262=1, indentq(3, 13, -->, [e, [superpose, []]]))), _458270, fbug((_458270-->if_trace((eval;e), (_438262=1, indentq(3, 13, -->, [e, [superpose, []]])))))))), '$restore_trace'(_458312, _458314))
^  <span class="ansi1 ansi32"
>Call: </span>(277) [system] sig_atomic(system:'$notrace'(_458312, _458314))
^  <span class="ansi1 ansi32"
>Exit: </span>(276) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _438262=1, indentq(3, 13, -->, [e, [superpose, []]]))), _458270, fbug((_458270-->if_trace((eval;e), (_438262=1, indentq(3, 13, -->, [e, [superpose, []]])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(274) [user] if_trace((eval;e), (_438262=1, indentq(3, 13, -->, [e, [superpose, []]])))
   <span class="ansi1 ansi32"
>Call: </span>(274) [system] _462156=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(274) [system] retval(fail)=retval(fail)
   <span class="ansi1 ansi32"
>Call: </span>(274) [system] _464018=(\+ \+ (flag(eval_num, _464038, _464038+1), (retval(fail)\=@=retval(fail), nonvar(_437236)->indentq(3, _464038, <--, [e, _437236]);indentq(3, _464038, <--, [e, retval(fail)]))))
   <span class="ansi1 ansi32"
>Exit: </span>(274) [system] (\+ \+ (flag(eval_num, _464038, _464038+1), (retval(fail)\=@=retval(fail), nonvar(_437236)->indentq(3, _464038, <--, [e, _437236]);indentq(3, _464038, <--, [e, retval(fail)]))))=(\+ \+ (flag(eval_num, _464038, _464038+1), (retval(fail)\=@=retval(fail), nonvar(_437236)->indentq(3, _464038, <--, [e, _437236]);indentq(3, _464038, <--, [e, retval(fail)]))))
^  <span class="ansi1 ansi32"
>Call: </span>(274) [user] call_cleanup(((call(eval_20(=, _404158), 496, '&self', [superpose, []], _437236)*->nb_setarg(1, retval(fail), _437236);fail, trace, call(eval_20(=, _404158), 496, '&self', [superpose, []], _437236)), ignore(notrace((\+_437236\=_438392, nb_setarg(1, retval(fail), _437236))))), ignore((_438262==1->ignore(\+ \+ (flag(eval_num, _464038, _464038+1), (retval(fail)\=@=retval(fail), nonvar(_437236)->indentq(3, _464038, <--, [e, _437236]);indentq(3, _464038, <--, [e, retval(fail)]))));notrace(ignore(if_t(3<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _464038, _464038+1), (retval(fail)\=@=retval(fail), nonvar(_437236)->indentq(3, _464038, <--, [e, _437236]);indentq(3, _464038, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi32"
>Call: </span>(276) [user] eval_20(=, _404158, 496, '&self', [superpose, []], _437236)
   <span class="ansi1 ansi32"
>Call: </span>(277) [system] atom([superpose, []])
^  <span class="ansi1 ansi32"
>Call: </span>(277) [user] no_eval([superpose, []])
^  <span class="ansi1 ansi32"
>Call: </span>(278) [user] self_eval([superpose, []])
^  <span class="ansi1 ansi32"
>Call: </span>(280) [system] setup_call_cleanup('$notrace'(_470810, _470812), once(user:self_eval0([superpose, []])), '$restore_trace'(_470810, _470812))
^  <span class="ansi1 ansi32"
>Call: </span>(281) [system] sig_atomic(system:'$notrace'(_470810, _470812))
^  <span class="ansi1 ansi31"
>Fail: </span>(278) [user] self_eval([superpose, []])
   <span class="ansi1 ansi32"
>Call: </span>(278) [system] atomic(superpose)
   <span class="ansi1 ansi32"
>Exit: </span>(278) [system] atomic(superpose)
^  <span class="ansi1 ansi32"
>Call: </span>(278) [user] is_sl(superpose)
   <span class="ansi1 ansi32"
>Call: </span>(279) [system] number(superpose)
   <span class="ansi1 ansi32"
>Call: </span>(277) [system] [[]]==[]
   <span class="ansi1 ansi32"
>Call: </span>(277) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(277) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(277) [system] (=)\==(=)
   <span class="ansi1 ansi32"
>Call: </span>(277) [system] callable(superpose)
   <span class="ansi1 ansi32"
>Exit: </span>(277) [system] callable(superpose)
   <span class="ansi1 ansi32"
>Call: </span>(277) [system] is_list([[]])
   <span class="ansi1 ansi32"
>Exit: </span>(277) [system] is_list([[]])
   <span class="ansi1 ansi32"
>Call: </span>(277) [system] is_list([superpose, []])
   <span class="ansi1 ansi32"
>Exit: </span>(277) [system] is_list([superpose, []])
   <span class="ansi1 ansi32"
>Call: </span>(277) [system] var(superpose)
^  <span class="ansi1 ansi32"
>Call: </span>(277) [user] once(expand_eval([superpose, []], _487512))
^  <span class="ansi1 ansi32"
>Call: </span>(278) [user] expand_eval([superpose, []], _487512)
   <span class="ansi1 ansi32"
>Call: </span>(279) [system] is_list([superpose, []])
   <span class="ansi1 ansi32"
>Exit: </span>(279) [system] is_list([superpose, []])
   <span class="ansi1 ansi32"
>Call: </span>(279) [system] ground(superpose)
   <span class="ansi1 ansi32"
>Exit: </span>(279) [system] ground(superpose)
^  <span class="ansi1 ansi32"
>Call: </span>(279) [user] apply:maplist(expand_eval, [[]], _493084)
   <span class="ansi1 ansi32"
>Call: </span>(280) [apply] apply:maplist_([[]], _493084, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(281) [user] expand_eval([], _494964)
   <span class="ansi1 ansi32"
>Call: </span>(282) [system] is_list([])
   <span class="ansi1 ansi32"
>Exit: </span>(282) [system] is_list([])
^  <span class="ansi1 ansi32"
>Call: </span>(277) [user] is_progn(superpose)
   <span class="ansi1 ansi32"
>Call: </span>(278) [system] var(superpose)
^  <span class="ansi1 ansi32"
>Call: </span>(277) [user] is_progn(superpose)
   <span class="ansi1 ansi32"
>Call: </span>(278) [system] var(superpose)
^  <span class="ansi1 ansi32"
>Call: </span>(277) [user] is_space_op(superpose)
   <span class="ansi1 ansi32"
>Call: </span>(277) [system] is_list([])
   <span class="ansi1 ansi32"
>Exit: </span>(277) [system] is_list([])
   <span class="ansi1 ansi32"
>Call: </span>(277) [system] []=[_504214, _504220, _504226]
   <span class="ansi1 ansi32"
>Call: </span>(277) [lists] lists:member(_505158, [])
^  <span class="ansi1 ansi31"
>Fail: </span>(276) [user] eval_20(=, _404158, 496, '&self', [superpose, []], _437236)
   <span class="ansi1 ansi32"
>Call: </span>(276) [system] fail
   <span class="ansi1 ansi31"
>Fail: </span>(276) [system] fail
^  <span class="ansi1 ansi32"
>Call: </span>(276) [user] ignore((_438262==1->ignore(\+ \+ (flag(eval_num, _464038, _464038+1), (retval(fail)\=@=retval(fail), nonvar(_437236)->indentq(3, _464038, <--, [e, _437236]);indentq(3, _464038, <--, [e, retval(fail)]))));notrace(ignore(if_t(3<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _464038, _464038+1), (retval(fail)\=@=retval(fail), nonvar(_437236)->indentq(3, _464038, <--, [e, _437236]);indentq(3, _464038, <--, [e, retval(fail)]))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(278) [system] _438262==1
   <span class="ansi1 ansi31"
>Fail: </span>(278) [system] _438262==1
^  <span class="ansi1 ansi32"
>Call: </span>(279) [system] setup_call_cleanup('$notrace'(_511664, _511666), once(user:ignore(if_t(3<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _464038, _464038+1), (retval(fail)\=@=retval(fail), nonvar(_437236)->indentq(3, _464038, <--, [e, _437236]);indentq(3, _464038, <--, [e, retval(fail)])))))))), '$restore_trace'(_511664, _511666))
^  <span class="ansi1 ansi32"
>Call: </span>(280) [system] sig_atomic(system:'$notrace'(_511664, _511666))
^  <span class="ansi1 ansi32"
>Exit: </span>(279) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:ignore(if_t(3<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _464038, _464038+1), (retval(fail)\=@=retval(fail), nonvar(_437236)->indentq(3, _464038, <--, [e, _437236]);indentq(3, _464038, <--, [e, retval(fail)])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(276) [system] ignore(user:(_438262==1->ignore(\+ \+ (flag(eval_num, _464038, _464038+1), (retval(fail)\=@=retval(fail), nonvar(_437236)->indentq(3, _464038, <--, [e, _437236]);indentq(3, _464038, <--, [e, retval(fail)]))));notrace(ignore(if_t(3<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _464038, _464038+1), (retval(fail)\=@=retval(fail), nonvar(_437236)->indentq(3, _464038, <--, [e, _437236]);indentq(3, _464038, <--, [e, retval(fail)]))))))))))
^  <span class="ansi1 ansi31"
>Fail: </span>(274) [system] call_cleanup(user:((call(eval_20(=, _404158), 496, '&self', [superpose, []], _437236)*->nb_setarg(1, retval(fail), _437236);fail, trace, call(eval_20(=, _404158), 496, '&self', [superpose, []], _437236)), ignore(notrace((\+_437236\=_438392, nb_setarg(1, retval(fail), _437236))))), user:ignore((_438262==1->ignore(\+ \+ (flag(eval_num, _464038, _464038+1), (retval(fail)\=@=retval(fail), nonvar(_437236)->indentq(3, _464038, <--, [e, _437236]);indentq(3, _464038, <--, [e, retval(fail)]))));notrace(ignore(if_t(3<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _464038, _464038+1), (retval(fail)\=@=retval(fail), nonvar(_437236)->indentq(3, _464038, <--, [e, _437236]);indentq(3, _464038, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi31"
>Fail: </span>(273) [user] trace_eval(eval_20(=, _404158), e, 496, '&self', [superpose, []], _437236)
^  <span class="ansi1 ansi31"
>Fail: </span>(270) [user] eval_args(=, _404158, 497, '&self', [superpose, []], _404172)
^  <span class="ansi1 ansi32"
>Call: </span>(267) [user] call(eval, [superpose, []], _404172)
   <span class="ansi1 ansi32"
>Call: </span>(268) [user] eval([superpose, []], _404172)
^  <span class="ansi1 ansi32"
>Call: </span>(269) [user] current_self(_520280)
   <span class="ansi1 ansi32"
>Call: </span>(270) [system] nb_current(self_space, _520280)
   <span class="ansi1 ansi32"
>Exit: </span>(270) [system] nb_current(self_space, '&self')
   <span class="ansi1 ansi32"
>Call: </span>(270) [system] '&self'\==[]
   <span class="ansi1 ansi32"
>Exit: </span>(270) [system] '&self'\==[]
^  <span class="ansi1 ansi32"
>Exit: </span>(269) [user] current_self('&self')
   <span class="ansi1 ansi32"
>Call: </span>(269) [user] eval('&self', [superpose, []], _404172)
   <span class="ansi1 ansi32"
>Call: </span>(270) [user] eval_H(500, '&self', [superpose, []], _404172)
^  <span class="ansi1 ansi32"
>Call: </span>(271) [user] catch_metta_return(eval_args(=, _527690, 500, '&self', [superpose, []], _404172), _404172)
^  <span class="ansi1 ansi32"
>Call: </span>(273) [user] eval_args(=, _527690, 500, '&self', [superpose, []], _404172)
   <span class="ansi1 ansi32"
>Call: </span>(274) [system] var([superpose, []])
^  <span class="ansi1 ansi32"
>Call: </span>(275) [system] setup_call_cleanup('$notrace'(_530536, _530538), once(user:self_eval([superpose, []])), '$restore_trace'(_530536, _530538))
^  <span class="ansi1 ansi32"
>Call: </span>(276) [system] sig_atomic(system:'$notrace'(_530536, _530538))
^  <span class="ansi1 ansi32"
>Call: </span>(275) [system] setup_call_cleanup('$notrace'(_532448, _532450), once(user:nonvar(_404172)), '$restore_trace'(_532448, _532450))
^  <span class="ansi1 ansi32"
>Call: </span>(276) [system] sig_atomic(system:'$notrace'(_532448, _532450))
^  <span class="ansi1 ansi32"
>Call: </span>(275) [system] setup_call_cleanup('$notrace'(_534360, _534362), once(user:nonvar(_404172)), '$restore_trace'(_534360, _534362))
^  <span class="ansi1 ansi32"
>Call: </span>(276) [system] sig_atomic(system:'$notrace'(_534360, _534362))
   <span class="ansi1 ansi32"
>Call: </span>(274) [system] [[]]==[]
   <span class="ansi1 ansi32"
>Call: </span>(274) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(274) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(274) [system] (=)\==(=)
^  <span class="ansi1 ansi32"
>Call: </span>(274) [user] self_eval([superpose, []])
^  <span class="ansi1 ansi32"
>Call: </span>(276) [system] setup_call_cleanup('$notrace'(_540900, _540902), once(user:self_eval0([superpose, []])), '$restore_trace'(_540900, _540902))
^  <span class="ansi1 ansi32"
>Call: </span>(277) [system] sig_atomic(system:'$notrace'(_540900, _540902))
^  <span class="ansi1 ansi31"
>Fail: </span>(274) [user] self_eval([superpose, []])
^  <span class="ansi1 ansi32"
>Call: </span>(274) [user] eval_00(=, _527690, 500, '&self', [superpose, []], _404172)
^  <span class="ansi1 ansi32"
>Call: </span>(275) [user] self_eval([superpose, []])
^  <span class="ansi1 ansi32"
>Call: </span>(277) [system] setup_call_cleanup('$notrace'(_545604, _545606), once(user:self_eval0([superpose, []])), '$restore_trace'(_545604, _545606))
^  <span class="ansi1 ansi32"
>Call: </span>(278) [system] sig_atomic(system:'$notrace'(_545604, _545606))
^  <span class="ansi1 ansi31"
>Fail: </span>(275) [user] self_eval([superpose, []])
^  <span class="ansi1 ansi32"
>Call: </span>(275) [user] eval_01(=, _527690, 500, '&self', [superpose, []], _404172)
^  <span class="ansi1 ansi32"
>Call: </span>(276) [user] if_t((500<1, trace_on_overflow), debug(metta(eval_args)))
   <span class="ansi1 ansi32"
>Call: </span>(278) [system] 500<1
   <span class="ansi1 ansi31"
>Fail: </span>(278) [system] 500<1
^  <span class="ansi1 ansi32"
>Exit: </span>(276) [user] if_t((500<1, trace_on_overflow), debug(metta(eval_args)))
^  <span class="ansi1 ansi32"
>Call: </span>(277) [system] setup_call_cleanup('$notrace'(_553136, _553138), once(user:(_553112 is 500-1, copy_term([superpose, []], _553126))), '$restore_trace'(_553136, _553138))
^  <span class="ansi1 ansi32"
>Call: </span>(278) [system] sig_atomic(system:'$notrace'(_553136, _553138))
^  <span class="ansi1 ansi32"
>Exit: </span>(277) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(499 is 500-1, copy_term([superpose, []], [superpose, []]))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(276) [user] trace_eval(eval_20(=, _527690), e, 499, '&self', [superpose, []], _555982)
^  <span class="ansi1 ansi32"
>Call: </span>(277) [user] must_det_ll((notrace((flag(eval_num, _556948, _556948+1), _556966 is _556948 mod 500, _556984 is 99-499 mod 100, _557008=_557010, option_else('trace-length', _557022, 500), option_else('trace-depth', _557030, 30))), quietly(if_t((nop(stop_rtrace), _556966>_557022), (set_debug(eval, false), _557086 is _557022+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_557086])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_557138)))))
^  <span class="ansi1 ansi32"
>Call: </span>(278) [user] once(user:(notrace((flag(eval_num, _556948, _556948+1), _556966 is _556948 mod 500, _556984 is 99-499 mod 100, _557008=_557010, option_else('trace-length', _557022, 500), option_else('trace-depth', _557030, 30))), quietly(if_t((nop(stop_rtrace), _556966>_557022), (set_debug(eval, false), _557086 is _557022+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_557086])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_557138)))))
^  <span class="ansi1 ansi32"
>Call: </span>(281) [system] setup_call_cleanup('$notrace'(_559008, _559010), once(user:(flag(eval_num, _556948, _556948+1), _556966 is _556948 mod 500, _556984 is 99-499 mod 100, _557008=_557010, option_else('trace-length', _557022, 500), option_else('trace-depth', _557030, 30))), '$restore_trace'(_559008, _559010))
^  <span class="ansi1 ansi32"
>Call: </span>(282) [system] sig_atomic(system:'$notrace'(_559008, _559010))
^  <span class="ansi1 ansi32"
>Exit: </span>(281) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(flag(eval_num, 14, 14+1), 14 is 14 mod 500, 0 is 99-499 mod 100, _557008=_557008, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(281) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 14>500), (set_debug(eval, false), _557086 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_557086])), nop((start_rtrace, rtrace)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(281) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 14>500), (set_debug(eval, false), _557086 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_557086])), nop((start_rtrace, rtrace)))))
   <span class="ansi1 ansi32"
>Call: </span>(280) [user] nop(notrace(no_repeats_var(_557138)))
   <span class="ansi1 ansi32"
>Exit: </span>(280) [user] nop(notrace(no_repeats_var(_557138)))
^  <span class="ansi1 ansi32"
>Exit: </span>(278) [system] once(user:(notrace((flag(eval_num, 14, 14+1), 14 is 14 mod 500, 0 is 99-499 mod 100, _557008=_557008, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 14>500), (set_debug(eval, false), _557086 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_557086])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_557138)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(277) [user] must_det_ll(user:(notrace((flag(eval_num, 14, 14+1), 14 is 14 mod 500, 0 is 99-499 mod 100, _557008=_557008, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 14>500), (set_debug(eval, false), _557086 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_557086])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_557138)))))
   <span class="ansi1 ansi32"
>Call: </span>(277) [occurs] occurs:sub_term(_567692, e)
   <span class="ansi1 ansi32"
>Exit: </span>(277) [occurs] occurs:sub_term(e, e)
   <span class="ansi1 ansi32"
>Call: </span>(277) [system] e\=e
   <span class="ansi1 ansi31"
>Fail: </span>(277) [system] e\=e
   <span class="ansi1 ansi32"
>Call: </span>(278) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(278) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(277) [occurs] occurs:sub_term(_567692, e)
   <span class="ansi1 ansi32"
>Call: </span>(277) [system] _574182=e
   <span class="ansi1 ansi32"
>Exit: </span>(277) [system] e=e
^  <span class="ansi1 ansi32"
>Call: </span>(277) [user] if_trace((eval;e), (_557008=1, indentq(0, 14, -->, [e, [superpose, []]])))
^  <span class="ansi1 ansi32"
>Call: </span>(279) [system] setup_call_cleanup('$notrace'(_577058, _577060), once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _557008=1, indentq(0, 14, -->, [e, [superpose, []]]))), _577016, fbug((_577016-->if_trace((eval;e), (_557008=1, indentq(0, 14, -->, [e, [superpose, []]])))))))), '$restore_trace'(_577058, _577060))
^  <span class="ansi1 ansi32"
>Call: </span>(280) [system] sig_atomic(system:'$notrace'(_577058, _577060))
^  <span class="ansi1 ansi32"
>Exit: </span>(279) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _557008=1, indentq(0, 14, -->, [e, [superpose, []]]))), _577016, fbug((_577016-->if_trace((eval;e), (_557008=1, indentq(0, 14, -->, [e, [superpose, []]])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(277) [user] if_trace((eval;e), (_557008=1, indentq(0, 14, -->, [e, [superpose, []]])))
   <span class="ansi1 ansi32"
>Call: </span>(277) [system] _580902=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(277) [system] retval(fail)=retval(fail)
   <span class="ansi1 ansi32"
>Call: </span>(277) [system] _582764=(\+ \+ (flag(eval_num, _582784, _582784+1), (retval(fail)\=@=retval(fail), nonvar(_555982)->indentq(0, _582784, <--, [e, _555982]);indentq(0, _582784, <--, [e, retval(fail)]))))
   <span class="ansi1 ansi32"
>Exit: </span>(277) [system] (\+ \+ (flag(eval_num, _582784, _582784+1), (retval(fail)\=@=retval(fail), nonvar(_555982)->indentq(0, _582784, <--, [e, _555982]);indentq(0, _582784, <--, [e, retval(fail)]))))=(\+ \+ (flag(eval_num, _582784, _582784+1), (retval(fail)\=@=retval(fail), nonvar(_555982)->indentq(0, _582784, <--, [e, _555982]);indentq(0, _582784, <--, [e, retval(fail)]))))
^  <span class="ansi1 ansi32"
>Call: </span>(277) [user] call_cleanup(((call(eval_20(=, _527690), 499, '&self', [superpose, []], _555982)*->nb_setarg(1, retval(fail), _555982);fail, trace, call(eval_20(=, _527690), 499, '&self', [superpose, []], _555982)), ignore(notrace((\+_555982\=_557138, nb_setarg(1, retval(fail), _555982))))), ignore((_557008==1->ignore(\+ \+ (flag(eval_num, _582784, _582784+1), (retval(fail)\=@=retval(fail), nonvar(_555982)->indentq(0, _582784, <--, [e, _555982]);indentq(0, _582784, <--, [e, retval(fail)]))));notrace(ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _582784, _582784+1), (retval(fail)\=@=retval(fail), nonvar(_555982)->indentq(0, _582784, <--, [e, _555982]);indentq(0, _582784, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi32"
>Call: </span>(279) [user] eval_20(=, _527690, 499, '&self', [superpose, []], _555982)
   <span class="ansi1 ansi32"
>Call: </span>(280) [system] atom([superpose, []])
^  <span class="ansi1 ansi32"
>Call: </span>(280) [user] no_eval([superpose, []])
^  <span class="ansi1 ansi32"
>Call: </span>(281) [user] self_eval([superpose, []])
^  <span class="ansi1 ansi32"
>Call: </span>(283) [system] setup_call_cleanup('$notrace'(_589556, _589558), once(user:self_eval0([superpose, []])), '$restore_trace'(_589556, _589558))
^  <span class="ansi1 ansi32"
>Call: </span>(284) [system] sig_atomic(system:'$notrace'(_589556, _589558))
^  <span class="ansi1 ansi31"
>Fail: </span>(281) [user] self_eval([superpose, []])
   <span class="ansi1 ansi32"
>Call: </span>(281) [system] atomic(superpose)
   <span class="ansi1 ansi32"
>Exit: </span>(281) [system] atomic(superpose)
^  <span class="ansi1 ansi32"
>Call: </span>(281) [user] is_sl(superpose)
   <span class="ansi1 ansi32"
>Call: </span>(282) [system] number(superpose)
   <span class="ansi1 ansi32"
>Call: </span>(280) [system] [[]]==[]
   <span class="ansi1 ansi32"
>Call: </span>(280) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(280) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(280) [system] (=)\==(=)
   <span class="ansi1 ansi32"
>Call: </span>(280) [system] callable(superpose)
   <span class="ansi1 ansi32"
>Exit: </span>(280) [system] callable(superpose)
   <span class="ansi1 ansi32"
>Call: </span>(280) [system] is_list([[]])
   <span class="ansi1 ansi32"
>Exit: </span>(280) [system] is_list([[]])
   <span class="ansi1 ansi32"
>Call: </span>(280) [system] is_list([superpose, []])
   <span class="ansi1 ansi32"
>Exit: </span>(280) [system] is_list([superpose, []])
   <span class="ansi1 ansi32"
>Call: </span>(280) [system] var(superpose)
^  <span class="ansi1 ansi32"
>Call: </span>(280) [user] once(expand_eval([superpose, []], _606258))
^  <span class="ansi1 ansi32"
>Call: </span>(281) [user] expand_eval([superpose, []], _606258)
   <span class="ansi1 ansi32"
>Call: </span>(282) [system] is_list([superpose, []])
   <span class="ansi1 ansi32"
>Exit: </span>(282) [system] is_list([superpose, []])
   <span class="ansi1 ansi32"
>Call: </span>(282) [system] ground(superpose)
   <span class="ansi1 ansi32"
>Exit: </span>(282) [system] ground(superpose)
^  <span class="ansi1 ansi32"
>Call: </span>(282) [user] apply:maplist(expand_eval, [[]], _611830)
   <span class="ansi1 ansi32"
>Call: </span>(283) [apply] apply:maplist_([[]], _611830, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(284) [user] expand_eval([], _613710)
   <span class="ansi1 ansi32"
>Call: </span>(285) [system] is_list([])
   <span class="ansi1 ansi32"
>Exit: </span>(285) [system] is_list([])
^  <span class="ansi1 ansi32"
>Call: </span>(280) [user] is_progn(superpose)
   <span class="ansi1 ansi32"
>Call: </span>(281) [system] var(superpose)
^  <span class="ansi1 ansi32"
>Call: </span>(280) [user] is_progn(superpose)
   <span class="ansi1 ansi32"
>Call: </span>(281) [system] var(superpose)
^  <span class="ansi1 ansi32"
>Call: </span>(280) [user] is_space_op(superpose)
   <span class="ansi1 ansi32"
>Call: </span>(280) [system] is_list([])
   <span class="ansi1 ansi32"
>Exit: </span>(280) [system] is_list([])
   <span class="ansi1 ansi32"
>Call: </span>(280) [system] []=[_622960, _622966, _622972]
   <span class="ansi1 ansi32"
>Call: </span>(280) [lists] lists:member(_623904, [])
^  <span class="ansi1 ansi31"
>Fail: </span>(279) [user] eval_20(=, _527690, 499, '&self', [superpose, []], _555982)
   <span class="ansi1 ansi32"
>Call: </span>(279) [system] fail
   <span class="ansi1 ansi31"
>Fail: </span>(279) [system] fail
^  <span class="ansi1 ansi32"
>Call: </span>(279) [user] ignore((_557008==1->ignore(\+ \+ (flag(eval_num, _582784, _582784+1), (retval(fail)\=@=retval(fail), nonvar(_555982)->indentq(0, _582784, <--, [e, _555982]);indentq(0, _582784, <--, [e, retval(fail)]))));notrace(ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _582784, _582784+1), (retval(fail)\=@=retval(fail), nonvar(_555982)->indentq(0, _582784, <--, [e, _555982]);indentq(0, _582784, <--, [e, retval(fail)]))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(281) [system] _557008==1
   <span class="ansi1 ansi31"
>Fail: </span>(281) [system] _557008==1
^  <span class="ansi1 ansi32"
>Call: </span>(282) [system] setup_call_cleanup('$notrace'(_630410, _630412), once(user:ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _582784, _582784+1), (retval(fail)\=@=retval(fail), nonvar(_555982)->indentq(0, _582784, <--, [e, _555982]);indentq(0, _582784, <--, [e, retval(fail)])))))))), '$restore_trace'(_630410, _630412))
^  <span class="ansi1 ansi32"
>Call: </span>(283) [system] sig_atomic(system:'$notrace'(_630410, _630412))
^  <span class="ansi1 ansi32"
>Exit: </span>(282) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _582784, _582784+1), (retval(fail)\=@=retval(fail), nonvar(_555982)->indentq(0, _582784, <--, [e, _555982]);indentq(0, _582784, <--, [e, retval(fail)])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(279) [system] ignore(user:(_557008==1->ignore(\+ \+ (flag(eval_num, _582784, _582784+1), (retval(fail)\=@=retval(fail), nonvar(_555982)->indentq(0, _582784, <--, [e, _555982]);indentq(0, _582784, <--, [e, retval(fail)]))));notrace(ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _582784, _582784+1), (retval(fail)\=@=retval(fail), nonvar(_555982)->indentq(0, _582784, <--, [e, _555982]);indentq(0, _582784, <--, [e, retval(fail)]))))))))))
^  <span class="ansi1 ansi31"
>Fail: </span>(277) [system] call_cleanup(user:((call(eval_20(=, _527690), 499, '&self', [superpose, []], _555982)*->nb_setarg(1, retval(fail), _555982);fail, trace, call(eval_20(=, _527690), 499, '&self', [superpose, []], _555982)), ignore(notrace((\+_555982\=_557138, nb_setarg(1, retval(fail), _555982))))), user:ignore((_557008==1->ignore(\+ \+ (flag(eval_num, _582784, _582784+1), (retval(fail)\=@=retval(fail), nonvar(_555982)->indentq(0, _582784, <--, [e, _555982]);indentq(0, _582784, <--, [e, retval(fail)]))));notrace(ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _582784, _582784+1), (retval(fail)\=@=retval(fail), nonvar(_555982)->indentq(0, _582784, <--, [e, _555982]);indentq(0, _582784, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi31"
>Fail: </span>(276) [user] trace_eval(eval_20(=, _527690), e, 499, '&self', [superpose, []], _555982)
^  <span class="ansi1 ansi31"
>Fail: </span>(273) [user] eval_args(=, _527690, 500, '&self', [superpose, []], _404172)
^  <span class="ansi1 ansi31"
>Fail: </span>(264) [system] call(user:once, user:if_or_else(eval(=, _404158, 497, '&self', [superpose, []], _404172), call(eval, [superpose, []], _404172)))
^  <span class="ansi1 ansi32"
>Call: </span>(264) [bugger] bugger:mquietly_if(true, rtrace:pop_tracer)
   <span class="ansi1 ansi32"
>Call: </span>(266) [system] var(rtrace:pop_tracer)
   <span class="ansi1 ansi31"
>Fail: </span>(266) [system] var(rtrace:pop_tracer)
^  <span class="ansi1 ansi32"
>Call: </span>(268) [system] setup_call_cleanup('$notrace'(_640904, _640906), once(rtrace:retract(t_l:tracer_reset(_640894))), '$restore_trace'(_640904, _640906))
^  <span class="ansi1 ansi32"
>Call: </span>(269) [system] sig_atomic(system:'$notrace'(_640904, _640906))
^  <span class="ansi1 ansi32"
>Exit: </span>(268) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(rtrace:retract(t_l:tracer_reset(tAt_normal))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(268) [rtrace] tAt(false, 271, 271, false)


  (failed  once 
    (if_or_else  
      (eval  = $_650048 497 &self 
        (superpose ()) $_650062) 
      (call  eval 
        (superpose ()) $_650062)))




  (failed  once 
    (if_or_else  
      (eval  = $_650048 497 &self 
        (superpose ()) $_650062) 
      (call  eval 
        (superpose ()) $_650062)))


^  <span class="ansi1 ansi32"
>Call: </span>(264) [user] call(user:once, user:if_or_else(eval(=, _650048, 497, '&self', [superpose, []], _650062), call(eval, [superpose, []], _650062)))
^  <span class="ansi1 ansi32"
>Call: </span>(265) [user] once(user:if_or_else(eval(=, _650048, 497, '&self', [superpose, []], _650062), call(eval, [superpose, []], _650062)))
   <span class="ansi1 ansi32"
>Call: </span>(266) [user] if_or_else(eval(=, _650048, 497, '&self', [superpose, []], _650062), call(eval, [superpose, []], _650062))
^  <span class="ansi1 ansi32"
>Call: </span>(267) [user] eval(=, _650048, 497, '&self', [superpose, []], _650062)
^  <span class="ansi1 ansi32"
>Call: </span>(268) [user] catch_metta_return(eval_args(=, _650048, 497, '&self', [superpose, []], _650062), _650062)
^  <span class="ansi1 ansi32"
>Call: </span>(270) [user] eval_args(=, _650048, 497, '&self', [superpose, []], _650062)
   <span class="ansi1 ansi32"
>Call: </span>(271) [system] var([superpose, []])
^  <span class="ansi1 ansi32"
>Call: </span>(272) [system] setup_call_cleanup('$notrace'(_657680, _657682), once(user:self_eval([superpose, []])), '$restore_trace'(_657680, _657682))
^  <span class="ansi1 ansi32"
>Call: </span>(273) [system] sig_atomic(system:'$notrace'(_657680, _657682))
^  <span class="ansi1 ansi32"
>Call: </span>(272) [system] setup_call_cleanup('$notrace'(_659592, _659594), once(user:nonvar(_650062)), '$restore_trace'(_659592, _659594))
^  <span class="ansi1 ansi32"
>Call: </span>(273) [system] sig_atomic(system:'$notrace'(_659592, _659594))
^  <span class="ansi1 ansi32"
>Call: </span>(272) [system] setup_call_cleanup('$notrace'(_661504, _661506), once(user:nonvar(_650062)), '$restore_trace'(_661504, _661506))
^  <span class="ansi1 ansi32"
>Call: </span>(273) [system] sig_atomic(system:'$notrace'(_661504, _661506))
   <span class="ansi1 ansi32"
>Call: </span>(271) [system] [[]]==[]
   <span class="ansi1 ansi32"
>Call: </span>(271) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(271) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(271) [system] (=)\==(=)
^  <span class="ansi1 ansi32"
>Call: </span>(271) [user] self_eval([superpose, []])
^  <span class="ansi1 ansi32"
>Call: </span>(273) [system] setup_call_cleanup('$notrace'(_668044, _668046), once(user:self_eval0([superpose, []])), '$restore_trace'(_668044, _668046))
^  <span class="ansi1 ansi32"
>Call: </span>(274) [system] sig_atomic(system:'$notrace'(_668044, _668046))
^  <span class="ansi1 ansi31"
>Fail: </span>(271) [user] self_eval([superpose, []])
^  <span class="ansi1 ansi32"
>Call: </span>(271) [user] eval_00(=, _650048, 497, '&self', [superpose, []], _650062)
^  <span class="ansi1 ansi32"
>Call: </span>(272) [user] self_eval([superpose, []])
^  <span class="ansi1 ansi32"
>Call: </span>(274) [system] setup_call_cleanup('$notrace'(_672748, _672750), once(user:self_eval0([superpose, []])), '$restore_trace'(_672748, _672750))
^  <span class="ansi1 ansi32"
>Call: </span>(275) [system] sig_atomic(system:'$notrace'(_672748, _672750))
^  <span class="ansi1 ansi31"
>Fail: </span>(272) [user] self_eval([superpose, []])
^  <span class="ansi1 ansi32"
>Call: </span>(272) [user] eval_01(=, _650048, 497, '&self', [superpose, []], _650062)
^  <span class="ansi1 ansi32"
>Call: </span>(273) [user] if_t((497<1, trace_on_overflow), debug(metta(eval_args)))
   <span class="ansi1 ansi32"
>Call: </span>(275) [system] 497<1
   <span class="ansi1 ansi31"
>Fail: </span>(275) [system] 497<1
^  <span class="ansi1 ansi32"
>Exit: </span>(273) [user] if_t((497<1, trace_on_overflow), debug(metta(eval_args)))
^  <span class="ansi1 ansi32"
>Call: </span>(274) [system] setup_call_cleanup('$notrace'(_680280, _680282), once(user:(_680256 is 497-1, copy_term([superpose, []], _680270))), '$restore_trace'(_680280, _680282))
^  <span class="ansi1 ansi32"
>Call: </span>(275) [system] sig_atomic(system:'$notrace'(_680280, _680282))
^  <span class="ansi1 ansi32"
>Exit: </span>(274) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(496 is 497-1, copy_term([superpose, []], [superpose, []]))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(273) [user] trace_eval(eval_20(=, _650048), e, 496, '&self', [superpose, []], _683126)
^  <span class="ansi1 ansi32"
>Call: </span>(274) [user] must_det_ll((notrace((flag(eval_num, _684092, _684092+1), _684110 is _684092 mod 500, _684128 is 99-496 mod 100, _684152=_684154, option_else('trace-length', _684166, 500), option_else('trace-depth', _684174, 30))), quietly(if_t((nop(stop_rtrace), _684110>_684166), (set_debug(eval, false), _684230 is _684166+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_684230])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_684282)))))
^  <span class="ansi1 ansi32"
>Call: </span>(275) [user] once(user:(notrace((flag(eval_num, _684092, _684092+1), _684110 is _684092 mod 500, _684128 is 99-496 mod 100, _684152=_684154, option_else('trace-length', _684166, 500), option_else('trace-depth', _684174, 30))), quietly(if_t((nop(stop_rtrace), _684110>_684166), (set_debug(eval, false), _684230 is _684166+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_684230])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_684282)))))
^  <span class="ansi1 ansi32"
>Call: </span>(278) [system] setup_call_cleanup('$notrace'(_686152, _686154), once(user:(flag(eval_num, _684092, _684092+1), _684110 is _684092 mod 500, _684128 is 99-496 mod 100, _684152=_684154, option_else('trace-length', _684166, 500), option_else('trace-depth', _684174, 30))), '$restore_trace'(_686152, _686154))
^  <span class="ansi1 ansi32"
>Call: </span>(279) [system] sig_atomic(system:'$notrace'(_686152, _686154))
^  <span class="ansi1 ansi32"
>Exit: </span>(278) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(flag(eval_num, 23, 23+1), 23 is 23 mod 500, 3 is 99-496 mod 100, _684152=_684152, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(278) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 23>500), (set_debug(eval, false), _684230 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_684230])), nop((start_rtrace, rtrace)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(278) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 23>500), (set_debug(eval, false), _684230 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_684230])), nop((start_rtrace, rtrace)))))
   <span class="ansi1 ansi32"
>Call: </span>(277) [user] nop(notrace(no_repeats_var(_684282)))
   <span class="ansi1 ansi32"
>Exit: </span>(277) [user] nop(notrace(no_repeats_var(_684282)))
^  <span class="ansi1 ansi32"
>Exit: </span>(275) [system] once(user:(notrace((flag(eval_num, 23, 23+1), 23 is 23 mod 500, 3 is 99-496 mod 100, _684152=_684152, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 23>500), (set_debug(eval, false), _684230 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_684230])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_684282)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(274) [user] must_det_ll(user:(notrace((flag(eval_num, 23, 23+1), 23 is 23 mod 500, 3 is 99-496 mod 100, _684152=_684152, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 23>500), (set_debug(eval, false), _684230 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_684230])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_684282)))))
   <span class="ansi1 ansi32"
>Call: </span>(274) [occurs] occurs:sub_term(_694836, e)
   <span class="ansi1 ansi32"
>Exit: </span>(274) [occurs] occurs:sub_term(e, e)
   <span class="ansi1 ansi32"
>Call: </span>(274) [system] e\=e
   <span class="ansi1 ansi31"
>Fail: </span>(274) [system] e\=e
   <span class="ansi1 ansi32"
>Call: </span>(275) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(275) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(274) [occurs] occurs:sub_term(_694836, e)
   <span class="ansi1 ansi32"
>Call: </span>(274) [system] _701326=e
   <span class="ansi1 ansi32"
>Exit: </span>(274) [system] e=e
^  <span class="ansi1 ansi32"
>Call: </span>(274) [user] if_trace((eval;e), (_684152=1, indentq(3, 23, -->, [e, [superpose, []]])))
^  <span class="ansi1 ansi32"
>Call: </span>(276) [system] setup_call_cleanup('$notrace'(_704202, _704204), once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _684152=1, indentq(3, 23, -->, [e, [superpose, []]]))), _704160, fbug((_704160-->if_trace((eval;e), (_684152=1, indentq(3, 23, -->, [e, [superpose, []]])))))))), '$restore_trace'(_704202, _704204))
^  <span class="ansi1 ansi32"
>Call: </span>(277) [system] sig_atomic(system:'$notrace'(_704202, _704204))
^  <span class="ansi1 ansi32"
>Exit: </span>(276) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _684152=1, indentq(3, 23, -->, [e, [superpose, []]]))), _704160, fbug((_704160-->if_trace((eval;e), (_684152=1, indentq(3, 23, -->, [e, [superpose, []]])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(274) [user] if_trace((eval;e), (_684152=1, indentq(3, 23, -->, [e, [superpose, []]])))
   <span class="ansi1 ansi32"
>Call: </span>(274) [system] _708046=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(274) [system] retval(fail)=retval(fail)
   <span class="ansi1 ansi32"
>Call: </span>(274) [system] _709908=(\+ \+ (flag(eval_num, _709928, _709928+1), (retval(fail)\=@=retval(fail), nonvar(_683126)->indentq(3, _709928, <--, [e, _683126]);indentq(3, _709928, <--, [e, retval(fail)]))))
   <span class="ansi1 ansi32"
>Exit: </span>(274) [system] (\+ \+ (flag(eval_num, _709928, _709928+1), (retval(fail)\=@=retval(fail), nonvar(_683126)->indentq(3, _709928, <--, [e, _683126]);indentq(3, _709928, <--, [e, retval(fail)]))))=(\+ \+ (flag(eval_num, _709928, _709928+1), (retval(fail)\=@=retval(fail), nonvar(_683126)->indentq(3, _709928, <--, [e, _683126]);indentq(3, _709928, <--, [e, retval(fail)]))))
^  <span class="ansi1 ansi32"
>Call: </span>(274) [user] call_cleanup(((call(eval_20(=, _650048), 496, '&self', [superpose, []], _683126)*->nb_setarg(1, retval(fail), _683126);fail, trace, call(eval_20(=, _650048), 496, '&self', [superpose, []], _683126)), ignore(notrace((\+_683126\=_684282, nb_setarg(1, retval(fail), _683126))))), ignore((_684152==1->ignore(\+ \+ (flag(eval_num, _709928, _709928+1), (retval(fail)\=@=retval(fail), nonvar(_683126)->indentq(3, _709928, <--, [e, _683126]);indentq(3, _709928, <--, [e, retval(fail)]))));notrace(ignore(if_t(3<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _709928, _709928+1), (retval(fail)\=@=retval(fail), nonvar(_683126)->indentq(3, _709928, <--, [e, _683126]);indentq(3, _709928, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi32"
>Call: </span>(276) [user] eval_20(=, _650048, 496, '&self', [superpose, []], _683126)
   <span class="ansi1 ansi32"
>Call: </span>(277) [system] atom([superpose, []])
^  <span class="ansi1 ansi32"
>Call: </span>(277) [user] no_eval([superpose, []])
^  <span class="ansi1 ansi32"
>Call: </span>(278) [user] self_eval([superpose, []])
^  <span class="ansi1 ansi32"
>Call: </span>(280) [system] setup_call_cleanup('$notrace'(_716700, _716702), once(user:self_eval0([superpose, []])), '$restore_trace'(_716700, _716702))
^  <span class="ansi1 ansi32"
>Call: </span>(281) [system] sig_atomic(system:'$notrace'(_716700, _716702))
^  <span class="ansi1 ansi31"
>Fail: </span>(278) [user] self_eval([superpose, []])
   <span class="ansi1 ansi32"
>Call: </span>(278) [system] atomic(superpose)
   <span class="ansi1 ansi32"
>Exit: </span>(278) [system] atomic(superpose)
^  <span class="ansi1 ansi32"
>Call: </span>(278) [user] is_sl(superpose)
   <span class="ansi1 ansi32"
>Call: </span>(279) [system] number(superpose)
   <span class="ansi1 ansi32"
>Call: </span>(277) [system] [[]]==[]
   <span class="ansi1 ansi32"
>Call: </span>(277) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(277) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(277) [system] (=)\==(=)
   <span class="ansi1 ansi32"
>Call: </span>(277) [system] callable(superpose)
   <span class="ansi1 ansi32"
>Exit: </span>(277) [system] callable(superpose)
   <span class="ansi1 ansi32"
>Call: </span>(277) [system] is_list([[]])
   <span class="ansi1 ansi32"
>Exit: </span>(277) [system] is_list([[]])
   <span class="ansi1 ansi32"
>Call: </span>(277) [system] is_list([superpose, []])
   <span class="ansi1 ansi32"
>Exit: </span>(277) [system] is_list([superpose, []])
   <span class="ansi1 ansi32"
>Call: </span>(277) [system] var(superpose)
^  <span class="ansi1 ansi32"
>Call: </span>(277) [user] once(expand_eval([superpose, []], _733402))
^  <span class="ansi1 ansi32"
>Call: </span>(278) [user] expand_eval([superpose, []], _733402)
   <span class="ansi1 ansi32"
>Call: </span>(279) [system] is_list([superpose, []])
   <span class="ansi1 ansi32"
>Exit: </span>(279) [system] is_list([superpose, []])
   <span class="ansi1 ansi32"
>Call: </span>(279) [system] ground(superpose)
   <span class="ansi1 ansi32"
>Exit: </span>(279) [system] ground(superpose)
^  <span class="ansi1 ansi32"
>Call: </span>(279) [user] apply:maplist(expand_eval, [[]], _738974)
   <span class="ansi1 ansi32"
>Call: </span>(280) [apply] apply:maplist_([[]], _738974, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(281) [user] expand_eval([], _740854)
   <span class="ansi1 ansi32"
>Call: </span>(282) [system] is_list([])
   <span class="ansi1 ansi32"
>Exit: </span>(282) [system] is_list([])
^  <span class="ansi1 ansi32"
>Call: </span>(277) [user] is_progn(superpose)
   <span class="ansi1 ansi32"
>Call: </span>(278) [system] var(superpose)
^  <span class="ansi1 ansi32"
>Call: </span>(277) [user] is_progn(superpose)
   <span class="ansi1 ansi32"
>Call: </span>(278) [system] var(superpose)
^  <span class="ansi1 ansi32"
>Call: </span>(277) [user] is_space_op(superpose)
   <span class="ansi1 ansi32"
>Call: </span>(277) [system] is_list([])
   <span class="ansi1 ansi32"
>Exit: </span>(277) [system] is_list([])
   <span class="ansi1 ansi32"
>Call: </span>(277) [system] []=[_750104, _750110, _750116]
   <span class="ansi1 ansi32"
>Call: </span>(277) [lists] lists:member(_751048, [])
^  <span class="ansi1 ansi31"
>Fail: </span>(276) [user] eval_20(=, _650048, 496, '&self', [superpose, []], _683126)
   <span class="ansi1 ansi32"
>Call: </span>(276) [system] fail
   <span class="ansi1 ansi31"
>Fail: </span>(276) [system] fail
^  <span class="ansi1 ansi32"
>Call: </span>(276) [user] ignore((_684152==1->ignore(\+ \+ (flag(eval_num, _709928, _709928+1), (retval(fail)\=@=retval(fail), nonvar(_683126)->indentq(3, _709928, <--, [e, _683126]);indentq(3, _709928, <--, [e, retval(fail)]))));notrace(ignore(if_t(3<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _709928, _709928+1), (retval(fail)\=@=retval(fail), nonvar(_683126)->indentq(3, _709928, <--, [e, _683126]);indentq(3, _709928, <--, [e, retval(fail)]))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(278) [system] _684152==1
   <span class="ansi1 ansi31"
>Fail: </span>(278) [system] _684152==1
^  <span class="ansi1 ansi32"
>Call: </span>(279) [system] setup_call_cleanup('$notrace'(_757554, _757556), once(user:ignore(if_t(3<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _709928, _709928+1), (retval(fail)\=@=retval(fail), nonvar(_683126)->indentq(3, _709928, <--, [e, _683126]);indentq(3, _709928, <--, [e, retval(fail)])))))))), '$restore_trace'(_757554, _757556))
^  <span class="ansi1 ansi32"
>Call: </span>(280) [system] sig_atomic(system:'$notrace'(_757554, _757556))
^  <span class="ansi1 ansi32"
>Exit: </span>(279) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:ignore(if_t(3<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _709928, _709928+1), (retval(fail)\=@=retval(fail), nonvar(_683126)->indentq(3, _709928, <--, [e, _683126]);indentq(3, _709928, <--, [e, retval(fail)])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(276) [system] ignore(user:(_684152==1->ignore(\+ \+ (flag(eval_num, _709928, _709928+1), (retval(fail)\=@=retval(fail), nonvar(_683126)->indentq(3, _709928, <--, [e, _683126]);indentq(3, _709928, <--, [e, retval(fail)]))));notrace(ignore(if_t(3<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _709928, _709928+1), (retval(fail)\=@=retval(fail), nonvar(_683126)->indentq(3, _709928, <--, [e, _683126]);indentq(3, _709928, <--, [e, retval(fail)]))))))))))
^  <span class="ansi1 ansi31"
>Fail: </span>(274) [system] call_cleanup(user:((call(eval_20(=, _650048), 496, '&self', [superpose, []], _683126)*->nb_setarg(1, retval(fail), _683126);fail, trace, call(eval_20(=, _650048), 496, '&self', [superpose, []], _683126)), ignore(notrace((\+_683126\=_684282, nb_setarg(1, retval(fail), _683126))))), user:ignore((_684152==1->ignore(\+ \+ (flag(eval_num, _709928, _709928+1), (retval(fail)\=@=retval(fail), nonvar(_683126)->indentq(3, _709928, <--, [e, _683126]);indentq(3, _709928, <--, [e, retval(fail)]))));notrace(ignore(if_t(3<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _709928, _709928+1), (retval(fail)\=@=retval(fail), nonvar(_683126)->indentq(3, _709928, <--, [e, _683126]);indentq(3, _709928, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi31"
>Fail: </span>(273) [user] trace_eval(eval_20(=, _650048), e, 496, '&self', [superpose, []], _683126)
^  <span class="ansi1 ansi31"
>Fail: </span>(270) [user] eval_args(=, _650048, 497, '&self', [superpose, []], _650062)
^  <span class="ansi1 ansi32"
>Call: </span>(267) [user] call(eval, [superpose, []], _650062)
   <span class="ansi1 ansi32"
>Call: </span>(268) [user] eval([superpose, []], _650062)
^  <span class="ansi1 ansi32"
>Call: </span>(269) [user] current_self(_766170)
   <span class="ansi1 ansi32"
>Call: </span>(270) [system] nb_current(self_space, _766170)
   <span class="ansi1 ansi32"
>Exit: </span>(270) [system] nb_current(self_space, '&self')
   <span class="ansi1 ansi32"
>Call: </span>(270) [system] '&self'\==[]
   <span class="ansi1 ansi32"
>Exit: </span>(270) [system] '&self'\==[]
^  <span class="ansi1 ansi32"
>Exit: </span>(269) [user] current_self('&self')
   <span class="ansi1 ansi32"
>Call: </span>(269) [user] eval('&self', [superpose, []], _650062)
   <span class="ansi1 ansi32"
>Call: </span>(270) [user] eval_H(500, '&self', [superpose, []], _650062)
^  <span class="ansi1 ansi32"
>Call: </span>(271) [user] catch_metta_return(eval_args(=, _773580, 500, '&self', [superpose, []], _650062), _650062)
^  <span class="ansi1 ansi32"
>Call: </span>(273) [user] eval_args(=, _773580, 500, '&self', [superpose, []], _650062)
   <span class="ansi1 ansi32"
>Call: </span>(274) [system] var([superpose, []])
^  <span class="ansi1 ansi32"
>Call: </span>(275) [system] setup_call_cleanup('$notrace'(_776426, _776428), once(user:self_eval([superpose, []])), '$restore_trace'(_776426, _776428))
^  <span class="ansi1 ansi32"
>Call: </span>(276) [system] sig_atomic(system:'$notrace'(_776426, _776428))
^  <span class="ansi1 ansi32"
>Call: </span>(275) [system] setup_call_cleanup('$notrace'(_778338, _778340), once(user:nonvar(_650062)), '$restore_trace'(_778338, _778340))
^  <span class="ansi1 ansi32"
>Call: </span>(276) [system] sig_atomic(system:'$notrace'(_778338, _778340))
^  <span class="ansi1 ansi32"
>Call: </span>(275) [system] setup_call_cleanup('$notrace'(_780250, _780252), once(user:nonvar(_650062)), '$restore_trace'(_780250, _780252))
^  <span class="ansi1 ansi32"
>Call: </span>(276) [system] sig_atomic(system:'$notrace'(_780250, _780252))
   <span class="ansi1 ansi32"
>Call: </span>(274) [system] [[]]==[]
   <span class="ansi1 ansi32"
>Call: </span>(274) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(274) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(274) [system] (=)\==(=)
^  <span class="ansi1 ansi32"
>Call: </span>(274) [user] self_eval([superpose, []])
^  <span class="ansi1 ansi32"
>Call: </span>(276) [system] setup_call_cleanup('$notrace'(_786790, _786792), once(user:self_eval0([superpose, []])), '$restore_trace'(_786790, _786792))
^  <span class="ansi1 ansi32"
>Call: </span>(277) [system] sig_atomic(system:'$notrace'(_786790, _786792))
^  <span class="ansi1 ansi31"
>Fail: </span>(274) [user] self_eval([superpose, []])
^  <span class="ansi1 ansi32"
>Call: </span>(274) [user] eval_00(=, _773580, 500, '&self', [superpose, []], _650062)
^  <span class="ansi1 ansi32"
>Call: </span>(275) [user] self_eval([superpose, []])
^  <span class="ansi1 ansi32"
>Call: </span>(277) [system] setup_call_cleanup('$notrace'(_791494, _791496), once(user:self_eval0([superpose, []])), '$restore_trace'(_791494, _791496))
^  <span class="ansi1 ansi32"
>Call: </span>(278) [system] sig_atomic(system:'$notrace'(_791494, _791496))
^  <span class="ansi1 ansi31"
>Fail: </span>(275) [user] self_eval([superpose, []])
^  <span class="ansi1 ansi32"
>Call: </span>(275) [user] eval_01(=, _773580, 500, '&self', [superpose, []], _650062)
^  <span class="ansi1 ansi32"
>Call: </span>(276) [user] if_t((500<1, trace_on_overflow), debug(metta(eval_args)))
   <span class="ansi1 ansi32"
>Call: </span>(278) [system] 500<1
   <span class="ansi1 ansi31"
>Fail: </span>(278) [system] 500<1
^  <span class="ansi1 ansi32"
>Exit: </span>(276) [user] if_t((500<1, trace_on_overflow), debug(metta(eval_args)))
^  <span class="ansi1 ansi32"
>Call: </span>(277) [system] setup_call_cleanup('$notrace'(_799026, _799028), once(user:(_799002 is 500-1, copy_term([superpose, []], _799016))), '$restore_trace'(_799026, _799028))
^  <span class="ansi1 ansi32"
>Call: </span>(278) [system] sig_atomic(system:'$notrace'(_799026, _799028))
^  <span class="ansi1 ansi32"
>Exit: </span>(277) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(499 is 500-1, copy_term([superpose, []], [superpose, []]))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(276) [user] trace_eval(eval_20(=, _773580), e, 499, '&self', [superpose, []], _801872)
^  <span class="ansi1 ansi32"
>Call: </span>(277) [user] must_det_ll((notrace((flag(eval_num, _802838, _802838+1), _802856 is _802838 mod 500, _802874 is 99-499 mod 100, _802898=_802900, option_else('trace-length', _802912, 500), option_else('trace-depth', _802920, 30))), quietly(if_t((nop(stop_rtrace), _802856>_802912), (set_debug(eval, false), _802976 is _802912+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_802976])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_803028)))))
^  <span class="ansi1 ansi32"
>Call: </span>(278) [user] once(user:(notrace((flag(eval_num, _802838, _802838+1), _802856 is _802838 mod 500, _802874 is 99-499 mod 100, _802898=_802900, option_else('trace-length', _802912, 500), option_else('trace-depth', _802920, 30))), quietly(if_t((nop(stop_rtrace), _802856>_802912), (set_debug(eval, false), _802976 is _802912+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_802976])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_803028)))))
^  <span class="ansi1 ansi32"
>Call: </span>(281) [system] setup_call_cleanup('$notrace'(_804898, _804900), once(user:(flag(eval_num, _802838, _802838+1), _802856 is _802838 mod 500, _802874 is 99-499 mod 100, _802898=_802900, option_else('trace-length', _802912, 500), option_else('trace-depth', _802920, 30))), '$restore_trace'(_804898, _804900))
^  <span class="ansi1 ansi32"
>Call: </span>(282) [system] sig_atomic(system:'$notrace'(_804898, _804900))
^  <span class="ansi1 ansi32"
>Exit: </span>(281) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(flag(eval_num, 24, 24+1), 24 is 24 mod 500, 0 is 99-499 mod 100, _802898=_802898, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(281) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 24>500), (set_debug(eval, false), _802976 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_802976])), nop((start_rtrace, rtrace)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(281) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 24>500), (set_debug(eval, false), _802976 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_802976])), nop((start_rtrace, rtrace)))))
   <span class="ansi1 ansi32"
>Call: </span>(280) [user] nop(notrace(no_repeats_var(_803028)))
   <span class="ansi1 ansi32"
>Exit: </span>(280) [user] nop(notrace(no_repeats_var(_803028)))
^  <span class="ansi1 ansi32"
>Exit: </span>(278) [system] once(user:(notrace((flag(eval_num, 24, 24+1), 24 is 24 mod 500, 0 is 99-499 mod 100, _802898=_802898, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 24>500), (set_debug(eval, false), _802976 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_802976])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_803028)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(277) [user] must_det_ll(user:(notrace((flag(eval_num, 24, 24+1), 24 is 24 mod 500, 0 is 99-499 mod 100, _802898=_802898, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 24>500), (set_debug(eval, false), _802976 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_802976])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_803028)))))
   <span class="ansi1 ansi32"
>Call: </span>(277) [occurs] occurs:sub_term(_813582, e)
   <span class="ansi1 ansi32"
>Exit: </span>(277) [occurs] occurs:sub_term(e, e)
   <span class="ansi1 ansi32"
>Call: </span>(277) [system] e\=e
   <span class="ansi1 ansi31"
>Fail: </span>(277) [system] e\=e
   <span class="ansi1 ansi32"
>Call: </span>(278) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(278) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(277) [occurs] occurs:sub_term(_813582, e)
   <span class="ansi1 ansi32"
>Call: </span>(277) [system] _820072=e
   <span class="ansi1 ansi32"
>Exit: </span>(277) [system] e=e
^  <span class="ansi1 ansi32"
>Call: </span>(277) [user] if_trace((eval;e), (_802898=1, indentq(0, 24, -->, [e, [superpose, []]])))
^  <span class="ansi1 ansi32"
>Call: </span>(279) [system] setup_call_cleanup('$notrace'(_822948, _822950), once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _802898=1, indentq(0, 24, -->, [e, [superpose, []]]))), _822906, fbug((_822906-->if_trace((eval;e), (_802898=1, indentq(0, 24, -->, [e, [superpose, []]])))))))), '$restore_trace'(_822948, _822950))
^  <span class="ansi1 ansi32"
>Call: </span>(280) [system] sig_atomic(system:'$notrace'(_822948, _822950))
^  <span class="ansi1 ansi32"
>Exit: </span>(279) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _802898=1, indentq(0, 24, -->, [e, [superpose, []]]))), _822906, fbug((_822906-->if_trace((eval;e), (_802898=1, indentq(0, 24, -->, [e, [superpose, []]])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(277) [user] if_trace((eval;e), (_802898=1, indentq(0, 24, -->, [e, [superpose, []]])))
   <span class="ansi1 ansi32"
>Call: </span>(277) [system] _826792=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(277) [system] retval(fail)=retval(fail)
   <span class="ansi1 ansi32"
>Call: </span>(277) [system] _828654=(\+ \+ (flag(eval_num, _828674, _828674+1), (retval(fail)\=@=retval(fail), nonvar(_801872)->indentq(0, _828674, <--, [e, _801872]);indentq(0, _828674, <--, [e, retval(fail)]))))
   <span class="ansi1 ansi32"
>Exit: </span>(277) [system] (\+ \+ (flag(eval_num, _828674, _828674+1), (retval(fail)\=@=retval(fail), nonvar(_801872)->indentq(0, _828674, <--, [e, _801872]);indentq(0, _828674, <--, [e, retval(fail)]))))=(\+ \+ (flag(eval_num, _828674, _828674+1), (retval(fail)\=@=retval(fail), nonvar(_801872)->indentq(0, _828674, <--, [e, _801872]);indentq(0, _828674, <--, [e, retval(fail)]))))
^  <span class="ansi1 ansi32"
>Call: </span>(277) [user] call_cleanup(((call(eval_20(=, _773580), 499, '&self', [superpose, []], _801872)*->nb_setarg(1, retval(fail), _801872);fail, trace, call(eval_20(=, _773580), 499, '&self', [superpose, []], _801872)), ignore(notrace((\+_801872\=_803028, nb_setarg(1, retval(fail), _801872))))), ignore((_802898==1->ignore(\+ \+ (flag(eval_num, _828674, _828674+1), (retval(fail)\=@=retval(fail), nonvar(_801872)->indentq(0, _828674, <--, [e, _801872]);indentq(0, _828674, <--, [e, retval(fail)]))));notrace(ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _828674, _828674+1), (retval(fail)\=@=retval(fail), nonvar(_801872)->indentq(0, _828674, <--, [e, _801872]);indentq(0, _828674, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi32"
>Call: </span>(279) [user] eval_20(=, _773580, 499, '&self', [superpose, []], _801872)
   <span class="ansi1 ansi32"
>Call: </span>(280) [system] atom([superpose, []])
^  <span class="ansi1 ansi32"
>Call: </span>(280) [user] no_eval([superpose, []])
^  <span class="ansi1 ansi32"
>Call: </span>(281) [user] self_eval([superpose, []])
^  <span class="ansi1 ansi32"
>Call: </span>(283) [system] setup_call_cleanup('$notrace'(_835446, _835448), once(user:self_eval0([superpose, []])), '$restore_trace'(_835446, _835448))
^  <span class="ansi1 ansi32"
>Call: </span>(284) [system] sig_atomic(system:'$notrace'(_835446, _835448))
^  <span class="ansi1 ansi31"
>Fail: </span>(281) [user] self_eval([superpose, []])
   <span class="ansi1 ansi32"
>Call: </span>(281) [system] atomic(superpose)
   <span class="ansi1 ansi32"
>Exit: </span>(281) [system] atomic(superpose)
^  <span class="ansi1 ansi32"
>Call: </span>(281) [user] is_sl(superpose)
   <span class="ansi1 ansi32"
>Call: </span>(282) [system] number(superpose)
   <span class="ansi1 ansi32"
>Call: </span>(280) [system] [[]]==[]
   <span class="ansi1 ansi32"
>Call: </span>(280) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(280) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(280) [system] (=)\==(=)
   <span class="ansi1 ansi32"
>Call: </span>(280) [system] callable(superpose)
   <span class="ansi1 ansi32"
>Exit: </span>(280) [system] callable(superpose)
   <span class="ansi1 ansi32"
>Call: </span>(280) [system] is_list([[]])
   <span class="ansi1 ansi32"
>Exit: </span>(280) [system] is_list([[]])
   <span class="ansi1 ansi32"
>Call: </span>(280) [system] is_list([superpose, []])
   <span class="ansi1 ansi32"
>Exit: </span>(280) [system] is_list([superpose, []])
   <span class="ansi1 ansi32"
>Call: </span>(280) [system] var(superpose)
^  <span class="ansi1 ansi32"
>Call: </span>(280) [user] once(expand_eval([superpose, []], _852148))
^  <span class="ansi1 ansi32"
>Call: </span>(281) [user] expand_eval([superpose, []], _852148)
   <span class="ansi1 ansi32"
>Call: </span>(282) [system] is_list([superpose, []])
   <span class="ansi1 ansi32"
>Exit: </span>(282) [system] is_list([superpose, []])
   <span class="ansi1 ansi32"
>Call: </span>(282) [system] ground(superpose)
   <span class="ansi1 ansi32"
>Exit: </span>(282) [system] ground(superpose)
^  <span class="ansi1 ansi32"
>Call: </span>(282) [user] apply:maplist(expand_eval, [[]], _857720)
   <span class="ansi1 ansi32"
>Call: </span>(283) [apply] apply:maplist_([[]], _857720, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(284) [user] expand_eval([], _859600)
   <span class="ansi1 ansi32"
>Call: </span>(285) [system] is_list([])
   <span class="ansi1 ansi32"
>Exit: </span>(285) [system] is_list([])
^  <span class="ansi1 ansi32"
>Call: </span>(280) [user] is_progn(superpose)
   <span class="ansi1 ansi32"
>Call: </span>(281) [system] var(superpose)
^  <span class="ansi1 ansi32"
>Call: </span>(280) [user] is_progn(superpose)
   <span class="ansi1 ansi32"
>Call: </span>(281) [system] var(superpose)
^  <span class="ansi1 ansi32"
>Call: </span>(280) [user] is_space_op(superpose)
   <span class="ansi1 ansi32"
>Call: </span>(280) [system] is_list([])
   <span class="ansi1 ansi32"
>Exit: </span>(280) [system] is_list([])
   <span class="ansi1 ansi32"
>Call: </span>(280) [system] []=[_868850, _868856, _868862]
   <span class="ansi1 ansi32"
>Call: </span>(280) [lists] lists:member(_869794, [])
^  <span class="ansi1 ansi31"
>Fail: </span>(279) [user] eval_20(=, _773580, 499, '&self', [superpose, []], _801872)
   <span class="ansi1 ansi32"
>Call: </span>(279) [system] fail
   <span class="ansi1 ansi31"
>Fail: </span>(279) [system] fail
^  <span class="ansi1 ansi32"
>Call: </span>(279) [user] ignore((_802898==1->ignore(\+ \+ (flag(eval_num, _828674, _828674+1), (retval(fail)\=@=retval(fail), nonvar(_801872)->indentq(0, _828674, <--, [e, _801872]);indentq(0, _828674, <--, [e, retval(fail)]))));notrace(ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _828674, _828674+1), (retval(fail)\=@=retval(fail), nonvar(_801872)->indentq(0, _828674, <--, [e, _801872]);indentq(0, _828674, <--, [e, retval(fail)]))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(281) [system] _802898==1
   <span class="ansi1 ansi31"
>Fail: </span>(281) [system] _802898==1
^  <span class="ansi1 ansi32"
>Call: </span>(282) [system] setup_call_cleanup('$notrace'(_876300, _876302), once(user:ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _828674, _828674+1), (retval(fail)\=@=retval(fail), nonvar(_801872)->indentq(0, _828674, <--, [e, _801872]);indentq(0, _828674, <--, [e, retval(fail)])))))))), '$restore_trace'(_876300, _876302))
^  <span class="ansi1 ansi32"
>Call: </span>(283) [system] sig_atomic(system:'$notrace'(_876300, _876302))
^  <span class="ansi1 ansi32"
>Exit: </span>(282) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _828674, _828674+1), (retval(fail)\=@=retval(fail), nonvar(_801872)->indentq(0, _828674, <--, [e, _801872]);indentq(0, _828674, <--, [e, retval(fail)])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(279) [system] ignore(user:(_802898==1->ignore(\+ \+ (flag(eval_num, _828674, _828674+1), (retval(fail)\=@=retval(fail), nonvar(_801872)->indentq(0, _828674, <--, [e, _801872]);indentq(0, _828674, <--, [e, retval(fail)]))));notrace(ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _828674, _828674+1), (retval(fail)\=@=retval(fail), nonvar(_801872)->indentq(0, _828674, <--, [e, _801872]);indentq(0, _828674, <--, [e, retval(fail)]))))))))))
^  <span class="ansi1 ansi31"
>Fail: </span>(277) [system] call_cleanup(user:((call(eval_20(=, _773580), 499, '&self', [superpose, []], _801872)*->nb_setarg(1, retval(fail), _801872);fail, trace, call(eval_20(=, _773580), 499, '&self', [superpose, []], _801872)), ignore(notrace((\+_801872\=_803028, nb_setarg(1, retval(fail), _801872))))), user:ignore((_802898==1->ignore(\+ \+ (flag(eval_num, _828674, _828674+1), (retval(fail)\=@=retval(fail), nonvar(_801872)->indentq(0, _828674, <--, [e, _801872]);indentq(0, _828674, <--, [e, retval(fail)]))));notrace(ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _828674, _828674+1), (retval(fail)\=@=retval(fail), nonvar(_801872)->indentq(0, _828674, <--, [e, _801872]);indentq(0, _828674, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi31"
>Fail: </span>(276) [user] trace_eval(eval_20(=, _773580), e, 499, '&self', [superpose, []], _801872)
^  <span class="ansi1 ansi31"
>Fail: </span>(273) [user] eval_args(=, _773580, 500, '&self', [superpose, []], _650062)
^  <span class="ansi1 ansi31"
>Fail: </span>(264) [system] call(user:once, user:if_or_else(eval(=, _650048, 497, '&self', [superpose, []], _650062), call(eval, [superpose, []], _650062)))
^  <span class="ansi1 ansi32"
>Call: </span>(264) [bugger] bugger:mquietly_if(true, rtrace:pop_tracer)
   <span class="ansi1 ansi32"
>Call: </span>(266) [system] var(rtrace:pop_tracer)
   <span class="ansi1 ansi31"
>Fail: </span>(266) [system] var(rtrace:pop_tracer)
^  <span class="ansi1 ansi32"
>Call: </span>(268) [system] setup_call_cleanup('$notrace'(_886794, _886796), once(rtrace:retract(t_l:tracer_reset(_886784))), '$restore_trace'(_886794, _886796))
^  <span class="ansi1 ansi32"
>Call: </span>(269) [system] sig_atomic(system:'$notrace'(_886794, _886796))
^  <span class="ansi1 ansi32"
>Exit: </span>(268) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(rtrace:retract(t_l:tracer_reset(tAt_normal))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(268) [rtrace] tAt(false, 271, 271, false)

NDet Result(1): (assertEqual (f (superpose ())) (Error (f (superpose ())) "NoValidAlternatives") (a) (Error b "BadType"))
  (assertEqual 
    (f (superpose ())) 
    (Error 
      (f (superpose ())) "NoValidAlternatives") 
    (a) 

    (Error b "BadType"))


NDet Result(2): (assertEqual (f a) (Error (f (superpose ())) "NoValidAlternatives") (a) (Error b "BadType")), 
  (assertEqual 
    (f a) 
    (Error 
      (f (superpose ())) "NoValidAlternatives") 
    (a) 

    (Error b "BadType"))


Last Result(3): (assertEqual (f b) (Error (f (superpose ())) "NoValidAlternatives") (a) (Error b "BadType")), 
  (assertEqual 
    (f b) 
    (Error 
      (f (superpose ())) "NoValidAlternatives") 
    (a) 

    (Error b "BadType"))]
;;;;    #[test]
;;;;    fn get_type_op() {
;;;;        let space = DynSpace::new(metta_space("
;;;;            (: B Type)
;;;;            (: C Type)
;;;;            (: A B)
;;;;            (: A C)
;;;;        "));
;;;;
;;;;        let get_type_op = GetTypeOp::new(space);
;;;;        assert_eq_no_order!(get_type_op.execute(&mut vec![sym!("A")]).unwrap(),
;;;;            vec![sym!("B"), sym!("C")]);
;;;;    }
;;;; Converted:
<span class="ansi38-255165000"
>  (let space 
    (new-space))
</span><span class="ansi38-255165000"
>  (: B Type)
</span><span class="ansi38-255165000"
>  (: C Type)
</span><span class="ansi38-255165000"
>  (: A B)
</span><span class="ansi38-255165000"
>  (: A C)
</span><span class="ansi38-013099040"
>  !(assertEqualNoOrder 
    (get-type! space A) 
    (B C))

</span>[P;HTML|
;                                           (eval_call
;                                             (apply  get_type
;                                               (space A)) $TF)


Deterministic: (assertEqualNoOrder False (B C))
  (assertEqualNoOrder False 

    (B C))]
;;;;    #[test]
;;;;    fn get_type_op_non_valid_atom() {
;;;;        let space = DynSpace::new(metta_space("
;;;;            (: f (-> Number String))
;;;;            (: 42 Number)
;;;;            (: \"test\" String)
;;;;        "));
;;;;
;;;;        let get_type_op = GetTypeOp::new(space);
;;;;        assert_eq_no_order!(get_type_op.execute(&mut vec![expr!("f" "42")]).unwrap(),
;;;;            vec![sym!("String")]);
;;;;        assert_eq_no_order!(get_type_op.execute(&mut vec![expr!("f" "\"test\"")]).unwrap(),
;;;;            Vec::<Atom>::new());
;;;;    }
;;;; Converted:
<span class="ansi38-255165000"
>  (let space 
    (new-space))
</span><span class="ansi38-255165000"
>  (: f 
    (-> Number String))
</span><span class="ansi38-255165000"
>  (: 42 Number)
</span><span class="ansi38-255165000"
>  (: "test" String)
</span><span class="ansi38-013099040"
>  !(assertEqualNoOrder 
    (get-type! space 
      ("f" 42)) 
    ("String"))

</span>[P;HTML|
;                                           (eval_call
;                                             (apply  get_type
;                                               (space ("f" 42))) $TF)


Deterministic: (assertEqualNoOrder False ("String"))
  (assertEqualNoOrder False 

    ("String"))]
<span class="ansi38-013099040"
>  !(assertEqualNoOrder 
    (get-type! space 
      ("f" "test")) ())

</span>[P;HTML|
;                                           (eval_call
;                                             (apply  get_type
;                                               (space ("f" "test"))) $TF)


Deterministic: (assertEqualNoOrder False ())

  (assertEqualNoOrder False ())]
;;;;    #[test]
;;;;    fn add_atom_op() {
;;;;        let space = DynSpace::new(GroundingSpace::new());
;;;;        let satom = Atom::gnd(space.clone());
;;;;        let res = AddAtomOp{}.execute(&mut vec![satom, expr!(("foo" "bar"))]).expect("No result returned");
;;;;        assert_eq!(res, vec![UNIT_ATOM()]);
;;;;        let space_atoms: Vec<Atom> = space.borrow().as_space().atom_iter().unwrap().cloned().collect();
;;;;        assert_eq_no_order!(space_atoms, vec![expr!(("foo" "bar"))]);
;;;;    }
;;;; Converted:
<span class="ansi38-255165000"
>  (let space 
    (new-space))
</span><span class="ansi38-255165000"
>  (add-atom space 
    (foo bar))
</span><span class="ansi38-013099040"
>  !(assertEqualNoOrder 
    (get-atoms space) 
    ( (foo bar)))

</span>

NDet Result(1): (assertEqualNoOrder (get-atoms space) ((function (chain (eval (function (return ()))) $_84810 (unify bar value (return ()) (return (Error () "Unexpected error")))))))[
  (assertEqualNoOrder 
    (get-atoms space) 

    ( (function (chain (eval (function (return ()))) $_84810 (unify bar value (return ()) (return (Error () "Unexpected error")))))))


NDet Result(2): (assertEqualNoOrder (get-atoms space) ((function (chain (eval (B C)) $_6088 (unify bar value (return ()) (return (Error () "Unexpected error"))))))), 
  (assertEqualNoOrder 
    (get-atoms space) 

    ( (function (chain (eval (B C)) $_6088 (unify bar value (return ()) (return (Error () "Unexpected error")))))))


NDet Result(3): (assertEqualNoOrder (get-atoms space) ((function (chain (eval (A B)) $_6088 (unify bar value (return ()) (return (Error () "Unexpected error"))))))), 
  (assertEqualNoOrder 
    (get-atoms space) 

    ( (function (chain (eval (A B)) $_6088 (unify bar value (return ()) (return (Error () "Unexpected error")))))))


NDet Result(4): (assertEqualNoOrder (get-atoms space) ((function (chain (eval (A (B C))) $_6084 (unify bar value (return ()) (return (Error () "Unexpected error"))))))), 
  (assertEqualNoOrder 
    (get-atoms space) 

    ( (function (chain (eval (A (B C))) $_6084 (unify bar value (return ()) (return (Error () "Unexpected error")))))))


NDet Result(5): (assertEqualNoOrder (get-atoms space) ((function (chain (eval p) $_6084 (unify bar value (return ()) (return (Error () "Unexpected error"))))))), 
  (assertEqualNoOrder 
    (get-atoms space) 

    ( (function (chain (eval p) $_6084 (unify bar value (return ()) (return (Error () "Unexpected error")))))))


NDet Result(6): (assertEqualNoOrder (get-atoms space) ((function (chain (eval (Q a)) $_6084 (unify bar value (return ()) (return (Error () "Unexpected error"))))))), 
  (assertEqualNoOrder 
    (get-atoms space) 

    ( (function (chain (eval (Q a)) $_6084 (unify bar value (return ()) (return (Error () "Unexpected error")))))))


NDet Result(7): (assertEqualNoOrder (get-atoms space) ((function (chain (eval g) $_6084 (unify bar value (return ()) (return (Error () "Unexpected error"))))))), 
  (assertEqualNoOrder 
    (get-atoms space) 

    ( (function (chain (eval g) $_6084 (unify bar value (return ()) (return (Error () "Unexpected error")))))))


NDet Result(8): (assertEqualNoOrder (get-atoms space) ((function (chain (eval Z) $_6084 (unify bar value (return ()) (return (Error () "Unexpected error"))))))), 
  (assertEqualNoOrder 
    (get-atoms space) 

    ( (function (chain (eval Z) $_6084 (unify bar value (return ()) (return (Error () "Unexpected error")))))))


NDet Result(9): (assertEqualNoOrder (get-atoms space) ((function (chain (eval S) $_6084 (unify bar value (return ()) (return (Error () "Unexpected error"))))))), 
  (assertEqualNoOrder 
    (get-atoms space) 

    ( (function (chain (eval S) $_6084 (unify bar value (return ()) (return (Error () "Unexpected error")))))))


NDet Result(10): (assertEqualNoOrder (get-atoms space) ((function (chain (eval (function (return ()))) $_85924 (unify bar (value) (return ()) (return (Error () "Unexpected error"))))))), 
  (assertEqualNoOrder 
    (get-atoms space) 

    ( (function (chain (eval (function (return ()))) $_85924 (unify bar (value) (return ()) (return (Error () "Unexpected error")))))))


NDet Result(11): (assertEqualNoOrder (get-atoms space) ((function (chain (eval (B C)) $_6084 (unify bar (value) (return ()) (return (Error () "Unexpected error"))))))), 
  (assertEqualNoOrder 
    (get-atoms space) 

    ( (function (chain (eval (B C)) $_6084 (unify bar (value) (return ()) (return (Error () "Unexpected error")))))))


NDet Result(12): (assertEqualNoOrder (get-atoms space) ((function (chain (eval (A B)) $_6084 (unify bar (value) (return ()) (return (Error () "Unexpected error"))))))), 
  (assertEqualNoOrder 
    (get-atoms space) 

    ( (function (chain (eval (A B)) $_6084 (unify bar (value) (return ()) (return (Error () "Unexpected error")))))))


NDet Result(13): (assertEqualNoOrder (get-atoms space) ((function (chain (eval (A (B C))) $_6084 (unify bar (value) (return ()) (return (Error () "Unexpected error"))))))), 
  (assertEqualNoOrder 
    (get-atoms space) 

    ( (function (chain (eval (A (B C))) $_6084 (unify bar (value) (return ()) (return (Error () "Unexpected error")))))))


NDet Result(14): (assertEqualNoOrder (get-atoms space) ((function (chain (eval p) $_6084 (unify bar (value) (return ()) (return (Error () "Unexpected error"))))))), 
  (assertEqualNoOrder 
    (get-atoms space) 

    ( (function (chain (eval p) $_6084 (unify bar (value) (return ()) (return (Error () "Unexpected error")))))))


NDet Result(15): (assertEqualNoOrder (get-atoms space) ((function (chain (eval (Q a)) $_6084 (unify bar (value) (return ()) (return (Error () "Unexpected error"))))))), 
  (assertEqualNoOrder 
    (get-atoms space) 

    ( (function (chain (eval (Q a)) $_6084 (unify bar (value) (return ()) (return (Error () "Unexpected error")))))))


NDet Result(16): (assertEqualNoOrder (get-atoms space) ((function (chain (eval g) $_6084 (unify bar (value) (return ()) (return (Error () "Unexpected error"))))))), 
  (assertEqualNoOrder 
    (get-atoms space) 

    ( (function (chain (eval g) $_6084 (unify bar (value) (return ()) (return (Error () "Unexpected error")))))))


NDet Result(17): (assertEqualNoOrder (get-atoms space) ((function (chain (eval Z) $_6084 (unify bar (value) (return ()) (return (Error () "Unexpected error"))))))), 
  (assertEqualNoOrder 
    (get-atoms space) 

    ( (function (chain (eval Z) $_6084 (unify bar (value) (return ()) (return (Error () "Unexpected error")))))))


NDet Result(18): (assertEqualNoOrder (get-atoms space) ((function (chain (eval S) $_6084 (unify bar (value) (return ()) (return (Error () "Unexpected error"))))))), 
  (assertEqualNoOrder 
    (get-atoms space) 

    ( (function (chain (eval S) $_6084 (unify bar (value) (return ()) (return (Error () "Unexpected error")))))))


NDet Result(19): (assertEqualNoOrder (get-atoms space) (a)), 
  (assertEqualNoOrder 
    (get-atoms space) 

    (a))
]
;;;;    #[test]
;;;;    fn remove_atom_op() {
;;;;        let space = DynSpace::new(metta_space("
;;;;            (foo bar)
;;;;            (bar foo)
;;;;        "));
;;;;        let satom = Atom::gnd(space.clone());
;;;;        let res = RemoveAtomOp{}.execute(&mut vec![satom, expr!(("foo" "bar"))]).expect("No result returned");
;;;;        // REM: can return Bool in future
;;;;        assert_eq!(res, vec![UNIT_ATOM()]);
;;;;        let space_atoms: Vec<Atom> = space.borrow().as_space().atom_iter().unwrap().cloned().collect();
;;;;        assert_eq_no_order!(space_atoms, vec![expr!(("bar" "foo"))]);
;;;;    }
;;;; Converted:
<span class="ansi38-255165000"
>  (let space 
    (new-space))
</span><span class="ansi38-255165000"
>  (add-atom space 
    (foo bar))
</span><span class="ansi38-255165000"
>  (add-atom space 
    (bar foo))
</span><span class="ansi38-255165000"
>  (remove-atom space 
    (foo bar))
</span><span class="ansi38-013099040"
>  !(assertEqualNoOrder 
    (get-atoms space) 
    ( (bar foo)))

</span>

Deterministic: (assertEqualNoOrder (get-atoms space) ((bar foo)))[
  (assertEqualNoOrder 
    (get-atoms space) 

    ( (bar foo)))]
;;;;    #[test]
;;;;    fn get_atoms_op() {
;;;;        let space = DynSpace::new(metta_space("
;;;;            (foo bar)
;;;;            (bar foo)
;;;;        "));
;;;;        let satom = Atom::gnd(space.clone());
;;;;        let res = GetAtomsOp{}.execute(&mut vec![satom]).expect("No result returned");
;;;;        let space_atoms: Vec<Atom> = space.borrow().as_space().atom_iter().unwrap().cloned().collect();
;;;;        assert_eq_no_order!(res, space_atoms);
;;;;        assert_eq_no_order!(res, vec![expr!(("foo" "bar")), expr!(("bar" "foo"))]);
;;;;    }
;;;; Converted:
<span class="ansi38-255165000"
>  (let space 
    (new-space))
</span><span class="ansi38-255165000"
>  (add-atom space 
    (foo bar))
</span><span class="ansi38-255165000"
>  (add-atom space 
    (bar foo))
</span><span class="ansi38-013099040"
>  !(assertEqualNoOrder 
    (get-atoms space) 
    ( (foo bar) (bar foo)))

</span>

NDet Result(1): (assertEqualNoOrder (get-atoms space) ((function (chain (eval (function (return ()))) $_6568 (unify bar value (return ()) (return (Error () "Unexpected error"))))) (bar foo)))[
  (assertEqualNoOrder 
    (get-atoms space) 

    ( (function (chain (eval (function (return ()))) $_6568 (unify bar value (return ()) (return (Error () "Unexpected error"))))) (bar foo)))


NDet Result(2): (assertEqualNoOrder (get-atoms space) ((function (chain (eval (B C)) $_6546 (unify bar value (return ()) (return (Error () "Unexpected error"))))) (bar foo))), 
  (assertEqualNoOrder 
    (get-atoms space) 

    ( (function (chain (eval (B C)) $_6546 (unify bar value (return ()) (return (Error () "Unexpected error"))))) (bar foo)))


NDet Result(3): (assertEqualNoOrder (get-atoms space) ((function (chain (eval (A B)) $_6546 (unify bar value (return ()) (return (Error () "Unexpected error"))))) (bar foo))), 
  (assertEqualNoOrder 
    (get-atoms space) 

    ( (function (chain (eval (A B)) $_6546 (unify bar value (return ()) (return (Error () "Unexpected error"))))) (bar foo)))


NDet Result(4): (assertEqualNoOrder (get-atoms space) ((function (chain (eval (A (B C))) $_6546 (unify bar value (return ()) (return (Error () "Unexpected error"))))) (bar foo))), 
  (assertEqualNoOrder 
    (get-atoms space) 

    ( (function (chain (eval (A (B C))) $_6546 (unify bar value (return ()) (return (Error () "Unexpected error"))))) (bar foo)))


NDet Result(5): (assertEqualNoOrder (get-atoms space) ((function (chain (eval p) $_6546 (unify bar value (return ()) (return (Error () "Unexpected error"))))) (bar foo))), 
  (assertEqualNoOrder 
    (get-atoms space) 

    ( (function (chain (eval p) $_6546 (unify bar value (return ()) (return (Error () "Unexpected error"))))) (bar foo)))


NDet Result(6): (assertEqualNoOrder (get-atoms space) ((function (chain (eval (Q a)) $_6546 (unify bar value (return ()) (return (Error () "Unexpected error"))))) (bar foo))), 
  (assertEqualNoOrder 
    (get-atoms space) 

    ( (function (chain (eval (Q a)) $_6546 (unify bar value (return ()) (return (Error () "Unexpected error"))))) (bar foo)))


NDet Result(7): (assertEqualNoOrder (get-atoms space) ((function (chain (eval g) $_6546 (unify bar value (return ()) (return (Error () "Unexpected error"))))) (bar foo))), 
  (assertEqualNoOrder 
    (get-atoms space) 

    ( (function (chain (eval g) $_6546 (unify bar value (return ()) (return (Error () "Unexpected error"))))) (bar foo)))


NDet Result(8): (assertEqualNoOrder (get-atoms space) ((function (chain (eval Z) $_6546 (unify bar value (return ()) (return (Error () "Unexpected error"))))) (bar foo))), 
  (assertEqualNoOrder 
    (get-atoms space) 

    ( (function (chain (eval Z) $_6546 (unify bar value (return ()) (return (Error () "Unexpected error"))))) (bar foo)))


NDet Result(9): (assertEqualNoOrder (get-atoms space) ((function (chain (eval S) $_6546 (unify bar value (return ()) (return (Error () "Unexpected error"))))) (bar foo))), 
  (assertEqualNoOrder 
    (get-atoms space) 

    ( (function (chain (eval S) $_6546 (unify bar value (return ()) (return (Error () "Unexpected error"))))) (bar foo)))


NDet Result(10): (assertEqualNoOrder (get-atoms space) ((function (chain (eval (function (return ()))) $_6170 (unify bar (value) (return ()) (return (Error () "Unexpected error"))))) (bar foo))), 
  (assertEqualNoOrder 
    (get-atoms space) 

    ( (function (chain (eval (function (return ()))) $_6170 (unify bar (value) (return ()) (return (Error () "Unexpected error"))))) (bar foo)))


NDet Result(11): (assertEqualNoOrder (get-atoms space) ((function (chain (eval (B C)) $_6142 (unify bar (value) (return ()) (return (Error () "Unexpected error"))))) (bar foo))), 
  (assertEqualNoOrder 
    (get-atoms space) 

    ( (function (chain (eval (B C)) $_6142 (unify bar (value) (return ()) (return (Error () "Unexpected error"))))) (bar foo)))


NDet Result(12): (assertEqualNoOrder (get-atoms space) ((function (chain (eval (A B)) $_6142 (unify bar (value) (return ()) (return (Error () "Unexpected error"))))) (bar foo))), 
  (assertEqualNoOrder 
    (get-atoms space) 

    ( (function (chain (eval (A B)) $_6142 (unify bar (value) (return ()) (return (Error () "Unexpected error"))))) (bar foo)))


NDet Result(13): (assertEqualNoOrder (get-atoms space) ((function (chain (eval (A (B C))) $_6142 (unify bar (value) (return ()) (return (Error () "Unexpected error"))))) (bar foo))), 
  (assertEqualNoOrder 
    (get-atoms space) 

    ( (function (chain (eval (A (B C))) $_6142 (unify bar (value) (return ()) (return (Error () "Unexpected error"))))) (bar foo)))


NDet Result(14): (assertEqualNoOrder (get-atoms space) ((function (chain (eval p) $_6142 (unify bar (value) (return ()) (return (Error () "Unexpected error"))))) (bar foo))), 
  (assertEqualNoOrder 
    (get-atoms space) 

    ( (function (chain (eval p) $_6142 (unify bar (value) (return ()) (return (Error () "Unexpected error"))))) (bar foo)))


NDet Result(15): (assertEqualNoOrder (get-atoms space) ((function (chain (eval (Q a)) $_6142 (unify bar (value) (return ()) (return (Error () "Unexpected error"))))) (bar foo))), 
  (assertEqualNoOrder 
    (get-atoms space) 

    ( (function (chain (eval (Q a)) $_6142 (unify bar (value) (return ()) (return (Error () "Unexpected error"))))) (bar foo)))


NDet Result(16): (assertEqualNoOrder (get-atoms space) ((function (chain (eval g) $_6142 (unify bar (value) (return ()) (return (Error () "Unexpected error"))))) (bar foo))), 
  (assertEqualNoOrder 
    (get-atoms space) 

    ( (function (chain (eval g) $_6142 (unify bar (value) (return ()) (return (Error () "Unexpected error"))))) (bar foo)))


NDet Result(17): (assertEqualNoOrder (get-atoms space) ((function (chain (eval Z) $_6142 (unify bar (value) (return ()) (return (Error () "Unexpected error"))))) (bar foo))), 
  (assertEqualNoOrder 
    (get-atoms space) 

    ( (function (chain (eval Z) $_6142 (unify bar (value) (return ()) (return (Error () "Unexpected error"))))) (bar foo)))


NDet Result(18): (assertEqualNoOrder (get-atoms space) ((function (chain (eval S) $_6142 (unify bar (value) (return ()) (return (Error () "Unexpected error"))))) (bar foo))), 
  (assertEqualNoOrder 
    (get-atoms space) 

    ( (function (chain (eval S) $_6142 (unify bar (value) (return ()) (return (Error () "Unexpected error"))))) (bar foo)))


Last Result(19): (assertEqualNoOrder (get-atoms space) (a (bar foo))), 
  (assertEqualNoOrder 
    (get-atoms space) 

    (a (bar foo)))]
;;;;    #[test]
;;;;    fn car_atom_op() {
;;;;        let res = CarAtomOp{}.execute(&mut vec![expr!(("A" "C") "B")]).expect("No result returned");
;;;;        assert_eq!(res, vec![expr!("A" "C")]);
;;;;    }
;;;; Converted:
<span class="ansi38-013099040"
>  !(assertEqual 
    (car-atom (("A" "C") "B")) 
    ("A" "C"))

</span>[

;<h3 id="STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.65"
>;; STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.65</h3>
; 
; EVAL TEST
; took 0.000454 secs. (453.99 microseconds) 

  !(assertEqual 
    (car-atom (("A" "C") "B")) 
    ("A" "C"))

<span class="ansi36"
>  (loonit_success  
    (equal_enough_for_test  
      ( ("A" "C")) 
      ( ("A" "C"))))
</span>
Deterministic: ()
()]
;;;;    #[test]
;;;;    fn cdr_atom_op() {
;;;;        let res = CdrAtomOp{}.execute(&mut vec![expr!(("A"))]).expect("No result returned");
;;;;        assert_eq!(res, vec![expr!()]);
;;;;        let res = CdrAtomOp{}.execute(&mut vec![expr!(("A" "C") ("D" "E") "B")]).expect("No result returned");
;;;;        assert_eq!(res, vec![expr!(("D" "E") "B")]);
;;;;     let res = CdrAtomOp{}.execute(&mut vec![]);
;;;;        assert_eq!(res, Err(ExecError::Runtime("cdr-atom expects non-empty expression".into())));
;;;;    }
;;;; Converted:
<span class="ansi38-013099040"
>  !(assertEqual 
    (cdr-atom (("A"))) ())

</span>[

;<h3 id="STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.66"
>;; STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.66</h3>
; 
; EVAL TEST
; took 0.000129 secs. (129.15 microseconds) 

  !(assertEqual 
    (cdr-atom (("A"))) ())

<span class="ansi36"
>  (loonit_success  
    (equal_enough_for_test  
      (()) 
      (())))
</span>
Deterministic: ()
()]
<span class="ansi38-013099040"
>  !(assertEqual 
    (cdr-atom (("A" "C") ("D" "E") "B")) 
    ( ("D" "E") "B"))

</span>[

;<h3 id="STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.67"
>;; STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.67</h3>
; 
; EVAL TEST
; took 0.001 secs. (1.21 milliseconds) 

  !(assertEqual 
    (cdr-atom (("A" "C") ("D" "E") "B")) 
    ( ("D" "E") "B"))

<span class="ansi36"
>  (loonit_success  
    (equal_enough_for_test  
      ( ( ("D" "E") "B")) 
      ( ( ("D" "E") "B"))))
</span>
Deterministic: ()
()]
<span class="ansi38-013099040"
>  !(assertEqual 
    (cdr-atom ()) 
    (error "cdr-atom expects non-empty expression"))

</span>[

;<h3 id="STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.68"
>;; STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.68</h3>
; 
; EVAL TEST
; took 0.000351 secs. (350.97 microseconds) 

  !(assertEqual 
    (cdr-atom ()) 
    (error "cdr-atom expects non-empty expression"))

<span class="ansi31"
>  (loonit_failureR  
    (equal_enough_for_test  () 
      ( (error "cdr-atom expects non-empty expression"))))
</span>
Deterministic: ((Error  (got  ()) (expected  ((error "cdr-atom expects non-empty expression")))))
((Error  (got  ()) (expected  ((error "cdr-atom expects non-empty expression")))))]
;;;;    #[test]
;;;;    fn cons_atom_op() {
;;;;        let res = ConsAtomOp{}.execute(&mut vec![expr!("A"), expr!()]).expect("No result returned");
;;;;        assert_eq!(res, vec![expr!(("A"))]);
;;;;        let res = ConsAtomOp{}.execute(&mut vec![expr!("A" "F"), expr!(("B" "C") "D")]).expect("No result returned");
;;;;        assert_eq!(res, vec![expr!(("A" "F") ("B" "C") "D")]);
;;;;    }
;;;; Converted:
<span class="ansi38-013099040"
>  !(assertEqual 
    (cons-atom 
      ("A") ()) 
    ( ("A")))

</span>[

;<h3 id="STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.69"
>;; STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.69</h3>
; 
; EVAL TEST
; took 0.000946 secs. (946.49 microseconds) 

  !(assertEqual 
    (cons-atom 
      ("A") ()) 
    ( ("A")))

<span class="ansi36"
>  (loonit_success  
    (equal_enough_for_test  
      ( ( ("A"))) 
      ( ( ("A")))))
</span>
Deterministic: ()
()]
<span class="ansi38-013099040"
>  !(assertEqual 
    (cons-atom 
      ("A" "F") 
      ( ("B" "C") "D")) 
    ( ("A" "F") 
      ("B" "C") "D"))

</span>[

;<h3 id="STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.70"
>;; STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.70</h3>
; 
; EVAL TEST
; took 0.002 secs. (1.73 milliseconds) 

  !(assertEqual 
    (cons-atom 
      ("A" "F") 
      ( ("B" "C") "D")) 
    ( ("A" "F") 
      ("B" "C") "D"))

<span class="ansi36"
>  (loonit_success  
    (equal_enough_for_test  
      ( ( ("A" "F") 
          ("B" "C") "D")) 
      ( ( ("A" "F") 
          ("B" "C") "D"))))
</span>
Deterministic: ()
()]
;;;;    #[test]
;;;;    fn bind_new_space_op() {
;;;;        let tokenizer = Shared::new(Tokenizer::new());
;;;;
;;;;        let bind_op = BindOp::new(tokenizer.clone());
;;;;
;;;;        assert_eq!(bind_op.execute(&mut vec![sym!("&my"), sym!("definition")]), unit_result());
;;;;        let borrowed = tokenizer.borrow();
;;;;        let constr = borrowed.find_token("&my");
;;;;        assert!(constr.is_some());
;;;;        assert_eq!(constr.unwrap()("&my"), Ok(sym!("definition")));
;;;;    }
;;;; Converted:
<span class="ansi38-255165000"
>  (let &my definition)
</span><span class="ansi38-013099040"
>  !(assertEqual 
    (&my) definition)

</span>[

;<h3 id="STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.71"
>;; STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.71</h3>
; 
; EVAL TEST
; took 0.000269 secs. (268.73 microseconds) 

  !(assertEqual 
    (&my) definition)

<span class="ansi31"
>  (loonit_failureR  
    (equal_enough_for_test  
      ( (&my)) 
      (definition)))
</span>
Deterministic: ((Error  (got  ((&my))) (expected  (definition))))
((Error  (got  ((&my))) (expected  (definition))))]
;;;;    #[test]
;;;;    fn case_op() {
;;;;        let space = DynSpace::new(metta_space("
;;;;            (= (foo) (A B))
;;;;        "));
;;;;
;;;;        let case_op = CaseOp::new(space.clone());
;;;;
;;;;        assert_eq!(case_op.execute(&mut vec![expr!(("foo")),
;;;;                expr!(((n "B") n) ("Empty" "D"))]),
;;;;            Ok(vec![Atom::sym("A")]));
;;;;        assert_eq!(case_op.execute(&mut vec![expr!({MatchOp{}} {space} ("B" "C") ("C" "B")),
;;;;                expr!(((n "C") n) ("Empty" "D"))]),
;;;;            Ok(vec![Atom::sym("D")]));
;;;;    }
;;;; Converted:
<span class="ansi38-255165000"
>  (let space 
    (new-space))
</span><span class="ansi38-255165000"
>  (= 
    (foo) 
    (A B))
</span><span class="ansi38-013099040"
>  !(assertEqual 
    (case! space 
      ("foo") 
      ( ( (n "B") n) ("Empty" "D"))) "A")

</span>[

;<h3 id="STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.72"
>;; STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.72</h3>
; 
; EVAL TEST
; took 0.001 secs. (1.34 milliseconds) 

  !(assertEqual 
    (case! space 
      ("foo") 
      ( ( (n "B") n) ("Empty" "D"))) "A")

<span class="ansi31"
>  (loonit_failureR  
    (equal_enough_for_test  
      ( (case! space 
          ("foo") 
          ( ( (n "B") n) ("Empty" "D")))) 
      ("A")))
</span>
Deterministic: ((Error  (got  ((case! space ("foo") (((n "B") n) ("Empty" "D"))))) (expected  ("A"))))
((Error  (got  ((case! space ("foo") (((n "B") n) ("Empty" "D"))))) (expected  ("A"))))]
<span class="ansi38-013099040"
>  !(assertEqual 
    (case! space 
      (match! space 
        ("B" "C") 
        ("C" "B")) 
      ( ( (n "C") n) ("Empty" "D"))) "D")

</span>[

;<h3 id="STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.73"
>;; STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.73</h3>
P;HTML|
;                                           (eval_call
;                                             (apply  match
;                                               (space
;                                                 ("B" "C")
;                                                 ("C" "B"))) $TF)

; 
; EVAL TEST
; took 0.004 secs. (4.03 milliseconds) 

  !(assertEqual 
    (case! space 
      (match! space 
        ("B" "C") 
        ("C" "B")) 
      ( ( (n "C") n) ("Empty" "D"))) "D")

<span class="ansi31"
>  (loonit_failureR  
    (equal_enough_for_test  
      ( (case! space False 
          ( ( (n "C") n) ("Empty" "D")))) 
      ("D")))
</span>
Deterministic: ((Error  (got  ((case! space False (((n "C") n) ("Empty" "D"))))) (expected  ("D"))))
((Error  (got  ((case! space False (((n "C") n) ("Empty" "D"))))) (expected  ("D"))))]
;;;;    #[test]
;;;;    fn case_op_external_vars_at_right_are_kept_untouched() {
;;;;        let space = DynSpace::new(GroundingSpace::new());
;;;;        let case_op = CaseOp::new(space.clone());
;;;;
;;;;        assert_eq!(case_op.execute(&mut vec![expr!(ext), expr!(((t t)))]),
;;;;            Ok(vec![expr!(ext)]));
;;;;        assert_eq!(case_op.execute(&mut vec![expr!(ext "A"), expr!(((t t)))]),
;;;;            Ok(vec![expr!(ext "A")]));
;;;;    }
;;;; Converted:
<span class="ansi38-255165000"
>  (let space 
    (new-space))
</span><span class="ansi38-013099040"
>  !(assertEqual 
    (case! space ext 
      ( ( (t t)))) ext)

</span>[

;<h3 id="STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.74"
>;; STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.74</h3>
; 
; EVAL TEST
; took 0.001 secs. (1.09 milliseconds) 

  !(assertEqual 
    (case! space ext 
      ( ( (t t)))) ext)

<span class="ansi31"
>  (loonit_failureR  
    (equal_enough_for_test  
      ( (case! space ext 
          ( ( (t t))))) 
      (ext)))
</span>
Deterministic: ((Error  (got  ((case! space ext (((t t)))))) (expected  (ext))))
((Error  (got  ((case! space ext (((t t)))))) (expected  (ext))))]
<span class="ansi38-013099040"
>  !(assertEqual 
    (case! space 
      (ext "A") 
      ( ( (t t)))) 
    (ext "A"))

</span>[

;<h3 id="STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.75"
>;; STDLIB-METTALOG.STDLIB-METTALOG-TEST-PT2.75</h3>
; 
; EVAL TEST
; took 0.001 secs. (1.26 milliseconds) 

  !(assertEqual 
    (case! space 
      (ext "A") 
      ( ( (t t)))) 
    (ext "A"))

<span class="ansi31"
>  (loonit_failureR  
    (equal_enough_for_test  
      ( (case! space 
          (ext "A") 
          ( ( (t t))))) 
      ( (ext "A"))))
</span>
Deterministic: ((Error  (got  ((case! space (ext "A") (((t t)))))) (expected  ((ext "A")))))
((Error  (got  ((case! space (ext "A") (((t t)))))) (expected  ((ext "A")))))]
<span class="ansi32"
>% 13,854,515 inferences, 2.624 CPU in 2.624 seconds (100% CPU, 5280901 Lips)
</span>P;HTML|
;                         (= /home/runner/work/metta-wam/metta-wam/tests/more-anti-regression/stdlib-mettalog/stdlib_mettalog_test_pt2.metta  0)
<span class="ansi1"
>LoonIt Report
</span>------------
<span class="ansi32"
>Successes: 36
</span><span class="ansi31"
>Failures: 39
</span><br/> <a href="#" onclick="window.history.back(); return false;"
>Return to summaries</a><br/>
P;HTML|
;           (is_cmd_option  execute halt --halt=true true)
P;HTML|
;            (set_option_value  halt true)
P;HTML|
;            (is_cmd_option  execute stdin --stdin=tty tty)
P;HTML|
;            (set_option_value  stdin tty)
P;HTML|
;            (is_cmd_option  execute stdout --stdout=tty tty)
P;HTML|
;             (set_option_value  stdout tty)
P;HTML|
;            (is_cmd_option  execute stderr --stderr=tty tty)
P;HTML|
;             (set_option_value  stderr tty)
P;HTML|
;           (set_option_value  prolog false)
P;HTML|
;           (set_option_value  compat auto)
P;HTML|
;           (set_option_value  compatio true)

Script done on 2024-10-01 00:56:53+00:00 [COMMAND_EXIT_CODE="7"]

</pre>
</body>

</html>
\033[0;32mCompleted successfully (EXITCODE=7) Under 40 seconds: ./mettalog '--output=./reports/tests_output/baseline-compat-2024-10-01T00:37:26/' --timeout=40 --html --repl=false  --test "tests/more-anti-regression/stdlib-mettalog/stdlib_mettalog_test_pt2.metta" --halt=true\033[0m

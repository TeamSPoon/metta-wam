<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"
>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"
>
<title></title>
<style type="text/css"
>
.ansi2html-content { display: inline; white-space: pre-wrap; word-wrap: break-word; }
.body_foreground { color: #AAAAAA; }
.body_background { background-color: #000000; }
.inv_foreground { color: #000000; }
.inv_background { background-color: #AAAAAA; }
.ansi1 { font-weight: bold; }
.ansi31 { color: #aa0000; }
.ansi32 { color: #00aa00; }
.ansi36 { color: #00aaaa; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165009 { color: #FFA509; }
.ansi38-255238088 { color: #FFEE58; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165009 { color: #FFA509; }
.ansi38-255238088 { color: #FFEE58; }
.ansi38-013099040 { color: #0D6328; }
</style>
</head>
<body class="body_foreground body_background" style="font-size: normal;" >
<pre class="ansi2html-content"
>
Script started on 2024-10-06 01:23:04+00:00 [TERM="xterm-256color" TTY="/dev/pts/0" COLUMNS="-1" LINES="-1"]
P;HTML|
;           (set_option_value  prolog false)

P;HTML|
;           (set_option_value  compat auto)

P;HTML|
;           (set_option_value  compatio true)
P;HTML|
;            (is_cmd_option  prescan halt --halt=true true)
P;HTML|
;            (set_option_value  halt true)
P;HTML|
;            (is_cmd_option  prescan stdin --stdin=tty tty)
P;HTML|
;             (set_option_value  stdin tty)
P;HTML|
;            (is_cmd_option  prescan stdout --stdout=tty tty)
P;HTML|
;             (set_option_value  stdout tty)
P;HTML|
;            (is_cmd_option  prescan stderr --stderr=tty tty)
P;HTML|
;             (set_option_value  stderr tty)
P;HTML|
;            (set_option_value  prolog false)
P;HTML|
;            (set_option_value  compat auto)
P;HTML|
;            (set_option_value  compatio true)
P;HTML|
;          (is_cmd_option  execute python --python=enable enable)
P;HTML|
;           (set_option_value  python enable)
P;HTML|
;          (is_cmd_option  execute timeout --timeout=40 40)
P;HTML|
;           (set_option_value  timeout 40)
P;HTML|
;           (is_cmd_option  execute output --output=./reports/tests_output/baseline-compat-2024-10-06T00:36:50/ ./reports/tests_output/baseline-compat-2024-10-06T00:36:50/)
P;HTML|
;           (set_option_value  output ./reports/tests_output/baseline-compat-2024-10-06T00:36:50/)
P;HTML|
;           (is_cmd_option  execute html --html true)
P;HTML|
;            (set_option_value  html true)
P;HTML|
;           (is_cmd_option  execute test --test true)
P;HTML|
;            (set_option_value  test true)

; (load_metta_file  &self tests/extended_compat/hyperon-pln/metta/pln/dependent-types/DeductionDTLTest.metta)
P;HTML|
;                         (track_load_into_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/pln/dependent-types/DeductionDTLTest.metta)
P;HTML|
;                                          (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/pln/dependent-types/DeductionDTLTest.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/pln/dependent-types/DeductionDTLTest.metta)
P;HTML|
;                                           (= 1  "Doing: timeout --foreground --kill-after=5 --signal=SIGINT 61 time metta /opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/hyperon-wam/reports/extended_compat/hyperon-pln/metta/pln/dependent-types/DeductionDTLTest.metta")
P;HTML|
;                                           (= 1  "[()]")
P;HTML|
;                                           (= 2  "[()]")
P;HTML|
;                                           (= 3  "[()]")
P;HTML|
;                                           (= 4  "[\"===== Test synthesizer ====\"]")
P;HTML|
;                                           (= 5  "[()]")
P;HTML|
;                                           (= 6  "[()]")
P;HTML|
;                                           (= 7  "[(let* (((: $proof4#3859 (≞ (→ P P) (STV $ABs#3865 $PQc#3871))) (synthesize (: $proof4#3859 (≞ (→ P P) (STV $ABs#3865 $PQc#3871))) kb rb Z)) ((: $proof5#3860 (≞ (→ P R) (STV $QRs#3867 $QRc#3872))) (synthesize (: $proof5#3860 (≞ (→ P R) (STV $QRs#3867 $QRc#3872))) kb rb Z))) (: (Deduction Pm Pm Rm $proof4#3859 $proof5#3860) (≞ (→ P R) (if (and (and (< 0 0.5) (and (<= (if (> 0 (if (< 1 (/ (- (+ 0.5 0.5) 1) 0.5)) 1 (/ (- (+ 0.5 0.5) 1) 0.5))) 0 (if (< 1 (/ (- (+ 0.5 0.5) 1) 0.5)) 1 (/ (- (+ 0.5 0.5) 1) 0.5))) $ABs#3865) (<= $ABs#3865 (if (> 0 (if (< 1 (/ 0.5 0.5)) 1 (/ 0.5 0.5))) 0 (if (< 1 (/ 0.5 0.5)) 1 (/ 0.5 0.5)))))) (and (< 0 0.5) (and (<= (if (> 0 (if (< 1 (/ (- (+ 0.5 0.7) 1) 0.5)) 1 (/ (- (+ 0.5 0.7) 1) 0.5))) 0 (if (< 1 (/ (- (+ 0.5 0.7) 1) 0.5)) 1 (/ (- (+ 0.5 0.7) 1) 0.5))) $QRs#3867) (<= $QRs#3867 (if (> 0 (if (< 1 (/ 0.7 0.5)) 1 (/ 0.7 0.5))) 0 (if (< 1 (/ 0.7 0.5)) 1 (/ 0.7 0.5))))))) (STV (if (< 0.9999 0.5) 0.7 (+ (* $ABs#3865 $QRs#3867) (/ (* (- 1 $ABs#3865) (- 0.7 (* 0.5 $QRs#3867))) (- 1 0.5)))) (min 0.1 (min 0.1 (min 0.3 (min $PQc#3871 $QRc#3872))))) (STV 1 0))))), (: (Deduction Pm Qm Rm PQm QRm) (≞ (→ P R) (STV 0.8 0.1))), (let* (((: $proof4#3859 (≞ (→ P R) (STV $ABs#3865 $PQc#3871))) (synthesize (: $proof4#3859 (≞ (→ P R) (STV $ABs#3865 $PQc#3871))) kb rb Z)) ((: $proof5#3860 (≞ (→ R R) (STV $QRs#3867 $QRc#3872))) (synthesize (: $proof5#3860 (≞ (→ R R) (STV $QRs#3867 $QRc#3872))) kb rb Z))) (: (Deduction Pm Rm Rm $proof4#3859 $proof5#3860) (≞ (→ P R) (if (and (and (< 0 0.5) (and (<= (if (> 0 (if (< 1 (/ (- (+ 0.5 0.7) 1) 0.5)) 1 (/ (- (+ 0.5 0.7) 1) 0.5))) 0 (if (< 1 (/ (- (+ 0.5 0.7) 1) 0.5)) 1 (/ (- (+ 0.5 0.7) 1) 0.5))) $ABs#3865) (<= $ABs#3865 (if (> 0 (if (< 1 (/ 0.7 0.5)) 1 (/ 0.7 0.5))) 0 (if (< 1 (/ 0.7 0.5)) 1 (/ 0.7 0.5)))))) (and (< 0 0.7) (and (<= (if (> 0 (if (< 1 (/ (- (+ 0.7 0.7) 1) 0.7)) 1 (/ (- (+ 0.7 0.7) 1) 0.7))) 0 (if (< 1 (/ (- (+ 0.7 0.7) 1) 0.7)) 1 (/ (- (+ 0.7 0.7) 1) 0.7))) $QRs#3867) (<= $QRs#3867 (if (> 0 (if (< 1 (/ 0.7 0.7)) 1 (/ 0.7 0.7))) 0 (if (< 1 (/ 0.7 0.7)) 1 (/ 0.7 0.7))))))) (STV (if (< 0.9999 0.7) 0.7 (+ (* $ABs#3865 $QRs#3867) (/ (* (- 1 $ABs#3865) (- 0.7 (* 0.7 $QRs#3867))) (- 1 0.7)))) (min 0.1 (min 0.3 (min 0.3 (min $PQc#3871 $QRc#3872))))) (STV 1 0))))), (let* (((: $proof4#3859 (≞ (→ P (→ P Q)) (STV $ABs#3865 $PQc#3871))) (synthesize (: $proof4#3859 (≞ (→ P (→ P Q)) (STV $ABs#3865 $PQc#3871))) kb rb Z)) ((: $proof5#3860 (≞ (→ (→ P Q) R) (STV $QRs#3867 $QRc#3872))) (synthesize (: $proof5#3860 (≞ (→ (→ P Q) R) (STV $QRs#3867 $QRc#3872))) kb rb Z))) (: (Deduction Pm PQm Rm $proof4#3859 $proof5#3860) (≞ (→ P R) (if (and (and (< 0 0.5) (and (<= (if (> 0 (if (< 1 (/ (- (+ 0.5 0.8) 1) 0.5)) 1 (/ (- (+ 0.5 0.8) 1) 0.5))) 0 (if (< 1 (/ (- (+ 0.5 0.8) 1) 0.5)) 1 (/ (- (+ 0.5 0.8) 1) 0.5))) $ABs#3865) (<= $ABs#3865 (if (> 0 (if (< 1 (/ 0.8 0.5)) 1 (/ 0.8 0.5))) 0 (if (< 1 (/ 0.8 0.5)) 1 (/ 0.8 0.5)))))) (and (< 0 0.8) (and (<= (if (> 0 (if (< 1 (/ (- (+ 0.8 0.7) 1) 0.8)) 1 (/ (- (+ 0.8 0.7) 1) 0.8))) 0 (if (< 1 (/ (- (+ 0.8 0.7) 1) 0.8)) 1 (/ (- (+ 0.8 0.7) 1) 0.8))) $QRs#3867) (<= $QRs#3867 (if (> 0 (if (< 1 (/ 0.7 0.8)) 1 (/ 0.7 0.8))) 0 (if (< 1 (/ 0.7 0.8)) 1 (/ 0.7 0.8))))))) (STV (if (< 0.9999 0.8) 0.7 (+ (* $ABs#3865 $QRs#3867) (/ (* (- 1 $ABs#3865) (- 0.7 (* 0.8 $QRs#3867))) (- 1 0.8)))) (min 0.1 (min 0.4 (min 0.3 (min $PQc#3871 $QRc#3872))))) (STV 1 0))))), (let* (((: $proof4#3859 (≞ (→ P (→ Q R)) (STV $ABs#3865 $PQc#3871))) (synthesize (: $proof4#3859 (≞ (→ P (→ Q R)) (STV $ABs#3865 $PQc#3871))) kb rb Z)) ((: $proof5#3860 (≞ (→ (→ Q R) R) (STV $QRs#3867 $QRc#3872))) (synthesize (: $proof5#3860 (≞ (→ (→ Q R) R) (STV $QRs#3867 $QRc#3872))) kb rb Z))) (: (Deduction Pm QRm Rm $proof4#3859 $proof5#3860) (≞ (→ P R) (if (and (and (< 0 0.5) (and (<= (if (> 0 (if (< 1 (/ (- (+ 0.5 0.9) 1) 0.5)) 1 (/ (- (+ 0.5 0.9) 1) 0.5))) 0 (if (< 1 (/ (- (+ 0.5 0.9) 1) 0.5)) 1 (/ (- (+ 0.5 0.9) 1) 0.5))) $ABs#3865) (<= $ABs#3865 (if (> 0 (if (< 1 (/ 0.9 0.5)) 1 (/ 0.9 0.5))) 0 (if (< 1 (/ 0.9 0.5)) 1 (/ 0.9 0.5)))))) (and (< 0 0.9) (and (<= (if (> 0 (if (< 1 (/ (- (+ 0.9 0.7) 1) 0.9)) 1 (/ (- (+ 0.9 0.7) 1) 0.9))) 0 (if (< 1 (/ (- (+ 0.9 0.7) 1) 0.9)) 1 (/ (- (+ 0.9 0.7) 1) 0.9))) $QRs#3867) (<= $QRs#3867 (if (> 0 (if (< 1 (/ 0.7 0.9)) 1 (/ 0.7 0.9))) 0 (if (< 1 (/ 0.7 0.9)) 1 (/ 0.7 0.9))))))) (STV (if (< 0.9999 0.9) 0.7 (+ (* $ABs#3865 $QRs#3867) (/ (* (- 1 $ABs#3865) (- 0.7 (* 0.9 $QRs#3867))) (- 1 0.9)))) (min 0.1 (min 0.5 (min 0.3 (min $PQc#3871 $QRc#3872))))) (STV 1 0)))))]")
P;HTML|
;                                           (= 8  "1.96user 0.00system 0:01.97elapsed 100%CPU (0avgtext+0avgdata 43672maxresident)k")
P;HTML|
;                                           (= 8  "0inputs+0outputs (0major+6150minor)pagefaults 0swaps")
P;HTML|
;                                          (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/pln/dependent-types/DeductionDTLTest.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/pln/dependent-types/DeductionDTLTest.metta)

;;;; ;; Type definitions checker
;;;; !(pragma! type-check auto)
;;;; ;; Equality type definition
;;;; (: = (-> $t $t Type))
;;;; Import modules
<span class="ansi38-013099040"
>  !(import! &self DeductionDTL.metta)

</span>[P;HTML|
;                                           (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/pln/dependent-types/DeductionDTL.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/pln/dependent-types/DeductionDTL.metta)
P;HTML|
;                                           (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/pln/dependent-types/DeductionDTL.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/pln/dependent-types/DeductionDTL.metta)

;;;; TODO: fix the following
;;;;
;;;; SOLUTION: do partial evaluation where each substitution is
;;;; provable.  For instance: arguments are well typed for function
;;;; calls, conditions are proven to be true or false for conditionals,
;;;; etc.
;;;;
;;;; !(record synthesize ((: $proof (≞ (→ P R) (STV $s $c))) kb rb (S Z))) ; (: (Deduction Pm Qm Rm PQm QRm) (≞ (→ P R) (STV 0.8 0.1)))
;;;; MeTTa port for deduction PLN rule
;;;; as DTL (Dependent Type Language)
;;;;
;;;; (≞ P ptv)
;;;; (≞ Q qtv)
;;;; (≞ R rtv)
;;;; (≞ (→ P Q) tv1)
;;;; (≞ (→ Q R) tv2)
;;;; ⊢
;;;; (≞ (→ P R) TV)
;;;;
;;;; where ptv, qtv, rtv, tv1 and tv2 are truth values of the
;;;; premises P, Q, R, (→ P Q) and (→ Q R) respectively.
;;;; TV represents the resulting truth value of the conclusion.
;;;; Import modules
<span class="ansi38-013099040"
>  !(import! &self ../../common/truthvalue/MeasEq.metta)

</span>P;HTML|
;                                           (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/truthvalue/MeasEq.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/truthvalue/MeasEq.metta)
P;HTML|
;                                           (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/truthvalue/MeasEq.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/truthvalue/MeasEq.metta)

;;;; The symbol ≞, called Measured By in Unicode, and \measeq in LaTeX,
;;;; is used to represent the measure of an event.  This measure may be
;;;; boolean, probabilistic first or second order, evidential or
;;;; otherwise.  The idea of using a dedicated equality, as opposed to
;;;; regular definitional equality =, is to not conflate event and
;;;; measure which can lead to contradictions.
;;;; Define ≞ as a dependent type, assigning a truth value to an event.
<span class="ansi38-255165000"
>  (: ≞ 
    (-> $event $tv Type))
</span>
Deterministic: ()
<span class="ansi38-013099040"
>  !(import! &self ../../common/formula/DeductionFormula.metta)

</span>P;HTML|
;                                           (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/formula/DeductionFormula.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/formula/DeductionFormula.metta)
P;HTML|
;                                           (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/formula/DeductionFormula.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/formula/DeductionFormula.metta)

;;;; Formula and other functions used for the deduction rule
;;;; Import modules
<span class="ansi38-013099040"
>  !(import! &self ../truthvalue/TruthValue.metta)

</span>P;HTML|
;                                           (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/truthvalue/TruthValue.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/truthvalue/TruthValue.metta)
P;HTML|
;                                           (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/truthvalue/TruthValue.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/truthvalue/TruthValue.metta)

;;;; Truth value type definition
;;;; Import modules
<span class="ansi38-013099040"
>  !(import! &self ../Num.metta)

</span>P;HTML|
;                                           (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/Num.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/Num.metta)
P;HTML|
;                                           (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/Num.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/Num.metta)

;;;; Collection of functions operating on numbers
;;;; Define max
<span class="ansi38-255165000"
>  (: max 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (max $x $y) 
    (if 
      (> $x $y) $x $y))
</span>;;;; Define min
<span class="ansi38-255165000"
>  (: min 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (min $x $y) 
    (if 
      (< $x $y) $x $y))
</span>;;;; Clamp a number to be within a certain range
<span class="ansi38-255165000"
>  (: clamp 
    (-> $a $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (clamp $x $l $u) 
    (max $l 
      (min $u $x)))
</span>;;;; Define abs
<span class="ansi38-255165000"
>  (: abs 
    (-> $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (abs $x) 
    (if 
      (< $x 0) 
      (* -1 $x) $x))
</span>;;;; Define <=
<span class="ansi38-255165000"
>  (: <= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (<= $x $y) 
    (or 
      (< $x $y) 
      (== $x $y)))
</span>;;;; Define >=
<span class="ansi38-255165000"
>  (: >= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (>= $x $y) 
    (or 
      (> $x $y) 
      (== $x $y)))
</span>;;;; Define approximately equal
<span class="ansi38-255165000"
>  (: approxEq 
    (-> $a $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (approxEq $x $y $epsilon) 
    (<= 
      (abs (- $x $y)) $epsilon))
</span>;;;; Define Nat
<span class="ansi38-255165000"
>  (: Nat Type)
</span><span class="ansi38-255165000"
>  (: Z Nat)
</span><span class="ansi38-255165000"
>  (: S 
    (-> Nat Nat))
</span>;;;; Define cast functions between Nat and Number
<span class="ansi38-255165000"
>  (: fromNumber 
    (-> Number Nat))
</span><span class="ansi38-255165000"
>  (= 
    (fromNumber $n) 
    (if 
      (<= $n 0) Z 
      (S (fromNumber (- $n 1)))))
</span><span class="ansi38-255165000"
>  (: fromNat 
    (-> Nat Number))
</span><span class="ansi38-255165000"
>  (= 
    (fromNat Z) 0)
</span><span class="ansi38-255165000"
>  (= 
    (fromNat (S $k)) 
    (+ 1 
      (fromNat $k)))
</span>;;;; Define a generic less than operator, ⩻, for Nat.  < cannot be used
;;;; because it is a built-in, its type is hardwired and cannot be
;;;; overloaded.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Nat Nat Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $ Z) False)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ Z 
      (S $)) True)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ 
      (S $x) 
      (S $y)) 
    (⩻ $x $y))
</span>;;;; Overload ⩻ for Number.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Number Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $x $y) 
    (< $x $y))
</span>;;;; Return the ceiling of a non negative number.  If the number is
;;;; negative it returns 1.
<span class="ansi38-255165000"
>  (: ceil 
    (-> Number Number))
</span><span class="ansi38-255165000"
>  (= 
    (ceil $n) 
    (fromNat (fromNumber $n)))
</span>;;;; Convert Number to Bool.  Anything above 0 converts to True.
<span class="ansi38-255165000"
>  (: number->bool 
    (-> Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (number->bool $x) 
    (< 0 $x))
</span>;;;; Convert Bool to Number.  False converts to 0, True converts to 1.
<span class="ansi38-255165000"
>  (: bool->number 
    (-> Bool Number))
</span><span class="ansi38-255165000"
>  (= 
    (bool->number False) 0)
</span><span class="ansi38-255165000"
>  (= 
    (bool->number True) 1)
</span>;;;; Define a less than type.  Note that it is purposefully different
;;;; than ⩻ as it is a type, not an operator.  Inhabitants of (⍃ x y)
;;;; are proofs that x ⩻ y == True.  For now ⍃ is only axiomatized for
;;;; Nat.
<span class="ansi38-255165000"
>  (: ⍃ 
    (-> $t $t Type))
</span>;;;; Zero is always less than the successor of something
<span class="ansi38-255165000"
>  (: 
    (zero-lt-succ-axiom) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (zero-lt-succ-axiom) 
    (: ZeroLTSucc 
      (⍃ Z 
        (S $k))))
</span>;;;; If x ⍃ y then (S x) ⍃ (S y)
<span class="ansi38-255165000"
>  (: 
    (succ-monotonicity-rule) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (succ-monotonicity-rule) 
    (: SuccMonotonicity 
      (-> 
        (⍃ $x $y) 
        (⍃ 
          (S $x) 
          (S $y)))))
</span>
Deterministic: ()
;;;;;;;;;;;;
;;;; Type ;;
;;;;;;;;;;;;
<span class="ansi38-255165000"
>  (: TruthValue Type)
</span>;;;;;;;;;;;;;;;;;;;;
;;;; Constructors ;;
;;;;;;;;;;;;;;;;;;;;
;;;; Boolean TV constructor
;;;; TODO: alternatively we could have (: ⊤ TruthValue) and (: ⊥ TruthValue)
<span class="ansi38-255165000"
>  (: Bl 
    (-> Bool TruthValue))
</span>;;;; First order probability TV constructor, i.e. mere probability.
<span class="ansi38-255165000"
>  (: Pr 
    (-> Number TruthValue))
</span>;;;; Simple Truth Value.  A Second order probability TV constructor,
;;;; i.e. probability and confidence.  The probability is in fact the
;;;; mode of the corresponding beta distribution.
<span class="ansi38-255165000"
>  (: STV 
    (-> Number Number TruthValue))
</span>;;;;;;;;;;;;;;;;;
;;;; Constants ;;
;;;;;;;;;;;;;;;;;
;;;; For now the underlying beta distributions have a Jeffreys prior,
;;;; i.e. the prior alpha and beta are 0.5.
<span class="ansi38-255165000"
>  (: prior-alpha 
    (-> Number))
</span><span class="ansi38-255165000"
>  (= 
    (prior-alpha) 0.5)
</span><span class="ansi38-255165000"
>  (: prior-beta 
    (-> Number))
</span><span class="ansi38-255165000"
>  (= 
    (prior-beta) 0.5)
</span>;;;; Lookahead
<span class="ansi38-255165000"
>  (: lookahead 
    (-> Number))
</span><span class="ansi38-255165000"
>  (= 
    (lookahead) 1.0)
</span>;;;; Maximum supported count (till +inf is supported, possibly).
<span class="ansi38-255165000"
>  (: max-count 
    (-> Number))
</span><span class="ansi38-255165000"
>  (= 
    (max-count) 1000000000.0)
</span>;;;;;;;;;;;;;;;
;;;; Methods ;;
;;;;;;;;;;;;;;;
;;;; Convert count to confidence using the formula
;;;;
;;;; confidence = count / (count + lookahead)
<span class="ansi38-255165000"
>  (: count->confidence 
    (-> Number Number))
</span><span class="ansi38-255165000"
>  (= 
    (count->confidence $cnt) 
    (/ $cnt 
      (+ $cnt 
        (lookahead))))
</span>;;;; Convert confidence to count using the formula
;;;;
;;;; count = (confidence * lookahead) / (1 - confidence)
<span class="ansi38-255165000"
>  (: confidence->count 
    (-> Number Number))
</span><span class="ansi38-255165000"
>  (= 
    (confidence->count $conf) 
    (if 
      (approxEq 1.0 $conf 1.0e-9) 
      (max-count) 
      (/ 
        (* $conf 
          (lookahead)) 
        (- 1.0 $conf))))
</span>;;;; Increment the negative count of a given truth value, by
;;;; incrementing its total count without incrementing the positive
;;;; count.
<span class="ansi38-255165000"
>  (: inc-neg-count 
    (-> TruthValue TruthValue))
</span><span class="ansi38-255165000"
>  (= 
    (inc-neg-count (STV $s $c)) 
    (let* 
      ( ($tot_cnt (confidence->count $c)) 
        ($pos_cnt (* $s $tot_cnt)) 
        ($new_tot_cnt (+ $tot_cnt 1))) 
      (STV 
        (/ $pos_cnt $new_tot_cnt) 
        (count->confidence $new_tot_cnt))))
</span>;;;; Increment the positive count of a given truth value, by
;;;; incrementing its total count and its positive count.
<span class="ansi38-255165000"
>  (: inc-pos-count 
    (-> TruthValue TruthValue))
</span><span class="ansi38-255165000"
>  (= 
    (inc-pos-count (STV $s $c)) 
    (let* 
      ( ($tot_cnt (confidence->count $c)) 
        ($pos_cnt (* $s $tot_cnt)) 
        ($new_pos_cnt (+ $pos_cnt 1)) 
        ($new_tot_cnt (+ $tot_cnt 1))) 
      (STV 
        (/ $new_pos_cnt $new_tot_cnt) 
        (count->confidence $new_tot_cnt))))
</span>;;;; Return the first order probability mode of the second order
;;;; distribution associated to a truth value.
<span class="ansi38-255165000"
>  (: mode 
    (-> TruthValue Number))
</span><span class="ansi38-255165000"
>  (= 
    (mode (Bl True)) 1.0)
</span><span class="ansi38-255165000"
>  (= 
    (mode (Bl False)) 0.0)
</span><span class="ansi38-255165000"
>  (= 
    (mode (Pr $pr)) $pr)
</span><span class="ansi38-255165000"
>  (= 
    (mode (STV $pr $)) $pr)
</span>;;;; Return the total count of a truth value.  For truth values not
;;;; capturing a notion of confidence, such as Bl or Pr then the count
;;;; is assumed to be a very large number (cause +inf does not seem to
;;;; be supported at the moment).
<span class="ansi38-255165000"
>  (: count 
    (-> TruthValue Number))
</span><span class="ansi38-255165000"
>  (= 
    (count (Bl $)) 
    (max-count))
</span><span class="ansi38-255165000"
>  (= 
    (count (Pr $)) 
    (max-count))
</span><span class="ansi38-255165000"
>  (= 
    (count (STV $ $conf)) 
    (confidence->count $conf))
</span>;;;; Return the confidence of a truth value.  For truth values not
;;;; capturing a notion of confidence, such as Bl or Pr then the
;;;; confidence is assumed to be 1.0.  For truth values capturing a
;;;; notion of confidence, such as STV, the formula to convert a count
;;;; into confidence is as follows
;;;;
;;;; confidence = count / (count + lookahead)
<span class="ansi38-255165000"
>  (: confidence 
    (-> TruthValue Number))
</span><span class="ansi38-255165000"
>  (= 
    (confidence (Bl $)) 1.0)
</span><span class="ansi38-255165000"
>  (= 
    (confidence (Pr $)) 1.0)
</span><span class="ansi38-255165000"
>  (= 
    (confidence (STV $ $conf)) $conf)
</span>;;;; Return the positive count of a truth value.
<span class="ansi38-255165000"
>  (: pos-count 
    (-> TruthValue Number))
</span><span class="ansi38-255165000"
>  (= 
    (pos-count $tv) 
    (* 
      (mode $tv) 
      (count $tv)))
</span>;;;; Return the negative count of a truth value.
<span class="ansi38-255165000"
>  (: neg-count 
    (-> TruthValue Number))
</span><span class="ansi38-255165000"
>  (= 
    (neg-count $tv) 
    (* 
      (- 1 
        (mode $tv)) 
      (count $tv)))
</span>;;;; Return the posterior alpha of a truth value
<span class="ansi38-255165000"
>  (: post-alpha 
    (-> TruthValue Number))
</span><span class="ansi38-255165000"
>  (= 
    (post-alpha $tv) 
    (+ 
      (prior-alpha) 
      (pos-count $tv)))
</span>;;;; Return the posterior beta of a truth value
<span class="ansi38-255165000"
>  (: post-beta 
    (-> TruthValue Number))
</span><span class="ansi38-255165000"
>  (= 
    (post-beta $tv) 
    (+ 
      (prior-beta) 
      (neg-count $tv)))
</span>;;;; Return the first order probability mean of the second order
;;;; distribution associated to a truth value.  For truth values not
;;;; capturing a notion of confidence, such as Bl or Pr then the
;;;; confidence is assumed to be 1.0.  For truth values capturing a
;;;; notion of confidence, such as STV, a beta distribution is assumed.
<span class="ansi38-255165000"
>  (: mean 
    (-> TruthValue Number))
</span><span class="ansi38-255165000"
>  (= 
    (mean (Bl True)) 1.0)
</span><span class="ansi38-255165000"
>  (= 
    (mean (Bl False)) 0.0)
</span><span class="ansi38-255165000"
>  (= 
    (mean (Pr $pr)) $pr)
</span><span class="ansi38-255165000"
>  (= 
    (mean (STV $pr $conf)) 
    (let* 
      ( ($a (post-alpha (STV $pr $conf))) ($b (post-beta (STV $pr $conf)))) 
      (/ $a 
        (+ $a $b))))
</span>
Last Result(2): ()
<span class="ansi38-013099040"
>  !(import! &self ../Num.metta)

</span>P;HTML|
;                                           (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/Num.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/Num.metta)
P;HTML|
;                                           (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/Num.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/Num.metta)

;;;; Collection of functions operating on numbers
;;;; Define max
<span class="ansi38-255165000"
>  (: max 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (max $x $y) 
    (if 
      (> $x $y) $x $y))
</span>;;;; Define min
<span class="ansi38-255165000"
>  (: min 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (min $x $y) 
    (if 
      (< $x $y) $x $y))
</span>;;;; Clamp a number to be within a certain range
<span class="ansi38-255165000"
>  (: clamp 
    (-> $a $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (clamp $x $l $u) 
    (max $l 
      (min $u $x)))
</span>;;;; Define abs
<span class="ansi38-255165000"
>  (: abs 
    (-> $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (abs $x) 
    (if 
      (< $x 0) 
      (* -1 $x) $x))
</span>;;;; Define <=
<span class="ansi38-255165000"
>  (: <= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (<= $x $y) 
    (or 
      (< $x $y) 
      (== $x $y)))
</span>;;;; Define >=
<span class="ansi38-255165000"
>  (: >= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (>= $x $y) 
    (or 
      (> $x $y) 
      (== $x $y)))
</span>;;;; Define approximately equal
<span class="ansi38-255165000"
>  (: approxEq 
    (-> $a $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (approxEq $x $y $epsilon) 
    (<= 
      (abs (- $x $y)) $epsilon))
</span>;;;; Define Nat
<span class="ansi38-255165000"
>  (: Nat Type)
</span><span class="ansi38-255165000"
>  (: Z Nat)
</span><span class="ansi38-255165000"
>  (: S 
    (-> Nat Nat))
</span>;;;; Define cast functions between Nat and Number
<span class="ansi38-255165000"
>  (: fromNumber 
    (-> Number Nat))
</span><span class="ansi38-255165000"
>  (= 
    (fromNumber $n) 
    (if 
      (<= $n 0) Z 
      (S (fromNumber (- $n 1)))))
</span><span class="ansi38-255165000"
>  (: fromNat 
    (-> Nat Number))
</span><span class="ansi38-255165000"
>  (= 
    (fromNat Z) 0)
</span><span class="ansi38-255165000"
>  (= 
    (fromNat (S $k)) 
    (+ 1 
      (fromNat $k)))
</span>;;;; Define a generic less than operator, ⩻, for Nat.  < cannot be used
;;;; because it is a built-in, its type is hardwired and cannot be
;;;; overloaded.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Nat Nat Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $ Z) False)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ Z 
      (S $)) True)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ 
      (S $x) 
      (S $y)) 
    (⩻ $x $y))
</span>;;;; Overload ⩻ for Number.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Number Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $x $y) 
    (< $x $y))
</span>;;;; Return the ceiling of a non negative number.  If the number is
;;;; negative it returns 1.
<span class="ansi38-255165000"
>  (: ceil 
    (-> Number Number))
</span><span class="ansi38-255165000"
>  (= 
    (ceil $n) 
    (fromNat (fromNumber $n)))
</span>;;;; Convert Number to Bool.  Anything above 0 converts to True.
<span class="ansi38-255165000"
>  (: number->bool 
    (-> Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (number->bool $x) 
    (< 0 $x))
</span>;;;; Convert Bool to Number.  False converts to 0, True converts to 1.
<span class="ansi38-255165000"
>  (: bool->number 
    (-> Bool Number))
</span><span class="ansi38-255165000"
>  (= 
    (bool->number False) 0)
</span><span class="ansi38-255165000"
>  (= 
    (bool->number True) 1)
</span>;;;; Define a less than type.  Note that it is purposefully different
;;;; than ⩻ as it is a type, not an operator.  Inhabitants of (⍃ x y)
;;;; are proofs that x ⩻ y == True.  For now ⍃ is only axiomatized for
;;;; Nat.
<span class="ansi38-255165000"
>  (: ⍃ 
    (-> $t $t Type))
</span>;;;; Zero is always less than the successor of something
<span class="ansi38-255165000"
>  (: 
    (zero-lt-succ-axiom) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (zero-lt-succ-axiom) 
    (: ZeroLTSucc 
      (⍃ Z 
        (S $k))))
</span>;;;; If x ⍃ y then (S x) ⍃ (S y)
<span class="ansi38-255165000"
>  (: 
    (succ-monotonicity-rule) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (succ-monotonicity-rule) 
    (: SuccMonotonicity 
      (-> 
        (⍃ $x $y) 
        (⍃ 
          (S $x) 
          (S $y)))))
</span>;;;; Collection of functions operating on numbers
;;;; Define max
<span class="ansi38-255165000"
>  (: max 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (max $x $y) 
    (if 
      (> $x $y) $x $y))
</span>;;;; Define min
<span class="ansi38-255165000"
>  (: min 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (min $x $y) 
    (if 
      (< $x $y) $x $y))
</span>;;;; Clamp a number to be within a certain range
<span class="ansi38-255165000"
>  (: clamp 
    (-> $a $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (clamp $x $l $u) 
    (max $l 
      (min $u $x)))
</span>;;;; Define abs
<span class="ansi38-255165000"
>  (: abs 
    (-> $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (abs $x) 
    (if 
      (< $x 0) 
      (* -1 $x) $x))
</span>;;;; Define <=
<span class="ansi38-255165000"
>  (: <= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (<= $x $y) 
    (or 
      (< $x $y) 
      (== $x $y)))
</span>;;;; Define >=
<span class="ansi38-255165000"
>  (: >= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (>= $x $y) 
    (or 
      (> $x $y) 
      (== $x $y)))
</span>;;;; Define approximately equal
<span class="ansi38-255165000"
>  (: approxEq 
    (-> $a $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (approxEq $x $y $epsilon) 
    (<= 
      (abs (- $x $y)) $epsilon))
</span>;;;; Define Nat
<span class="ansi38-255165000"
>  (: Nat Type)
</span><span class="ansi38-255165000"
>  (: Z Nat)
</span><span class="ansi38-255165000"
>  (: S 
    (-> Nat Nat))
</span>;;;; Define cast functions between Nat and Number
<span class="ansi38-255165000"
>  (: fromNumber 
    (-> Number Nat))
</span><span class="ansi38-255165000"
>  (= 
    (fromNumber $n) 
    (if 
      (<= $n 0) Z 
      (S (fromNumber (- $n 1)))))
</span><span class="ansi38-255165000"
>  (: fromNat 
    (-> Nat Number))
</span><span class="ansi38-255165000"
>  (= 
    (fromNat Z) 0)
</span><span class="ansi38-255165000"
>  (= 
    (fromNat (S $k)) 
    (+ 1 
      (fromNat $k)))
</span>;;;; Define a generic less than operator, ⩻, for Nat.  < cannot be used
;;;; because it is a built-in, its type is hardwired and cannot be
;;;; overloaded.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Nat Nat Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $ Z) False)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ Z 
      (S $)) True)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ 
      (S $x) 
      (S $y)) 
    (⩻ $x $y))
</span>;;;; Overload ⩻ for Number.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Number Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $x $y) 
    (< $x $y))
</span>;;;; Return the ceiling of a non negative number.  If the number is
;;;; negative it returns 1.
<span class="ansi38-255165000"
>  (: ceil 
    (-> Number Number))
</span><span class="ansi38-255165000"
>  (= 
    (ceil $n) 
    (fromNat (fromNumber $n)))
</span>;;;; Convert Number to Bool.  Anything above 0 converts to True.
<span class="ansi38-255165000"
>  (: number->bool 
    (-> Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (number->bool $x) 
    (< 0 $x))
</span>;;;; Convert Bool to Number.  False converts to 0, True converts to 1.
<span class="ansi38-255165000"
>  (: bool->number 
    (-> Bool Number))
</span><span class="ansi38-255165000"
>  (= 
    (bool->number False) 0)
</span><span class="ansi38-255165000"
>  (= 
    (bool->number True) 1)
</span>;;;; Define a less than type.  Note that it is purposefully different
;;;; than ⩻ as it is a type, not an operator.  Inhabitants of (⍃ x y)
;;;; are proofs that x ⩻ y == True.  For now ⍃ is only axiomatized for
;;;; Nat.
<span class="ansi38-255165000"
>  (: ⍃ 
    (-> $t $t Type))
</span>;;;; Zero is always less than the successor of something
<span class="ansi38-255165000"
>  (: 
    (zero-lt-succ-axiom) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (zero-lt-succ-axiom) 
    (: ZeroLTSucc 
      (⍃ Z 
        (S $k))))
</span>;;;; If x ⍃ y then (S x) ⍃ (S y)
<span class="ansi38-255165000"
>  (: 
    (succ-monotonicity-rule) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (succ-monotonicity-rule) 
    (: SuccMonotonicity 
      (-> 
        (⍃ $x $y) 
        (⍃ 
          (S $x) 
          (S $y)))))
</span>
Deterministic: ()
;;; Consistency Conditions
<span class="ansi38-255165000"
>  (: smallest-intersection-probability 
    (-> Number Number Number))
</span><span class="ansi38-255165000"
>  (= 
    (smallest-intersection-probability $As $Bs) 
    (clamp 
      (/ 
        (- 
          (+ $As $Bs) 1) $As) 0 1))
</span><span class="ansi38-255165000"
>  (: largest-intersection-probability 
    (-> Number Number Number))
</span><span class="ansi38-255165000"
>  (= 
    (largest-intersection-probability $As $Bs) 
    (clamp 
      (/ $Bs $As) 0 1))
</span><span class="ansi38-255165000"
>  (: conditional-probability-consistency 
    (-> Number Number Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (conditional-probability-consistency $As $Bs $ABs) 
    (and 
      (< 0 $As) 
      (and 
        (<= 
          (smallest-intersection-probability $As $Bs) $ABs) 
        (<= $ABs 
          (largest-intersection-probability $As $Bs)))))
</span>;;;; Main Formula
<span class="ansi38-255165000"
>  (: simple-deduction-strength-formula 
    (-> Number Number Number Number Number Number))
</span>;;;; Preconditions are met
;;;; sB tends to 1
;;;; otherwise
;;;; Preconditions are not met
<span class="ansi38-255165000"
>  (= 
    (simple-deduction-strength-formula $As $Bs $Cs $ABs $BCs) 
    (if 
      (and 
        (conditional-probability-consistency $As $Bs $ABs) 
        (conditional-probability-consistency $Bs $Cs $BCs)) 
      (if 
        (< 0.99 $Bs) $Cs 
        (+ 
          (* $ABs $BCs) 
          (/ 
            (* 
              (- 1 $ABs) 
              (- $Cs 
                (* $Bs $BCs))) 
            (- 1 $Bs)))) 0))
</span>;;;; Alternate deduction formula hardwired for STV to make it faster.
;;;; Preconditions are met
;;; avoid division by 0
;;;; Qs tends to 1
;;;; Otherwise
;;;; Preconditions are not met
<span class="ansi38-255165000"
>  (= 
    (deduction-formula 
      (STV $Ps $Pc) 
      (STV $Qs $Qc) 
      (STV $Rs $Rc) 
      (STV $PQs $PQc) 
      (STV $QRs $QRc)) 
    (if 
      (and 
        (conditional-probability-consistency $Ps $Qs $PQs) 
        (conditional-probability-consistency $Qs $Rs $QRs)) 
      (STV 
        (if 
          (< 0.9999 $Qs) $Rs 
          (+ 
            (* $PQs $QRs) 
            (/ 
              (* 
                (- 1 $PQs) 
                (- $Rs 
                  (* $Qs $QRs))) 
              (- 1 $Qs)))) 
        (min $Pc 
          (min $Qc 
            (min $Rc 
              (min $PQc $QRc))))) 
      (STV 1 0)))
</span>
Last Result(2): ()
;;;; Define deduction rule
<span class="ansi38-255165000"
>  (: deduction-rule 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (deduction-rule) 
    (: Deduction 
      (-> 
        (≞ $p $ptv) 
        (≞ $q $qtv) 
        (≞ $r $rtv) 
        (≞ 
          (→ $p $q) $pqtv) 
        (≞ 
          (→ $q $r) $qrtv) 
        (≞ 
          (→ $p $r) 
          (deduction-formula $ptv $qtv $rtv $pqtv $qrtv)))))
</span>
Last Result(3): ()
()]
<span class="ansi38-013099040"
>  !(import! &self ../../synthesis/Synthesize.metta)

</span>[P;HTML|
;                                           (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/synthesis/Synthesize.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/synthesis/Synthesize.metta)
P;HTML|
;                                           (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/synthesis/Synthesize.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/synthesis/Synthesize.metta)

;;;; Import modules
<span class="ansi38-013099040"
>  !(import! &self ../common/Num.metta)

</span>P;HTML|
;                                           (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/Num.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/Num.metta)
P;HTML|
;                                           (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/Num.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/Num.metta)

;;;; Collection of functions operating on numbers
;;;; Define max
<span class="ansi38-255165000"
>  (: max 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (max $x $y) 
    (if 
      (> $x $y) $x $y))
</span>;;;; Define min
<span class="ansi38-255165000"
>  (: min 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (min $x $y) 
    (if 
      (< $x $y) $x $y))
</span>;;;; Clamp a number to be within a certain range
<span class="ansi38-255165000"
>  (: clamp 
    (-> $a $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (clamp $x $l $u) 
    (max $l 
      (min $u $x)))
</span>;;;; Define abs
<span class="ansi38-255165000"
>  (: abs 
    (-> $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (abs $x) 
    (if 
      (< $x 0) 
      (* -1 $x) $x))
</span>;;;; Define <=
<span class="ansi38-255165000"
>  (: <= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (<= $x $y) 
    (or 
      (< $x $y) 
      (== $x $y)))
</span>;;;; Define >=
<span class="ansi38-255165000"
>  (: >= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (>= $x $y) 
    (or 
      (> $x $y) 
      (== $x $y)))
</span>;;;; Define approximately equal
<span class="ansi38-255165000"
>  (: approxEq 
    (-> $a $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (approxEq $x $y $epsilon) 
    (<= 
      (abs (- $x $y)) $epsilon))
</span>;;;; Define Nat
<span class="ansi38-255165000"
>  (: Nat Type)
</span><span class="ansi38-255165000"
>  (: Z Nat)
</span><span class="ansi38-255165000"
>  (: S 
    (-> Nat Nat))
</span>;;;; Define cast functions between Nat and Number
<span class="ansi38-255165000"
>  (: fromNumber 
    (-> Number Nat))
</span><span class="ansi38-255165000"
>  (= 
    (fromNumber $n) 
    (if 
      (<= $n 0) Z 
      (S (fromNumber (- $n 1)))))
</span><span class="ansi38-255165000"
>  (: fromNat 
    (-> Nat Number))
</span><span class="ansi38-255165000"
>  (= 
    (fromNat Z) 0)
</span><span class="ansi38-255165000"
>  (= 
    (fromNat (S $k)) 
    (+ 1 
      (fromNat $k)))
</span>;;;; Define a generic less than operator, ⩻, for Nat.  < cannot be used
;;;; because it is a built-in, its type is hardwired and cannot be
;;;; overloaded.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Nat Nat Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $ Z) False)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ Z 
      (S $)) True)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ 
      (S $x) 
      (S $y)) 
    (⩻ $x $y))
</span>;;;; Overload ⩻ for Number.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Number Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $x $y) 
    (< $x $y))
</span>;;;; Return the ceiling of a non negative number.  If the number is
;;;; negative it returns 1.
<span class="ansi38-255165000"
>  (: ceil 
    (-> Number Number))
</span><span class="ansi38-255165000"
>  (= 
    (ceil $n) 
    (fromNat (fromNumber $n)))
</span>;;;; Convert Number to Bool.  Anything above 0 converts to True.
<span class="ansi38-255165000"
>  (: number->bool 
    (-> Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (number->bool $x) 
    (< 0 $x))
</span>;;;; Convert Bool to Number.  False converts to 0, True converts to 1.
<span class="ansi38-255165000"
>  (: bool->number 
    (-> Bool Number))
</span><span class="ansi38-255165000"
>  (= 
    (bool->number False) 0)
</span><span class="ansi38-255165000"
>  (= 
    (bool->number True) 1)
</span>;;;; Define a less than type.  Note that it is purposefully different
;;;; than ⩻ as it is a type, not an operator.  Inhabitants of (⍃ x y)
;;;; are proofs that x ⩻ y == True.  For now ⍃ is only axiomatized for
;;;; Nat.
<span class="ansi38-255165000"
>  (: ⍃ 
    (-> $t $t Type))
</span>;;;; Zero is always less than the successor of something
<span class="ansi38-255165000"
>  (: 
    (zero-lt-succ-axiom) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (zero-lt-succ-axiom) 
    (: ZeroLTSucc 
      (⍃ Z 
        (S $k))))
</span>;;;; If x ⍃ y then (S x) ⍃ (S y)
<span class="ansi38-255165000"
>  (: 
    (succ-monotonicity-rule) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (succ-monotonicity-rule) 
    (: SuccMonotonicity 
      (-> 
        (⍃ $x $y) 
        (⍃ 
          (S $x) 
          (S $y)))))
</span>;;;; Collection of functions operating on numbers
;;;; Define max
<span class="ansi38-255165000"
>  (: max 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (max $x $y) 
    (if 
      (> $x $y) $x $y))
</span>;;;; Define min
<span class="ansi38-255165000"
>  (: min 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (min $x $y) 
    (if 
      (< $x $y) $x $y))
</span>;;;; Clamp a number to be within a certain range
<span class="ansi38-255165000"
>  (: clamp 
    (-> $a $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (clamp $x $l $u) 
    (max $l 
      (min $u $x)))
</span>;;;; Define abs
<span class="ansi38-255165000"
>  (: abs 
    (-> $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (abs $x) 
    (if 
      (< $x 0) 
      (* -1 $x) $x))
</span>;;;; Define <=
<span class="ansi38-255165000"
>  (: <= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (<= $x $y) 
    (or 
      (< $x $y) 
      (== $x $y)))
</span>;;;; Define >=
<span class="ansi38-255165000"
>  (: >= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (>= $x $y) 
    (or 
      (> $x $y) 
      (== $x $y)))
</span>;;;; Define approximately equal
<span class="ansi38-255165000"
>  (: approxEq 
    (-> $a $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (approxEq $x $y $epsilon) 
    (<= 
      (abs (- $x $y)) $epsilon))
</span>;;;; Define Nat
<span class="ansi38-255165000"
>  (: Nat Type)
</span><span class="ansi38-255165000"
>  (: Z Nat)
</span><span class="ansi38-255165000"
>  (: S 
    (-> Nat Nat))
</span>;;;; Define cast functions between Nat and Number
<span class="ansi38-255165000"
>  (: fromNumber 
    (-> Number Nat))
</span><span class="ansi38-255165000"
>  (= 
    (fromNumber $n) 
    (if 
      (<= $n 0) Z 
      (S (fromNumber (- $n 1)))))
</span><span class="ansi38-255165000"
>  (: fromNat 
    (-> Nat Number))
</span><span class="ansi38-255165000"
>  (= 
    (fromNat Z) 0)
</span><span class="ansi38-255165000"
>  (= 
    (fromNat (S $k)) 
    (+ 1 
      (fromNat $k)))
</span>;;;; Define a generic less than operator, ⩻, for Nat.  < cannot be used
;;;; because it is a built-in, its type is hardwired and cannot be
;;;; overloaded.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Nat Nat Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $ Z) False)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ Z 
      (S $)) True)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ 
      (S $x) 
      (S $y)) 
    (⩻ $x $y))
</span>;;;; Overload ⩻ for Number.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Number Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $x $y) 
    (< $x $y))
</span>;;;; Return the ceiling of a non negative number.  If the number is
;;;; negative it returns 1.
<span class="ansi38-255165000"
>  (: ceil 
    (-> Number Number))
</span><span class="ansi38-255165000"
>  (= 
    (ceil $n) 
    (fromNat (fromNumber $n)))
</span>;;;; Convert Number to Bool.  Anything above 0 converts to True.
<span class="ansi38-255165000"
>  (: number->bool 
    (-> Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (number->bool $x) 
    (< 0 $x))
</span>;;;; Convert Bool to Number.  False converts to 0, True converts to 1.
<span class="ansi38-255165000"
>  (: bool->number 
    (-> Bool Number))
</span><span class="ansi38-255165000"
>  (= 
    (bool->number False) 0)
</span><span class="ansi38-255165000"
>  (= 
    (bool->number True) 1)
</span>;;;; Define a less than type.  Note that it is purposefully different
;;;; than ⩻ as it is a type, not an operator.  Inhabitants of (⍃ x y)
;;;; are proofs that x ⩻ y == True.  For now ⍃ is only axiomatized for
;;;; Nat.
<span class="ansi38-255165000"
>  (: ⍃ 
    (-> $t $t Type))
</span>;;;; Zero is always less than the successor of something
<span class="ansi38-255165000"
>  (: 
    (zero-lt-succ-axiom) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (zero-lt-succ-axiom) 
    (: ZeroLTSucc 
      (⍃ Z 
        (S $k))))
</span>;;;; If x ⍃ y then (S x) ⍃ (S y)
<span class="ansi38-255165000"
>  (: 
    (succ-monotonicity-rule) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (succ-monotonicity-rule) 
    (: SuccMonotonicity 
      (-> 
        (⍃ $x $y) 
        (⍃ 
          (S $x) 
          (S $y)))))
</span>;;;; Collection of functions operating on numbers
;;;; Define max
<span class="ansi38-255165000"
>  (: max 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (max $x $y) 
    (if 
      (> $x $y) $x $y))
</span>;;;; Define min
<span class="ansi38-255165000"
>  (: min 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (min $x $y) 
    (if 
      (< $x $y) $x $y))
</span>;;;; Clamp a number to be within a certain range
<span class="ansi38-255165000"
>  (: clamp 
    (-> $a $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (clamp $x $l $u) 
    (max $l 
      (min $u $x)))
</span>;;;; Define abs
<span class="ansi38-255165000"
>  (: abs 
    (-> $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (abs $x) 
    (if 
      (< $x 0) 
      (* -1 $x) $x))
</span>;;;; Define <=
<span class="ansi38-255165000"
>  (: <= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (<= $x $y) 
    (or 
      (< $x $y) 
      (== $x $y)))
</span>;;;; Define >=
<span class="ansi38-255165000"
>  (: >= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (>= $x $y) 
    (or 
      (> $x $y) 
      (== $x $y)))
</span>;;;; Define approximately equal
<span class="ansi38-255165000"
>  (: approxEq 
    (-> $a $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (approxEq $x $y $epsilon) 
    (<= 
      (abs (- $x $y)) $epsilon))
</span>;;;; Define Nat
<span class="ansi38-255165000"
>  (: Nat Type)
</span><span class="ansi38-255165000"
>  (: Z Nat)
</span><span class="ansi38-255165000"
>  (: S 
    (-> Nat Nat))
</span>;;;; Define cast functions between Nat and Number
<span class="ansi38-255165000"
>  (: fromNumber 
    (-> Number Nat))
</span><span class="ansi38-255165000"
>  (= 
    (fromNumber $n) 
    (if 
      (<= $n 0) Z 
      (S (fromNumber (- $n 1)))))
</span><span class="ansi38-255165000"
>  (: fromNat 
    (-> Nat Number))
</span><span class="ansi38-255165000"
>  (= 
    (fromNat Z) 0)
</span><span class="ansi38-255165000"
>  (= 
    (fromNat (S $k)) 
    (+ 1 
      (fromNat $k)))
</span>;;;; Define a generic less than operator, ⩻, for Nat.  < cannot be used
;;;; because it is a built-in, its type is hardwired and cannot be
;;;; overloaded.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Nat Nat Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $ Z) False)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ Z 
      (S $)) True)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ 
      (S $x) 
      (S $y)) 
    (⩻ $x $y))
</span>;;;; Overload ⩻ for Number.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Number Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $x $y) 
    (< $x $y))
</span>;;;; Return the ceiling of a non negative number.  If the number is
;;;; negative it returns 1.
<span class="ansi38-255165000"
>  (: ceil 
    (-> Number Number))
</span><span class="ansi38-255165000"
>  (= 
    (ceil $n) 
    (fromNat (fromNumber $n)))
</span>;;;; Convert Number to Bool.  Anything above 0 converts to True.
<span class="ansi38-255165000"
>  (: number->bool 
    (-> Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (number->bool $x) 
    (< 0 $x))
</span>;;;; Convert Bool to Number.  False converts to 0, True converts to 1.
<span class="ansi38-255165000"
>  (: bool->number 
    (-> Bool Number))
</span><span class="ansi38-255165000"
>  (= 
    (bool->number False) 0)
</span><span class="ansi38-255165000"
>  (= 
    (bool->number True) 1)
</span>;;;; Define a less than type.  Note that it is purposefully different
;;;; than ⩻ as it is a type, not an operator.  Inhabitants of (⍃ x y)
;;;; are proofs that x ⩻ y == True.  For now ⍃ is only axiomatized for
;;;; Nat.
<span class="ansi38-255165000"
>  (: ⍃ 
    (-> $t $t Type))
</span>;;;; Zero is always less than the successor of something
<span class="ansi38-255165000"
>  (: 
    (zero-lt-succ-axiom) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (zero-lt-succ-axiom) 
    (: ZeroLTSucc 
      (⍃ Z 
        (S $k))))
</span>;;;; If x ⍃ y then (S x) ⍃ (S y)
<span class="ansi38-255165000"
>  (: 
    (succ-monotonicity-rule) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (succ-monotonicity-rule) 
    (: SuccMonotonicity 
      (-> 
        (⍃ $x $y) 
        (⍃ 
          (S $x) 
          (S $y)))))
</span>
Deterministic: ()
;;;; !(import! &self Unify.metta)
;;;; Enumerate all programs up to a given depth that are consistent with
;;;; the query, using the given axiom non-deterministic functions and rules.
;;;;
;;;; The arguments are:
;;;;
;;;; $query: an Atom under the form (: TERM TYPE).  The atom may contain
;;;;         free variables within TERM and TYPE to form various sort of
;;;;         queries, such as:
;;;;         1. Backward chaining: (: $term (Inheritance $x Mammal))
;;;;         2. Forward chaining: (: ($rule $premise AXIOM) $type)
;;;;         3. Mixed chaining: (: ($rule $premise AXIOM) (Inheritance $x Mammal))
;;;;         4. Type checking: (: TERM TYPE)
;;;;         5. Type inference: (: TERM $type)
;;;;
;;;; $kb: a nullary function to axiom, to non-deterministically pick up
;;;;      an axiom.  An axiom is an Atom of the form (: TERM TYPE).
;;;;
;;;; $rb: a nullary function to rule, to non-deterministically pick up a
;;;;      rule.  A rule is a function mapping premises to conclusion,
;;;;      where premises and conclusion have the form (: TERM TYPE).
;;;;
;;;; $depth: a Nat representing the maximum depth of the generated
;;;;         programs.
;;;;
;;;; TODO: recurse over curried rules instead of duplicating code over
;;;; tuples.
<span class="ansi38-255165000"
>  (: synthesize 
    (-> $a 
      (-> $kt) 
      (-> $rt) Nat $a))
</span>;;;; Nullary rule (axiom)
<span class="ansi38-255165000"
>  (= 
    (synthesize $query $kb $rb $depth) 
    (let $query 
      ($kb) $query))
</span>;;;; Unary rule
<span class="ansi38-255165000"
>  (= 
    (synthesize $query $kb $rb 
      (S $k)) 
    (let* 
      ( ( (: $ructor 
            (-> $premise $conclusion)) ($rb)) 
        ( (: 
            ($ructor $proof) $conclusion) $query) 
        ( (: $proof $premise) (synthesize (: $proof $premise) $kb $rb $k))) $query))
</span>;;;; Binary rule
<span class="ansi38-255165000"
>  (= 
    (synthesize $query $kb $rb 
      (S $k)) 
    (let* 
      ( ( (: $ructor 
            (-> $premise1 $premise2 $conclusion)) ($rb)) 
        ( (: 
            ($ructor $proof1 $proof2) $conclusion) $query) 
        ( (: $proof1 $premise1) (synthesize (: $proof1 $premise1) $kb $rb $k)) 
        ( (: $proof2 $premise2) (synthesize (: $proof2 $premise2) $kb $rb $k))) $query))
</span>;;;; Trinary rule
<span class="ansi38-255165000"
>  (= 
    (synthesize $query $kb $rb 
      (S $k)) 
    (let* 
      ( ( (: $ructor 
            (-> $premise1 $premise2 $premise3 $conclusion)) ($rb)) 
        ( (: 
            ($ructor $proof1 $proof2 $proof3) $conclusion) $query) 
        ( (: $proof1 $premise1) (synthesize (: $proof1 $premise1) $kb $rb $k)) 
        ( (: $proof2 $premise2) (synthesize (: $proof2 $premise2) $kb $rb $k)) 
        ( (: $proof3 $premise3) (synthesize (: $proof3 $premise3) $kb $rb $k))) $query))
</span>;;;; Quaternary rule
<span class="ansi38-255165000"
>  (= 
    (synthesize $query $kb $rb 
      (S $k)) 
    (let* 
      ( ( (: $ructor 
            (-> $premise1 $premise2 $premise3 $premise4 $conclusion)) ($rb)) 
        ( (: 
            ($ructor $proof1 $proof2 $proof3 $proof4) $conclusion) $query) 
        ( (: $proof1 $premise1) (synthesize (: $proof1 $premise1) $kb $rb $k)) 
        ( (: $proof2 $premise2) (synthesize (: $proof2 $premise2) $kb $rb $k)) 
        ( (: $proof3 $premise3) (synthesize (: $proof3 $premise3) $kb $rb $k)) 
        ( (: $proof4 $premise4) (synthesize (: $proof4 $premise4) $kb $rb $k))) $query))
</span>;;;; Quintenary rule
<span class="ansi38-255165000"
>  (= 
    (synthesize $query $kb $rb 
      (S $k)) 
    (let* 
      ( ( (: $ructor 
            (-> $premise1 $premise2 $premise3 $premise4 $premise5 $conclusion)) ($rb)) 
        ( (: 
            ($ructor $proof1 $proof2 $proof3 $proof4 $proof5) $conclusion) $query) 
        ( (: $proof1 $premise1) (synthesize (: $proof1 $premise1) $kb $rb $k)) 
        ( (: $proof2 $premise2) (synthesize (: $proof2 $premise2) $kb $rb $k)) 
        ( (: $proof3 $premise3) (synthesize (: $proof3 $premise3) $kb $rb $k)) 
        ( (: $proof4 $premise4) (synthesize (: $proof4 $premise4) $kb $rb $k)) 
        ( (: $proof5 $premise5) (synthesize (: $proof5 $premise5) $kb $rb $k))) $query))
</span>
Last Result(2): ()
()]
<span class="ansi38-013099040"
>  !(import! &self ../../common/Record.metta)

</span>[P;HTML|
;                                           (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/Record.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/Record.metta)
P;HTML|
;                                           (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/Record.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/Record.metta)

;;;; Given a function call, produce records of that function call.
;;;; There can be multiple records with only one call due to the
;;;; non-determinism of MeTTa.  Each record is represented by (⊷ f x y)
;;;; which can be read as
;;;;
;;;; "under f, the image of x is y"
;;;;
;;;; It was chosen because it is described as IMAGE OF in UTF-8.  It is
;;;; the MeTTa equivalent of ExecutionLink in Atomese.  The character ⊷
;;;; has description: IMAGE OF, hexadecimal code: 0x22B7, unicode-math
;;;; code: \imageof and latex code: \multimapdotbothB.
<span class="ansi38-255165000"
>  (= 
    (record $f 
      ($arg)) 
    (⊷ $f $arg 
      ($f $arg)))
</span><span class="ansi38-255165000"
>  (= 
    (record $f 
      ($arg1 $arg2)) 
    (⊷ $f 
      ($arg1 $arg2) 
      ($f $arg1 $arg2)))
</span><span class="ansi38-255165000"
>  (= 
    (record $f 
      ($arg1 $arg2 $arg3)) 
    (⊷ $f 
      ($arg1 $arg2 $arg3) 
      ($f $arg1 $arg2 $arg3)))
</span><span class="ansi38-255165000"
>  (= 
    (record $f 
      ($arg1 $arg2 $arg3 $arg4)) 
    (⊷ $f 
      ($arg1 $arg2 $arg3 $arg4) 
      ($f $arg1 $arg2 $arg3 $arg4)))
</span>
Deterministic: ()
()]
;;;; Knowledge base
<span class="ansi38-255165000"
>  (: Predicate Type)
</span><span class="ansi38-255165000"
>  (: → 
    (-> Predicate Predicate Type))
</span><span class="ansi38-255165000"
>  (: P Predicate)
</span><span class="ansi38-255165000"
>  (: Q Predicate)
</span><span class="ansi38-255165000"
>  (: R Predicate)
</span><span class="ansi38-255165000"
>  (: kb 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (kb) 
    (superpose ((: Pm (≞ P (STV 0.5 0.1))) (: Qm (≞ Q (STV 0.6 0.2))) (: Rm (≞ R (STV 0.7 0.3))) (: PQm (≞ (→ P Q) (STV 0.8 0.4))) (: QRm (≞ (→ Q R) (STV 0.9 0.5))))))
</span>;;;; Rule base
<span class="ansi38-255165000"
>  (: rb 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (rb) 
    (deduction-rule))
</span>;;;; Test deduction rule
;;;;
;;;; Build the following inference tree
;;;;
;;;; ------------(Pm)  ----------(Qm)  ------------(Rm)  ------------  --(PQm)  ----------------(QRm)
;;;; P ≞ <0.5 0.1>     Q ≞ <0.6 0.2>   R ≞ <0.7 0.1>     P → Q ≞ <0.8 0.5>      Q → R ≞ <0.9 0.5>
;;;; -------------------------------------------------------------------------------------------(Deduction)
;;;;                                          P → R ≞ $tv
;;;; The following is disabled till the type checker supports running functions inside types
;;;; ! "===== Test type checker on deduction rule ====="
;;;; (: deduction_prf (≞ (→ P R) $tv))
;;;; (= deduction_prf (Deduction Pm Qm Rm PQm QRm))
;;;; !(deduction_prf)
;;;; !(get-type deduction_prf)
;;;; Test synthesizer
<span class="ansi38-255165009"
>;; In file as:  
</span><span class="ansi1 ansi38-255238088"
>  !=====
</span>;; To unit test case:
<span class="ansi38-013099040"
>  !(assertEqualToResult ===== 
    ("===== Test synthesizer ===="))

</span>[

;<h3 id="DEPENDENT-TYPES.DEDUCTIONDTLTEST.01"
>;; DEPENDENT-TYPES.DEDUCTIONDTLTEST.01</h3>
; 
; EVAL TEST
; took 0.000040 secs. (40.06 microseconds) 

  !(assertEqualToResult ===== 
    ("===== Test synthesizer ===="))

<span class="ansi31"
>  (loonit_failureR  
    (equal_enough_for_test  
      (=====) 
      ("===== Test synthesizer ====")))
</span>
Deterministic: ((Error  (got  (=====)) (expected  ("===== Test synthesizer ===="))))
((Error  (got  (=====)) (expected  ("===== Test synthesizer ===="))))]
<span class="ansi38-013099040"
>  !(assertEqual 
    (synthesize 
      (: $proof 
        (≞ 
          (→ P Q) $tv)) kb rb Z) 
    (: PQm 
      (≞ 
        (→ P Q) 
        (STV 0.8 0.4))))

</span>[

;<h3 id="DEPENDENT-TYPES.DEDUCTIONDTLTEST.02"
>;; DEPENDENT-TYPES.DEDUCTIONDTLTEST.02</h3>
; 
; EVAL TEST
; took 0.010 secs. (10.19 milliseconds) 

  !(assertEqual 
    (synthesize 
      (: $proof 
        (≞ 
          (→ P Q) $tv)) kb rb Z) 
    (: PQm 
      (≞ 
        (→ P Q) 
        (STV 0.8 0.4))))

<span class="ansi36"
>  (loonit_success  
    (equal_enough_for_test  
      ( (: PQm 
          (≞ 
            (→ P Q) 
            (STV 0.8 0.4)))) 
      ( (: PQm 
          (≞ 
            (→ P Q) 
            (STV 0.8 0.4))))))
</span>
Deterministic: ()
()]
<span class="ansi38-013099040"
>  !(assertEqual 
    (synthesize 
      (: $proof 
        (≞ 
          (→ Q R) $tv)) kb rb Z) 
    (: QRm 
      (≞ 
        (→ Q R) 
        (STV 0.9 0.5))))

</span>[

;<h3 id="DEPENDENT-TYPES.DEDUCTIONDTLTEST.03"
>;; DEPENDENT-TYPES.DEDUCTIONDTLTEST.03</h3>
; 
; EVAL TEST
; took 0.010 secs. (9.90 milliseconds) 

  !(assertEqual 
    (synthesize 
      (: $proof 
        (≞ 
          (→ Q R) $tv)) kb rb Z) 
    (: QRm 
      (≞ 
        (→ Q R) 
        (STV 0.9 0.5))))

<span class="ansi36"
>  (loonit_success  
    (equal_enough_for_test  
      ( (: QRm 
          (≞ 
            (→ Q R) 
            (STV 0.9 0.5)))) 
      ( (: QRm 
          (≞ 
            (→ Q R) 
            (STV 0.9 0.5))))))
</span>
Deterministic: ()
()]
;;;; Do not use assert because of all the incompleted reductions
<span class="ansi38-255165009"
>;; In file as:  
</span><span class="ansi1 ansi38-255238088"
>  !(synthesize 
    (: $proof 
      (≞ 
        (→ P R) $tv)) kb rb 
    (S Z))
</span>;; To unit test case:
<span class="ansi38-013099040"
>  !(assertEqualToResult 
    (synthesize 
      (: $proof 
        (≞ 
          (→ P R) $tv)) kb rb 
      (S Z)) 
    ( (let* 
        ( ( (: $proof4#3859 
              (≞ 
                (→ P P) 
                (STV $ABs#3865 $PQc#3871))) (synthesize (: $proof4#3859 (≞ (→ P P) (STV $ABs#3865 $PQc#3871))) kb rb Z)) ((: $proof5#3860 (≞ (→ P R) (STV $QRs#3867 $QRc#3872))) (synthesize (: $proof5#3860 (≞ (→ P R) (STV $QRs#3867 $QRc#3872))) kb rb Z))) 
        (: 
          (Deduction Pm Pm Rm $proof4#3859 $proof5#3860) 
          (≞ 
            (→ P R) 
            (if 
              (and 
                (and 
                  (< 0 0.5) 
                  (and 
                    (<= 
                      (if 
                        (> 0 
                          (if 
                            (< 1 
                              (/ 
                                (- 
                                  (+ 0.5 0.5) 1) 0.5)) 1 
                            (/ 
                              (- 
                                (+ 0.5 0.5) 1) 0.5))) 0 
                        (if 
                          (< 1 
                            (/ 
                              (- 
                                (+ 0.5 0.5) 1) 0.5)) 1 
                          (/ 
                            (- 
                              (+ 0.5 0.5) 1) 0.5))) $ABs#3865) 
                    (<= $ABs#3865 
                      (if 
                        (> 0 
                          (if 
                            (< 1 
                              (/ 0.5 0.5)) 1 
                            (/ 0.5 0.5))) 0 
                        (if 
                          (< 1 
                            (/ 0.5 0.5)) 1 
                          (/ 0.5 0.5)))))) 
                (and 
                  (< 0 0.5) 
                  (and 
                    (<= 
                      (if 
                        (> 0 
                          (if 
                            (< 1 
                              (/ 
                                (- 
                                  (+ 0.5 0.7) 1) 0.5)) 1 
                            (/ 
                              (- 
                                (+ 0.5 0.7) 1) 0.5))) 0 
                        (if 
                          (< 1 
                            (/ 
                              (- 
                                (+ 0.5 0.7) 1) 0.5)) 1 
                          (/ 
                            (- 
                              (+ 0.5 0.7) 1) 0.5))) $QRs#3867) 
                    (<= $QRs#3867 
                      (if 
                        (> 0 
                          (if 
                            (< 1 
                              (/ 0.7 0.5)) 1 
                            (/ 0.7 0.5))) 0 
                        (if 
                          (< 1 
                            (/ 0.7 0.5)) 1 
                          (/ 0.7 0.5))))))) 
              (STV 
                (if 
                  (< 0.9999 0.5) 0.7 
                  (+ 
                    (* $ABs#3865 $QRs#3867) 
                    (/ 
                      (* 
                        (- 1 $ABs#3865) 
                        (- 0.7 
                          (* 0.5 $QRs#3867))) 
                      (- 1 0.5)))) 
                (min 0.1 
                  (min 0.1 
                    (min 0.3 
                      (min $PQc#3871 $QRc#3872))))) 
              (STV 1 0))))) 
      (: 
        (Deduction Pm Qm Rm PQm QRm) 
        (≞ 
          (→ P R) 
          (STV 0.8 0.1))) 
      (let* 
        ( ( (: $proof4#3859 
              (≞ 
                (→ P R) 
                (STV $ABs#3865 $PQc#3871))) (synthesize (: $proof4#3859 (≞ (→ P R) (STV $ABs#3865 $PQc#3871))) kb rb Z)) ((: $proof5#3860 (≞ (→ R R) (STV $QRs#3867 $QRc#3872))) (synthesize (: $proof5#3860 (≞ (→ R R) (STV $QRs#3867 $QRc#3872))) kb rb Z))) 
        (: 
          (Deduction Pm Rm Rm $proof4#3859 $proof5#3860) 
          (≞ 
            (→ P R) 
            (if 
              (and 
                (and 
                  (< 0 0.5) 
                  (and 
                    (<= 
                      (if 
                        (> 0 
                          (if 
                            (< 1 
                              (/ 
                                (- 
                                  (+ 0.5 0.7) 1) 0.5)) 1 
                            (/ 
                              (- 
                                (+ 0.5 0.7) 1) 0.5))) 0 
                        (if 
                          (< 1 
                            (/ 
                              (- 
                                (+ 0.5 0.7) 1) 0.5)) 1 
                          (/ 
                            (- 
                              (+ 0.5 0.7) 1) 0.5))) $ABs#3865) 
                    (<= $ABs#3865 
                      (if 
                        (> 0 
                          (if 
                            (< 1 
                              (/ 0.7 0.5)) 1 
                            (/ 0.7 0.5))) 0 
                        (if 
                          (< 1 
                            (/ 0.7 0.5)) 1 
                          (/ 0.7 0.5)))))) 
                (and 
                  (< 0 0.7) 
                  (and 
                    (<= 
                      (if 
                        (> 0 
                          (if 
                            (< 1 
                              (/ 
                                (- 
                                  (+ 0.7 0.7) 1) 0.7)) 1 
                            (/ 
                              (- 
                                (+ 0.7 0.7) 1) 0.7))) 0 
                        (if 
                          (< 1 
                            (/ 
                              (- 
                                (+ 0.7 0.7) 1) 0.7)) 1 
                          (/ 
                            (- 
                              (+ 0.7 0.7) 1) 0.7))) $QRs#3867) 
                    (<= $QRs#3867 
                      (if 
                        (> 0 
                          (if 
                            (< 1 
                              (/ 0.7 0.7)) 1 
                            (/ 0.7 0.7))) 0 
                        (if 
                          (< 1 
                            (/ 0.7 0.7)) 1 
                          (/ 0.7 0.7))))))) 
              (STV 
                (if 
                  (< 0.9999 0.7) 0.7 
                  (+ 
                    (* $ABs#3865 $QRs#3867) 
                    (/ 
                      (* 
                        (- 1 $ABs#3865) 
                        (- 0.7 
                          (* 0.7 $QRs#3867))) 
                      (- 1 0.7)))) 
                (min 0.1 
                  (min 0.3 
                    (min 0.3 
                      (min $PQc#3871 $QRc#3872))))) 
              (STV 1 0))))) 
      (let* 
        ( ( (: $proof4#3859 
              (≞ 
                (→ P 
                  (→ P Q)) 
                (STV $ABs#3865 $PQc#3871))) (synthesize (: $proof4#3859 (≞ (→ P (→ P Q)) (STV $ABs#3865 $PQc#3871))) kb rb Z)) ((: $proof5#3860 (≞ (→ (→ P Q) R) (STV $QRs#3867 $QRc#3872))) (synthesize (: $proof5#3860 (≞ (→ (→ P Q) R) (STV $QRs#3867 $QRc#3872))) kb rb Z))) 
        (: 
          (Deduction Pm PQm Rm $proof4#3859 $proof5#3860) 
          (≞ 
            (→ P R) 
            (if 
              (and 
                (and 
                  (< 0 0.5) 
                  (and 
                    (<= 
                      (if 
                        (> 0 
                          (if 
                            (< 1 
                              (/ 
                                (- 
                                  (+ 0.5 0.8) 1) 0.5)) 1 
                            (/ 
                              (- 
                                (+ 0.5 0.8) 1) 0.5))) 0 
                        (if 
                          (< 1 
                            (/ 
                              (- 
                                (+ 0.5 0.8) 1) 0.5)) 1 
                          (/ 
                            (- 
                              (+ 0.5 0.8) 1) 0.5))) $ABs#3865) 
                    (<= $ABs#3865 
                      (if 
                        (> 0 
                          (if 
                            (< 1 
                              (/ 0.8 0.5)) 1 
                            (/ 0.8 0.5))) 0 
                        (if 
                          (< 1 
                            (/ 0.8 0.5)) 1 
                          (/ 0.8 0.5)))))) 
                (and 
                  (< 0 0.8) 
                  (and 
                    (<= 
                      (if 
                        (> 0 
                          (if 
                            (< 1 
                              (/ 
                                (- 
                                  (+ 0.8 0.7) 1) 0.8)) 1 
                            (/ 
                              (- 
                                (+ 0.8 0.7) 1) 0.8))) 0 
                        (if 
                          (< 1 
                            (/ 
                              (- 
                                (+ 0.8 0.7) 1) 0.8)) 1 
                          (/ 
                            (- 
                              (+ 0.8 0.7) 1) 0.8))) $QRs#3867) 
                    (<= $QRs#3867 
                      (if 
                        (> 0 
                          (if 
                            (< 1 
                              (/ 0.7 0.8)) 1 
                            (/ 0.7 0.8))) 0 
                        (if 
                          (< 1 
                            (/ 0.7 0.8)) 1 
                          (/ 0.7 0.8))))))) 
              (STV 
                (if 
                  (< 0.9999 0.8) 0.7 
                  (+ 
                    (* $ABs#3865 $QRs#3867) 
                    (/ 
                      (* 
                        (- 1 $ABs#3865) 
                        (- 0.7 
                          (* 0.8 $QRs#3867))) 
                      (- 1 0.8)))) 
                (min 0.1 
                  (min 0.4 
                    (min 0.3 
                      (min $PQc#3871 $QRc#3872))))) 
              (STV 1 0))))) 
      (let* 
        ( ( (: $proof4#3859 
              (≞ 
                (→ P 
                  (→ Q R)) 
                (STV $ABs#3865 $PQc#3871))) (synthesize (: $proof4#3859 (≞ (→ P (→ Q R)) (STV $ABs#3865 $PQc#3871))) kb rb Z)) ((: $proof5#3860 (≞ (→ (→ Q R) R) (STV $QRs#3867 $QRc#3872))) (synthesize (: $proof5#3860 (≞ (→ (→ Q R) R) (STV $QRs#3867 $QRc#3872))) kb rb Z))) 
        (: 
          (Deduction Pm QRm Rm $proof4#3859 $proof5#3860) 
          (≞ 
            (→ P R) 
            (if 
              (and 
                (and 
                  (< 0 0.5) 
                  (and 
                    (<= 
                      (if 
                        (> 0 
                          (if 
                            (< 1 
                              (/ 
                                (- 
                                  (+ 0.5 0.9) 1) 0.5)) 1 
                            (/ 
                              (- 
                                (+ 0.5 0.9) 1) 0.5))) 0 
                        (if 
                          (< 1 
                            (/ 
                              (- 
                                (+ 0.5 0.9) 1) 0.5)) 1 
                          (/ 
                            (- 
                              (+ 0.5 0.9) 1) 0.5))) $ABs#3865) 
                    (<= $ABs#3865 
                      (if 
                        (> 0 
                          (if 
                            (< 1 
                              (/ 0.9 0.5)) 1 
                            (/ 0.9 0.5))) 0 
                        (if 
                          (< 1 
                            (/ 0.9 0.5)) 1 
                          (/ 0.9 0.5)))))) 
                (and 
                  (< 0 0.9) 
                  (and 
                    (<= 
                      (if 
                        (> 0 
                          (if 
                            (< 1 
                              (/ 
                                (- 
                                  (+ 0.9 0.7) 1) 0.9)) 1 
                            (/ 
                              (- 
                                (+ 0.9 0.7) 1) 0.9))) 0 
                        (if 
                          (< 1 
                            (/ 
                              (- 
                                (+ 0.9 0.7) 1) 0.9)) 1 
                          (/ 
                            (- 
                              (+ 0.9 0.7) 1) 0.9))) $QRs#3867) 
                    (<= $QRs#3867 
                      (if 
                        (> 0 
                          (if 
                            (< 1 
                              (/ 0.7 0.9)) 1 
                            (/ 0.7 0.9))) 0 
                        (if 
                          (< 1 
                            (/ 0.7 0.9)) 1 
                          (/ 0.7 0.9))))))) 
              (STV 
                (if 
                  (< 0.9999 0.9) 0.7 
                  (+ 
                    (* $ABs#3865 $QRs#3867) 
                    (/ 
                      (* 
                        (- 1 $ABs#3865) 
                        (- 0.7 
                          (* 0.9 $QRs#3867))) 
                      (- 1 0.9)))) 
                (min 0.1 
                  (min 0.5 
                    (min 0.3 
                      (min $PQc#3871 $QRc#3872))))) 
              (STV 1 0)))))))

</span>[

;<h3 id="DEPENDENT-TYPES.DEDUCTIONDTLTEST.04"
>;; DEPENDENT-TYPES.DEDUCTIONDTLTEST.04</h3>
; 
; EVAL TEST
; took 0.151 secs. (151.14 milliseconds) 

  !(assertEqualToResult 
    (synthesize 
      (: $proof 
        (≞ 
          (→ P R) $tv)) kb rb 
      (S Z)) 
    ( (let* 
        ( ( (: $proof4#3859 
              (≞ 
                (→ P P) 
                (STV $ABs#3865 $PQc#3871))) (synthesize (: $proof4#3859 (≞ (→ P P) (STV $ABs#3865 $PQc#3871))) kb rb Z)) ((: $proof5#3860 (≞ (→ P R) (STV $QRs#3867 $QRc#3872))) (synthesize (: $proof5#3860 (≞ (→ P R) (STV $QRs#3867 $QRc#3872))) kb rb Z))) 
        (: 
          (Deduction Pm Pm Rm $proof4#3859 $proof5#3860) 
          (≞ 
            (→ P R) 
            (if 
              (and 
                (and 
                  (< 0 0.5) 
                  (and 
                    (<= 
                      (if 
                        (> 0 
                          (if 
                            (< 1 
                              (/ 
                                (- 
                                  (+ 0.5 0.5) 1) 0.5)) 1 
                            (/ 
                              (- 
                                (+ 0.5 0.5) 1) 0.5))) 0 
                        (if 
                          (< 1 
                            (/ 
                              (- 
                                (+ 0.5 0.5) 1) 0.5)) 1 
                          (/ 
                            (- 
                              (+ 0.5 0.5) 1) 0.5))) $ABs#3865) 
                    (<= $ABs#3865 
                      (if 
                        (> 0 
                          (if 
                            (< 1 
                              (/ 0.5 0.5)) 1 
                            (/ 0.5 0.5))) 0 
                        (if 
                          (< 1 
                            (/ 0.5 0.5)) 1 
                          (/ 0.5 0.5)))))) 
                (and 
                  (< 0 0.5) 
                  (and 
                    (<= 
                      (if 
                        (> 0 
                          (if 
                            (< 1 
                              (/ 
                                (- 
                                  (+ 0.5 0.7) 1) 0.5)) 1 
                            (/ 
                              (- 
                                (+ 0.5 0.7) 1) 0.5))) 0 
                        (if 
                          (< 1 
                            (/ 
                              (- 
                                (+ 0.5 0.7) 1) 0.5)) 1 
                          (/ 
                            (- 
                              (+ 0.5 0.7) 1) 0.5))) $QRs#3867) 
                    (<= $QRs#3867 
                      (if 
                        (> 0 
                          (if 
                            (< 1 
                              (/ 0.7 0.5)) 1 
                            (/ 0.7 0.5))) 0 
                        (if 
                          (< 1 
                            (/ 0.7 0.5)) 1 
                          (/ 0.7 0.5))))))) 
              (STV 
                (if 
                  (< 0.9999 0.5) 0.7 
                  (+ 
                    (* $ABs#3865 $QRs#3867) 
                    (/ 
                      (* 
                        (- 1 $ABs#3865) 
                        (- 0.7 
                          (* 0.5 $QRs#3867))) 
                      (- 1 0.5)))) 
                (min 0.1 
                  (min 0.1 
                    (min 0.3 
                      (min $PQc#3871 $QRc#3872))))) 
              (STV 1 0))))) 
      (: 
        (Deduction Pm Qm Rm PQm QRm) 
        (≞ 
          (→ P R) 
          (STV 0.8 0.1))) 
      (let* 
        ( ( (: $proof4#3859 
              (≞ 
                (→ P R) 
                (STV $ABs#3865 $PQc#3871))) (synthesize (: $proof4#3859 (≞ (→ P R) (STV $ABs#3865 $PQc#3871))) kb rb Z)) ((: $proof5#3860 (≞ (→ R R) (STV $QRs#3867 $QRc#3872))) (synthesize (: $proof5#3860 (≞ (→ R R) (STV $QRs#3867 $QRc#3872))) kb rb Z))) 
        (: 
          (Deduction Pm Rm Rm $proof4#3859 $proof5#3860) 
          (≞ 
            (→ P R) 
            (if 
              (and 
                (and 
                  (< 0 0.5) 
                  (and 
                    (<= 
                      (if 
                        (> 0 
                          (if 
                            (< 1 
                              (/ 
                                (- 
                                  (+ 0.5 0.7) 1) 0.5)) 1 
                            (/ 
                              (- 
                                (+ 0.5 0.7) 1) 0.5))) 0 
                        (if 
                          (< 1 
                            (/ 
                              (- 
                                (+ 0.5 0.7) 1) 0.5)) 1 
                          (/ 
                            (- 
                              (+ 0.5 0.7) 1) 0.5))) $ABs#3865) 
                    (<= $ABs#3865 
                      (if 
                        (> 0 
                          (if 
                            (< 1 
                              (/ 0.7 0.5)) 1 
                            (/ 0.7 0.5))) 0 
                        (if 
                          (< 1 
                            (/ 0.7 0.5)) 1 
                          (/ 0.7 0.5)))))) 
                (and 
                  (< 0 0.7) 
                  (and 
                    (<= 
                      (if 
                        (> 0 
                          (if 
                            (< 1 
                              (/ 
                                (- 
                                  (+ 0.7 0.7) 1) 0.7)) 1 
                            (/ 
                              (- 
                                (+ 0.7 0.7) 1) 0.7))) 0 
                        (if 
                          (< 1 
                            (/ 
                              (- 
                                (+ 0.7 0.7) 1) 0.7)) 1 
                          (/ 
                            (- 
                              (+ 0.7 0.7) 1) 0.7))) $QRs#3867) 
                    (<= $QRs#3867 
                      (if 
                        (> 0 
                          (if 
                            (< 1 
                              (/ 0.7 0.7)) 1 
                            (/ 0.7 0.7))) 0 
                        (if 
                          (< 1 
                            (/ 0.7 0.7)) 1 
                          (/ 0.7 0.7))))))) 
              (STV 
                (if 
                  (< 0.9999 0.7) 0.7 
                  (+ 
                    (* $ABs#3865 $QRs#3867) 
                    (/ 
                      (* 
                        (- 1 $ABs#3865) 
                        (- 0.7 
                          (* 0.7 $QRs#3867))) 
                      (- 1 0.7)))) 
                (min 0.1 
                  (min 0.3 
                    (min 0.3 
                      (min $PQc#3871 $QRc#3872))))) 
              (STV 1 0))))) 
      (let* 
        ( ( (: $proof4#3859 
              (≞ 
                (→ P 
                  (→ P Q)) 
                (STV $ABs#3865 $PQc#3871))) (synthesize (: $proof4#3859 (≞ (→ P (→ P Q)) (STV $ABs#3865 $PQc#3871))) kb rb Z)) ((: $proof5#3860 (≞ (→ (→ P Q) R) (STV $QRs#3867 $QRc#3872))) (synthesize (: $proof5#3860 (≞ (→ (→ P Q) R) (STV $QRs#3867 $QRc#3872))) kb rb Z))) 
        (: 
          (Deduction Pm PQm Rm $proof4#3859 $proof5#3860) 
          (≞ 
            (→ P R) 
            (if 
              (and 
                (and 
                  (< 0 0.5) 
                  (and 
                    (<= 
                      (if 
                        (> 0 
                          (if 
                            (< 1 
                              (/ 
                                (- 
                                  (+ 0.5 0.8) 1) 0.5)) 1 
                            (/ 
                              (- 
                                (+ 0.5 0.8) 1) 0.5))) 0 
                        (if 
                          (< 1 
                            (/ 
                              (- 
                                (+ 0.5 0.8) 1) 0.5)) 1 
                          (/ 
                            (- 
                              (+ 0.5 0.8) 1) 0.5))) $ABs#3865) 
                    (<= $ABs#3865 
                      (if 
                        (> 0 
                          (if 
                            (< 1 
                              (/ 0.8 0.5)) 1 
                            (/ 0.8 0.5))) 0 
                        (if 
                          (< 1 
                            (/ 0.8 0.5)) 1 
                          (/ 0.8 0.5)))))) 
                (and 
                  (< 0 0.8) 
                  (and 
                    (<= 
                      (if 
                        (> 0 
                          (if 
                            (< 1 
                              (/ 
                                (- 
                                  (+ 0.8 0.7) 1) 0.8)) 1 
                            (/ 
                              (- 
                                (+ 0.8 0.7) 1) 0.8))) 0 
                        (if 
                          (< 1 
                            (/ 
                              (- 
                                (+ 0.8 0.7) 1) 0.8)) 1 
                          (/ 
                            (- 
                              (+ 0.8 0.7) 1) 0.8))) $QRs#3867) 
                    (<= $QRs#3867 
                      (if 
                        (> 0 
                          (if 
                            (< 1 
                              (/ 0.7 0.8)) 1 
                            (/ 0.7 0.8))) 0 
                        (if 
                          (< 1 
                            (/ 0.7 0.8)) 1 
                          (/ 0.7 0.8))))))) 
              (STV 
                (if 
                  (< 0.9999 0.8) 0.7 
                  (+ 
                    (* $ABs#3865 $QRs#3867) 
                    (/ 
                      (* 
                        (- 1 $ABs#3865) 
                        (- 0.7 
                          (* 0.8 $QRs#3867))) 
                      (- 1 0.8)))) 
                (min 0.1 
                  (min 0.4 
                    (min 0.3 
                      (min $PQc#3871 $QRc#3872))))) 
              (STV 1 0))))) 
      (let* 
        ( ( (: $proof4#3859 
              (≞ 
                (→ P 
                  (→ Q R)) 
                (STV $ABs#3865 $PQc#3871))) (synthesize (: $proof4#3859 (≞ (→ P (→ Q R)) (STV $ABs#3865 $PQc#3871))) kb rb Z)) ((: $proof5#3860 (≞ (→ (→ Q R) R) (STV $QRs#3867 $QRc#3872))) (synthesize (: $proof5#3860 (≞ (→ (→ Q R) R) (STV $QRs#3867 $QRc#3872))) kb rb Z))) 
        (: 
          (Deduction Pm QRm Rm $proof4#3859 $proof5#3860) 
          (≞ 
            (→ P R) 
            (if 
              (and 
                (and 
                  (< 0 0.5) 
                  (and 
                    (<= 
                      (if 
                        (> 0 
                          (if 
                            (< 1 
                              (/ 
                                (- 
                                  (+ 0.5 0.9) 1) 0.5)) 1 
                            (/ 
                              (- 
                                (+ 0.5 0.9) 1) 0.5))) 0 
                        (if 
                          (< 1 
                            (/ 
                              (- 
                                (+ 0.5 0.9) 1) 0.5)) 1 
                          (/ 
                            (- 
                              (+ 0.5 0.9) 1) 0.5))) $ABs#3865) 
                    (<= $ABs#3865 
                      (if 
                        (> 0 
                          (if 
                            (< 1 
                              (/ 0.9 0.5)) 1 
                            (/ 0.9 0.5))) 0 
                        (if 
                          (< 1 
                            (/ 0.9 0.5)) 1 
                          (/ 0.9 0.5)))))) 
                (and 
                  (< 0 0.9) 
                  (and 
                    (<= 
                      (if 
                        (> 0 
                          (if 
                            (< 1 
                              (/ 
                                (- 
                                  (+ 0.9 0.7) 1) 0.9)) 1 
                            (/ 
                              (- 
                                (+ 0.9 0.7) 1) 0.9))) 0 
                        (if 
                          (< 1 
                            (/ 
                              (- 
                                (+ 0.9 0.7) 1) 0.9)) 1 
                          (/ 
                            (- 
                              (+ 0.9 0.7) 1) 0.9))) $QRs#3867) 
                    (<= $QRs#3867 
                      (if 
                        (> 0 
                          (if 
                            (< 1 
                              (/ 0.7 0.9)) 1 
                            (/ 0.7 0.9))) 0 
                        (if 
                          (< 1 
                            (/ 0.7 0.9)) 1 
                          (/ 0.7 0.9))))))) 
              (STV 
                (if 
                  (< 0.9999 0.9) 0.7 
                  (+ 
                    (* $ABs#3865 $QRs#3867) 
                    (/ 
                      (* 
                        (- 1 $ABs#3865) 
                        (- 0.7 
                          (* 0.9 $QRs#3867))) 
                      (- 1 0.9)))) 
                (min 0.1 
                  (min 0.5 
                    (min 0.3 
                      (min $PQc#3871 $QRc#3872))))) 
              (STV 1 0)))))))

<span class="ansi36"
>  (loonit_success  
    (equal_enough_for_test  
      ( (: 
          (Deduction Pm Qm Rm PQm QRm) 
          (≞ 
            (→ P R) 
            (STV 0.8 0.1)))) 
      ( (let* 
          ( ( (: $_23688 
                (≞ 
                  (→ P P) 
                  (STV $_23754 $_23772))) (synthesize (: $_23688 (≞ (→ P P) (STV $_23754 $_23772))) kb rb Z)) ((: $_23916 (≞ (→ P R) (STV $_23982 $_24000))) (synthesize (: $_23916 (≞ (→ P R) (STV $_23982 $_24000))) kb rb Z))) 
          (: 
            (Deduction Pm Pm Rm $_23688 $_23916) 
            (≞ 
              (→ P R) 
              (if 
                (and 
                  (and 
                    (< 0 0.5) 
                    (and 
                      (<= 
                        (if 
                          (> 0 
                            (if 
                              (< 1 
                                (/ 
                                  (- 
                                    (+ 0.5 0.5) 1) 0.5)) 1 
                              (/ 
                                (- 
                                  (+ 0.5 0.5) 1) 0.5))) 0 
                          (if 
                            (< 1 
                              (/ 
                                (- 
                                  (+ 0.5 0.5) 1) 0.5)) 1 
                            (/ 
                              (- 
                                (+ 0.5 0.5) 1) 0.5))) $_23754) 
                      (<= $_23754 
                        (if 
                          (> 0 
                            (if 
                              (< 1 
                                (/ 0.5 0.5)) 1 
                              (/ 0.5 0.5))) 0 
                          (if 
                            (< 1 
                              (/ 0.5 0.5)) 1 
                            (/ 0.5 0.5)))))) 
                  (and 
                    (< 0 0.5) 
                    (and 
                      (<= 
                        (if 
                          (> 0 
                            (if 
                              (< 1 
                                (/ 
                                  (- 
                                    (+ 0.5 0.7) 1) 0.5)) 1 
                              (/ 
                                (- 
                                  (+ 0.5 0.7) 1) 0.5))) 0 
                          (if 
                            (< 1 
                              (/ 
                                (- 
                                  (+ 0.5 0.7) 1) 0.5)) 1 
                            (/ 
                              (- 
                                (+ 0.5 0.7) 1) 0.5))) $_23982) 
                      (<= $_23982 
                        (if 
                          (> 0 
                            (if 
                              (< 1 
                                (/ 0.7 0.5)) 1 
                              (/ 0.7 0.5))) 0 
                          (if 
                            (< 1 
                              (/ 0.7 0.5)) 1 
                            (/ 0.7 0.5))))))) 
                (STV 
                  (if 
                    (< 0.9999 0.5) 0.7 
                    (+ 
                      (* $_23754 $_23982) 
                      (/ 
                        (* 
                          (- 1 $_23754) 
                          (- 0.7 
                            (* 0.5 $_23982))) 
                        (- 1 0.5)))) 
                  (min 0.1 
                    (min 0.1 
                      (min 0.3 
                        (min $_23772 $_24000))))) 
                (STV 1 0))))) 
        (: 
          (Deduction Pm Qm Rm PQm QRm) 
          (≞ 
            (→ P R) 
            (STV 0.8 0.1))) 
        (let 
          (: $_23688 
            (≞ 
              (→ P R) 
              (STV $_23754 $_23772))) 
          (synthesize 
            (: $_23688 
              (≞ 
                (→ P R) 
                (STV $_23754 $_23772))) kb rb Z) 
          (let 
            (: $_23916 
              (≞ 
                (→ R R) 
                (STV $_23982 $_24000))) 
            (synthesize 
              (: $_23916 
                (≞ 
                  (→ R R) 
                  (STV $_23982 $_24000))) kb rb Z) 
            (: 
              (Deduction Pm Rm Rm $_23688 $_23916) 
              (≞ 
                (→ P R) 
                (if 
                  (and 
                    (and 
                      (< 0 0.5) 
                      (and 
                        (<= 
                          (if 
                            (> 0 
                              (if 
                                (< 1 
                                  (/ 
                                    (- 
                                      (+ 0.5 0.7) 1) 0.5)) 1 
                                (/ 
                                  (- 
                                    (+ 0.5 0.7) 1) 0.5))) 0 
                            (if 
                              (< 1 
                                (/ 
                                  (- 
                                    (+ 0.5 0.7) 1) 0.5)) 1 
                              (/ 
                                (- 
                                  (+ 0.5 0.7) 1) 0.5))) $_23754) 
                        (<= $_23754 
                          (if 
                            (> 0 
                              (if 
                                (< 1 
                                  (/ 0.7 0.5)) 1 
                                (/ 0.7 0.5))) 0 
                            (if 
                              (< 1 
                                (/ 0.7 0.5)) 1 
                              (/ 0.7 0.5)))))) 
                    (and 
                      (< 0 0.7) 
                      (and 
                        (<= 
                          (if 
                            (> 0 
                              (if 
                                (< 1 
                                  (/ 
                                    (- 
                                      (+ 0.7 0.7) 1) 0.7)) 1 
                                (/ 
                                  (- 
                                    (+ 0.7 0.7) 1) 0.7))) 0 
                            (if 
                              (< 1 
                                (/ 
                                  (- 
                                    (+ 0.7 0.7) 1) 0.7)) 1 
                              (/ 
                                (- 
                                  (+ 0.7 0.7) 1) 0.7))) $_23982) 
                        (<= $_23982 
                          (if 
                            (> 0 
                              (if 
                                (< 1 
                                  (/ 0.7 0.7)) 1 
                                (/ 0.7 0.7))) 0 
                            (if 
                              (< 1 
                                (/ 0.7 0.7)) 1 
                              (/ 0.7 0.7))))))) 
                  (STV 
                    (if 
                      (< 0.9999 0.7) 0.7 
                      (+ 
                        (* $_23754 $_23982) 
                        (/ 
                          (* 
                            (- 1 $_23754) 
                            (- 0.7 
                              (* 0.7 $_23982))) 
                          (- 1 0.7)))) 
                    (min 0.1 
                      (min 0.3 
                        (min 0.3 
                          (min $_23772 $_24000))))) 
                  (STV 1 0)))))) 
        (let 
          (: $_23688 
            (≞ 
              (→ P 
                (→ P Q)) 
              (STV $_23754 $_23772))) 
          (synthesize 
            (: $_23688 
              (≞ 
                (→ P 
                  (→ P Q)) 
                (STV $_23754 $_23772))) kb rb Z) 
          (let 
            (: $_23916 
              (≞ 
                (→ 
                  (→ P Q) R) 
                (STV $_23982 $_24000))) 
            (synthesize 
              (: $_23916 
                (≞ 
                  (→ 
                    (→ P Q) R) 
                  (STV $_23982 $_24000))) kb rb Z) 
            (: 
              (Deduction Pm PQm Rm $_23688 $_23916) 
              (≞ 
                (→ P R) 
                (if 
                  (and 
                    (and 
                      (< 0 0.5) 
                      (and 
                        (<= 
                          (if 
                            (> 0 
                              (if 
                                (< 1 
                                  (/ 
                                    (- 
                                      (+ 0.5 0.8) 1) 0.5)) 1 
                                (/ 
                                  (- 
                                    (+ 0.5 0.8) 1) 0.5))) 0 
                            (if 
                              (< 1 
                                (/ 
                                  (- 
                                    (+ 0.5 0.8) 1) 0.5)) 1 
                              (/ 
                                (- 
                                  (+ 0.5 0.8) 1) 0.5))) $_23754) 
                        (<= $_23754 
                          (if 
                            (> 0 
                              (if 
                                (< 1 
                                  (/ 0.8 0.5)) 1 
                                (/ 0.8 0.5))) 0 
                            (if 
                              (< 1 
                                (/ 0.8 0.5)) 1 
                              (/ 0.8 0.5)))))) 
                    (and 
                      (< 0 0.8) 
                      (and 
                        (<= 
                          (if 
                            (> 0 
                              (if 
                                (< 1 
                                  (/ 
                                    (- 
                                      (+ 0.8 0.7) 1) 0.8)) 1 
                                (/ 
                                  (- 
                                    (+ 0.8 0.7) 1) 0.8))) 0 
                            (if 
                              (< 1 
                                (/ 
                                  (- 
                                    (+ 0.8 0.7) 1) 0.8)) 1 
                              (/ 
                                (- 
                                  (+ 0.8 0.7) 1) 0.8))) $_23982) 
                        (<= $_23982 
                          (if 
                            (> 0 
                              (if 
                                (< 1 
                                  (/ 0.7 0.8)) 1 
                                (/ 0.7 0.8))) 0 
                            (if 
                              (< 1 
                                (/ 0.7 0.8)) 1 
                              (/ 0.7 0.8))))))) 
                  (STV 
                    (if 
                      (< 0.9999 0.8) 0.7 
                      (+ 
                        (* $_23754 $_23982) 
                        (/ 
                          (* 
                            (- 1 $_23754) 
                            (- 0.7 
                              (* 0.8 $_23982))) 
                          (- 1 0.8)))) 
                    (min 0.1 
                      (min 0.4 
                        (min 0.3 
                          (min $_23772 $_24000))))) 
                  (STV 1 0)))))) 
        (let 
          (: $_23688 
            (≞ 
              (→ P 
                (→ Q R)) 
              (STV $_23754 $_23772))) 
          (synthesize 
            (: $_23688 
              (≞ 
                (→ P 
                  (→ Q R)) 
                (STV $_23754 $_23772))) kb rb Z) 
          (let 
            (: $_23916 
              (≞ 
                (→ 
                  (→ Q R) R) 
                (STV $_23982 $_24000))) 
            (synthesize 
              (: $_23916 
                (≞ 
                  (→ 
                    (→ Q R) R) 
                  (STV $_23982 $_24000))) kb rb Z) 
            (: 
              (Deduction Pm QRm Rm $_23688 $_23916) 
              (≞ 
                (→ P R) 
                (if 
                  (and 
                    (and 
                      (< 0 0.5) 
                      (and 
                        (<= 
                          (if 
                            (> 0 
                              (if 
                                (< 1 
                                  (/ 
                                    (- 
                                      (+ 0.5 0.9) 1) 0.5)) 1 
                                (/ 
                                  (- 
                                    (+ 0.5 0.9) 1) 0.5))) 0 
                            (if 
                              (< 1 
                                (/ 
                                  (- 
                                    (+ 0.5 0.9) 1) 0.5)) 1 
                              (/ 
                                (- 
                                  (+ 0.5 0.9) 1) 0.5))) $_23754) 
                        (<= $_23754 
                          (if 
                            (> 0 
                              (if 
                                (< 1 
                                  (/ 0.9 0.5)) 1 
                                (/ 0.9 0.5))) 0 
                            (if 
                              (< 1 
                                (/ 0.9 0.5)) 1 
                              (/ 0.9 0.5)))))) 
                    (and 
                      (< 0 0.9) 
                      (and 
                        (<= 
                          (if 
                            (> 0 
                              (if 
                                (< 1 
                                  (/ 
                                    (- 
                                      (+ 0.9 0.7) 1) 0.9)) 1 
                                (/ 
                                  (- 
                                    (+ 0.9 0.7) 1) 0.9))) 0 
                            (if 
                              (< 1 
                                (/ 
                                  (- 
                                    (+ 0.9 0.7) 1) 0.9)) 1 
                              (/ 
                                (- 
                                  (+ 0.9 0.7) 1) 0.9))) $_23982) 
                        (<= $_23982 
                          (if 
                            (> 0 
                              (if 
                                (< 1 
                                  (/ 0.7 0.9)) 1 
                                (/ 0.7 0.9))) 0 
                            (if 
                              (< 1 
                                (/ 0.7 0.9)) 1 
                              (/ 0.7 0.9))))))) 
                  (STV 
                    (if 
                      (< 0.9999 0.9) 0.7 
                      (+ 
                        (* $_23754 $_23982) 
                        (/ 
                          (* 
                            (- 1 $_23754) 
                            (- 0.7 
                              (* 0.9 $_23982))) 
                          (- 1 0.9)))) 
                    (min 0.1 
                      (min 0.5 
                        (min 0.3 
                          (min $_23772 $_24000))))) 
                  (STV 1 0)))))))))
</span>
Deterministic: ()
()]
;;; (: (Deduction Pm Qm Rm PQm QRm) (≞ (→ P R) (STV 0.8 0.1))))
<span class="ansi32"
>% 4,503,964 inferences, 1.841 CPU in 1.841 seconds (100% CPU, 2446414 Lips)
</span>P;HTML|
;                         (= /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/pln/dependent-types/DeductionDTLTest.metta  0)
<span class="ansi1"
>LoonIt Report
</span>------------
<span class="ansi32"
>Successes: 3
</span><span class="ansi31"
>Failures: 1
</span><br/> <a href="#" onclick="window.history.back(); return false;"
>Return to summaries</a><br/>
P;HTML|
;           (is_cmd_option  execute halt --halt=true true)
P;HTML|
;            (set_option_value  halt true)
P;HTML|
;            (is_cmd_option  execute stdin --stdin=tty tty)
P;HTML|
;            (set_option_value  stdin tty)
P;HTML|
;            (is_cmd_option  execute stdout --stdout=tty tty)
P;HTML|
;             (set_option_value  stdout tty)
P;HTML|
;            (is_cmd_option  execute stderr --stderr=tty tty)
P;HTML|
;             (set_option_value  stderr tty)
P;HTML|
;           (set_option_value  prolog false)
P;HTML|
;           (set_option_value  compat auto)
P;HTML|
;           (set_option_value  compatio true)

Script done on 2024-10-06 01:23:10+00:00 [COMMAND_EXIT_CODE="7"]

</pre>
</body>

</html>
\033[0;32mCompleted successfully (EXITCODE=7) Under 40 seconds: ./mettalog '--output=./reports/tests_output/baseline-compat-2024-10-06T00:36:50/' --timeout=40 --html --repl=false  --test "tests/extended_compat/hyperon-pln/metta/pln/dependent-types/DeductionDTLTest.metta" --halt=true\033[0m

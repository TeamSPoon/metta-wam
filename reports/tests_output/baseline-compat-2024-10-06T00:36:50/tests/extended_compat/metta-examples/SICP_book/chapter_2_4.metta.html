<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"
>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"
>
<title></title>
<style type="text/css"
>
.ansi2html-content { display: inline; white-space: pre-wrap; word-wrap: break-word; }
.body_foreground { color: #AAAAAA; }
.body_background { background-color: #000000; }
.inv_foreground { color: #000000; }
.inv_background { background-color: #AAAAAA; }
.ansi1 { font-weight: bold; }
.ansi31 { color: #aa0000; }
.ansi32 { color: #00aa00; }
.ansi36 { color: #00aaaa; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
</style>
</head>
<body class="body_foreground body_background" style="font-size: normal;" >
<pre class="ansi2html-content"
>
Script started on 2024-10-06 01:00:45+00:00 [TERM="xterm-256color" TTY="/dev/pts/0" COLUMNS="-1" LINES="-1"]
P;HTML|
;           (set_option_value  prolog false)

P;HTML|
;           (set_option_value  compat auto)

P;HTML|
;           (set_option_value  compatio true)
P;HTML|
;            (is_cmd_option  prescan halt --halt=true true)
P;HTML|
;            (set_option_value  halt true)
P;HTML|
;            (is_cmd_option  prescan stdin --stdin=tty tty)
P;HTML|
;             (set_option_value  stdin tty)
P;HTML|
;            (is_cmd_option  prescan stdout --stdout=tty tty)
P;HTML|
;             (set_option_value  stdout tty)
P;HTML|
;            (is_cmd_option  prescan stderr --stderr=tty tty)
P;HTML|
;             (set_option_value  stderr tty)
P;HTML|
;            (set_option_value  prolog false)
P;HTML|
;            (set_option_value  compat auto)
P;HTML|
;            (set_option_value  compatio true)
P;HTML|
;          (is_cmd_option  execute python --python=enable enable)
P;HTML|
;           (set_option_value  python enable)
P;HTML|
;          (is_cmd_option  execute timeout --timeout=40 40)
P;HTML|
;           (set_option_value  timeout 40)
P;HTML|
;           (is_cmd_option  execute output --output=./reports/tests_output/baseline-compat-2024-10-06T00:36:50/ ./reports/tests_output/baseline-compat-2024-10-06T00:36:50/)
P;HTML|
;           (set_option_value  output ./reports/tests_output/baseline-compat-2024-10-06T00:36:50/)
P;HTML|
;           (is_cmd_option  execute html --html true)
P;HTML|
;            (set_option_value  html true)
P;HTML|
;           (is_cmd_option  execute test --test true)
P;HTML|
;            (set_option_value  test true)

; (load_metta_file  &self tests/extended_compat/metta-examples/SICP_book/chapter_2_4.metta)
P;HTML|
;                         (track_load_into_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/metta-examples/SICP_book/chapter_2_4.metta)
P;HTML|
;                                          (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/metta-examples/SICP_book/chapter_2_4.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/metta-examples/SICP_book/chapter_2_4.metta)
P;HTML|
;                                           (= 1  "timeout: failed to run command 'time': No such file or directory")
P;HTML|
;                                          (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/metta-examples/SICP_book/chapter_2_4.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/metta-examples/SICP_book/chapter_2_4.metta)
P;HTML|
;                                           (= 1  "timeout: failed to run command 'time': No such file or directory")

;;; This chapter is dedicated to generic procedures which works with different object representation, type tags and data-
;;; directed programming.
;;; Complex numbers.
;;; Two different representations for complex numbers - (real, imag) parts and (magnitude, angle).
;;; One way to implement complex numers' selectors:
;;; (all sqrt/square/cos/atan etc functions are builtin in Scheme. I'll use imports from python)
<span class="ansi38-255165000"
>  (= 
    (square $x) 
    (* $x $x))
</span><span class="ansi38-013099040"
>  !(import! &self additional_funcs)

</span>[P;HTML|
;                                           (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/metta-examples/SICP_book/additional_funcs.py.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/metta-examples/SICP_book/additional_funcs.py)
P;HTML|
;                                           (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/metta-examples/SICP_book/additional_funcs.py.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/metta-examples/SICP_book/additional_funcs.py)
<span class="ansi38-255165000"
> from
</span><span class="ansi38-255165000"
> hyperon.atoms
</span><span class="ansi38-255165000"
> import
</span><span class="ansi38-255165000"
> 'OperationAtom,'
</span><span class="ansi38-255165000"
> ValueAtom
</span><span class="ansi38-255165000"
> from
</span><span class="ansi38-255165000"
> hyperon.ext
</span><span class="ansi38-255165000"
> import
</span><span class="ansi38-255165000"
> *
</span><span class="ansi38-255165000"
> import
</span><span class="ansi38-255165000"
> random
</span><span class="ansi38-255165000"
> random.seed
</span><span class="ansi38-255165000"
>  (123)
</span><span class="ansi38-255165000"
> import
</span><span class="ansi38-255165000"
> time
</span><span class="ansi38-255165000"
> import
</span><span class="ansi38-255165000"
> math
</span><span class="ansi38-255165000"
> def
</span><span class="ansi38-255165000"
> updateSeed
</span><span class="ansi38-255165000"
> :
</span><span class="ansi38-255165000"
> random.seed
</span><span class="ansi38-255165000"
>  (getCurTime ())
</span><span class="ansi38-255165000"
> def
</span><span class="ansi38-255165000"
> getRandInt
</span><span class="ansi38-255165000"
>  ('start,' end)
</span><span class="ansi38-255165000"
> :
</span><span class="ansi38-255165000"
> updateSeed
</span><span class="ansi38-255165000"
> return
</span><span class="ansi38-255165000"
> random.randint
</span><span class="ansi38-255165000"
>  ('start,' end)
</span><span class="ansi38-255165000"
> def
</span><span class="ansi38-255165000"
> getCurTime
</span><span class="ansi38-255165000"
> :
</span><span class="ansi38-255165000"
> return
</span><span class="ansi38-255165000"
> time.time_ns
</span><span class="ansi38-255165000"
> /
</span><span class="ansi38-255165000"
>  (10 ** 6)
</span><span class="ansi38-255165000"
> def
</span><span class="ansi38-255165000"
> quotient
</span><span class="ansi38-255165000"
>  ('x,' y)
</span><span class="ansi38-255165000"
> :
</span><span class="ansi38-255165000"
> return
</span><span class="ansi38-255165000"
> x
</span><span class="ansi38-255165000"
> //
</span><span class="ansi38-255165000"
> y
</span><span class="ansi38-255165000"
> def
</span><span class="ansi38-255165000"
> getSqrt
</span><span class="ansi38-255165000"
>  (x)
</span><span class="ansi38-255165000"
> :
</span><span class="ansi38-255165000"
> return
</span><span class="ansi38-255165000"
> math.sqrt
</span><span class="ansi38-255165000"
>  (x)
</span><span class="ansi38-255165000"
> def
</span><span class="ansi38-255165000"
> getAtan
</span><span class="ansi38-255165000"
>  ('x,y=1')
</span><span class="ansi38-255165000"
> :
</span><span class="ansi38-255165000"
> return
</span><span class="ansi38-255165000"
> math.atan2
</span><span class="ansi38-255165000"
>  ('x,' y)
</span><span class="ansi38-255165000"
> def
</span><span class="ansi38-255165000"
> getCos
</span><span class="ansi38-255165000"
>  (x)
</span><span class="ansi38-255165000"
> :
</span><span class="ansi38-255165000"
> return
</span><span class="ansi38-255165000"
> math.cos
</span><span class="ansi38-255165000"
>  (x)
</span><span class="ansi38-255165000"
> def
</span><span class="ansi38-255165000"
> getSin
</span><span class="ansi38-255165000"
>  (x)
</span><span class="ansi38-255165000"
> :
</span><span class="ansi38-255165000"
> return
</span><span class="ansi38-255165000"
> math.sin
</span><span class="ansi38-255165000"
>  (x)
</span><span class="ansi38-255165000"
> @register_atoms
</span><span class="ansi38-255165000"
> def
</span><span class="ansi38-255165000"
> my_glob_atoms
</span><span class="ansi38-255165000"
> :
</span><span class="ansi38-255165000"
> return
</span><span class="ansi38-255165000"
>  { (randomint! : OperationAtom 
      ("randomint!" , getRandInt) , timems! : OperationAtom 
      ("timems!" , getCurTime) , // : OperationAtom 
      ("//" , quotient) , sqrt : OperationAtom 
      ("sqrt" , getSqrt) , atan : OperationAtom 
      ("atan" , getAtan) , cos : OperationAtom 
      ("cos" , getCos) , sin : OperationAtom 
      ("sin" , getSin) ,) }
</span>
Deterministic: ()
()]
<span class="ansi38-255165000"
>  (= 
    (real-part (Cons $r $i)) $r)
</span><span class="ansi38-255165000"
>  (= 
    (imag-part (Cons $r $i)) $i)
</span><span class="ansi38-255165000"
>  (= 
    (magnitude $z) 
    (sqrt (+ (square (real-part $z)) (square (imag-part $z)))))
</span><span class="ansi38-255165000"
>  (= 
    (angle $z) 
    (atan 
      (imag-part $z) 
      (real-part $z)))
</span><span class="ansi38-255165000"
>  (= 
    (make-from-real-imag $r $i) 
    (Cons $r $i))
</span><span class="ansi38-255165000"
>  (= 
    (make-from-mag-ang $r $a) 
    (Cons 
      (* $r 
        (cos $a)) 
      (* $r 
        (sin $a))))
</span>;;; Another way to implement selectors:
<span class="ansi38-255165000"
>  (= 
    (real-part_ $z) 
    (* 
      (magnitude_ $z) 
      (cos (angle_ $z))))
</span><span class="ansi38-255165000"
>  (= 
    (imag-part_ $z) 
    (* 
      (magnitude_ $z) 
      (sin (angle_ $z))))
</span><span class="ansi38-255165000"
>  (= 
    (magnitude_ (Cons $m $a)) $m)
</span><span class="ansi38-255165000"
>  (= 
    (angle_ (Cons $m $a)) $a)
</span><span class="ansi38-255165000"
>  (= 
    (make-from-real-imag_ $x $y) 
    (Cons 
      (sqrt (+ (square $x) (square $y))) 
      (atan $y $x)))
</span><span class="ansi38-255165000"
>  (= 
    (make-from-mag-ang_ $r $a) 
    (Cons $r $a))
</span>;;; We can possibly use any of those complex number's representations. Though if we need to use both then we need to
;;; make a type tag to distinguish which representation we are using right now.
<span class="ansi38-255165000"
>  (= 
    (make-pair $x $y) 
    (pair $x $y))
</span><span class="ansi38-255165000"
>  (= 
    (first-pair (pair $x $y)) $x)
</span><span class="ansi38-255165000"
>  (= 
    (second-pair (pair $x $y)) $y)
</span><span class="ansi38-255165000"
>  (= 
    (pair? $x) 
    (case $x 
      ( ( (pair $a $b) True) ($ False))))
</span><span class="ansi38-255165000"
>  (= 
    (attach-tag $type-tag $contents) 
    (make-pair $type-tag $contents))
</span><span class="ansi38-255165000"
>  (= 
    (type-tag $datum) 
    (if 
      (pair? $datum) 
      (first-pair $datum) 
      (Error 
        (type-tag $datum) "Input is not a pair")))
</span><span class="ansi38-255165000"
>  (= 
    (contents $datum) 
    (if 
      (pair? $datum) 
      (second-pair $datum) 
      (Error 
        (contents $datum) "Input is not a pair")))
</span><span class="ansi38-255165000"
>  (= 
    (rectangular? $z) 
    (== 
      (type-tag $z) rectangular))
</span><span class="ansi38-255165000"
>  (= 
    (polar? $z) 
    (== 
      (type-tag $z) polar))
</span>;;; So now we need to re-write functions for both types of complex number representations. For functions to be in one
;;; program their names will also be changed to represent their representation.
;;; Rectangular representation of complex number with type tag:
<span class="ansi38-255165000"
>  (= 
    (real-part-rectangular (Cons $r $i)) $r)
</span><span class="ansi38-255165000"
>  (= 
    (imag-part-rectangular (Cons $r $i)) $i)
</span><span class="ansi38-255165000"
>  (= 
    (magnitude-rectangular $z) 
    (sqrt (+ (square (real-part-rectangular $z)) (square (imag-part-rectangular $z)))))
</span><span class="ansi38-255165000"
>  (= 
    (angle-rectangular $z) 
    (atan 
      (imag-part-rectangular $z) 
      (real-part-rectangular $z)))
</span><span class="ansi38-255165000"
>  (= 
    (make-from-real-imag-rectangular $x $y) 
    (attach-tag rectangular 
      (Cons $x $y)))
</span><span class="ansi38-255165000"
>  (= 
    (make-from-mag-ang-rectangular $r $i) 
    (attach-tag rectangular 
      (cons 
        (* $r 
          (cos $i)) 
        (* $r 
          (sin $i)))))
</span>;;; Polar representation of complex number with type tag:
<span class="ansi38-255165000"
>  (= 
    (real-part-polar $z) 
    (* 
      (magnitude-polar $z) 
      (cos (angle-polar $z))))
</span><span class="ansi38-255165000"
>  (= 
    (imag-part-polar $z) 
    (* 
      (magnitude-polar $z) 
      (sin (angle-polar $z))))
</span><span class="ansi38-255165000"
>  (= 
    (magnitude-polar (Cons $m $a)) $m)
</span><span class="ansi38-255165000"
>  (= 
    (angle-polar (Cons $m $a)) $a)
</span><span class="ansi38-255165000"
>  (= 
    (make-from-real-imag-polar $x $y) 
    (attach-tag polar 
      (Cons 
        (sqrt (+ (square $x) (square $y))) 
        (atan $y $x))))
</span><span class="ansi38-255165000"
>  (= 
    (make-from-mag-ang-polar $r $a) 
    (attach-tag polar 
      (Cons $r $a)))
</span><span class="ansi38-255165000"
>  (= 
    (real-part_general $z) 
    (case $z 
      ( ( (pair rectangular $contents) (real-part-rectangular $contents)) 
        ( (pair polar $contents) (real-part-polar $contents)) 
        ($ (Error (real-part $z) "Unknown representation type")))))
</span><span class="ansi38-255165000"
>  (= 
    (imag-part_general $z) 
    (case $z 
      ( ( (pair rectangular $contents) (imag-part-rectangular $contents)) 
        ( (pair polar $contents) (imag-part-polar $contents)) 
        ($ (Error (real-part $z) "Unknown representation type")))))
</span><span class="ansi38-255165000"
>  (= 
    (magnitude_general $z) 
    (case $z 
      ( ( (pair rectangular $contents) (magnitude-rectangular $contents)) 
        ( (pair polar $contents) (magnitude-polar $contents)) 
        ($ (Error (real-part $z) "Unknown representation type")))))
</span><span class="ansi38-255165000"
>  (= 
    (angle_general $z) 
    (case $z 
      ( ( (pair rectangular $contents) (angle-rectangular $contents)) 
        ( (pair polar $contents) (angle-polar $contents)) 
        ($ (Error (real-part $z) "Unknown representation type")))))
</span>;;; Now to use add-complex, sub-complex, mul-complex and div-complex we need to implement more general make-from-* functions:
<span class="ansi38-255165000"
>  (= 
    (make-from-real-imag_general $r $i) 
    (make-from-real-imag-rectangular $r $i))
</span><span class="ansi38-255165000"
>  (= 
    (make-from-mag-ang_general $m $a) 
    (make-from-mag-ang-polar $m $a))
</span><span class="ansi38-255165000"
>  (= 
    (add-complex $z1 $z2) 
    (make-from-real-imag_general 
      (+ 
        (real-part_general $z1) 
        (real-part_general $z2)) 
      (+ 
        (imag-part_general $z1) 
        (imag-part_general $z2))))
</span><span class="ansi38-255165000"
>  (= 
    (sub-complex $z1 $z2) 
    (make-from-real-imag_general 
      (- 
        (real-part_general $z1) 
        (real-part_general $z2)) 
      (- 
        (imag-part_general $z1) 
        (imag-part_general $z2))))
</span><span class="ansi38-255165000"
>  (= 
    (mul-complex $z1 $z2) 
    (make-from-mag-ang_general 
      (* 
        (magnitude_general $z1) 
        (magnitude_general $z2)) 
      (+ 
        (angle_general $z1) 
        (angle_general $z2))))
</span><span class="ansi38-255165000"
>  (= 
    (div-complex $z1 $z2) 
    (make-from-mag-ang_general 
      (/ 
        (magnitude_general $z1) 
        (magnitude_general $z2)) 
      (- 
        (angle_general $z1) 
        (angle_general $z2))))
</span>;;; So now we have three independent parts of whole complex-number's arithmetics program: arithmetics (sub, mul, add, div),
;;; polar representation of complex-number and rectangular representation. Several asserts for current code.
<span class="ansi38-013099040"
>  !(assertEqual 
    (make-from-real-imag_general 5 2) 
    (pair rectangular 
      (Cons 5 2)))

</span>[

;<h3 id="SICP-BOOK.CHAPTER-2-4.01"
>;; SICP-BOOK.CHAPTER-2-4.01</h3>
; 
; EVAL TEST
; took 0.002 secs. (1.94 milliseconds) 

  !(assertEqual 
    (make-from-real-imag_general 5 2) 
    (pair rectangular 
      (Cons 5 2)))

<span class="ansi36"
>  (loonit_success  
    (equal_enough_for_test  
      ( (pair rectangular 
          (Cons 5 2))) 
      ( (pair rectangular 
          (Cons 5 2)))))
</span>
Deterministic: ()
()]
<span class="ansi38-013099040"
>  !(assertEqual 
    (make-from-mag-ang_general 3 4) 
    (pair polar 
      (Cons 3 4)))

</span>[

;<h3 id="SICP-BOOK.CHAPTER-2-4.02"
>;; SICP-BOOK.CHAPTER-2-4.02</h3>
; 
; EVAL TEST
; took 0.002 secs. (1.70 milliseconds) 

  !(assertEqual 
    (make-from-mag-ang_general 3 4) 
    (pair polar 
      (Cons 3 4)))

<span class="ansi36"
>  (loonit_success  
    (equal_enough_for_test  
      ( (pair polar 
          (Cons 3 4))) 
      ( (pair polar 
          (Cons 3 4)))))
</span>
Deterministic: ()
()]
<span class="ansi38-013099040"
>  !(bind! &z1 
    (make-from-real-imag_general 5 2))

</span>

Deterministic: ()
[()]
<span class="ansi38-013099040"
>  !(bind! &z2 
    (make-from-mag-ang_general 3 4))

</span>

Deterministic: ()
[()]
<span class="ansi38-013099040"
>  !(assertEqual 
    (real-part_general &z1) 5)

</span>[

;<h3 id="SICP-BOOK.CHAPTER-2-4.03"
>;; SICP-BOOK.CHAPTER-2-4.03</h3>
; 
; EVAL TEST
; took 0.001 secs. (1.27 milliseconds) 

  !(assertEqual 
    (real-part_general &z1) 5)

<span class="ansi36"
>  (loonit_success  
    (equal_enough_for_test  
      (5) 
      (5)))
</span>
Deterministic: ()
()]
<span class="ansi38-013099040"
>  !(assertEqual 
    (real-part_general &z2) -1.960930862590836)

</span>[

;<h3 id="SICP-BOOK.CHAPTER-2-4.04"
>;; SICP-BOOK.CHAPTER-2-4.04</h3>
; 
; EVAL TEST
; took 0.003 secs. (3.15 milliseconds) 

  !(assertEqual 
    (real-part_general &z2) -1.960930862590836)

<span class="ansi36"
>  (loonit_success  
    (equal_enough_for_test  
      (-1.960930862590836) 
      (-1.960930862590836)))
</span>
Deterministic: ()
()]
<span class="ansi38-013099040"
>  !(assertEqual 
    (imag-part_general &z1) 2)

</span>[

;<h3 id="SICP-BOOK.CHAPTER-2-4.05"
>;; SICP-BOOK.CHAPTER-2-4.05</h3>
; 
; EVAL TEST
; took 0.001 secs. (1.23 milliseconds) 

  !(assertEqual 
    (imag-part_general &z1) 2)

<span class="ansi36"
>  (loonit_success  
    (equal_enough_for_test  
      (2) 
      (2)))
</span>
Deterministic: ()
()]
<span class="ansi38-013099040"
>  !(assertEqual 
    (imag-part_general &z2) -2.2704074859237844)

</span>[

;<h3 id="SICP-BOOK.CHAPTER-2-4.06"
>;; SICP-BOOK.CHAPTER-2-4.06</h3>
; 
; EVAL TEST
; took 0.003 secs. (3.08 milliseconds) 

  !(assertEqual 
    (imag-part_general &z2) -2.2704074859237844)

<span class="ansi36"
>  (loonit_success  
    (equal_enough_for_test  
      (-2.2704074859237844) 
      (-2.2704074859237844)))
</span>
Deterministic: ()
()]
<span class="ansi38-013099040"
>  !(assertEqual 
    (magnitude_general &z1) 5.385164807134504)

</span>[

;<h3 id="SICP-BOOK.CHAPTER-2-4.07"
>;; SICP-BOOK.CHAPTER-2-4.07</h3>
; 
; EVAL TEST
; took 0.004 secs. (4.10 milliseconds) 

  !(assertEqual 
    (magnitude_general &z1) 5.385164807134504)

<span class="ansi31"
>  (loonit_failureR  
    (equal_enough_for_test  
      ( (sqrt 29)) 
      (5.385164807134504)))
</span>
Deterministic: ((Error  (got  ((sqrt 29))) (expected  (5.385164807134504))))
((Error  (got  ((sqrt 29))) (expected  (5.385164807134504))))]
<span class="ansi38-013099040"
>  !(assertEqual 
    (magnitude_general &z2) 3)

</span>[

;<h3 id="SICP-BOOK.CHAPTER-2-4.08"
>;; SICP-BOOK.CHAPTER-2-4.08</h3>
; 
; EVAL TEST
; took 0.001 secs. (1.24 milliseconds) 

  !(assertEqual 
    (magnitude_general &z2) 3)

<span class="ansi36"
>  (loonit_success  
    (equal_enough_for_test  
      (3) 
      (3)))
</span>
Deterministic: ()
()]
<span class="ansi38-013099040"
>  !(assertEqual 
    (angle_general &z1) 0.3805063771123649)

</span>[

;<h3 id="SICP-BOOK.CHAPTER-2-4.09"
>;; SICP-BOOK.CHAPTER-2-4.09</h3>
; 
; EVAL TEST
; took 0.003 secs. (3.23 milliseconds) 

  !(assertEqual 
    (angle_general &z1) 0.3805063771123649)

<span class="ansi31"
>  (loonit_failureR  
    (equal_enough_for_test  
      ( (atan 2 5)) 
      (0.3805063771123649)))
</span>
Deterministic: ((Error  (got  ((atan 2 5))) (expected  (0.3805063771123649))))
((Error  (got  ((atan 2 5))) (expected  (0.3805063771123649))))]
<span class="ansi38-013099040"
>  !(assertEqual 
    (angle_general &z2) 4)

</span>[

;<h3 id="SICP-BOOK.CHAPTER-2-4.10"
>;; SICP-BOOK.CHAPTER-2-4.10</h3>
; 
; EVAL TEST
; took 0.001 secs. (1.29 milliseconds) 

  !(assertEqual 
    (angle_general &z2) 4)

<span class="ansi36"
>  (loonit_success  
    (equal_enough_for_test  
      (4) 
      (4)))
</span>
Deterministic: ()
()]
<span class="ansi38-013099040"
>  !(assertEqual 
    (div-complex &z1 &z2) 
    (pair polar 
      (Cons 1.7950549357115013 -3.619493622887635)))

</span>[

;<h3 id="SICP-BOOK.CHAPTER-2-4.11"
>;; SICP-BOOK.CHAPTER-2-4.11</h3>
; 
; EVAL TEST
; took 0.012 secs. (12.08 milliseconds) 

  !(assertEqual 
    (div-complex &z1 &z2) 
    (pair polar 
      (Cons 1.7950549357115013 -3.619493622887635)))

<span class="ansi36"
>  (loonit_success  
    (equal_enough_for_test  
      ( (pair polar 
          (Cons 1.7950549357115013 -3.619493622887635))) 
      ( (pair polar 
          (Cons 1.7950549357115013 -3.619493622887635)))))
</span>
Deterministic: ()
()]
<span class="ansi38-013099040"
>  !(assertEqual 
    (sub-complex &z1 &z2) 
    (pair rectangular 
      (Cons 6.9609308625908355 4.270407485923784)))

</span>[

;<h3 id="SICP-BOOK.CHAPTER-2-4.12"
>;; SICP-BOOK.CHAPTER-2-4.12</h3>
; 
; EVAL TEST
; took 0.011 secs. (10.68 milliseconds) 

  !(assertEqual 
    (sub-complex &z1 &z2) 
    (pair rectangular 
      (Cons 6.9609308625908355 4.270407485923784)))

<span class="ansi36"
>  (loonit_success  
    (equal_enough_for_test  
      ( (pair rectangular 
          (Cons 6.9609308625908355 4.270407485923784))) 
      ( (pair rectangular 
          (Cons 6.9609308625908355 4.270407485923784)))))
</span>
Deterministic: ()
()]
<span class="ansi38-013099040"
>  !(assertEqual 
    (add-complex &z1 &z2) 
    (pair rectangular 
      (Cons 3.039069137409164 -0.2704074859237844)))

</span>[

;<h3 id="SICP-BOOK.CHAPTER-2-4.13"
>;; SICP-BOOK.CHAPTER-2-4.13</h3>
; 
; EVAL TEST
; took 0.011 secs. (10.68 milliseconds) 

  !(assertEqual 
    (add-complex &z1 &z2) 
    (pair rectangular 
      (Cons 3.039069137409164 -0.2704074859237844)))

<span class="ansi36"
>  (loonit_success  
    (equal_enough_for_test  
      ( (pair rectangular 
          (Cons 3.039069137409164 -0.2704074859237844))) 
      ( (pair rectangular 
          (Cons 3.039069137409164 -0.2704074859237844)))))
</span>
Deterministic: ()
()]
<span class="ansi38-013099040"
>  !(assertEqual 
    (mul-complex &z1 &z2) 
    (pair polar 
      (Cons 16.15549442140351 4.380506377112365)))

</span>[

;<h3 id="SICP-BOOK.CHAPTER-2-4.14"
>;; SICP-BOOK.CHAPTER-2-4.14</h3>
; 
; EVAL TEST
; took 0.012 secs. (12.06 milliseconds) 

  !(assertEqual 
    (mul-complex &z1 &z2) 
    (pair polar 
      (Cons 16.15549442140351 4.380506377112365)))

<span class="ansi36"
>  (loonit_success  
    (equal_enough_for_test  
      ( (pair polar 
          (Cons 16.15549442140351 4.380506377112365))) 
      ( (pair polar 
          (Cons 16.15549442140351 4.380506377112365)))))
</span>
Deterministic: ()
()]
;;; Data driven programming.
;;; Problem of the previous complex number representation is that general functions real-part, angle, magnitude and
;;; imag-part should know which representations we have. And in case of a new representation we need to add couple of
;;; lines to that functions.
;;; Another problem - we need to check that functions in different representations have different name. In case of Scheme
;;; we will get an error. In case of Metta, we will get several outputs.
;;; We need a table of types and operations like this:
;;;    ______________________________________________________________
;;;    |                                     Types                  |
;;;    | Functions              Polar             Rectangular       |
;;;    |____________________________________________________________|
;;;    | real-part         real-part-polar     real-part-rectangular|
;;;    |                                                            |
;;;    | imag-part         imag-part-polar     imag-part-rectangular|
;;;    |                                                            |
;;;    | magnitude         magnitude-polar     magnitude-rectangular|
;;;    |                                                            |
;;;    | angle             angle-polar         angle-polar          |
;;;    |____________________________________________________________|
;;; In case of data driven programming we need a function which is using this sort of table to call necessary functions.
<span class="ansi38-255165000"
>  (: lambda1 
    (-> Variable Atom 
      (-> $a $t)))
</span><span class="ansi38-255165000"
>  (= 
    ( (lambda1 $var $body) $val) 
    (let 
      (quote ($v $b)) 
      (sealed 
        ($var) 
        (quote ($var $body))) 
      (let 
        (quote $v) 
        (quote $val) $b)))
</span><span class="ansi38-255165000"
>  (: lambda2 
    (-> Variable Variable Atom 
      (-> $a $b $t)))
</span><span class="ansi38-255165000"
>  (= 
    ( (lambda2 $var1 $var2 $body) $val1 $val2) 
    (let 
      (quote ($v1 $v2 $b)) 
      (sealed 
        ($var1 $var2) 
        (quote ($var1 $var2 $body))) 
      (let 
        (quote ($v1 $v2)) 
        (quote ($val1 $val2)) $b)))
</span><span class="ansi38-255165000"
>  (: lambda3 
    (-> Variable Variable Variable Atom 
      (-> $a $b $c $t)))
</span><span class="ansi38-255165000"
>  (= 
    ( (lambda3 $var1 $var2 $var3 $body) $val1 $val2 $val3) 
    (let 
      (quote ($v1 $v2 $v3 $b)) 
      (sealed 
        ($var1 $var2 $var3) 
        (quote ($var1 $var2 $var3 $body))) 
      (let 
        (quote ($v1 $v2 $v3)) 
        (quote ($val1 $val2 $val3)) $b)))
</span><span class="ansi38-255165000"
>  (= 
    (car-list (Cons $x $xs)) $x)
</span><span class="ansi38-255165000"
>  (= 
    (car-list Nil) Nil)
</span><span class="ansi38-255165000"
>  (= 
    (cdr-list (Cons $x $xs)) $xs)
</span><span class="ansi38-255165000"
>  (= 
    (cdr-list Nil) Nil)
</span><span class="ansi38-255165000"
>  (= 
    (cadr-list $x) 
    (car-list (cdr-list $x)))
</span>;;; in the following code functions put and get are used. Those functions works with table and get/puts functions from/to
;;; it. Implementations of those functions is a part of further chapters so they won't be implemented here. So I'm not sure
;;; if this is something we need to leave here. Opinions?
;;;; inner functions
<span class="ansi38-255165000"
>  (= 
    (install-rectangular-package) 
    (let* 
      ( ($real-part (lambda1 $z (car-list $z))) 
        ($imag-part (lambda1 $z (cdr-list $z))) 
        ($make-from-real-imag (lambda2 $x $y (Cons $x $y))) 
        ($magnitude (lambda1 $z (sqrt (+ (square ($real-part $z)) (square ($imag-part $z)))))) 
        ($angle (lambda1 $z (atan ($imag-part $z) ($real-part $z)))) 
        ($make-from-mag-ang (lambda2 $r $a (Cons (* $r (cos $a)) (* $r (sin $a))))) 
        ($tag (lambda1 $x (attach-tag rectangular $x)))) 
      (let* 
        ( (() (put real-part (Cons rectangular Nil) $real-part)) 
          (() (put imag-part (Cons rectangular Nil) $imag-part)) 
          (() (put magnitude (Cons rectangular Nil) $magnitude)) 
          (() (put angle (Cons rectangular Nil) $angle)) 
          (() (put make-from-real-imag rectangular (lambda2 $x $y ($tag ($make-from-real-imag $x $y))))) 
          (() (put make-from-mag-ang rectangular (lambda2 $r $a ($tag ($make-from-mag-ang $r $a)))))) ())))
</span>;;;; inner functions
<span class="ansi38-255165000"
>  (= 
    (install-polar-package) 
    (let* 
      ( ($magnitude (lambda1 $z (car-list $z))) 
        ($angle (lambda1 $z (cdr-list $z))) 
        ($make-from-mag-ang (lambda2 $x $y (Cons $x $y))) 
        ($real-part (lambda1 $z (* ($magnitude $z) (cos ($angle $z))))) 
        ($imag-part (lambda1 $z (* ($magnitude $z) (sin ($angle $z))))) 
        ($make-from-real-imag (lambda2 $x $y (Cons (sqrt (+ (square $x) (square $y))) (atan $y $x)))) 
        ($tag (lambda1 $x (attach-tag polar $x)))) 
      (let* 
        ( (() (put real-part (Cons polar Nil) $real-part)) 
          (() (put imag-part (Cons polar Nil) $imag-part)) 
          (() (put magnitude (Cons polar Nil) $magnitude)) 
          (() (put angle (Cons polar Nil) $angle)) 
          (() (put make-from-real-imag polar (lambda2 $x $y ($tag ($make-from-real-imag $x $y))))) 
          (() (put make-from-mag-ang polar (lambda2 $r $a ($tag ($make-from-mag-ang $r $a)))))) ())))
</span>;;; This way we don't need to think about intersection of functions' names.
;;; Map function used here is the built-in Scheme function. Since this code due to not implemented put and get is sort of
;;; demonstration I won't implement it right now. Apply-generic is actually uses random number of arguments. In this case
;;; it should probably use some sort of car/cdr of $args but once again since this is a demonstrative code and I cant
;;; even launch it to check, I'll leave it like this.
<span class="ansi38-255165000"
>  (= 
    (apply-generic $op $args) 
    (let* 
      ( ($type-tags (map $type-tag $args)) ($proc (get $op $type-tags))) 
      (if $proc 
        (apply $proc 
          (map $contents $args)) 
        (Error 
          (apply-generic $op $args) "No method for these types"))))
</span><span class="ansi38-255165000"
>  (= 
    (real-part $z) 
    (apply-generic real-part $z))
</span><span class="ansi38-255165000"
>  (= 
    (imag-part $z) 
    (apply-generic imag-part $z))
</span><span class="ansi38-255165000"
>  (= 
    (magnitude $z) 
    (apply-generic magnitude $z))
</span><span class="ansi38-255165000"
>  (= 
    (angle $z) 
    (apply-generic angle $z))
</span><span class="ansi38-255165000"
>  (= 
    (make-from-real-imag $x $y) 
    ( (get make-from-real-imag rectangular) $x $y))
</span><span class="ansi38-255165000"
>  (= 
    (make-from-mag-ang $r $a) 
    ( (get make-from-mag-ang polar) $r $a))
</span>;;; Exercise 2.73.
;;;
;;; Section 2.3.2 described a program that performs
;;; symbolic differentiation:
;;;(= (deriv $exp $var)
;;;      (if (number? $exp)
;;;            0
;;;            (if (variable? $exp)
;;;                (if (same-variable? $exp $var) 1 0)
;;;                (if (sum? $exp)
;;;                     (make-sum (deriv (addend $exp) $var)
;;;                               (deriv (augend $exp) $var))
;;;                     (if (product? $exp)
;;;                         (make-sum
;;;                              (make-product (multiplier $exp)
;;;                                            (deriv (multiplicand $exp) $var))
;;;                              (make-product (deriv (multiplier $exp) $var)
;;;                                            (multiplicand $exp)))
;;;                         (Error (deriv $exp $var) "Unknown expression type"))))))
;;; We can regard this program as performing a dispatch on the type of the
;;; expression to be differentiated. In this situation the ``type tag'' of the
;;; datum is the algebraic operator symbol (such as +) and the operation being
;;; performed is deriv. We can transform this program into data-directed style by
;;; rewriting the basic derivative procedure as
<span class="ansi38-255165000"
>  (= 
    (number? $x) 
    (and 
      (== 
        (get-type $x) Number) 
      (not (== (get-metatype $x) Expression))))
</span><span class="ansi38-255165000"
>  (= 
    (variable? $x) 
    (== 
      (get-metatype $x) Symbol))
</span><span class="ansi38-255165000"
>  (= 
    (same-variable? $v1 $v2) 
    (and$ ((variable? $v1) (variable? $v2) (== $v1 $v2))))
</span><span class="ansi38-255165000"
>  (= 
    (car $x) 
    (car-atom $x))
</span><span class="ansi38-255165000"
>  (= 
    (cdr $x) 
    (cdr-atom $x))
</span><span class="ansi38-255165000"
>  (= 
    (operator $exp) 
    (car $exp))
</span><span class="ansi38-255165000"
>  (= 
    (operands $exp) 
    (cdr $exp))
</span><span class="ansi38-255165000"
>  (= 
    (apply-deriv $exp $var) 
    (if 
      (number? $exp) 0 
      (if 
        (variable? $exp) 
        (if 
          (same-variable? $exp $var) 1 0) 
        ( (get deriv 
            (operator $exp)) 
          (operands $exp) $var))))
</span>;;; Write the procedures for derivatives of sums and products, and the
;;; auxiliary code required to install them in the table used by the program
;;; above.
;;; Choose any additional differentiation rule that you like, such as the one
;;; for exponents (exercise 2.56), and install it in this data-directed system.
<span class="ansi38-255165000"
>  (= 
    (cadr $x) 
    (car (cdr $x)))
</span><span class="ansi38-255165000"
>  (= 
    (caddr $x) 
    (car (cdr (cdr $x))))
</span><span class="ansi38-255165000"
>  (= 
    (make-sum_simplified $a1 $a2) 
    (if 
      (=number? $a1 0) $a2 
      (if 
        (=number? $a2 0) $a1 
        (if 
          (and 
            (number? $a1) 
            (number? $a2)) 
          (+ $a1 $a2) 
          ('+ $a1 $a2)))))

(= (make-product_simplified $m1 $m2)
  (if (or (=number? $m1 0) (=number? $m2 0))
        0
        (if (=number? $m1 1)
            $m2
            (if (=number? $m2 1)
                $m1
                (if (and (number? $m1) (number? $m2))
                    (* $m1 $m2)
                    (' * $m1 $m2)))))
</span><span class="ansi38-255165000"
> )
</span>;;; This one should probably add sum and project derivs to the table. I'll also added exponentiation here so I won't need
;;; to split this to another install function with duplicative make-product.
<span class="ansi38-255165000"
>  (= 
    (install-sum-product-deriv) 
    (let* 
      ( ($addend (lambda1 $exp (cadr $exp))) 
        ($augend (lambda1 $exp (caddr $exp))) 
        ($=number? (lambda2 $exp $num (and (number? $exp) (== $exp $num)))) 
        ($make-sum (lambda2 $a1 $a2 (if ($=number? $a1 0) $a2 (if ($=number? $a2 0) $a1 (if (and (number? $a1) (number? $a2)) (+ $a1 $a2) ('+ $a1 $a2))))))
    ($multiplier (lambda1 $exp (cadr $exp)))
    ($multiplicand (lambda1 $exp (caddr $exp)))
    ($make-product (lambda2 $m1 $m2
        (if (or ($=number? $m1 0) ($=number? $m2 0))
            0
            (if ($=number? $m1 1)
                $m2
                (if ($=number? $m2 1)
                    $m1
                    (if (and (number? $m1) (number? $m2))
                        (* $m1 $m2)
                        (' * $m1 $m2))))))) 
      ($base (lambda1 $exp (cadr $exp))) 
      ($exponent (lambda1 $exp (caddr $exp))) 
      ($make-exponentiation (lambda3 $base $dbase $exponent (let $newe (- $exponent 1) (if (== $newe 0) $dbase (if (== $newe 1) ($make-product $exponent ($make-product $base $dbase)) ($make-product ($make-product $exponent (** $base (- $exponent 1))) $dbase))))))) 
    (let* 
      ( (() (put deriv '+ (lambda2 $exp $var ($make-sum (apply-deriv ($addend $exp) $var)
                               (apply-deriv ($augend $exp) $var)))))
        (() (put deriv ' * (lambda2 $exp $var ($make-sum ($make-product ($multiplier $exp) (apply-deriv ($multiplicand $exp) $var)) ($make-product (apply-deriv ($multiplier $exp) $var) ($multiplicand $exp)))))) (() (put deriv ** (lambda2 $exp $var ($make-exponentiation ($base $exp) (apply-deriv ($base $exp) $var) ($exponent $exp)))))) ()))
</span><span class="ansi38-255165000"
> )
</span>;;; Once again I can't test it since we do not have put and get functions. So I'll call it an end of this exercise.
;;; -----------------------End of Exercise 2.73---------------------------
;;; Exercise 2.74.
;;;
;;; Insatiable Enterprises, Inc., is a highly decentralized
;;; conglomerate company consisting of a large number of independent divisions
;;; located all over the world. The company's computer facilities have just been
;;; interconnected by means of a clever network-interfacing scheme that makes the
;;; entire network appear to any user to be a single computer. Insatiable's
;;; president, in her first attempt to exploit the ability of the network to
;;; extract administrative information from division files, is dismayed to
;;; discover that, although all the division files have been implemented as data
;;; structures in Scheme, the particular data structure used varies from division
;;; to division. A meeting of division managers is hastily called to search for a
;;; strategy to integrate the files that will satisfy headquarters' needs while
;;; preserving the existing autonomy of the divisions.
;;; Show how such a strategy can be implemented with data-directed programming.
;;; As an example, suppose that each division's personnel records consist of a
;;; single file, which contains a set of records keyed on employees' names. The
;;; structure of the set varies from division to division. Furthermore, each
;;; employee's record is itself a set (structured differently from division to
;;; division) that contains information keyed under identifiers such as address
;;; and salary. In particular:
;;; a.  Implement for headquarters a get-record procedure that retrieves a
;;; specified employee's record from a specified personnel file. The procedure
;;; should be applicable to any division's file. Explain how the individual
;;; divisions' files should be structured. In particular, what type information
;;; must be supplied?
;;; b.  Implement for headquarters a get-salary procedure that returns the salary
;;; information from a given employee's record from any division's personnel
;;; file. How should the record be structured in order to make this operation
;;; work?
;;; c.  Implement for headquarters a find-employee-record procedure. This should
;;; search all the divisions' files for the record of a given employee and return
;;; the record. Assume that this procedure takes as arguments an employee's name
;;; and a list of all the divisions' files.
<span class="ansi38-255165000"
>  (= 
    (null? $expr) 
    (== $expr ()))
</span><span class="ansi38-255165000"
>  (= 
    (list $expr) 
    (if 
      (null? $expr) Nil 
      (Cons 
        (car-atom $expr) 
        (list (cdr-atom $expr)))))
</span><span class="ansi38-255165000"
>  (= 
    (tree $expr) 
    (if 
      (null? $expr) Nil 
      (let* 
        ( ($head (car-atom $expr)) ($tail (cdr-atom $expr))) 
        (if 
          (== 
            (get-metatype $head) Expression) 
          (Cons 
            (tree $head) 
            (tree $tail)) 
          (Cons $head 
            (tree $tail))))))
</span><span class="ansi38-255165000"
>  (= 
    (null-list? $list) 
    (== $list Nil))
</span>;;; Division1 record file and insert function.
<span class="ansi38-255165000"
>  (= 
    (division1-recordfile) 
    (tree ((John John_address 1000$) (Jim Jim_address 300$))))
</span>;;; This one should insert necessary functions to retrieve info from division1's record file.
<span class="ansi38-255165000"
>  (= 
    (insert-division1-records) 
    (let* 
      ( ($emp_name (lambda1 $record_file (car-list (car-list $record_file)))) 
        ($record_by_name (lambda3 $name $record_file $self (if (null-list? $record_file) Nil (if (== $name ($emp_name $record_file)) (car-list $record_file) ($self $name (cdr-list $record-file) $self))))) 
        ($salary (lambda1 $record (cadr-list $record))) 
        ($address (lambda1 $record (car-list $record)))) 
      (let* ((() (put get-record division1 (lambda2 $name $record_file ($record_by_name $name $record_file $record_by_name)))) (() (put get-salary division1 (lambda1 $record ($salary $record))))))))
</span>;;; Division2 record file and insert function.
<span class="ansi38-255165000"
>  (= 
    (division2-recordfile) 
    (list ((Peter . Peter_address . 5200$) (Kane . Kane_address 1500$))))
</span><span class="ansi38-255165000"
>  (= 
    (insert-division2-records) 
    (let* 
      ( ($emp_name (lambda1 ($name . $address . $salary) $name)) 
        ($salary (lambda1 ($name . $address . $salary) $salary)) 
        ($address (lambda1 ($name . $address . $salary) $address)) 
        ($record_by_name (lambda3 $name $record_file $self (if (null-list? $record_file) Nil (if (== $name ($emp_name $record_file)) (car-list $record_file) ($self $name (cdr-list $record-file) $self)))))) 
      (let* ((() (put get-record division2 (lambda2 $name $record_file ($record_by_name $name $record_file $record_by_name)))) (() (put get-salary division2 (lambda1 $record ($salary $record))))))))
</span>;;; a)
<span class="ansi38-255165000"
>  (= 
    (get-record $emp_name $division $division_recordfile) 
    ( (get get-record $division) $emp_name $division_recordfile))
</span>;;; b)
<span class="ansi38-255165000"
>  (= 
    (get-salary $division $record) 
    ( (get get-salary $division) $record))
</span>;;; c)
;;; Let division_recordfiles contain pairs ($division_name . $record_file). Output is the first entry of emp_name in any
;;; record file.
<span class="ansi38-255165000"
>  (= 
    (find-employee-record $emp_name Nil) 
    (Error 
      (find-employee-record $emp_name Nil) "No such employee in input record files"))
</span><span class="ansi38-255165000"
>  (= 
    (find-employee-record $emp_name 
      (Cons 
        ($division_name . $record_file) $tail)) 
    (let $get-rec-res 
      (get-record $emp_name $division_name $record_file) 
      (if 
        (== $get-rec-res Nil) 
        (find-employee-record $emp_name $tail) $get-rec-res)))
</span>;;; -----------------------End of Exercise 2.74---------------------------
;;; Message passing style:
<span class="ansi38-255165000"
>  (= 
    (make-from-real-imag_message $x $y) 
    (let $dispatch 
      (lambda1 $op 
        (if 
          (== $op real-part) $x 
          (if 
            (== $op imag-part) $y 
            (if 
              (== $op magnitude) 
              (sqrt (+ (square $x) (square $y))) 
              (if 
                (== $op angle) 
                (atan $y $x) 
                (Error 
                  (make-from-real-imag_message $x $y) "Unknown operation")))))) $dispatch))
</span><span class="ansi38-255165000"
>  (= 
    (apply-generic_message $op $arg) 
    ($arg $op))
</span>;;; Exercise 2.75.  Implement the constructor make-from-mag-ang in
;;; message-passing style. This procedure should be analogous to the
;;; make-from-real-imag procedure given.
<span class="ansi38-255165000"
>  (= 
    (make-from-mag-ang_message $m $a) 
    (let $dispatch 
      (lambda1 $op 
        (if 
          (== $op real-part) 
          (* $m 
            (cos $a)) 
          (if 
            (== $op imag-part) 
            (* $m 
              (sin $a)) 
            (if 
              (== $op magnitude) $m 
              (if 
                (== $op angle) $a 
                (Error 
                  (make-from-mag-ang_message $m $a) "Unknown operation")))))) $dispatch))
</span>;;; Some asserts for those message passing functions:
<span class="ansi38-013099040"
>  !(bind! &m_z1 
    (make-from-real-imag_message 5 2))

</span>

Deterministic: ()
[()]
<span class="ansi38-013099040"
>  !(bind! &m_z2 
    (make-from-mag-ang_message 3 4))

</span>

Deterministic: ()
[()]
<span class="ansi38-013099040"
>  !(assertEqual 
    (apply-generic_message real-part &m_z1) 5)

</span>[

;<h3 id="SICP-BOOK.CHAPTER-2-4.15"
>;; SICP-BOOK.CHAPTER-2-4.15</h3>
; 
; EVAL TEST
; took 0.000948 secs. (947.91 microseconds) 

  !(assertEqual 
    (apply-generic_message real-part &m_z1) 5)

<span class="ansi36"
>  (loonit_success  
    (equal_enough_for_test  
      (5) 
      (5)))
</span>
Deterministic: ()
()]
<span class="ansi38-013099040"
>  !(assertEqual 
    (apply-generic_message real-part &m_z2) -1.960930862590836)

</span>[

;<h3 id="SICP-BOOK.CHAPTER-2-4.16"
>;; SICP-BOOK.CHAPTER-2-4.16</h3>
; 
; EVAL TEST
; took 0.000978 secs. (978.06 microseconds) 

  !(assertEqual 
    (apply-generic_message real-part &m_z2) -1.960930862590836)

<span class="ansi36"
>  (loonit_success  
    (equal_enough_for_test  
      (-1.960930862590836) 
      (-1.960930862590836)))
</span>
Deterministic: ()
()]
<span class="ansi38-013099040"
>  !(assertEqual 
    (apply-generic_message imag-part &m_z1) 2)

</span>[

;<h3 id="SICP-BOOK.CHAPTER-2-4.17"
>;; SICP-BOOK.CHAPTER-2-4.17</h3>
; 
; EVAL TEST
; took 0.000927 secs. (926.56 microseconds) 

  !(assertEqual 
    (apply-generic_message imag-part &m_z1) 2)

<span class="ansi31"
>  (loonit_failureR  
    (equal_enough_for_test  () 
      (2)))
</span>
Deterministic: ((Error  (got  ()) (expected  (2))))
((Error  (got  ()) (expected  (2))))]
<span class="ansi38-013099040"
>  !(assertEqual 
    (apply-generic_message imag-part &m_z2) -2.2704074859237844)

</span>[

;<h3 id="SICP-BOOK.CHAPTER-2-4.18"
>;; SICP-BOOK.CHAPTER-2-4.18</h3>
; 
; EVAL TEST
; took 0.000926 secs. (926.19 microseconds) 

  !(assertEqual 
    (apply-generic_message imag-part &m_z2) -2.2704074859237844)

<span class="ansi31"
>  (loonit_failureR  
    (equal_enough_for_test  () 
      (-2.2704074859237844)))
</span>
Deterministic: ((Error  (got  ()) (expected  (-2.2704074859237844))))
((Error  (got  ()) (expected  (-2.2704074859237844))))]
<span class="ansi38-013099040"
>  !(assertEqual 
    (apply-generic_message magnitude &m_z1) 5.385164807134504)

</span>[

;<h3 id="SICP-BOOK.CHAPTER-2-4.19"
>;; SICP-BOOK.CHAPTER-2-4.19</h3>
; 
; EVAL TEST
; took 0.000941 secs. (940.71 microseconds) 

  !(assertEqual 
    (apply-generic_message magnitude &m_z1) 5.385164807134504)

<span class="ansi31"
>  (loonit_failureR  
    (equal_enough_for_test  () 
      (5.385164807134504)))
</span>
Deterministic: ((Error  (got  ()) (expected  (5.385164807134504))))
((Error  (got  ()) (expected  (5.385164807134504))))]
<span class="ansi38-013099040"
>  !(assertEqual 
    (apply-generic_message magnitude &m_z2) 3)

</span>[

;<h3 id="SICP-BOOK.CHAPTER-2-4.20"
>;; SICP-BOOK.CHAPTER-2-4.20</h3>
; 
; EVAL TEST
; took 0.000871 secs. (870.87 microseconds) 

  !(assertEqual 
    (apply-generic_message magnitude &m_z2) 3)

<span class="ansi31"
>  (loonit_failureR  
    (equal_enough_for_test  () 
      (3)))
</span>
Deterministic: ((Error  (got  ()) (expected  (3))))
((Error  (got  ()) (expected  (3))))]
<span class="ansi38-013099040"
>  !(assertEqual 
    (apply-generic_message angle &m_z1) 0.3805063771123649)

</span>[

;<h3 id="SICP-BOOK.CHAPTER-2-4.21"
>;; SICP-BOOK.CHAPTER-2-4.21</h3>
; 
; EVAL TEST
; took 0.000868 secs. (867.65 microseconds) 

  !(assertEqual 
    (apply-generic_message angle &m_z1) 0.3805063771123649)

<span class="ansi31"
>  (loonit_failureR  
    (equal_enough_for_test  () 
      (0.3805063771123649)))
</span>
Deterministic: ((Error  (got  ()) (expected  (0.3805063771123649))))
((Error  (got  ()) (expected  (0.3805063771123649))))]
<span class="ansi38-013099040"
>  !(assertEqual 
    (apply-generic_message angle &m_z2) 4)

</span>[

;<h3 id="SICP-BOOK.CHAPTER-2-4.22"
>;; SICP-BOOK.CHAPTER-2-4.22</h3>
; 
; EVAL TEST
; took 0.000882 secs. (882.24 microseconds) 

  !(assertEqual 
    (apply-generic_message angle &m_z2) 4)

<span class="ansi31"
>  (loonit_failureR  
    (equal_enough_for_test  () 
      (4)))
</span>
Deterministic: ((Error  (got  ()) (expected  (4))))
((Error  (got  ()) (expected  (4))))]
;;; -----------------------End of Exercise 2.75---------------------------
<span class="ansi32"
>% 2,318,454 inferences, 0.642 CPU in 0.642 seconds (100% CPU, 3612613 Lips)
</span>P;HTML|
;                         (= /home/runner/work/metta-wam/metta-wam/tests/extended_compat/metta-examples/SICP_book/chapter_2_4.metta  0)
<span class="ansi1"
>LoonIt Report
</span>------------
<span class="ansi32"
>Successes: 14
</span><span class="ansi31"
>Failures: 8
</span><br/> <a href="#" onclick="window.history.back(); return false;"
>Return to summaries</a><br/>
P;HTML|
;           (is_cmd_option  execute halt --halt=true true)
P;HTML|
;            (set_option_value  halt true)
P;HTML|
;            (is_cmd_option  execute stdin --stdin=tty tty)
P;HTML|
;            (set_option_value  stdin tty)
P;HTML|
;            (is_cmd_option  execute stdout --stdout=tty tty)
P;HTML|
;             (set_option_value  stdout tty)
P;HTML|
;            (is_cmd_option  execute stderr --stderr=tty tty)
P;HTML|
;             (set_option_value  stderr tty)
P;HTML|
;           (set_option_value  prolog false)
P;HTML|
;           (set_option_value  compat auto)
P;HTML|
;           (set_option_value  compatio true)

Script done on 2024-10-06 01:00:50+00:00 [COMMAND_EXIT_CODE="7"]

</pre>
</body>

</html>
\033[0;32mCompleted successfully (EXITCODE=7) Under 40 seconds: ./mettalog '--output=./reports/tests_output/baseline-compat-2024-10-06T00:36:50/' --timeout=40 --html --repl=false  --test "tests/extended_compat/metta-examples/SICP_book/chapter_2_4.metta" --halt=true\033[0m

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"
>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"
>
<title></title>
<style type="text/css"
>
.ansi2html-content { display: inline; white-space: pre-wrap; word-wrap: break-word; }
.body_foreground { color: #AAAAAA; }
.body_background { background-color: #000000; }
.inv_foreground { color: #000000; }
.inv_background { background-color: #AAAAAA; }
.ansi32 { color: #00aa00; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
</style>
</head>
<body class="body_foreground body_background" style="font-size: normal;" >
<pre class="ansi2html-content"
>
Script started on 2024-09-20 01:14:11+00:00 [TERM="xterm-256color" TTY="/dev/pts/0" COLUMNS="-1" LINES="-1"]
P;HTML|
;           (set_option_value  prolog false)

P;HTML|
;           (set_option_value  compat auto)

P;HTML|
;           (set_option_value  compatio true)
P;HTML|
;            (is_cmd_option  prescan halt --halt=true true)
P;HTML|
;            (set_option_value  halt true)
P;HTML|
;            (is_cmd_option  prescan stdin --stdin=tty tty)
P;HTML|
;             (set_option_value  stdin tty)
P;HTML|
;            (is_cmd_option  prescan stdout --stdout=tty tty)
P;HTML|
;             (set_option_value  stdout tty)
P;HTML|
;            (is_cmd_option  prescan stderr --stderr=tty tty)
P;HTML|
;             (set_option_value  stderr tty)
P;HTML|
;            (set_option_value  prolog false)
P;HTML|
;            (set_option_value  compat auto)
P;HTML|
;            (set_option_value  compatio true)
P;HTML|
;          (is_cmd_option  execute python --python=enable enable)
P;HTML|
;           (set_option_value  python enable)
P;HTML|
;          (is_cmd_option  execute timeout --timeout=40 40)
P;HTML|
;           (set_option_value  timeout 40)
P;HTML|
;           (is_cmd_option  execute output --output=./reports/tests_output/baseline-compat-2024-09-20T00:33:03/ ./reports/tests_output/baseline-compat-2024-09-20T00:33:03/)
P;HTML|
;           (set_option_value  output ./reports/tests_output/baseline-compat-2024-09-20T00:33:03/)
P;HTML|
;           (is_cmd_option  execute html --html true)
P;HTML|
;            (set_option_value  html true)
P;HTML|
;           (is_cmd_option  execute test --test true)
P;HTML|
;            (set_option_value  test true)

; (load_metta_file  &self tests/extended_compat/hyperon-pln/metta/dependent-types/ImplicationDirectIntroductionDTLTest.metta)
P;HTML|
;                         (track_load_into_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/dependent-types/ImplicationDirectIntroductionDTLTest.metta)
P;HTML|
;                                          (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/dependent-types/ImplicationDirectIntroductionDTLTest.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/dependent-types/ImplicationDirectIntroductionDTLTest.metta)
P;HTML|
;                                           (= 1  "+ '[' 0 -eq 1 ']'")
P;HTML|
;                                           (= 1  "+ echo 'Doing: timeout --foreground --kill-after=5 --signal=SIGINT 61 time metta /opt/logicmoo_opencog/hyperon-wam/examples/baseline_compat/hyperon-pln_metta/dependent-types/ImplicationDirectIntroductionDTLTest.metta'")
P;HTML|
;                                           (= 1  "Doing: timeout --foreground --kill-after=5 --signal=SIGINT 61 time metta /opt/logicmoo_opencog/hyperon-wam/examples/baseline_compat/hyperon-pln_metta/dependent-types/ImplicationDirectIntroductionDTLTest.metta")
P;HTML|
;                                           (= 1  "+ eval 'timeout --foreground --kill-after=5 --signal=SIGINT 61 time metta /opt/logicmoo_opencog/hyperon-wam/examples/baseline_compat/hyperon-pln_metta/dependent-types/ImplicationDirectIntroductionDTLTest.metta'")
P;HTML|
;                                           (= 1  "++ timeout --foreground --kill-after=5 --signal=SIGINT 61 time metta /opt/logicmoo_opencog/hyperon-wam/examples/baseline_compat/hyperon-pln_metta/dependent-types/ImplicationDirectIntroductionDTLTest.metta")
P;HTML|
;                                          (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/dependent-types/ImplicationDirectIntroductionDTLTest.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/dependent-types/ImplicationDirectIntroductionDTLTest.metta)
P;HTML|
;                                           (= 1  "+ '[' 0 -eq 1 ']'")
P;HTML|
;                                           (= 1  "+ echo 'Doing: timeout --foreground --kill-after=5 --signal=SIGINT 61 time metta /opt/logicmoo_opencog/hyperon-wam/examples/baseline_compat/hyperon-pln_metta/dependent-types/ImplicationDirectIntroductionDTLTest.metta'")
P;HTML|
;                                           (= 1  "Doing: timeout --foreground --kill-after=5 --signal=SIGINT 61 time metta /opt/logicmoo_opencog/hyperon-wam/examples/baseline_compat/hyperon-pln_metta/dependent-types/ImplicationDirectIntroductionDTLTest.metta")
P;HTML|
;                                           (= 1  "+ eval 'timeout --foreground --kill-after=5 --signal=SIGINT 61 time metta /opt/logicmoo_opencog/hyperon-wam/examples/baseline_compat/hyperon-pln_metta/dependent-types/ImplicationDirectIntroductionDTLTest.metta'")
P;HTML|
;                                           (= 1  "++ timeout --foreground --kill-after=5 --signal=SIGINT 61 time metta /opt/logicmoo_opencog/hyperon-wam/examples/baseline_compat/hyperon-pln_metta/dependent-types/ImplicationDirectIntroductionDTLTest.metta")

;;;; Test Implication Direct Introduction DTL Rule
;;;; Import modules
<span class="ansi38-013099040"
>  !(import! &self ImplicationDirectIntroductionDTL.metta)

</span>[P;HTML|
;                                           (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/dependent-types/ImplicationDirectIntroductionDTL.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/dependent-types/ImplicationDirectIntroductionDTL.metta)
P;HTML|
;                                           (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/dependent-types/ImplicationDirectIntroductionDTL.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/dependent-types/ImplicationDirectIntroductionDTL.metta)

;;;; MeTTa port of the Implication Direct Introduction PLN rule, encoded
;;;; as dependent types, i.e. propositions as types.
;;;;
;;;; See ImplicationDirectIntroductionEntail.metta for more detail on a
;;;; pseudo formal description.
;;;;
;;;; In the case of dependent types, inference rules are constructors of
;;;; the propositions to be proven.  Then a proof is an tree composed of
;;;; calls of such constructors.
;;;;
;;;; For instance assuming two inference rules
;;;;
;;;; ImplicationDirectIntroduction (IDI, for short)
;;;; Deduction (DED, for short)
;;;;
;;;; The following inference tree
;;;;
;;;; ...            ...
;;;; -----(IDI)     -----(IDI)
;;;; P → Q          Q → R
;;;; ---------------------(DED)
;;;;         P → R
;;;;
;;;; is represented by the following MeTTa expression
;;;;
;;;; (Deduction
;;;;    (ImplicationDirectIntroduction ...)
;;;;    (ImplicationDirectIntroduction ...))
;;;;
;;;; where the premises of ImplicationDirectIntroduction are left
;;;; undefined for now.
;;;;
;;;; How such propositions as types can be defined still remains to be
;;;; determined but ideally it may look something like
;;;;
;;;; (: Deduction
;;;;    (-> (≞ (→ $P $Q) $TV1)
;;;;        (≞ (→ $Q $R) $TV2)
;;;;        (≞ (→ $P $R) (deduction-formula $TV1 $TV2))))
;;;;
;;;; where ≞, → are dependent types, and formula is just a regular metta
;;;; function.
;;;; Import modules
<span class="ansi38-013099040"
>  !(import! &self ../common/truthvalue/EvidentialTruthValue.metta)

</span>P;HTML|
;                                           (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/truthvalue/EvidentialTruthValue.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/truthvalue/EvidentialTruthValue.metta)
P;HTML|
;                                           (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/truthvalue/EvidentialTruthValue.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/truthvalue/EvidentialTruthValue.metta)

;;;; Evidential truth value type. Represent a truth value alongside its
;;;; evidence.
<span class="ansi38-013099040"
>  !(import! &self TruthValue.metta)

</span>P;HTML|
;                                           (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/truthvalue/TruthValue.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/truthvalue/TruthValue.metta)
P;HTML|
;                                           (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/truthvalue/TruthValue.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/truthvalue/TruthValue.metta)

;;;; Truth value type definition
;;;; Import modules
<span class="ansi38-013099040"
>  !(import! &self ../Num.metta)

</span>P;HTML|
;                                           (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/Num.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/Num.metta)
P;HTML|
;                                           (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/Num.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/Num.metta)

;;;; Collection of functions operating on numbers
;;;; Define max
<span class="ansi38-255165000"
>  (: max 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (max $x $y) 
    (if 
      (> $x $y) $x $y))
</span>;;;; Define min
<span class="ansi38-255165000"
>  (: min 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (min $x $y) 
    (if 
      (< $x $y) $x $y))
</span>;;;; Clamp a number to be within a certain range
<span class="ansi38-255165000"
>  (: clamp 
    (-> $a $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (clamp $x $l $u) 
    (max $l 
      (min $u $x)))
</span>;;;; Define abs
<span class="ansi38-255165000"
>  (: abs 
    (-> $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (abs $x) 
    (if 
      (< $x 0) 
      (* -1 $x) $x))
</span>;;;; Define <=
<span class="ansi38-255165000"
>  (: <= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (<= $x $y) 
    (or 
      (< $x $y) 
      (== $x $y)))
</span>;;;; Define >=
<span class="ansi38-255165000"
>  (: >= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (>= $x $y) 
    (or 
      (> $x $y) 
      (== $x $y)))
</span>;;;; Define approximately equal
<span class="ansi38-255165000"
>  (: approxEq 
    (-> $a $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (approxEq $x $y $epsilon) 
    (<= 
      (abs (- $x $y)) $epsilon))
</span>;;;; Define Nat
<span class="ansi38-255165000"
>  (: Nat Type)
</span><span class="ansi38-255165000"
>  (: Z Nat)
</span><span class="ansi38-255165000"
>  (: S 
    (-> Nat Nat))
</span>;;;; Define cast functions between Nat and Number
<span class="ansi38-255165000"
>  (: fromNumber 
    (-> Number Nat))
</span><span class="ansi38-255165000"
>  (= 
    (fromNumber $n) 
    (if 
      (<= $n 0) Z 
      (S (fromNumber (- $n 1)))))
</span><span class="ansi38-255165000"
>  (: fromNat 
    (-> Nat Number))
</span><span class="ansi38-255165000"
>  (= 
    (fromNat Z) 0)
</span><span class="ansi38-255165000"
>  (= 
    (fromNat (S $k)) 
    (+ 1 
      (fromNat $k)))
</span>;;;; Define a generic less than operator, ⩻, for Nat.  < cannot be used
;;;; because it is a built-in, its type is hardwired and cannot be
;;;; overloaded.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Nat Nat Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $ Z) False)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ Z 
      (S $)) True)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ 
      (S $x) 
      (S $y)) 
    (⩻ $x $y))
</span>;;;; Overload ⩻ for Number.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Number Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $x $y) 
    (< $x $y))
</span>;;;; Return the ceiling of a non negative number.  If the number is
;;;; negative it returns 1.
<span class="ansi38-255165000"
>  (: ceil 
    (-> Number Number))
</span><span class="ansi38-255165000"
>  (= 
    (ceil $n) 
    (fromNat (fromNumber $n)))
</span>;;;; Convert Number to Bool.  Anything above 0 converts to True.
<span class="ansi38-255165000"
>  (: number->bool 
    (-> Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (number->bool $x) 
    (< 0 $x))
</span>;;;; Convert Bool to Number.  False converts to 0, True converts to 1.
<span class="ansi38-255165000"
>  (: bool->number 
    (-> Bool Number))
</span><span class="ansi38-255165000"
>  (= 
    (bool->number False) 0)
</span><span class="ansi38-255165000"
>  (= 
    (bool->number True) 1)
</span>;;;; Define a less than type.  Note that it is purposefully different
;;;; than ⩻ as it is a type, not an operator.  Inhabitants of (⍃ x y)
;;;; are proofs that x ⩻ y == True.  For now ⍃ is only axiomatized for
;;;; Nat.
<span class="ansi38-255165000"
>  (: ⍃ 
    (-> $t $t Type))
</span>;;;; Zero is always less than the successor of something
<span class="ansi38-255165000"
>  (: 
    (zero-lt-succ-axiom) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (zero-lt-succ-axiom) 
    (: ZeroLTSucc 
      (⍃ Z 
        (S $k))))
</span>;;;; If x ⍃ y then (S x) ⍃ (S y)
<span class="ansi38-255165000"
>  (: 
    (succ-monotonicity-rule) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (succ-monotonicity-rule) 
    (: SuccMonotonicity 
      (-> 
        (⍃ $x $y) 
        (⍃ 
          (S $x) 
          (S $y)))))
</span>
Deterministic: ()
;;;;;;;;;;;;
;;;; Type ;;
;;;;;;;;;;;;
<span class="ansi38-255165000"
>  (: TruthValue Type)
</span>;;;;;;;;;;;;;;;;;;;;
;;;; Constructors ;;
;;;;;;;;;;;;;;;;;;;;
;;;; Boolean TV constructor
;;;; TODO: alternatively we could have (: ⊤ TruthValue) and (: ⊥ TruthValue)
<span class="ansi38-255165000"
>  (: Bl 
    (-> Bool TruthValue))
</span>;;;; First order probability TV constructor, i.e. mere probability.
<span class="ansi38-255165000"
>  (: Pr 
    (-> Number TruthValue))
</span>;;;; Simple Truth Value.  A Second order probability TV constructor,
;;;; i.e. probability and confidence.  The probability is in fact the
;;;; mode of the corresponding beta distribution.
<span class="ansi38-255165000"
>  (: STV 
    (-> Number Number TruthValue))
</span>;;;;;;;;;;;;;;;;;
;;;; Constants ;;
;;;;;;;;;;;;;;;;;
;;;; For now the underlying beta distributions have a Jeffreys prior,
;;;; i.e. the prior alpha and beta are 0.5.
<span class="ansi38-255165000"
>  (: prior-alpha 
    (-> Number))
</span><span class="ansi38-255165000"
>  (= 
    (prior-alpha) 0.5)
</span><span class="ansi38-255165000"
>  (: prior-beta 
    (-> Number))
</span><span class="ansi38-255165000"
>  (= 
    (prior-beta) 0.5)
</span>;;;; Lookahead
<span class="ansi38-255165000"
>  (: lookahead 
    (-> Number))
</span><span class="ansi38-255165000"
>  (= 
    (lookahead) 1.0)
</span>;;;; Maximum supported count (till +inf is supported, possibly).
<span class="ansi38-255165000"
>  (: max-count 
    (-> Number))
</span><span class="ansi38-255165000"
>  (= 
    (max-count) 1000000000.0)
</span>;;;;;;;;;;;;;;;
;;;; Methods ;;
;;;;;;;;;;;;;;;
;;;; Convert count to confidence using the formula
;;;;
;;;; confidence = count / (count + lookahead)
<span class="ansi38-255165000"
>  (: count->confidence 
    (-> Number Number))
</span><span class="ansi38-255165000"
>  (= 
    (count->confidence $cnt) 
    (/ $cnt 
      (+ $cnt 
        (lookahead))))
</span>;;;; Convert confidence to count using the formula
;;;;
;;;; count = (confidence * lookahead) / (1 - confidence)
<span class="ansi38-255165000"
>  (: confidence->count 
    (-> Number Number))
</span><span class="ansi38-255165000"
>  (= 
    (confidence->count $conf) 
    (if 
      (approxEq 1.0 $conf 1.0e-9) 
      (max-count) 
      (/ 
        (* $conf 
          (lookahead)) 
        (- 1.0 $conf))))
</span>;;;; Increment the negative count of a given truth value, by
;;;; incrementing its total count without incrementing the positive
;;;; count.
<span class="ansi38-255165000"
>  (: inc-neg-count 
    (-> TruthValue TruthValue))
</span><span class="ansi38-255165000"
>  (= 
    (inc-neg-count (STV $s $c)) 
    (let* 
      ( ($tot_cnt (confidence->count $c)) 
        ($pos_cnt (* $s $tot_cnt)) 
        ($new_tot_cnt (+ $tot_cnt 1))) 
      (STV 
        (/ $pos_cnt $new_tot_cnt) 
        (count->confidence $new_tot_cnt))))
</span>;;;; Increment the positive count of a given truth value, by
;;;; incrementing its total count and its positive count.
<span class="ansi38-255165000"
>  (: inc-pos-count 
    (-> TruthValue TruthValue))
</span><span class="ansi38-255165000"
>  (= 
    (inc-pos-count (STV $s $c)) 
    (let* 
      ( ($tot_cnt (confidence->count $c)) 
        ($pos_cnt (* $s $tot_cnt)) 
        ($new_pos_cnt (+ $pos_cnt 1)) 
        ($new_tot_cnt (+ $tot_cnt 1))) 
      (STV 
        (/ $new_pos_cnt $new_tot_cnt) 
        (count->confidence $new_tot_cnt))))
</span>;;;; Return the first order probability mode of the second order
;;;; distribution associated to a truth value.
<span class="ansi38-255165000"
>  (: mode 
    (-> TruthValue Number))
</span><span class="ansi38-255165000"
>  (= 
    (mode (Bl True)) 1.0)
</span><span class="ansi38-255165000"
>  (= 
    (mode (Bl False)) 0.0)
</span><span class="ansi38-255165000"
>  (= 
    (mode (Pr $pr)) $pr)
</span><span class="ansi38-255165000"
>  (= 
    (mode (STV $pr $)) $pr)
</span>;;;; Return the total count of a truth value.  For truth values not
;;;; capturing a notion of confidence, such as Bl or Pr then the count
;;;; is assumed to be a very large number (cause +inf does not seem to
;;;; be supported at the moment).
<span class="ansi38-255165000"
>  (: count 
    (-> TruthValue Number))
</span><span class="ansi38-255165000"
>  (= 
    (count (Bl $)) 
    (max-count))
</span><span class="ansi38-255165000"
>  (= 
    (count (Pr $)) 
    (max-count))
</span><span class="ansi38-255165000"
>  (= 
    (count (STV $ $conf)) 
    (confidence->count $conf))
</span>;;;; Return the confidence of a truth value.  For truth values not
;;;; capturing a notion of confidence, such as Bl or Pr then the
;;;; confidence is assumed to be 1.0.  For truth values capturing a
;;;; notion of confidence, such as STV, the formula to convert a count
;;;; into confidence is as follows
;;;;
;;;; confidence = count / (count + lookahead)
<span class="ansi38-255165000"
>  (: confidence 
    (-> TruthValue Number))
</span><span class="ansi38-255165000"
>  (= 
    (confidence (Bl $)) 1.0)
</span><span class="ansi38-255165000"
>  (= 
    (confidence (Pr $)) 1.0)
</span><span class="ansi38-255165000"
>  (= 
    (confidence (STV $ $conf)) $conf)
</span>;;;; Return the positive count of a truth value.
<span class="ansi38-255165000"
>  (: pos-count 
    (-> TruthValue Number))
</span><span class="ansi38-255165000"
>  (= 
    (pos-count $tv) 
    (* 
      (mode $tv) 
      (count $tv)))
</span>;;;; Return the negative count of a truth value.
<span class="ansi38-255165000"
>  (: neg-count 
    (-> TruthValue Number))
</span><span class="ansi38-255165000"
>  (= 
    (neg-count $tv) 
    (* 
      (- 1 
        (mode $tv)) 
      (count $tv)))
</span>;;;; Return the posterior alpha of a truth value
<span class="ansi38-255165000"
>  (: post-alpha 
    (-> TruthValue Number))
</span><span class="ansi38-255165000"
>  (= 
    (post-alpha $tv) 
    (+ 
      (prior-alpha) 
      (pos-count $tv)))
</span>;;;; Return the posterior beta of a truth value
<span class="ansi38-255165000"
>  (: post-beta 
    (-> TruthValue Number))
</span><span class="ansi38-255165000"
>  (= 
    (post-beta $tv) 
    (+ 
      (prior-beta) 
      (neg-count $tv)))
</span>;;;; Return the first order probability mean of the second order
;;;; distribution associated to a truth value.  For truth values not
;;;; capturing a notion of confidence, such as Bl or Pr then the
;;;; confidence is assumed to be 1.0.  For truth values capturing a
;;;; notion of confidence, such as STV, a beta distribution is assumed.
<span class="ansi38-255165000"
>  (: mean 
    (-> TruthValue Number))
</span><span class="ansi38-255165000"
>  (= 
    (mean (Bl True)) 1.0)
</span><span class="ansi38-255165000"
>  (= 
    (mean (Bl False)) 0.0)
</span><span class="ansi38-255165000"
>  (= 
    (mean (Pr $pr)) $pr)
</span><span class="ansi38-255165000"
>  (= 
    (mean (STV $pr $conf)) 
    (let* 
      ( ($a (post-alpha (STV $pr $conf))) ($b (post-beta (STV $pr $conf)))) 
      (/ $a 
        (+ $a $b))))
</span>
Last Result(2): ()
<span class="ansi38-013099040"
>  !(import! &self ../OrderedSet.metta)

</span>P;HTML|
;                                           (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/OrderedSet.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/OrderedSet.metta)
P;HTML|
;                                           (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/OrderedSet.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/OrderedSet.metta)

;;;; Import modules
<span class="ansi38-013099040"
>  !(import! &self Num.metta)

</span>P;HTML|
;                                           (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/Num.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/Num.metta)
P;HTML|
;                                           (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/Num.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/Num.metta)

;;;; Collection of functions operating on numbers
;;;; Define max
<span class="ansi38-255165000"
>  (: max 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (max $x $y) 
    (if 
      (> $x $y) $x $y))
</span>;;;; Define min
<span class="ansi38-255165000"
>  (: min 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (min $x $y) 
    (if 
      (< $x $y) $x $y))
</span>;;;; Clamp a number to be within a certain range
<span class="ansi38-255165000"
>  (: clamp 
    (-> $a $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (clamp $x $l $u) 
    (max $l 
      (min $u $x)))
</span>;;;; Define abs
<span class="ansi38-255165000"
>  (: abs 
    (-> $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (abs $x) 
    (if 
      (< $x 0) 
      (* -1 $x) $x))
</span>;;;; Define <=
<span class="ansi38-255165000"
>  (: <= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (<= $x $y) 
    (or 
      (< $x $y) 
      (== $x $y)))
</span>;;;; Define >=
<span class="ansi38-255165000"
>  (: >= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (>= $x $y) 
    (or 
      (> $x $y) 
      (== $x $y)))
</span>;;;; Define approximately equal
<span class="ansi38-255165000"
>  (: approxEq 
    (-> $a $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (approxEq $x $y $epsilon) 
    (<= 
      (abs (- $x $y)) $epsilon))
</span>;;;; Define Nat
<span class="ansi38-255165000"
>  (: Nat Type)
</span><span class="ansi38-255165000"
>  (: Z Nat)
</span><span class="ansi38-255165000"
>  (: S 
    (-> Nat Nat))
</span>;;;; Define cast functions between Nat and Number
<span class="ansi38-255165000"
>  (: fromNumber 
    (-> Number Nat))
</span><span class="ansi38-255165000"
>  (= 
    (fromNumber $n) 
    (if 
      (<= $n 0) Z 
      (S (fromNumber (- $n 1)))))
</span><span class="ansi38-255165000"
>  (: fromNat 
    (-> Nat Number))
</span><span class="ansi38-255165000"
>  (= 
    (fromNat Z) 0)
</span><span class="ansi38-255165000"
>  (= 
    (fromNat (S $k)) 
    (+ 1 
      (fromNat $k)))
</span>;;;; Define a generic less than operator, ⩻, for Nat.  < cannot be used
;;;; because it is a built-in, its type is hardwired and cannot be
;;;; overloaded.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Nat Nat Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $ Z) False)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ Z 
      (S $)) True)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ 
      (S $x) 
      (S $y)) 
    (⩻ $x $y))
</span>;;;; Overload ⩻ for Number.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Number Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $x $y) 
    (< $x $y))
</span>;;;; Return the ceiling of a non negative number.  If the number is
;;;; negative it returns 1.
<span class="ansi38-255165000"
>  (: ceil 
    (-> Number Number))
</span><span class="ansi38-255165000"
>  (= 
    (ceil $n) 
    (fromNat (fromNumber $n)))
</span>;;;; Convert Number to Bool.  Anything above 0 converts to True.
<span class="ansi38-255165000"
>  (: number->bool 
    (-> Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (number->bool $x) 
    (< 0 $x))
</span>;;;; Convert Bool to Number.  False converts to 0, True converts to 1.
<span class="ansi38-255165000"
>  (: bool->number 
    (-> Bool Number))
</span><span class="ansi38-255165000"
>  (= 
    (bool->number False) 0)
</span><span class="ansi38-255165000"
>  (= 
    (bool->number True) 1)
</span>;;;; Define a less than type.  Note that it is purposefully different
;;;; than ⩻ as it is a type, not an operator.  Inhabitants of (⍃ x y)
;;;; are proofs that x ⩻ y == True.  For now ⍃ is only axiomatized for
;;;; Nat.
<span class="ansi38-255165000"
>  (: ⍃ 
    (-> $t $t Type))
</span>;;;; Zero is always less than the successor of something
<span class="ansi38-255165000"
>  (: 
    (zero-lt-succ-axiom) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (zero-lt-succ-axiom) 
    (: ZeroLTSucc 
      (⍃ Z 
        (S $k))))
</span>;;;; If x ⍃ y then (S x) ⍃ (S y)
<span class="ansi38-255165000"
>  (: 
    (succ-monotonicity-rule) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (succ-monotonicity-rule) 
    (: SuccMonotonicity 
      (-> 
        (⍃ $x $y) 
        (⍃ 
          (S $x) 
          (S $y)))))
</span>;;;; Collection of functions operating on numbers
;;;; Define max
<span class="ansi38-255165000"
>  (: max 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (max $x $y) 
    (if 
      (> $x $y) $x $y))
</span>;;;; Define min
<span class="ansi38-255165000"
>  (: min 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (min $x $y) 
    (if 
      (< $x $y) $x $y))
</span>;;;; Clamp a number to be within a certain range
<span class="ansi38-255165000"
>  (: clamp 
    (-> $a $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (clamp $x $l $u) 
    (max $l 
      (min $u $x)))
</span>;;;; Define abs
<span class="ansi38-255165000"
>  (: abs 
    (-> $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (abs $x) 
    (if 
      (< $x 0) 
      (* -1 $x) $x))
</span>;;;; Define <=
<span class="ansi38-255165000"
>  (: <= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (<= $x $y) 
    (or 
      (< $x $y) 
      (== $x $y)))
</span>;;;; Define >=
<span class="ansi38-255165000"
>  (: >= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (>= $x $y) 
    (or 
      (> $x $y) 
      (== $x $y)))
</span>;;;; Define approximately equal
<span class="ansi38-255165000"
>  (: approxEq 
    (-> $a $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (approxEq $x $y $epsilon) 
    (<= 
      (abs (- $x $y)) $epsilon))
</span>;;;; Define Nat
<span class="ansi38-255165000"
>  (: Nat Type)
</span><span class="ansi38-255165000"
>  (: Z Nat)
</span><span class="ansi38-255165000"
>  (: S 
    (-> Nat Nat))
</span>;;;; Define cast functions between Nat and Number
<span class="ansi38-255165000"
>  (: fromNumber 
    (-> Number Nat))
</span><span class="ansi38-255165000"
>  (= 
    (fromNumber $n) 
    (if 
      (<= $n 0) Z 
      (S (fromNumber (- $n 1)))))
</span><span class="ansi38-255165000"
>  (: fromNat 
    (-> Nat Number))
</span><span class="ansi38-255165000"
>  (= 
    (fromNat Z) 0)
</span><span class="ansi38-255165000"
>  (= 
    (fromNat (S $k)) 
    (+ 1 
      (fromNat $k)))
</span>;;;; Define a generic less than operator, ⩻, for Nat.  < cannot be used
;;;; because it is a built-in, its type is hardwired and cannot be
;;;; overloaded.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Nat Nat Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $ Z) False)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ Z 
      (S $)) True)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ 
      (S $x) 
      (S $y)) 
    (⩻ $x $y))
</span>;;;; Overload ⩻ for Number.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Number Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $x $y) 
    (< $x $y))
</span>;;;; Return the ceiling of a non negative number.  If the number is
;;;; negative it returns 1.
<span class="ansi38-255165000"
>  (: ceil 
    (-> Number Number))
</span><span class="ansi38-255165000"
>  (= 
    (ceil $n) 
    (fromNat (fromNumber $n)))
</span>;;;; Convert Number to Bool.  Anything above 0 converts to True.
<span class="ansi38-255165000"
>  (: number->bool 
    (-> Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (number->bool $x) 
    (< 0 $x))
</span>;;;; Convert Bool to Number.  False converts to 0, True converts to 1.
<span class="ansi38-255165000"
>  (: bool->number 
    (-> Bool Number))
</span><span class="ansi38-255165000"
>  (= 
    (bool->number False) 0)
</span><span class="ansi38-255165000"
>  (= 
    (bool->number True) 1)
</span>;;;; Define a less than type.  Note that it is purposefully different
;;;; than ⩻ as it is a type, not an operator.  Inhabitants of (⍃ x y)
;;;; are proofs that x ⩻ y == True.  For now ⍃ is only axiomatized for
;;;; Nat.
<span class="ansi38-255165000"
>  (: ⍃ 
    (-> $t $t Type))
</span>;;;; Zero is always less than the successor of something
<span class="ansi38-255165000"
>  (: 
    (zero-lt-succ-axiom) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (zero-lt-succ-axiom) 
    (: ZeroLTSucc 
      (⍃ Z 
        (S $k))))
</span>;;;; If x ⍃ y then (S x) ⍃ (S y)
<span class="ansi38-255165000"
>  (: 
    (succ-monotonicity-rule) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (succ-monotonicity-rule) 
    (: SuccMonotonicity 
      (-> 
        (⍃ $x $y) 
        (⍃ 
          (S $x) 
          (S $y)))))
</span>
Deterministic: ()
;;;; Definition of a set data structure.  Under the hood it is a sorted
;;;; list without duplicates, thus called OrderedSet.  For now its
;;;; constructor :: is unconstrained, meaning it does not guaranty that
;;;; the constructed OrderedSet are sorted and without duplicates.
;;;; Rather this is delegated to the insert function defined below.  In
;;;; order to guaranty that it is sorted without duplicates, the
;;;; constructor :: would need to take an additional argument encoding a
;;;; proof that the element to prepend is less than the head of the set
;;;; to be prepended to.
<span class="ansi38-255165000"
>  (: OrderedSet 
    (-> $a Type))
</span><span class="ansi38-255165000"
>  (: ∅ 
    (OrderedSet $a))
</span><span class="ansi38-255165000"
>  (: :: 
    (-> $a 
      (OrderedSet $a) 
      (OrderedSet $a)))
</span>;;;; Check if an element is in a set.  TODO: optimize assuming it is
;;;; ordered.
<span class="ansi38-255165000"
>  (: elem 
    (-> $a 
      (OrderedSet $a) Bool))
</span><span class="ansi38-255165000"
>  (= 
    (elem $x ∅) False)
</span><span class="ansi38-255165000"
>  (= 
    (elem $x 
      (:: $h $t)) 
    (if 
      (== $x $h) True 
      (elem $x $t)))
</span>;;;; Insert an element into a set.  Only insert if the element is not
;;;; already in the set as to produce an ordered set.
<span class="ansi38-255165000"
>  (: insert 
    (-> $a 
      (OrderedSet $a) 
      (OrderedSet $a)))
</span><span class="ansi38-255165000"
>  (= 
    (insert $x ∅) 
    (:: $x ∅))
</span>;;; Base case
;;; Recursive step
;;; Present, no need to insert
;;; Use generic <
;;; Safely insert since $x < $h
<span class="ansi38-255165000"
>  (= 
    (insert $x 
      (:: $h $t)) 
    (if 
      (== $x $h) 
      (:: $h $t) 
      (if 
        (⩻ $x $h) 
        (:: $x 
          (:: $h $t)) 
        (:: $h 
          (insert $x $t)))))
</span>;;; Recursive call

Last Result(2): ()
;;;;;;;;;;;;
;;;; Type ;;
;;;;;;;;;;;;
<span class="ansi38-255165000"
>  (: EvidentialTruthValue Type)
</span>;;;;;;;;;;;;;;;;;;;;
;;;; Constructor ;;
;;;;;;;;;;;;;;;;;;;;
;;;; Takes an evidence set ascribed to a truth value to form an
;;;; evidential truth value.
<span class="ansi38-255165000"
>  (: ETV 
    (-> 
      (OrderedSet $a) TruthValue EvidentialTruthValue))
</span>;;;;;;;;;;;;;;;
;;;; Methods ;;
;;;;;;;;;;;;;;;
;;;; Access the truth value of an evidential truth value.
<span class="ansi38-255165000"
>  (: tv 
    (-> EvidentialTruthValue TruthValue))
</span><span class="ansi38-255165000"
>  (= 
    (tv (ETV $ev $tv)) $tv)
</span>;;;; Return the first order probability mode of the second order
;;;; distribution associated to an evidential truth value.
<span class="ansi38-255165000"
>  (: mode 
    (-> EvidentialTruthValue Number))
</span><span class="ansi38-255165000"
>  (= 
    (mode (ETV $ev $tv)) 
    (mode $tv))
</span>;;;; Return the total count of an evidential truth value.
<span class="ansi38-255165000"
>  (: count 
    (-> EvidentialTruthValue Number))
</span><span class="ansi38-255165000"
>  (= 
    (count (ETV $ev $tv)) 
    (count $tv))
</span>;;;; Return the positive count of a truth value.
<span class="ansi38-255165000"
>  (: pos_count 
    (-> EvidentialTruthValue Number))
</span><span class="ansi38-255165000"
>  (= 
    (pos_count (ETV $ev $tv)) 
    (* 
      (mode $tv) 
      (count $tv)))
</span>;;;; Return the negative count of a truth value.
<span class="ansi38-255165000"
>  (: neg_count 
    (-> EvidentialTruthValue Number))
</span><span class="ansi38-255165000"
>  (= 
    (neg_count (ETV $ev $tv)) 
    (* 
      (- 1 
        (mode $tv)) 
      (count $tv)))
</span>;;;; Return the posterior alpha of a truth value
<span class="ansi38-255165000"
>  (: post_alpha 
    (-> EvidentialTruthValue Number))
</span><span class="ansi38-255165000"
>  (= 
    (post_alpha (ETV $ev $tv)) 
    (+ 
      (prior_alpha) 
      (pos_count $tv)))
</span>;;;; Return the posterior beta of a truth value
<span class="ansi38-255165000"
>  (: post_beta 
    (-> EvidentialTruthValue Number))
</span><span class="ansi38-255165000"
>  (= 
    (post_beta (ETV $ev $tv)) 
    (+ 
      (prior_beta) 
      (neg_count $tv)))
</span>;;;; Return the first order probability mean of the second order
;;;; distribution associated to an evidential truth value.
<span class="ansi38-255165000"
>  (: mean 
    (-> EvidentialTruthValue Number))
</span><span class="ansi38-255165000"
>  (= 
    (mean (ETV $ev $tv)) 
    (mean $tv))
</span>;;;; Return the confidence of an evidential truth value.
<span class="ansi38-255165000"
>  (: confidence 
    (-> EvidentialTruthValue Number))
</span><span class="ansi38-255165000"
>  (= 
    (confidence (ETV $ev $tv)) 
    (confidence $tv))
</span>
Last Result(3): ()
<span class="ansi38-013099040"
>  !(import! &self ../common/formula/ImplicationDirectIntroductionFormula.metta)

</span>P;HTML|
;                                           (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/formula/ImplicationDirectIntroductionFormula.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/formula/ImplicationDirectIntroductionFormula.metta)
P;HTML|
;                                           (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/formula/ImplicationDirectIntroductionFormula.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/formula/ImplicationDirectIntroductionFormula.metta)

;;;; Formula for the inductive Implication Direct Introduction rule.
;;;; Import modules
<span class="ansi38-013099040"
>  !(import! &self ../truthvalue/TruthValue.metta)

</span>P;HTML|
;                                           (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/truthvalue/TruthValue.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/truthvalue/TruthValue.metta)
P;HTML|
;                                           (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/truthvalue/TruthValue.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/truthvalue/TruthValue.metta)

;;;; Truth value type definition
;;;; Import modules
<span class="ansi38-013099040"
>  !(import! &self ../Num.metta)

</span>P;HTML|
;                                           (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/Num.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/Num.metta)
P;HTML|
;                                           (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/Num.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/Num.metta)

;;;; Collection of functions operating on numbers
;;;; Define max
<span class="ansi38-255165000"
>  (: max 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (max $x $y) 
    (if 
      (> $x $y) $x $y))
</span>;;;; Define min
<span class="ansi38-255165000"
>  (: min 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (min $x $y) 
    (if 
      (< $x $y) $x $y))
</span>;;;; Clamp a number to be within a certain range
<span class="ansi38-255165000"
>  (: clamp 
    (-> $a $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (clamp $x $l $u) 
    (max $l 
      (min $u $x)))
</span>;;;; Define abs
<span class="ansi38-255165000"
>  (: abs 
    (-> $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (abs $x) 
    (if 
      (< $x 0) 
      (* -1 $x) $x))
</span>;;;; Define <=
<span class="ansi38-255165000"
>  (: <= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (<= $x $y) 
    (or 
      (< $x $y) 
      (== $x $y)))
</span>;;;; Define >=
<span class="ansi38-255165000"
>  (: >= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (>= $x $y) 
    (or 
      (> $x $y) 
      (== $x $y)))
</span>;;;; Define approximately equal
<span class="ansi38-255165000"
>  (: approxEq 
    (-> $a $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (approxEq $x $y $epsilon) 
    (<= 
      (abs (- $x $y)) $epsilon))
</span>;;;; Define Nat
<span class="ansi38-255165000"
>  (: Nat Type)
</span><span class="ansi38-255165000"
>  (: Z Nat)
</span><span class="ansi38-255165000"
>  (: S 
    (-> Nat Nat))
</span>;;;; Define cast functions between Nat and Number
<span class="ansi38-255165000"
>  (: fromNumber 
    (-> Number Nat))
</span><span class="ansi38-255165000"
>  (= 
    (fromNumber $n) 
    (if 
      (<= $n 0) Z 
      (S (fromNumber (- $n 1)))))
</span><span class="ansi38-255165000"
>  (: fromNat 
    (-> Nat Number))
</span><span class="ansi38-255165000"
>  (= 
    (fromNat Z) 0)
</span><span class="ansi38-255165000"
>  (= 
    (fromNat (S $k)) 
    (+ 1 
      (fromNat $k)))
</span>;;;; Define a generic less than operator, ⩻, for Nat.  < cannot be used
;;;; because it is a built-in, its type is hardwired and cannot be
;;;; overloaded.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Nat Nat Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $ Z) False)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ Z 
      (S $)) True)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ 
      (S $x) 
      (S $y)) 
    (⩻ $x $y))
</span>;;;; Overload ⩻ for Number.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Number Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $x $y) 
    (< $x $y))
</span>;;;; Return the ceiling of a non negative number.  If the number is
;;;; negative it returns 1.
<span class="ansi38-255165000"
>  (: ceil 
    (-> Number Number))
</span><span class="ansi38-255165000"
>  (= 
    (ceil $n) 
    (fromNat (fromNumber $n)))
</span>;;;; Convert Number to Bool.  Anything above 0 converts to True.
<span class="ansi38-255165000"
>  (: number->bool 
    (-> Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (number->bool $x) 
    (< 0 $x))
</span>;;;; Convert Bool to Number.  False converts to 0, True converts to 1.
<span class="ansi38-255165000"
>  (: bool->number 
    (-> Bool Number))
</span><span class="ansi38-255165000"
>  (= 
    (bool->number False) 0)
</span><span class="ansi38-255165000"
>  (= 
    (bool->number True) 1)
</span>;;;; Define a less than type.  Note that it is purposefully different
;;;; than ⩻ as it is a type, not an operator.  Inhabitants of (⍃ x y)
;;;; are proofs that x ⩻ y == True.  For now ⍃ is only axiomatized for
;;;; Nat.
<span class="ansi38-255165000"
>  (: ⍃ 
    (-> $t $t Type))
</span>;;;; Zero is always less than the successor of something
<span class="ansi38-255165000"
>  (: 
    (zero-lt-succ-axiom) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (zero-lt-succ-axiom) 
    (: ZeroLTSucc 
      (⍃ Z 
        (S $k))))
</span>;;;; If x ⍃ y then (S x) ⍃ (S y)
<span class="ansi38-255165000"
>  (: 
    (succ-monotonicity-rule) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (succ-monotonicity-rule) 
    (: SuccMonotonicity 
      (-> 
        (⍃ $x $y) 
        (⍃ 
          (S $x) 
          (S $y)))))
</span>;;;; Collection of functions operating on numbers
;;;; Define max
<span class="ansi38-255165000"
>  (: max 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (max $x $y) 
    (if 
      (> $x $y) $x $y))
</span>;;;; Define min
<span class="ansi38-255165000"
>  (: min 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (min $x $y) 
    (if 
      (< $x $y) $x $y))
</span>;;;; Clamp a number to be within a certain range
<span class="ansi38-255165000"
>  (: clamp 
    (-> $a $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (clamp $x $l $u) 
    (max $l 
      (min $u $x)))
</span>;;;; Define abs
<span class="ansi38-255165000"
>  (: abs 
    (-> $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (abs $x) 
    (if 
      (< $x 0) 
      (* -1 $x) $x))
</span>;;;; Define <=
<span class="ansi38-255165000"
>  (: <= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (<= $x $y) 
    (or 
      (< $x $y) 
      (== $x $y)))
</span>;;;; Define >=
<span class="ansi38-255165000"
>  (: >= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (>= $x $y) 
    (or 
      (> $x $y) 
      (== $x $y)))
</span>;;;; Define approximately equal
<span class="ansi38-255165000"
>  (: approxEq 
    (-> $a $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (approxEq $x $y $epsilon) 
    (<= 
      (abs (- $x $y)) $epsilon))
</span>;;;; Define Nat
<span class="ansi38-255165000"
>  (: Nat Type)
</span><span class="ansi38-255165000"
>  (: Z Nat)
</span><span class="ansi38-255165000"
>  (: S 
    (-> Nat Nat))
</span>;;;; Define cast functions between Nat and Number
<span class="ansi38-255165000"
>  (: fromNumber 
    (-> Number Nat))
</span><span class="ansi38-255165000"
>  (= 
    (fromNumber $n) 
    (if 
      (<= $n 0) Z 
      (S (fromNumber (- $n 1)))))
</span><span class="ansi38-255165000"
>  (: fromNat 
    (-> Nat Number))
</span><span class="ansi38-255165000"
>  (= 
    (fromNat Z) 0)
</span><span class="ansi38-255165000"
>  (= 
    (fromNat (S $k)) 
    (+ 1 
      (fromNat $k)))
</span>;;;; Define a generic less than operator, ⩻, for Nat.  < cannot be used
;;;; because it is a built-in, its type is hardwired and cannot be
;;;; overloaded.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Nat Nat Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $ Z) False)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ Z 
      (S $)) True)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ 
      (S $x) 
      (S $y)) 
    (⩻ $x $y))
</span>;;;; Overload ⩻ for Number.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Number Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $x $y) 
    (< $x $y))
</span>;;;; Return the ceiling of a non negative number.  If the number is
;;;; negative it returns 1.
<span class="ansi38-255165000"
>  (: ceil 
    (-> Number Number))
</span><span class="ansi38-255165000"
>  (= 
    (ceil $n) 
    (fromNat (fromNumber $n)))
</span>;;;; Convert Number to Bool.  Anything above 0 converts to True.
<span class="ansi38-255165000"
>  (: number->bool 
    (-> Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (number->bool $x) 
    (< 0 $x))
</span>;;;; Convert Bool to Number.  False converts to 0, True converts to 1.
<span class="ansi38-255165000"
>  (: bool->number 
    (-> Bool Number))
</span><span class="ansi38-255165000"
>  (= 
    (bool->number False) 0)
</span><span class="ansi38-255165000"
>  (= 
    (bool->number True) 1)
</span>;;;; Define a less than type.  Note that it is purposefully different
;;;; than ⩻ as it is a type, not an operator.  Inhabitants of (⍃ x y)
;;;; are proofs that x ⩻ y == True.  For now ⍃ is only axiomatized for
;;;; Nat.
<span class="ansi38-255165000"
>  (: ⍃ 
    (-> $t $t Type))
</span>;;;; Zero is always less than the successor of something
<span class="ansi38-255165000"
>  (: 
    (zero-lt-succ-axiom) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (zero-lt-succ-axiom) 
    (: ZeroLTSucc 
      (⍃ Z 
        (S $k))))
</span>;;;; If x ⍃ y then (S x) ⍃ (S y)
<span class="ansi38-255165000"
>  (: 
    (succ-monotonicity-rule) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (succ-monotonicity-rule) 
    (: SuccMonotonicity 
      (-> 
        (⍃ $x $y) 
        (⍃ 
          (S $x) 
          (S $y)))))
</span>;;;; Collection of functions operating on numbers
;;;; Define max
<span class="ansi38-255165000"
>  (: max 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (max $x $y) 
    (if 
      (> $x $y) $x $y))
</span>;;;; Define min
<span class="ansi38-255165000"
>  (: min 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (min $x $y) 
    (if 
      (< $x $y) $x $y))
</span>;;;; Clamp a number to be within a certain range
<span class="ansi38-255165000"
>  (: clamp 
    (-> $a $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (clamp $x $l $u) 
    (max $l 
      (min $u $x)))
</span>;;;; Define abs
<span class="ansi38-255165000"
>  (: abs 
    (-> $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (abs $x) 
    (if 
      (< $x 0) 
      (* -1 $x) $x))
</span>;;;; Define <=
<span class="ansi38-255165000"
>  (: <= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (<= $x $y) 
    (or 
      (< $x $y) 
      (== $x $y)))
</span>;;;; Define >=
<span class="ansi38-255165000"
>  (: >= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (>= $x $y) 
    (or 
      (> $x $y) 
      (== $x $y)))
</span>;;;; Define approximately equal
<span class="ansi38-255165000"
>  (: approxEq 
    (-> $a $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (approxEq $x $y $epsilon) 
    (<= 
      (abs (- $x $y)) $epsilon))
</span>;;;; Define Nat
<span class="ansi38-255165000"
>  (: Nat Type)
</span><span class="ansi38-255165000"
>  (: Z Nat)
</span><span class="ansi38-255165000"
>  (: S 
    (-> Nat Nat))
</span>;;;; Define cast functions between Nat and Number
<span class="ansi38-255165000"
>  (: fromNumber 
    (-> Number Nat))
</span><span class="ansi38-255165000"
>  (= 
    (fromNumber $n) 
    (if 
      (<= $n 0) Z 
      (S (fromNumber (- $n 1)))))
</span><span class="ansi38-255165000"
>  (: fromNat 
    (-> Nat Number))
</span><span class="ansi38-255165000"
>  (= 
    (fromNat Z) 0)
</span><span class="ansi38-255165000"
>  (= 
    (fromNat (S $k)) 
    (+ 1 
      (fromNat $k)))
</span>;;;; Define a generic less than operator, ⩻, for Nat.  < cannot be used
;;;; because it is a built-in, its type is hardwired and cannot be
;;;; overloaded.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Nat Nat Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $ Z) False)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ Z 
      (S $)) True)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ 
      (S $x) 
      (S $y)) 
    (⩻ $x $y))
</span>;;;; Overload ⩻ for Number.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Number Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $x $y) 
    (< $x $y))
</span>;;;; Return the ceiling of a non negative number.  If the number is
;;;; negative it returns 1.
<span class="ansi38-255165000"
>  (: ceil 
    (-> Number Number))
</span><span class="ansi38-255165000"
>  (= 
    (ceil $n) 
    (fromNat (fromNumber $n)))
</span>;;;; Convert Number to Bool.  Anything above 0 converts to True.
<span class="ansi38-255165000"
>  (: number->bool 
    (-> Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (number->bool $x) 
    (< 0 $x))
</span>;;;; Convert Bool to Number.  False converts to 0, True converts to 1.
<span class="ansi38-255165000"
>  (: bool->number 
    (-> Bool Number))
</span><span class="ansi38-255165000"
>  (= 
    (bool->number False) 0)
</span><span class="ansi38-255165000"
>  (= 
    (bool->number True) 1)
</span>;;;; Define a less than type.  Note that it is purposefully different
;;;; than ⩻ as it is a type, not an operator.  Inhabitants of (⍃ x y)
;;;; are proofs that x ⩻ y == True.  For now ⍃ is only axiomatized for
;;;; Nat.
<span class="ansi38-255165000"
>  (: ⍃ 
    (-> $t $t Type))
</span>;;;; Zero is always less than the successor of something
<span class="ansi38-255165000"
>  (: 
    (zero-lt-succ-axiom) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (zero-lt-succ-axiom) 
    (: ZeroLTSucc 
      (⍃ Z 
        (S $k))))
</span>;;;; If x ⍃ y then (S x) ⍃ (S y)
<span class="ansi38-255165000"
>  (: 
    (succ-monotonicity-rule) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (succ-monotonicity-rule) 
    (: SuccMonotonicity 
      (-> 
        (⍃ $x $y) 
        (⍃ 
          (S $x) 
          (S $y)))))
</span>
Deterministic: ()
;;;;;;;;;;;;
;;;; Type ;;
;;;;;;;;;;;;
<span class="ansi38-255165000"
>  (: TruthValue Type)
</span>;;;;;;;;;;;;;;;;;;;;
;;;; Constructors ;;
;;;;;;;;;;;;;;;;;;;;
;;;; Boolean TV constructor
;;;; TODO: alternatively we could have (: ⊤ TruthValue) and (: ⊥ TruthValue)
<span class="ansi38-255165000"
>  (: Bl 
    (-> Bool TruthValue))
</span>;;;; First order probability TV constructor, i.e. mere probability.
<span class="ansi38-255165000"
>  (: Pr 
    (-> Number TruthValue))
</span>;;;; Simple Truth Value.  A Second order probability TV constructor,
;;;; i.e. probability and confidence.  The probability is in fact the
;;;; mode of the corresponding beta distribution.
<span class="ansi38-255165000"
>  (: STV 
    (-> Number Number TruthValue))
</span>;;;;;;;;;;;;;;;;;
;;;; Constants ;;
;;;;;;;;;;;;;;;;;
;;;; For now the underlying beta distributions have a Jeffreys prior,
;;;; i.e. the prior alpha and beta are 0.5.
<span class="ansi38-255165000"
>  (: prior-alpha 
    (-> Number))
</span><span class="ansi38-255165000"
>  (= 
    (prior-alpha) 0.5)
</span><span class="ansi38-255165000"
>  (: prior-beta 
    (-> Number))
</span><span class="ansi38-255165000"
>  (= 
    (prior-beta) 0.5)
</span>;;;; Lookahead
<span class="ansi38-255165000"
>  (: lookahead 
    (-> Number))
</span><span class="ansi38-255165000"
>  (= 
    (lookahead) 1.0)
</span>;;;; Maximum supported count (till +inf is supported, possibly).
<span class="ansi38-255165000"
>  (: max-count 
    (-> Number))
</span><span class="ansi38-255165000"
>  (= 
    (max-count) 1000000000.0)
</span>;;;;;;;;;;;;;;;
;;;; Methods ;;
;;;;;;;;;;;;;;;
;;;; Convert count to confidence using the formula
;;;;
;;;; confidence = count / (count + lookahead)
<span class="ansi38-255165000"
>  (: count->confidence 
    (-> Number Number))
</span><span class="ansi38-255165000"
>  (= 
    (count->confidence $cnt) 
    (/ $cnt 
      (+ $cnt 
        (lookahead))))
</span>;;;; Convert confidence to count using the formula
;;;;
;;;; count = (confidence * lookahead) / (1 - confidence)
<span class="ansi38-255165000"
>  (: confidence->count 
    (-> Number Number))
</span><span class="ansi38-255165000"
>  (= 
    (confidence->count $conf) 
    (if 
      (approxEq 1.0 $conf 1.0e-9) 
      (max-count) 
      (/ 
        (* $conf 
          (lookahead)) 
        (- 1.0 $conf))))
</span>;;;; Increment the negative count of a given truth value, by
;;;; incrementing its total count without incrementing the positive
;;;; count.
<span class="ansi38-255165000"
>  (: inc-neg-count 
    (-> TruthValue TruthValue))
</span><span class="ansi38-255165000"
>  (= 
    (inc-neg-count (STV $s $c)) 
    (let* 
      ( ($tot_cnt (confidence->count $c)) 
        ($pos_cnt (* $s $tot_cnt)) 
        ($new_tot_cnt (+ $tot_cnt 1))) 
      (STV 
        (/ $pos_cnt $new_tot_cnt) 
        (count->confidence $new_tot_cnt))))
</span>;;;; Increment the positive count of a given truth value, by
;;;; incrementing its total count and its positive count.
<span class="ansi38-255165000"
>  (: inc-pos-count 
    (-> TruthValue TruthValue))
</span><span class="ansi38-255165000"
>  (= 
    (inc-pos-count (STV $s $c)) 
    (let* 
      ( ($tot_cnt (confidence->count $c)) 
        ($pos_cnt (* $s $tot_cnt)) 
        ($new_pos_cnt (+ $pos_cnt 1)) 
        ($new_tot_cnt (+ $tot_cnt 1))) 
      (STV 
        (/ $new_pos_cnt $new_tot_cnt) 
        (count->confidence $new_tot_cnt))))
</span>;;;; Return the first order probability mode of the second order
;;;; distribution associated to a truth value.
<span class="ansi38-255165000"
>  (: mode 
    (-> TruthValue Number))
</span><span class="ansi38-255165000"
>  (= 
    (mode (Bl True)) 1.0)
</span><span class="ansi38-255165000"
>  (= 
    (mode (Bl False)) 0.0)
</span><span class="ansi38-255165000"
>  (= 
    (mode (Pr $pr)) $pr)
</span><span class="ansi38-255165000"
>  (= 
    (mode (STV $pr $)) $pr)
</span>;;;; Return the total count of a truth value.  For truth values not
;;;; capturing a notion of confidence, such as Bl or Pr then the count
;;;; is assumed to be a very large number (cause +inf does not seem to
;;;; be supported at the moment).
<span class="ansi38-255165000"
>  (: count 
    (-> TruthValue Number))
</span><span class="ansi38-255165000"
>  (= 
    (count (Bl $)) 
    (max-count))
</span><span class="ansi38-255165000"
>  (= 
    (count (Pr $)) 
    (max-count))
</span><span class="ansi38-255165000"
>  (= 
    (count (STV $ $conf)) 
    (confidence->count $conf))
</span>;;;; Return the confidence of a truth value.  For truth values not
;;;; capturing a notion of confidence, such as Bl or Pr then the
;;;; confidence is assumed to be 1.0.  For truth values capturing a
;;;; notion of confidence, such as STV, the formula to convert a count
;;;; into confidence is as follows
;;;;
;;;; confidence = count / (count + lookahead)
<span class="ansi38-255165000"
>  (: confidence 
    (-> TruthValue Number))
</span><span class="ansi38-255165000"
>  (= 
    (confidence (Bl $)) 1.0)
</span><span class="ansi38-255165000"
>  (= 
    (confidence (Pr $)) 1.0)
</span><span class="ansi38-255165000"
>  (= 
    (confidence (STV $ $conf)) $conf)
</span>;;;; Return the positive count of a truth value.
<span class="ansi38-255165000"
>  (: pos-count 
    (-> TruthValue Number))
</span><span class="ansi38-255165000"
>  (= 
    (pos-count $tv) 
    (* 
      (mode $tv) 
      (count $tv)))
</span>;;;; Return the negative count of a truth value.
<span class="ansi38-255165000"
>  (: neg-count 
    (-> TruthValue Number))
</span><span class="ansi38-255165000"
>  (= 
    (neg-count $tv) 
    (* 
      (- 1 
        (mode $tv)) 
      (count $tv)))
</span>;;;; Return the posterior alpha of a truth value
<span class="ansi38-255165000"
>  (: post-alpha 
    (-> TruthValue Number))
</span><span class="ansi38-255165000"
>  (= 
    (post-alpha $tv) 
    (+ 
      (prior-alpha) 
      (pos-count $tv)))
</span>;;;; Return the posterior beta of a truth value
<span class="ansi38-255165000"
>  (: post-beta 
    (-> TruthValue Number))
</span><span class="ansi38-255165000"
>  (= 
    (post-beta $tv) 
    (+ 
      (prior-beta) 
      (neg-count $tv)))
</span>;;;; Return the first order probability mean of the second order
;;;; distribution associated to a truth value.  For truth values not
;;;; capturing a notion of confidence, such as Bl or Pr then the
;;;; confidence is assumed to be 1.0.  For truth values capturing a
;;;; notion of confidence, such as STV, a beta distribution is assumed.
<span class="ansi38-255165000"
>  (: mean 
    (-> TruthValue Number))
</span><span class="ansi38-255165000"
>  (= 
    (mean (Bl True)) 1.0)
</span><span class="ansi38-255165000"
>  (= 
    (mean (Bl False)) 0.0)
</span><span class="ansi38-255165000"
>  (= 
    (mean (Pr $pr)) $pr)
</span><span class="ansi38-255165000"
>  (= 
    (mean (STV $pr $conf)) 
    (let* 
      ( ($a (post-alpha (STV $pr $conf))) ($b (post-beta (STV $pr $conf)))) 
      (/ $a 
        (+ $a $b))))
</span>;;;; Truth value type definition
;;;; Import modules
<span class="ansi38-013099040"
>  !(import! &self ../Num.metta)

</span>P;HTML|
;                                           (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/Num.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/Num.metta)
P;HTML|
;                                           (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/Num.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/Num.metta)

;;;; Collection of functions operating on numbers
;;;; Define max
<span class="ansi38-255165000"
>  (: max 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (max $x $y) 
    (if 
      (> $x $y) $x $y))
</span>;;;; Define min
<span class="ansi38-255165000"
>  (: min 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (min $x $y) 
    (if 
      (< $x $y) $x $y))
</span>;;;; Clamp a number to be within a certain range
<span class="ansi38-255165000"
>  (: clamp 
    (-> $a $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (clamp $x $l $u) 
    (max $l 
      (min $u $x)))
</span>;;;; Define abs
<span class="ansi38-255165000"
>  (: abs 
    (-> $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (abs $x) 
    (if 
      (< $x 0) 
      (* -1 $x) $x))
</span>;;;; Define <=
<span class="ansi38-255165000"
>  (: <= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (<= $x $y) 
    (or 
      (< $x $y) 
      (== $x $y)))
</span>;;;; Define >=
<span class="ansi38-255165000"
>  (: >= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (>= $x $y) 
    (or 
      (> $x $y) 
      (== $x $y)))
</span>;;;; Define approximately equal
<span class="ansi38-255165000"
>  (: approxEq 
    (-> $a $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (approxEq $x $y $epsilon) 
    (<= 
      (abs (- $x $y)) $epsilon))
</span>;;;; Define Nat
<span class="ansi38-255165000"
>  (: Nat Type)
</span><span class="ansi38-255165000"
>  (: Z Nat)
</span><span class="ansi38-255165000"
>  (: S 
    (-> Nat Nat))
</span>;;;; Define cast functions between Nat and Number
<span class="ansi38-255165000"
>  (: fromNumber 
    (-> Number Nat))
</span><span class="ansi38-255165000"
>  (= 
    (fromNumber $n) 
    (if 
      (<= $n 0) Z 
      (S (fromNumber (- $n 1)))))
</span><span class="ansi38-255165000"
>  (: fromNat 
    (-> Nat Number))
</span><span class="ansi38-255165000"
>  (= 
    (fromNat Z) 0)
</span><span class="ansi38-255165000"
>  (= 
    (fromNat (S $k)) 
    (+ 1 
      (fromNat $k)))
</span>;;;; Define a generic less than operator, ⩻, for Nat.  < cannot be used
;;;; because it is a built-in, its type is hardwired and cannot be
;;;; overloaded.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Nat Nat Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $ Z) False)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ Z 
      (S $)) True)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ 
      (S $x) 
      (S $y)) 
    (⩻ $x $y))
</span>;;;; Overload ⩻ for Number.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Number Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $x $y) 
    (< $x $y))
</span>;;;; Return the ceiling of a non negative number.  If the number is
;;;; negative it returns 1.
<span class="ansi38-255165000"
>  (: ceil 
    (-> Number Number))
</span><span class="ansi38-255165000"
>  (= 
    (ceil $n) 
    (fromNat (fromNumber $n)))
</span>;;;; Convert Number to Bool.  Anything above 0 converts to True.
<span class="ansi38-255165000"
>  (: number->bool 
    (-> Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (number->bool $x) 
    (< 0 $x))
</span>;;;; Convert Bool to Number.  False converts to 0, True converts to 1.
<span class="ansi38-255165000"
>  (: bool->number 
    (-> Bool Number))
</span><span class="ansi38-255165000"
>  (= 
    (bool->number False) 0)
</span><span class="ansi38-255165000"
>  (= 
    (bool->number True) 1)
</span>;;;; Define a less than type.  Note that it is purposefully different
;;;; than ⩻ as it is a type, not an operator.  Inhabitants of (⍃ x y)
;;;; are proofs that x ⩻ y == True.  For now ⍃ is only axiomatized for
;;;; Nat.
<span class="ansi38-255165000"
>  (: ⍃ 
    (-> $t $t Type))
</span>;;;; Zero is always less than the successor of something
<span class="ansi38-255165000"
>  (: 
    (zero-lt-succ-axiom) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (zero-lt-succ-axiom) 
    (: ZeroLTSucc 
      (⍃ Z 
        (S $k))))
</span>;;;; If x ⍃ y then (S x) ⍃ (S y)
<span class="ansi38-255165000"
>  (: 
    (succ-monotonicity-rule) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (succ-monotonicity-rule) 
    (: SuccMonotonicity 
      (-> 
        (⍃ $x $y) 
        (⍃ 
          (S $x) 
          (S $y)))))
</span>;;;; Collection of functions operating on numbers
;;;; Define max
<span class="ansi38-255165000"
>  (: max 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (max $x $y) 
    (if 
      (> $x $y) $x $y))
</span>;;;; Define min
<span class="ansi38-255165000"
>  (: min 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (min $x $y) 
    (if 
      (< $x $y) $x $y))
</span>;;;; Clamp a number to be within a certain range
<span class="ansi38-255165000"
>  (: clamp 
    (-> $a $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (clamp $x $l $u) 
    (max $l 
      (min $u $x)))
</span>;;;; Define abs
<span class="ansi38-255165000"
>  (: abs 
    (-> $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (abs $x) 
    (if 
      (< $x 0) 
      (* -1 $x) $x))
</span>;;;; Define <=
<span class="ansi38-255165000"
>  (: <= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (<= $x $y) 
    (or 
      (< $x $y) 
      (== $x $y)))
</span>;;;; Define >=
<span class="ansi38-255165000"
>  (: >= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (>= $x $y) 
    (or 
      (> $x $y) 
      (== $x $y)))
</span>;;;; Define approximately equal
<span class="ansi38-255165000"
>  (: approxEq 
    (-> $a $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (approxEq $x $y $epsilon) 
    (<= 
      (abs (- $x $y)) $epsilon))
</span>;;;; Define Nat
<span class="ansi38-255165000"
>  (: Nat Type)
</span><span class="ansi38-255165000"
>  (: Z Nat)
</span><span class="ansi38-255165000"
>  (: S 
    (-> Nat Nat))
</span>;;;; Define cast functions between Nat and Number
<span class="ansi38-255165000"
>  (: fromNumber 
    (-> Number Nat))
</span><span class="ansi38-255165000"
>  (= 
    (fromNumber $n) 
    (if 
      (<= $n 0) Z 
      (S (fromNumber (- $n 1)))))
</span><span class="ansi38-255165000"
>  (: fromNat 
    (-> Nat Number))
</span><span class="ansi38-255165000"
>  (= 
    (fromNat Z) 0)
</span><span class="ansi38-255165000"
>  (= 
    (fromNat (S $k)) 
    (+ 1 
      (fromNat $k)))
</span>;;;; Define a generic less than operator, ⩻, for Nat.  < cannot be used
;;;; because it is a built-in, its type is hardwired and cannot be
;;;; overloaded.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Nat Nat Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $ Z) False)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ Z 
      (S $)) True)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ 
      (S $x) 
      (S $y)) 
    (⩻ $x $y))
</span>;;;; Overload ⩻ for Number.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Number Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $x $y) 
    (< $x $y))
</span>;;;; Return the ceiling of a non negative number.  If the number is
;;;; negative it returns 1.
<span class="ansi38-255165000"
>  (: ceil 
    (-> Number Number))
</span><span class="ansi38-255165000"
>  (= 
    (ceil $n) 
    (fromNat (fromNumber $n)))
</span>;;;; Convert Number to Bool.  Anything above 0 converts to True.
<span class="ansi38-255165000"
>  (: number->bool 
    (-> Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (number->bool $x) 
    (< 0 $x))
</span>;;;; Convert Bool to Number.  False converts to 0, True converts to 1.
<span class="ansi38-255165000"
>  (: bool->number 
    (-> Bool Number))
</span><span class="ansi38-255165000"
>  (= 
    (bool->number False) 0)
</span><span class="ansi38-255165000"
>  (= 
    (bool->number True) 1)
</span>;;;; Define a less than type.  Note that it is purposefully different
;;;; than ⩻ as it is a type, not an operator.  Inhabitants of (⍃ x y)
;;;; are proofs that x ⩻ y == True.  For now ⍃ is only axiomatized for
;;;; Nat.
<span class="ansi38-255165000"
>  (: ⍃ 
    (-> $t $t Type))
</span>;;;; Zero is always less than the successor of something
<span class="ansi38-255165000"
>  (: 
    (zero-lt-succ-axiom) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (zero-lt-succ-axiom) 
    (: ZeroLTSucc 
      (⍃ Z 
        (S $k))))
</span>;;;; If x ⍃ y then (S x) ⍃ (S y)
<span class="ansi38-255165000"
>  (: 
    (succ-monotonicity-rule) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (succ-monotonicity-rule) 
    (: SuccMonotonicity 
      (-> 
        (⍃ $x $y) 
        (⍃ 
          (S $x) 
          (S $y)))))
</span>;;;; Collection of functions operating on numbers
;;;; Define max
<span class="ansi38-255165000"
>  (: max 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (max $x $y) 
    (if 
      (> $x $y) $x $y))
</span>;;;; Define min
<span class="ansi38-255165000"
>  (: min 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (min $x $y) 
    (if 
      (< $x $y) $x $y))
</span>;;;; Clamp a number to be within a certain range
<span class="ansi38-255165000"
>  (: clamp 
    (-> $a $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (clamp $x $l $u) 
    (max $l 
      (min $u $x)))
</span>;;;; Define abs
<span class="ansi38-255165000"
>  (: abs 
    (-> $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (abs $x) 
    (if 
      (< $x 0) 
      (* -1 $x) $x))
</span>;;;; Define <=
<span class="ansi38-255165000"
>  (: <= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (<= $x $y) 
    (or 
      (< $x $y) 
      (== $x $y)))
</span>;;;; Define >=
<span class="ansi38-255165000"
>  (: >= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (>= $x $y) 
    (or 
      (> $x $y) 
      (== $x $y)))
</span>;;;; Define approximately equal
<span class="ansi38-255165000"
>  (: approxEq 
    (-> $a $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (approxEq $x $y $epsilon) 
    (<= 
      (abs (- $x $y)) $epsilon))
</span>;;;; Define Nat
<span class="ansi38-255165000"
>  (: Nat Type)
</span><span class="ansi38-255165000"
>  (: Z Nat)
</span><span class="ansi38-255165000"
>  (: S 
    (-> Nat Nat))
</span>;;;; Define cast functions between Nat and Number
<span class="ansi38-255165000"
>  (: fromNumber 
    (-> Number Nat))
</span><span class="ansi38-255165000"
>  (= 
    (fromNumber $n) 
    (if 
      (<= $n 0) Z 
      (S (fromNumber (- $n 1)))))
</span><span class="ansi38-255165000"
>  (: fromNat 
    (-> Nat Number))
</span><span class="ansi38-255165000"
>  (= 
    (fromNat Z) 0)
</span><span class="ansi38-255165000"
>  (= 
    (fromNat (S $k)) 
    (+ 1 
      (fromNat $k)))
</span>;;;; Define a generic less than operator, ⩻, for Nat.  < cannot be used
;;;; because it is a built-in, its type is hardwired and cannot be
;;;; overloaded.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Nat Nat Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $ Z) False)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ Z 
      (S $)) True)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ 
      (S $x) 
      (S $y)) 
    (⩻ $x $y))
</span>;;;; Overload ⩻ for Number.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Number Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $x $y) 
    (< $x $y))
</span>;;;; Return the ceiling of a non negative number.  If the number is
;;;; negative it returns 1.
<span class="ansi38-255165000"
>  (: ceil 
    (-> Number Number))
</span><span class="ansi38-255165000"
>  (= 
    (ceil $n) 
    (fromNat (fromNumber $n)))
</span>;;;; Convert Number to Bool.  Anything above 0 converts to True.
<span class="ansi38-255165000"
>  (: number->bool 
    (-> Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (number->bool $x) 
    (< 0 $x))
</span>;;;; Convert Bool to Number.  False converts to 0, True converts to 1.
<span class="ansi38-255165000"
>  (: bool->number 
    (-> Bool Number))
</span><span class="ansi38-255165000"
>  (= 
    (bool->number False) 0)
</span><span class="ansi38-255165000"
>  (= 
    (bool->number True) 1)
</span>;;;; Define a less than type.  Note that it is purposefully different
;;;; than ⩻ as it is a type, not an operator.  Inhabitants of (⍃ x y)
;;;; are proofs that x ⩻ y == True.  For now ⍃ is only axiomatized for
;;;; Nat.
<span class="ansi38-255165000"
>  (: ⍃ 
    (-> $t $t Type))
</span>;;;; Zero is always less than the successor of something
<span class="ansi38-255165000"
>  (: 
    (zero-lt-succ-axiom) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (zero-lt-succ-axiom) 
    (: ZeroLTSucc 
      (⍃ Z 
        (S $k))))
</span>;;;; If x ⍃ y then (S x) ⍃ (S y)
<span class="ansi38-255165000"
>  (: 
    (succ-monotonicity-rule) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (succ-monotonicity-rule) 
    (: SuccMonotonicity 
      (-> 
        (⍃ $x $y) 
        (⍃ 
          (S $x) 
          (S $y)))))
</span>;;;; Collection of functions operating on numbers
;;;; Define max
<span class="ansi38-255165000"
>  (: max 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (max $x $y) 
    (if 
      (> $x $y) $x $y))
</span>;;;; Define min
<span class="ansi38-255165000"
>  (: min 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (min $x $y) 
    (if 
      (< $x $y) $x $y))
</span>;;;; Clamp a number to be within a certain range
<span class="ansi38-255165000"
>  (: clamp 
    (-> $a $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (clamp $x $l $u) 
    (max $l 
      (min $u $x)))
</span>;;;; Define abs
<span class="ansi38-255165000"
>  (: abs 
    (-> $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (abs $x) 
    (if 
      (< $x 0) 
      (* -1 $x) $x))
</span>;;;; Define <=
<span class="ansi38-255165000"
>  (: <= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (<= $x $y) 
    (or 
      (< $x $y) 
      (== $x $y)))
</span>;;;; Define >=
<span class="ansi38-255165000"
>  (: >= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (>= $x $y) 
    (or 
      (> $x $y) 
      (== $x $y)))
</span>;;;; Define approximately equal
<span class="ansi38-255165000"
>  (: approxEq 
    (-> $a $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (approxEq $x $y $epsilon) 
    (<= 
      (abs (- $x $y)) $epsilon))
</span>;;;; Define Nat
<span class="ansi38-255165000"
>  (: Nat Type)
</span><span class="ansi38-255165000"
>  (: Z Nat)
</span><span class="ansi38-255165000"
>  (: S 
    (-> Nat Nat))
</span>;;;; Define cast functions between Nat and Number
<span class="ansi38-255165000"
>  (: fromNumber 
    (-> Number Nat))
</span><span class="ansi38-255165000"
>  (= 
    (fromNumber $n) 
    (if 
      (<= $n 0) Z 
      (S (fromNumber (- $n 1)))))
</span><span class="ansi38-255165000"
>  (: fromNat 
    (-> Nat Number))
</span><span class="ansi38-255165000"
>  (= 
    (fromNat Z) 0)
</span><span class="ansi38-255165000"
>  (= 
    (fromNat (S $k)) 
    (+ 1 
      (fromNat $k)))
</span>;;;; Define a generic less than operator, ⩻, for Nat.  < cannot be used
;;;; because it is a built-in, its type is hardwired and cannot be
;;;; overloaded.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Nat Nat Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $ Z) False)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ Z 
      (S $)) True)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ 
      (S $x) 
      (S $y)) 
    (⩻ $x $y))
</span>;;;; Overload ⩻ for Number.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Number Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $x $y) 
    (< $x $y))
</span>;;;; Return the ceiling of a non negative number.  If the number is
;;;; negative it returns 1.
<span class="ansi38-255165000"
>  (: ceil 
    (-> Number Number))
</span><span class="ansi38-255165000"
>  (= 
    (ceil $n) 
    (fromNat (fromNumber $n)))
</span>;;;; Convert Number to Bool.  Anything above 0 converts to True.
<span class="ansi38-255165000"
>  (: number->bool 
    (-> Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (number->bool $x) 
    (< 0 $x))
</span>;;;; Convert Bool to Number.  False converts to 0, True converts to 1.
<span class="ansi38-255165000"
>  (: bool->number 
    (-> Bool Number))
</span><span class="ansi38-255165000"
>  (= 
    (bool->number False) 0)
</span><span class="ansi38-255165000"
>  (= 
    (bool->number True) 1)
</span>;;;; Define a less than type.  Note that it is purposefully different
;;;; than ⩻ as it is a type, not an operator.  Inhabitants of (⍃ x y)
;;;; are proofs that x ⩻ y == True.  For now ⍃ is only axiomatized for
;;;; Nat.
<span class="ansi38-255165000"
>  (: ⍃ 
    (-> $t $t Type))
</span>;;;; Zero is always less than the successor of something
<span class="ansi38-255165000"
>  (: 
    (zero-lt-succ-axiom) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (zero-lt-succ-axiom) 
    (: ZeroLTSucc 
      (⍃ Z 
        (S $k))))
</span>;;;; If x ⍃ y then (S x) ⍃ (S y)
<span class="ansi38-255165000"
>  (: 
    (succ-monotonicity-rule) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (succ-monotonicity-rule) 
    (: SuccMonotonicity 
      (-> 
        (⍃ $x $y) 
        (⍃ 
          (S $x) 
          (S $y)))))
</span>
Deterministic: ()
;;;;;;;;;;;;
;;;; Type ;;
;;;;;;;;;;;;
<span class="ansi38-255165000"
>  (: TruthValue Type)
</span>;;;;;;;;;;;;;;;;;;;;
;;;; Constructors ;;
;;;;;;;;;;;;;;;;;;;;
;;;; Boolean TV constructor
;;;; TODO: alternatively we could have (: ⊤ TruthValue) and (: ⊥ TruthValue)
<span class="ansi38-255165000"
>  (: Bl 
    (-> Bool TruthValue))
</span>;;;; First order probability TV constructor, i.e. mere probability.
<span class="ansi38-255165000"
>  (: Pr 
    (-> Number TruthValue))
</span>;;;; Simple Truth Value.  A Second order probability TV constructor,
;;;; i.e. probability and confidence.  The probability is in fact the
;;;; mode of the corresponding beta distribution.
<span class="ansi38-255165000"
>  (: STV 
    (-> Number Number TruthValue))
</span>;;;;;;;;;;;;;;;;;
;;;; Constants ;;
;;;;;;;;;;;;;;;;;
;;;; For now the underlying beta distributions have a Jeffreys prior,
;;;; i.e. the prior alpha and beta are 0.5.
<span class="ansi38-255165000"
>  (: prior-alpha 
    (-> Number))
</span><span class="ansi38-255165000"
>  (= 
    (prior-alpha) 0.5)
</span><span class="ansi38-255165000"
>  (: prior-beta 
    (-> Number))
</span><span class="ansi38-255165000"
>  (= 
    (prior-beta) 0.5)
</span>;;;; Lookahead
<span class="ansi38-255165000"
>  (: lookahead 
    (-> Number))
</span><span class="ansi38-255165000"
>  (= 
    (lookahead) 1.0)
</span>;;;; Maximum supported count (till +inf is supported, possibly).
<span class="ansi38-255165000"
>  (: max-count 
    (-> Number))
</span><span class="ansi38-255165000"
>  (= 
    (max-count) 1000000000.0)
</span>;;;;;;;;;;;;;;;
;;;; Methods ;;
;;;;;;;;;;;;;;;
;;;; Convert count to confidence using the formula
;;;;
;;;; confidence = count / (count + lookahead)
<span class="ansi38-255165000"
>  (: count->confidence 
    (-> Number Number))
</span><span class="ansi38-255165000"
>  (= 
    (count->confidence $cnt) 
    (/ $cnt 
      (+ $cnt 
        (lookahead))))
</span>;;;; Convert confidence to count using the formula
;;;;
;;;; count = (confidence * lookahead) / (1 - confidence)
<span class="ansi38-255165000"
>  (: confidence->count 
    (-> Number Number))
</span><span class="ansi38-255165000"
>  (= 
    (confidence->count $conf) 
    (if 
      (approxEq 1.0 $conf 1.0e-9) 
      (max-count) 
      (/ 
        (* $conf 
          (lookahead)) 
        (- 1.0 $conf))))
</span>;;;; Increment the negative count of a given truth value, by
;;;; incrementing its total count without incrementing the positive
;;;; count.
<span class="ansi38-255165000"
>  (: inc-neg-count 
    (-> TruthValue TruthValue))
</span><span class="ansi38-255165000"
>  (= 
    (inc-neg-count (STV $s $c)) 
    (let* 
      ( ($tot_cnt (confidence->count $c)) 
        ($pos_cnt (* $s $tot_cnt)) 
        ($new_tot_cnt (+ $tot_cnt 1))) 
      (STV 
        (/ $pos_cnt $new_tot_cnt) 
        (count->confidence $new_tot_cnt))))
</span>;;;; Increment the positive count of a given truth value, by
;;;; incrementing its total count and its positive count.
<span class="ansi38-255165000"
>  (: inc-pos-count 
    (-> TruthValue TruthValue))
</span><span class="ansi38-255165000"
>  (= 
    (inc-pos-count (STV $s $c)) 
    (let* 
      ( ($tot_cnt (confidence->count $c)) 
        ($pos_cnt (* $s $tot_cnt)) 
        ($new_pos_cnt (+ $pos_cnt 1)) 
        ($new_tot_cnt (+ $tot_cnt 1))) 
      (STV 
        (/ $new_pos_cnt $new_tot_cnt) 
        (count->confidence $new_tot_cnt))))
</span>;;;; Return the first order probability mode of the second order
;;;; distribution associated to a truth value.
<span class="ansi38-255165000"
>  (: mode 
    (-> TruthValue Number))
</span><span class="ansi38-255165000"
>  (= 
    (mode (Bl True)) 1.0)
</span><span class="ansi38-255165000"
>  (= 
    (mode (Bl False)) 0.0)
</span><span class="ansi38-255165000"
>  (= 
    (mode (Pr $pr)) $pr)
</span><span class="ansi38-255165000"
>  (= 
    (mode (STV $pr $)) $pr)
</span>;;;; Return the total count of a truth value.  For truth values not
;;;; capturing a notion of confidence, such as Bl or Pr then the count
;;;; is assumed to be a very large number (cause +inf does not seem to
;;;; be supported at the moment).
<span class="ansi38-255165000"
>  (: count 
    (-> TruthValue Number))
</span><span class="ansi38-255165000"
>  (= 
    (count (Bl $)) 
    (max-count))
</span><span class="ansi38-255165000"
>  (= 
    (count (Pr $)) 
    (max-count))
</span><span class="ansi38-255165000"
>  (= 
    (count (STV $ $conf)) 
    (confidence->count $conf))
</span>;;;; Return the confidence of a truth value.  For truth values not
;;;; capturing a notion of confidence, such as Bl or Pr then the
;;;; confidence is assumed to be 1.0.  For truth values capturing a
;;;; notion of confidence, such as STV, the formula to convert a count
;;;; into confidence is as follows
;;;;
;;;; confidence = count / (count + lookahead)
<span class="ansi38-255165000"
>  (: confidence 
    (-> TruthValue Number))
</span><span class="ansi38-255165000"
>  (= 
    (confidence (Bl $)) 1.0)
</span><span class="ansi38-255165000"
>  (= 
    (confidence (Pr $)) 1.0)
</span><span class="ansi38-255165000"
>  (= 
    (confidence (STV $ $conf)) $conf)
</span>;;;; Return the positive count of a truth value.
<span class="ansi38-255165000"
>  (: pos-count 
    (-> TruthValue Number))
</span><span class="ansi38-255165000"
>  (= 
    (pos-count $tv) 
    (* 
      (mode $tv) 
      (count $tv)))
</span>;;;; Return the negative count of a truth value.
<span class="ansi38-255165000"
>  (: neg-count 
    (-> TruthValue Number))
</span><span class="ansi38-255165000"
>  (= 
    (neg-count $tv) 
    (* 
      (- 1 
        (mode $tv)) 
      (count $tv)))
</span>;;;; Return the posterior alpha of a truth value
<span class="ansi38-255165000"
>  (: post-alpha 
    (-> TruthValue Number))
</span><span class="ansi38-255165000"
>  (= 
    (post-alpha $tv) 
    (+ 
      (prior-alpha) 
      (pos-count $tv)))
</span>;;;; Return the posterior beta of a truth value
<span class="ansi38-255165000"
>  (: post-beta 
    (-> TruthValue Number))
</span><span class="ansi38-255165000"
>  (= 
    (post-beta $tv) 
    (+ 
      (prior-beta) 
      (neg-count $tv)))
</span>;;;; Return the first order probability mean of the second order
;;;; distribution associated to a truth value.  For truth values not
;;;; capturing a notion of confidence, such as Bl or Pr then the
;;;; confidence is assumed to be 1.0.  For truth values capturing a
;;;; notion of confidence, such as STV, a beta distribution is assumed.
<span class="ansi38-255165000"
>  (: mean 
    (-> TruthValue Number))
</span><span class="ansi38-255165000"
>  (= 
    (mean (Bl True)) 1.0)
</span><span class="ansi38-255165000"
>  (= 
    (mean (Bl False)) 0.0)
</span><span class="ansi38-255165000"
>  (= 
    (mean (Pr $pr)) $pr)
</span><span class="ansi38-255165000"
>  (= 
    (mean (STV $pr $conf)) 
    (let* 
      ( ($a (post-alpha (STV $pr $conf))) ($b (post-beta (STV $pr $conf)))) 
      (/ $a 
        (+ $a $b))))
</span>
Last Result(2): ()
;;;; Alternate implication direct introduction formula assuming Boolean
;;;; evidence.  Base case, meaning there is only one piece of evidence.
<span class="ansi38-255165000"
>  (: direct-introduction-base-formula 
    (-> Bool TruthValue))
</span><span class="ansi38-255165000"
>  (= 
    (direct-introduction-base-formula $qa) 
    (STV 
      (bool->number $qa) 
      (count->confidence 1)))
</span>;;;; Alternate implication direct introduction formula.  Inductive case,
;;;; meaning the piece of evidence gets aggregated to another truth
;;;; value.
<span class="ansi38-255165000"
>  (: direct-introduction-recursive-formula 
    (-> Bool TruthValue TruthValue))
</span><span class="ansi38-255165000"
>  (= 
    (direct-introduction-recursive-formula False 
      (STV $PQs $PQc)) 
    (inc-neg-count (STV $PQs $PQc)))
</span><span class="ansi38-255165000"
>  (= 
    (direct-introduction-recursive-formula True 
      (STV $PQs $PQc)) 
    (inc-pos-count (STV $PQs $PQc)))
</span>
Last Result(3): ()
;;;;;;;;;;;;;;;;;;;;;;;
;;;; Rule Definition ;;
;;;;;;;;;;;;;;;;;;;;;;;
;;;; All rules are implemented as constructors of propositions encoded
;;;; as types.
;;;; To deal with an abritrary number of pieces of evidence the rule is
;;;; defined inductively.
;;;; Base case (one piece of evidence):
;;;;
;;;; (p a) = True
;;;; (q a) = qa
;;;; ⊢
;;;; p→q ≞ (ETV (:: a ∅) tv)
;;;;
;;;; where tv is calculated according to the direct introduction
;;;; formula.  Note that we don't bother to take into account pieces of
;;;; evidence that is not True on (p a), because it has no impact on the
;;;; resulting truth value otherwise.
;;;;
;;;; To avoid prematurely reducing (p a) = pa to pa = pa, the following
;;;; representation is used instead
;;;;
;;;; (⊷ p a pa)
;;;;
;;;; which can be read as "under p, the image of a is pa".
;;;;
;;;; ⊷ is essentially the Atomese equivalent of ExecutionLink.  It has
;;;; description: IMAGE OF, hexadecimal code: 0x22B7, unicode-math code:
;;;; \imageof and latex code: \multimapdotbothB.
<span class="ansi38-255165000"
>  (: implication-direct-introduction-base-rule 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (implication-direct-introduction-base-rule) 
    (: IDIBase 
      (-> 
        (⊷ $p $a True) 
        (⊷ $q $a $qa) 
        (≞ 
          (→ $p $q) 
          (ETV 
            (:: $a ∅) 
            (direct-introduction-base-formula $qa))))))
</span>;;;; Recursive step (more than one piece of evidence):
;;;;
;;;; (p a) = True
;;;; (q a) = qa
;;;; p→q ≞ (ETV (:: h t) pqtv)
;;;; h < a
;;;; ⊢
;;;; p→q ≞ (ETV (:: a (:: h t)) tv)
;;;;
;;;; where tv is calculated using the direct introduction formula.  Note
;;;; that we don't bother to take into account pieces of evidence that
;;;; is not True on (p a), because it has no impact on the resulting
;;;; truth value otherwise.
;;;;
;;;; To avoid prematurely reducing (p a) = pa to pa = pa, the following
;;;; representation is used instead
;;;;
;;;; (⊷ p a pa)
;;;;
;;;; which can be read as "under p, the image of a is pa".
;;;;
;;;; For a similar reason, the premise h < a is represented as
;;;;
;;;; h ⍃ a
;;;;
;;;; ⍃ is the axiomatized version of <.  It is defined in Num.metta.
;;;; The box around the less than sign is here to manifest its
;;;; axiomatic, as opposed to computational, nature.  It has
;;;; description: APL FUNCTIONAL SYMBOL QUAD LESS-THAN and hexadecimal
;;;; code: 0x2343.
;;;;
;;;; The h ⍃ a premise is there to garanty that evidence is not double
;;;; counted.
;;;;
;;;; Historical note: initially the premise
;;;;
;;;; h ⍃ a
;;;;
;;;; was replaced by
;;;;
;;;; a ∉ (:: h t)
;;;;
;;;; But then it was realized that it is far more efficient to enforce
;;;; the order in which evidence can be pilled up, than to prove that a
;;;; new piece of evidence does not belongs to an existing evidence set.
;;;; And now you know why time is the way it is.
<span class="ansi38-255165000"
>  (: implication-direct-introduction-recursive-rule 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (implication-direct-introduction-recursive-rule) 
    (: IDIRecursive 
      (-> 
        (⊷ $p $a True) 
        (⊷ $q $a $qa) 
        (≞ 
          (→ $p $q) 
          (ETV 
            (:: $h $t) $pqtv)) 
        (⍃ $h $a) 
        (≞ 
          (→ $p $q) 
          (ETV 
            (:: $a 
              (:: $h $t)) 
            (direct-introduction-recursive-formula $qa $pqtv))))))
</span>;;;; Convert an EvidenceTruthValue to a TruthValue (i.e. elimate the
;;;; evidential part).
;;;;
;;;; (ETV evidence tv)
;;;; ⊢
;;;; tv
<span class="ansi38-255165000"
>  (: evidence-elimination-rule 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (evidence-elimination-rule) 
    (: EvidenceElimination 
      (-> 
        (≞ $a 
          (ETV $evidence $tv)) 
        (≞ $a $tv))))
</span>
Last Result(4): ()
()]
<span class="ansi38-013099040"
>  !(import! &self ../synthesis/Synthesize.metta)

</span>[P;HTML|
;                                           (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/synthesis/Synthesize.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/synthesis/Synthesize.metta)
P;HTML|
;                                           (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/synthesis/Synthesize.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/synthesis/Synthesize.metta)

;;;; Import modules
<span class="ansi38-013099040"
>  !(import! &self ../common/Num.metta)

</span>P;HTML|
;                                           (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/Num.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/Num.metta)
P;HTML|
;                                           (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/Num.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/Num.metta)

;;;; Collection of functions operating on numbers
;;;; Define max
<span class="ansi38-255165000"
>  (: max 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (max $x $y) 
    (if 
      (> $x $y) $x $y))
</span>;;;; Define min
<span class="ansi38-255165000"
>  (: min 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (min $x $y) 
    (if 
      (< $x $y) $x $y))
</span>;;;; Clamp a number to be within a certain range
<span class="ansi38-255165000"
>  (: clamp 
    (-> $a $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (clamp $x $l $u) 
    (max $l 
      (min $u $x)))
</span>;;;; Define abs
<span class="ansi38-255165000"
>  (: abs 
    (-> $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (abs $x) 
    (if 
      (< $x 0) 
      (* -1 $x) $x))
</span>;;;; Define <=
<span class="ansi38-255165000"
>  (: <= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (<= $x $y) 
    (or 
      (< $x $y) 
      (== $x $y)))
</span>;;;; Define >=
<span class="ansi38-255165000"
>  (: >= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (>= $x $y) 
    (or 
      (> $x $y) 
      (== $x $y)))
</span>;;;; Define approximately equal
<span class="ansi38-255165000"
>  (: approxEq 
    (-> $a $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (approxEq $x $y $epsilon) 
    (<= 
      (abs (- $x $y)) $epsilon))
</span>;;;; Define Nat
<span class="ansi38-255165000"
>  (: Nat Type)
</span><span class="ansi38-255165000"
>  (: Z Nat)
</span><span class="ansi38-255165000"
>  (: S 
    (-> Nat Nat))
</span>;;;; Define cast functions between Nat and Number
<span class="ansi38-255165000"
>  (: fromNumber 
    (-> Number Nat))
</span><span class="ansi38-255165000"
>  (= 
    (fromNumber $n) 
    (if 
      (<= $n 0) Z 
      (S (fromNumber (- $n 1)))))
</span><span class="ansi38-255165000"
>  (: fromNat 
    (-> Nat Number))
</span><span class="ansi38-255165000"
>  (= 
    (fromNat Z) 0)
</span><span class="ansi38-255165000"
>  (= 
    (fromNat (S $k)) 
    (+ 1 
      (fromNat $k)))
</span>;;;; Define a generic less than operator, ⩻, for Nat.  < cannot be used
;;;; because it is a built-in, its type is hardwired and cannot be
;;;; overloaded.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Nat Nat Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $ Z) False)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ Z 
      (S $)) True)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ 
      (S $x) 
      (S $y)) 
    (⩻ $x $y))
</span>;;;; Overload ⩻ for Number.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Number Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $x $y) 
    (< $x $y))
</span>;;;; Return the ceiling of a non negative number.  If the number is
;;;; negative it returns 1.
<span class="ansi38-255165000"
>  (: ceil 
    (-> Number Number))
</span><span class="ansi38-255165000"
>  (= 
    (ceil $n) 
    (fromNat (fromNumber $n)))
</span>;;;; Convert Number to Bool.  Anything above 0 converts to True.
<span class="ansi38-255165000"
>  (: number->bool 
    (-> Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (number->bool $x) 
    (< 0 $x))
</span>;;;; Convert Bool to Number.  False converts to 0, True converts to 1.
<span class="ansi38-255165000"
>  (: bool->number 
    (-> Bool Number))
</span><span class="ansi38-255165000"
>  (= 
    (bool->number False) 0)
</span><span class="ansi38-255165000"
>  (= 
    (bool->number True) 1)
</span>;;;; Define a less than type.  Note that it is purposefully different
;;;; than ⩻ as it is a type, not an operator.  Inhabitants of (⍃ x y)
;;;; are proofs that x ⩻ y == True.  For now ⍃ is only axiomatized for
;;;; Nat.
<span class="ansi38-255165000"
>  (: ⍃ 
    (-> $t $t Type))
</span>;;;; Zero is always less than the successor of something
<span class="ansi38-255165000"
>  (: 
    (zero-lt-succ-axiom) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (zero-lt-succ-axiom) 
    (: ZeroLTSucc 
      (⍃ Z 
        (S $k))))
</span>;;;; If x ⍃ y then (S x) ⍃ (S y)
<span class="ansi38-255165000"
>  (: 
    (succ-monotonicity-rule) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (succ-monotonicity-rule) 
    (: SuccMonotonicity 
      (-> 
        (⍃ $x $y) 
        (⍃ 
          (S $x) 
          (S $y)))))
</span>;;;; Collection of functions operating on numbers
;;;; Define max
<span class="ansi38-255165000"
>  (: max 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (max $x $y) 
    (if 
      (> $x $y) $x $y))
</span>;;;; Define min
<span class="ansi38-255165000"
>  (: min 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (min $x $y) 
    (if 
      (< $x $y) $x $y))
</span>;;;; Clamp a number to be within a certain range
<span class="ansi38-255165000"
>  (: clamp 
    (-> $a $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (clamp $x $l $u) 
    (max $l 
      (min $u $x)))
</span>;;;; Define abs
<span class="ansi38-255165000"
>  (: abs 
    (-> $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (abs $x) 
    (if 
      (< $x 0) 
      (* -1 $x) $x))
</span>;;;; Define <=
<span class="ansi38-255165000"
>  (: <= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (<= $x $y) 
    (or 
      (< $x $y) 
      (== $x $y)))
</span>;;;; Define >=
<span class="ansi38-255165000"
>  (: >= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (>= $x $y) 
    (or 
      (> $x $y) 
      (== $x $y)))
</span>;;;; Define approximately equal
<span class="ansi38-255165000"
>  (: approxEq 
    (-> $a $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (approxEq $x $y $epsilon) 
    (<= 
      (abs (- $x $y)) $epsilon))
</span>;;;; Define Nat
<span class="ansi38-255165000"
>  (: Nat Type)
</span><span class="ansi38-255165000"
>  (: Z Nat)
</span><span class="ansi38-255165000"
>  (: S 
    (-> Nat Nat))
</span>;;;; Define cast functions between Nat and Number
<span class="ansi38-255165000"
>  (: fromNumber 
    (-> Number Nat))
</span><span class="ansi38-255165000"
>  (= 
    (fromNumber $n) 
    (if 
      (<= $n 0) Z 
      (S (fromNumber (- $n 1)))))
</span><span class="ansi38-255165000"
>  (: fromNat 
    (-> Nat Number))
</span><span class="ansi38-255165000"
>  (= 
    (fromNat Z) 0)
</span><span class="ansi38-255165000"
>  (= 
    (fromNat (S $k)) 
    (+ 1 
      (fromNat $k)))
</span>;;;; Define a generic less than operator, ⩻, for Nat.  < cannot be used
;;;; because it is a built-in, its type is hardwired and cannot be
;;;; overloaded.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Nat Nat Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $ Z) False)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ Z 
      (S $)) True)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ 
      (S $x) 
      (S $y)) 
    (⩻ $x $y))
</span>;;;; Overload ⩻ for Number.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Number Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $x $y) 
    (< $x $y))
</span>;;;; Return the ceiling of a non negative number.  If the number is
;;;; negative it returns 1.
<span class="ansi38-255165000"
>  (: ceil 
    (-> Number Number))
</span><span class="ansi38-255165000"
>  (= 
    (ceil $n) 
    (fromNat (fromNumber $n)))
</span>;;;; Convert Number to Bool.  Anything above 0 converts to True.
<span class="ansi38-255165000"
>  (: number->bool 
    (-> Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (number->bool $x) 
    (< 0 $x))
</span>;;;; Convert Bool to Number.  False converts to 0, True converts to 1.
<span class="ansi38-255165000"
>  (: bool->number 
    (-> Bool Number))
</span><span class="ansi38-255165000"
>  (= 
    (bool->number False) 0)
</span><span class="ansi38-255165000"
>  (= 
    (bool->number True) 1)
</span>;;;; Define a less than type.  Note that it is purposefully different
;;;; than ⩻ as it is a type, not an operator.  Inhabitants of (⍃ x y)
;;;; are proofs that x ⩻ y == True.  For now ⍃ is only axiomatized for
;;;; Nat.
<span class="ansi38-255165000"
>  (: ⍃ 
    (-> $t $t Type))
</span>;;;; Zero is always less than the successor of something
<span class="ansi38-255165000"
>  (: 
    (zero-lt-succ-axiom) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (zero-lt-succ-axiom) 
    (: ZeroLTSucc 
      (⍃ Z 
        (S $k))))
</span>;;;; If x ⍃ y then (S x) ⍃ (S y)
<span class="ansi38-255165000"
>  (: 
    (succ-monotonicity-rule) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (succ-monotonicity-rule) 
    (: SuccMonotonicity 
      (-> 
        (⍃ $x $y) 
        (⍃ 
          (S $x) 
          (S $y)))))
</span>;;;; Collection of functions operating on numbers
;;;; Define max
<span class="ansi38-255165000"
>  (: max 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (max $x $y) 
    (if 
      (> $x $y) $x $y))
</span>;;;; Define min
<span class="ansi38-255165000"
>  (: min 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (min $x $y) 
    (if 
      (< $x $y) $x $y))
</span>;;;; Clamp a number to be within a certain range
<span class="ansi38-255165000"
>  (: clamp 
    (-> $a $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (clamp $x $l $u) 
    (max $l 
      (min $u $x)))
</span>;;;; Define abs
<span class="ansi38-255165000"
>  (: abs 
    (-> $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (abs $x) 
    (if 
      (< $x 0) 
      (* -1 $x) $x))
</span>;;;; Define <=
<span class="ansi38-255165000"
>  (: <= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (<= $x $y) 
    (or 
      (< $x $y) 
      (== $x $y)))
</span>;;;; Define >=
<span class="ansi38-255165000"
>  (: >= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (>= $x $y) 
    (or 
      (> $x $y) 
      (== $x $y)))
</span>;;;; Define approximately equal
<span class="ansi38-255165000"
>  (: approxEq 
    (-> $a $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (approxEq $x $y $epsilon) 
    (<= 
      (abs (- $x $y)) $epsilon))
</span>;;;; Define Nat
<span class="ansi38-255165000"
>  (: Nat Type)
</span><span class="ansi38-255165000"
>  (: Z Nat)
</span><span class="ansi38-255165000"
>  (: S 
    (-> Nat Nat))
</span>;;;; Define cast functions between Nat and Number
<span class="ansi38-255165000"
>  (: fromNumber 
    (-> Number Nat))
</span><span class="ansi38-255165000"
>  (= 
    (fromNumber $n) 
    (if 
      (<= $n 0) Z 
      (S (fromNumber (- $n 1)))))
</span><span class="ansi38-255165000"
>  (: fromNat 
    (-> Nat Number))
</span><span class="ansi38-255165000"
>  (= 
    (fromNat Z) 0)
</span><span class="ansi38-255165000"
>  (= 
    (fromNat (S $k)) 
    (+ 1 
      (fromNat $k)))
</span>;;;; Define a generic less than operator, ⩻, for Nat.  < cannot be used
;;;; because it is a built-in, its type is hardwired and cannot be
;;;; overloaded.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Nat Nat Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $ Z) False)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ Z 
      (S $)) True)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ 
      (S $x) 
      (S $y)) 
    (⩻ $x $y))
</span>;;;; Overload ⩻ for Number.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Number Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $x $y) 
    (< $x $y))
</span>;;;; Return the ceiling of a non negative number.  If the number is
;;;; negative it returns 1.
<span class="ansi38-255165000"
>  (: ceil 
    (-> Number Number))
</span><span class="ansi38-255165000"
>  (= 
    (ceil $n) 
    (fromNat (fromNumber $n)))
</span>;;;; Convert Number to Bool.  Anything above 0 converts to True.
<span class="ansi38-255165000"
>  (: number->bool 
    (-> Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (number->bool $x) 
    (< 0 $x))
</span>;;;; Convert Bool to Number.  False converts to 0, True converts to 1.
<span class="ansi38-255165000"
>  (: bool->number 
    (-> Bool Number))
</span><span class="ansi38-255165000"
>  (= 
    (bool->number False) 0)
</span><span class="ansi38-255165000"
>  (= 
    (bool->number True) 1)
</span>;;;; Define a less than type.  Note that it is purposefully different
;;;; than ⩻ as it is a type, not an operator.  Inhabitants of (⍃ x y)
;;;; are proofs that x ⩻ y == True.  For now ⍃ is only axiomatized for
;;;; Nat.
<span class="ansi38-255165000"
>  (: ⍃ 
    (-> $t $t Type))
</span>;;;; Zero is always less than the successor of something
<span class="ansi38-255165000"
>  (: 
    (zero-lt-succ-axiom) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (zero-lt-succ-axiom) 
    (: ZeroLTSucc 
      (⍃ Z 
        (S $k))))
</span>;;;; If x ⍃ y then (S x) ⍃ (S y)
<span class="ansi38-255165000"
>  (: 
    (succ-monotonicity-rule) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (succ-monotonicity-rule) 
    (: SuccMonotonicity 
      (-> 
        (⍃ $x $y) 
        (⍃ 
          (S $x) 
          (S $y)))))
</span>;;;; Collection of functions operating on numbers
;;;; Define max
<span class="ansi38-255165000"
>  (: max 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (max $x $y) 
    (if 
      (> $x $y) $x $y))
</span>;;;; Define min
<span class="ansi38-255165000"
>  (: min 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (min $x $y) 
    (if 
      (< $x $y) $x $y))
</span>;;;; Clamp a number to be within a certain range
<span class="ansi38-255165000"
>  (: clamp 
    (-> $a $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (clamp $x $l $u) 
    (max $l 
      (min $u $x)))
</span>;;;; Define abs
<span class="ansi38-255165000"
>  (: abs 
    (-> $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (abs $x) 
    (if 
      (< $x 0) 
      (* -1 $x) $x))
</span>;;;; Define <=
<span class="ansi38-255165000"
>  (: <= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (<= $x $y) 
    (or 
      (< $x $y) 
      (== $x $y)))
</span>;;;; Define >=
<span class="ansi38-255165000"
>  (: >= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (>= $x $y) 
    (or 
      (> $x $y) 
      (== $x $y)))
</span>;;;; Define approximately equal
<span class="ansi38-255165000"
>  (: approxEq 
    (-> $a $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (approxEq $x $y $epsilon) 
    (<= 
      (abs (- $x $y)) $epsilon))
</span>;;;; Define Nat
<span class="ansi38-255165000"
>  (: Nat Type)
</span><span class="ansi38-255165000"
>  (: Z Nat)
</span><span class="ansi38-255165000"
>  (: S 
    (-> Nat Nat))
</span>;;;; Define cast functions between Nat and Number
<span class="ansi38-255165000"
>  (: fromNumber 
    (-> Number Nat))
</span><span class="ansi38-255165000"
>  (= 
    (fromNumber $n) 
    (if 
      (<= $n 0) Z 
      (S (fromNumber (- $n 1)))))
</span><span class="ansi38-255165000"
>  (: fromNat 
    (-> Nat Number))
</span><span class="ansi38-255165000"
>  (= 
    (fromNat Z) 0)
</span><span class="ansi38-255165000"
>  (= 
    (fromNat (S $k)) 
    (+ 1 
      (fromNat $k)))
</span>;;;; Define a generic less than operator, ⩻, for Nat.  < cannot be used
;;;; because it is a built-in, its type is hardwired and cannot be
;;;; overloaded.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Nat Nat Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $ Z) False)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ Z 
      (S $)) True)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ 
      (S $x) 
      (S $y)) 
    (⩻ $x $y))
</span>;;;; Overload ⩻ for Number.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Number Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $x $y) 
    (< $x $y))
</span>;;;; Return the ceiling of a non negative number.  If the number is
;;;; negative it returns 1.
<span class="ansi38-255165000"
>  (: ceil 
    (-> Number Number))
</span><span class="ansi38-255165000"
>  (= 
    (ceil $n) 
    (fromNat (fromNumber $n)))
</span>;;;; Convert Number to Bool.  Anything above 0 converts to True.
<span class="ansi38-255165000"
>  (: number->bool 
    (-> Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (number->bool $x) 
    (< 0 $x))
</span>;;;; Convert Bool to Number.  False converts to 0, True converts to 1.
<span class="ansi38-255165000"
>  (: bool->number 
    (-> Bool Number))
</span><span class="ansi38-255165000"
>  (= 
    (bool->number False) 0)
</span><span class="ansi38-255165000"
>  (= 
    (bool->number True) 1)
</span>;;;; Define a less than type.  Note that it is purposefully different
;;;; than ⩻ as it is a type, not an operator.  Inhabitants of (⍃ x y)
;;;; are proofs that x ⩻ y == True.  For now ⍃ is only axiomatized for
;;;; Nat.
<span class="ansi38-255165000"
>  (: ⍃ 
    (-> $t $t Type))
</span>;;;; Zero is always less than the successor of something
<span class="ansi38-255165000"
>  (: 
    (zero-lt-succ-axiom) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (zero-lt-succ-axiom) 
    (: ZeroLTSucc 
      (⍃ Z 
        (S $k))))
</span>;;;; If x ⍃ y then (S x) ⍃ (S y)
<span class="ansi38-255165000"
>  (: 
    (succ-monotonicity-rule) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (succ-monotonicity-rule) 
    (: SuccMonotonicity 
      (-> 
        (⍃ $x $y) 
        (⍃ 
          (S $x) 
          (S $y)))))
</span>;;;; Collection of functions operating on numbers
;;;; Define max
<span class="ansi38-255165000"
>  (: max 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (max $x $y) 
    (if 
      (> $x $y) $x $y))
</span>;;;; Define min
<span class="ansi38-255165000"
>  (: min 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (min $x $y) 
    (if 
      (< $x $y) $x $y))
</span>;;;; Clamp a number to be within a certain range
<span class="ansi38-255165000"
>  (: clamp 
    (-> $a $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (clamp $x $l $u) 
    (max $l 
      (min $u $x)))
</span>;;;; Define abs
<span class="ansi38-255165000"
>  (: abs 
    (-> $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (abs $x) 
    (if 
      (< $x 0) 
      (* -1 $x) $x))
</span>;;;; Define <=
<span class="ansi38-255165000"
>  (: <= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (<= $x $y) 
    (or 
      (< $x $y) 
      (== $x $y)))
</span>;;;; Define >=
<span class="ansi38-255165000"
>  (: >= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (>= $x $y) 
    (or 
      (> $x $y) 
      (== $x $y)))
</span>;;;; Define approximately equal
<span class="ansi38-255165000"
>  (: approxEq 
    (-> $a $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (approxEq $x $y $epsilon) 
    (<= 
      (abs (- $x $y)) $epsilon))
</span>;;;; Define Nat
<span class="ansi38-255165000"
>  (: Nat Type)
</span><span class="ansi38-255165000"
>  (: Z Nat)
</span><span class="ansi38-255165000"
>  (: S 
    (-> Nat Nat))
</span>;;;; Define cast functions between Nat and Number
<span class="ansi38-255165000"
>  (: fromNumber 
    (-> Number Nat))
</span><span class="ansi38-255165000"
>  (= 
    (fromNumber $n) 
    (if 
      (<= $n 0) Z 
      (S (fromNumber (- $n 1)))))
</span><span class="ansi38-255165000"
>  (: fromNat 
    (-> Nat Number))
</span><span class="ansi38-255165000"
>  (= 
    (fromNat Z) 0)
</span><span class="ansi38-255165000"
>  (= 
    (fromNat (S $k)) 
    (+ 1 
      (fromNat $k)))
</span>;;;; Define a generic less than operator, ⩻, for Nat.  < cannot be used
;;;; because it is a built-in, its type is hardwired and cannot be
;;;; overloaded.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Nat Nat Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $ Z) False)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ Z 
      (S $)) True)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ 
      (S $x) 
      (S $y)) 
    (⩻ $x $y))
</span>;;;; Overload ⩻ for Number.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Number Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $x $y) 
    (< $x $y))
</span>;;;; Return the ceiling of a non negative number.  If the number is
;;;; negative it returns 1.
<span class="ansi38-255165000"
>  (: ceil 
    (-> Number Number))
</span><span class="ansi38-255165000"
>  (= 
    (ceil $n) 
    (fromNat (fromNumber $n)))
</span>;;;; Convert Number to Bool.  Anything above 0 converts to True.
<span class="ansi38-255165000"
>  (: number->bool 
    (-> Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (number->bool $x) 
    (< 0 $x))
</span>;;;; Convert Bool to Number.  False converts to 0, True converts to 1.
<span class="ansi38-255165000"
>  (: bool->number 
    (-> Bool Number))
</span><span class="ansi38-255165000"
>  (= 
    (bool->number False) 0)
</span><span class="ansi38-255165000"
>  (= 
    (bool->number True) 1)
</span>;;;; Define a less than type.  Note that it is purposefully different
;;;; than ⩻ as it is a type, not an operator.  Inhabitants of (⍃ x y)
;;;; are proofs that x ⩻ y == True.  For now ⍃ is only axiomatized for
;;;; Nat.
<span class="ansi38-255165000"
>  (: ⍃ 
    (-> $t $t Type))
</span>;;;; Zero is always less than the successor of something
<span class="ansi38-255165000"
>  (: 
    (zero-lt-succ-axiom) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (zero-lt-succ-axiom) 
    (: ZeroLTSucc 
      (⍃ Z 
        (S $k))))
</span>;;;; If x ⍃ y then (S x) ⍃ (S y)
<span class="ansi38-255165000"
>  (: 
    (succ-monotonicity-rule) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (succ-monotonicity-rule) 
    (: SuccMonotonicity 
      (-> 
        (⍃ $x $y) 
        (⍃ 
          (S $x) 
          (S $y)))))
</span>
Deterministic: ()
;;;; !(import! &self Unify.metta)
;;;; Enumerate all programs up to a given depth that are consistent with
;;;; the query, using the given axiom non-deterministic functions and rules.
;;;;
;;;; The arguments are:
;;;;
;;;; $query: an Atom under the form (: TERM TYPE).  The atom may contain
;;;;         free variables within TERM and TYPE to form various sort of
;;;;         queries, such as:
;;;;         1. Backward chaining: (: $term (Inheritance $x Mammal))
;;;;         2. Forward chaining: (: ($rule $premise AXIOM) $type)
;;;;         3. Mixed chaining: (: ($rule $premise AXIOM) (Inheritance $x Mammal))
;;;;         4. Type checking: (: TERM TYPE)
;;;;         5. Type inference: (: TERM $type)
;;;;
;;;; $kb: a nullary function to axiom, to non-deterministically pick up
;;;;      an axiom.  An axiom is an Atom of the form (: TERM TYPE).
;;;;
;;;; $rb: a nullary function to rule, to non-deterministically pick up a
;;;;      rule.  A rule is a function mapping premises to conclusion,
;;;;      where premises and conclusion have the form (: TERM TYPE).
;;;;
;;;; $depth: a Nat representing the maximum depth of the generated
;;;;         programs.
;;;;
;;;; TODO: recurse over curried rules instead of duplicating code over
;;;; tuples.
<span class="ansi38-255165000"
>  (: synthesize 
    (-> $a 
      (-> $kt) 
      (-> $rt) Nat $a))
</span>;;;; Nullary rule (axiom)
<span class="ansi38-255165000"
>  (= 
    (synthesize $query $kb $rb $depth) 
    (let $query 
      ($kb) $query))
</span>;;;; Unary rule
<span class="ansi38-255165000"
>  (= 
    (synthesize $query $kb $rb 
      (S $k)) 
    (let* 
      ( ( (: $ructor 
            (-> $premise $conclusion)) ($rb)) 
        ( (: 
            ($ructor $proof) $conclusion) $query) 
        ( (: $proof $premise) (synthesize (: $proof $premise) $kb $rb $k))) $query))
</span>;;;; Binary rule
<span class="ansi38-255165000"
>  (= 
    (synthesize $query $kb $rb 
      (S $k)) 
    (let* 
      ( ( (: $ructor 
            (-> $premise1 $premise2 $conclusion)) ($rb)) 
        ( (: 
            ($ructor $proof1 $proof2) $conclusion) $query) 
        ( (: $proof1 $premise1) (synthesize (: $proof1 $premise1) $kb $rb $k)) 
        ( (: $proof2 $premise2) (synthesize (: $proof2 $premise2) $kb $rb $k))) $query))
</span>;;;; Trinary rule
<span class="ansi38-255165000"
>  (= 
    (synthesize $query $kb $rb 
      (S $k)) 
    (let* 
      ( ( (: $ructor 
            (-> $premise1 $premise2 $premise3 $conclusion)) ($rb)) 
        ( (: 
            ($ructor $proof1 $proof2 $proof3) $conclusion) $query) 
        ( (: $proof1 $premise1) (synthesize (: $proof1 $premise1) $kb $rb $k)) 
        ( (: $proof2 $premise2) (synthesize (: $proof2 $premise2) $kb $rb $k)) 
        ( (: $proof3 $premise3) (synthesize (: $proof3 $premise3) $kb $rb $k))) $query))
</span>;;;; Quaternary rule
<span class="ansi38-255165000"
>  (= 
    (synthesize $query $kb $rb 
      (S $k)) 
    (let* 
      ( ( (: $ructor 
            (-> $premise1 $premise2 $premise3 $premise4 $conclusion)) ($rb)) 
        ( (: 
            ($ructor $proof1 $proof2 $proof3 $proof4) $conclusion) $query) 
        ( (: $proof1 $premise1) (synthesize (: $proof1 $premise1) $kb $rb $k)) 
        ( (: $proof2 $premise2) (synthesize (: $proof2 $premise2) $kb $rb $k)) 
        ( (: $proof3 $premise3) (synthesize (: $proof3 $premise3) $kb $rb $k)) 
        ( (: $proof4 $premise4) (synthesize (: $proof4 $premise4) $kb $rb $k))) $query))
</span>;;;; Quintenary rule
<span class="ansi38-255165000"
>  (= 
    (synthesize $query $kb $rb 
      (S $k)) 
    (let* 
      ( ( (: $ructor 
            (-> $premise1 $premise2 $premise3 $premise4 $premise5 $conclusion)) ($rb)) 
        ( (: 
            ($ructor $proof1 $proof2 $proof3 $proof4 $proof5) $conclusion) $query) 
        ( (: $proof1 $premise1) (synthesize (: $proof1 $premise1) $kb $rb $k)) 
        ( (: $proof2 $premise2) (synthesize (: $proof2 $premise2) $kb $rb $k)) 
        ( (: $proof3 $premise3) (synthesize (: $proof3 $premise3) $kb $rb $k)) 
        ( (: $proof4 $premise4) (synthesize (: $proof4 $premise4) $kb $rb $k)) 
        ( (: $proof5 $premise5) (synthesize (: $proof5 $premise5) $kb $rb $k))) $query))
</span>
Last Result(2): ()
()]
;;;; Knowledge base
<span class="ansi38-255165000"
>  (: kb 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (kb) 
    (superpose ((: P2 (⊷ P (fromNumber 2) True)) (: Q2 (⊷ Q (fromNumber 2) False)) (: P3 (⊷ P (fromNumber 3) True)) (: Q3 (⊷ Q (fromNumber 3) True)) (: P5 (⊷ P (fromNumber 5) False)) (: Q5 (⊷ Q (fromNumber 5) True)) (: P7 (⊷ P (fromNumber 7) True)) (: Q7 (⊷ Q (fromNumber 7) True)))))
</span>;;;; Axioms are placed in the kb as well
<span class="ansi38-255165000"
>  (= 
    (kb) 
    (zero-lt-succ-axiom))
</span>;;;; Rule base
<span class="ansi38-255165000"
>  (: rb 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (rb) 
    (superpose ((succ-monotonicity-rule) (implication-direct-introduction-base-rule) (implication-direct-introduction-recursive-rule))))
</span>;;;; Test base rule (one piece of evidence)
;;;;
;;;; Build the following inference tree
;;;;
;;;; --------(P2)     --------(Q2)
;;;; (P 2) = ⊤        (Q 2) = ⊥
;;;; --------------------------(IDIBase)
;;;; P → Q ≞ ((:: 2 ∅), <0 0.5>)
<span class="ansi38-013099040"
>  !=====

</span>

Deterministic: =====
[=====]
<span class="ansi38-255165000"
>  (: base_prf 
    (≞ 
      (→ P Q) 
      (ETV 
        (:: 
          (fromNumber 2) ∅) 
        (STV 0 
          (count->confidence 1)))))
</span><span class="ansi38-255165000"
>  (= base_prf IDIBase)
</span><span class="ansi38-013099040"
>  !(base_prf)

</span>

Deterministic: (base_prf)
[(base_prf)]
<span class="ansi38-013099040"
>  !(get-type base_prf)

</span>

NDet Result(1): (≞ (→ P Q) (ETV (:: (S (S Z)) ∅) (STV 0 0.5)))[
  (≞ 
    (→ P Q) 
    (ETV 
      (:: 
        (S (S Z)) ∅) 

      (STV 0 0.5)))


Last Result(2): (≞ (→ P Q) (ETV (:: (S (S Z)) ∅) (STV 0 0.5))), 
  (≞ 
    (→ P Q) 
    (ETV 
      (:: 
        (S (S Z)) ∅) 

      (STV 0 0.5)))]
;;;; Test recursive rule
;;;;
;;;; Build the following inference tree
;;;;
;;;;                 --------(P2)     --------(Q2)
;;;;                 (P 2) = ⊤        (Q 2) = ⊥
;;;;                 --------------------------(IDIBase)
;;;;                 P → Q ≞ ((:: 2 ∅), <0 0.5>)
;;;;                              |               -----(ZeroLTSucc)
;;;;                              |               0 ⍃ 5
;;;;                              |               -----(SuccMonotonicity)
;;;;                              |               1 ⍃ 6
;;;; --------(P7)  --------(Q7)   |               -----(SuccMonotonicity)
;;;; (P 7) = ⊤     (Q 7) = ⊤      |               2 ⍃ 7
;;;; --------------------------------------------------(IDIRecursive)
;;;;           P → Q ≞ ((:: 7 (:: 2 ∅)), <0.5 0.6667>)
<span class="ansi38-013099040"
>  !=====

</span>

Deterministic: =====
[=====]
<span class="ansi38-255165000"
>  (: recursive_prf 
    (≞ 
      (→ P Q) $etv))
</span><span class="ansi38-255165000"
>  (= recursive_prf 
    (IDIRecursive P7 Q7 
      (IDIBase P2 Q2) 
      (SuccMonotonicity (SuccMonotonicity ZeroLTSucc))))
</span><span class="ansi38-013099040"
>  !(recursive_prf)

</span>

Deterministic: (recursive_prf)
[(recursive_prf)]
<span class="ansi38-013099040"
>  !(get-type recursive_prf)

</span>

Deterministic: (≞ (→ P Q) $_143808)[
  (≞ 

    (→ P Q) $_143808)]
;;;; Test synthesizer
<span class="ansi38-013099040"
>  !=====

</span>

Deterministic: =====
[=====]
<span class="ansi38-013099040"
>  !(synthesize 
    (: $proof 
      (⍃ 
        (fromNumber 2) 
        (fromNumber 7))) kb rb 
    (fromNumber 2))

</span>

NDet Result(1): (: (SuccMonotonicity (SuccMonotonicity ZeroLTSucc)) (⍃ (S (S Z)) (S (S (S (S (S (S (S Z)))))))))[
  (: 
    (SuccMonotonicity (SuccMonotonicity ZeroLTSucc)) 
    (⍃ 
      (S (S Z)) 

$proof = 
  (SuccMonotonicity (SuccMonotonicity ZeroLTSucc))
      (S (S (S (S (S (S (S Z)))))))))
]
<span class="ansi38-013099040"
>  !=====

</span>

Deterministic: =====
[=====]
<span class="ansi38-013099040"
>  !(synthesize 
    (: $proof 
      (⍃ 
        (fromNumber 2) 
        (fromNumber 3))) kb rb 
    (fromNumber 2))

</span>

NDet Result(1): (: (SuccMonotonicity (SuccMonotonicity ZeroLTSucc)) (⍃ (S (S Z)) (S (S (S Z)))))[
  (: 
    (SuccMonotonicity (SuccMonotonicity ZeroLTSucc)) 
    (⍃ 
      (S (S Z)) 

$proof = 
  (SuccMonotonicity (SuccMonotonicity ZeroLTSucc))
      (S (S (S Z)))))
]
<span class="ansi38-013099040"
>  !=====

</span>

Deterministic: =====
[=====]
<span class="ansi38-013099040"
>  !(synthesize 
    (: $proof 
      (⍃ 
        (fromNumber 3) 
        (fromNumber 7))) kb rb 
    (fromNumber 3))

</span>

NDet Result(1): (: (SuccMonotonicity (SuccMonotonicity (SuccMonotonicity ZeroLTSucc))) (⍃ (S (S (S Z))) (S (S (S (S (S (S (S Z)))))))))[
  (: 
    (SuccMonotonicity (SuccMonotonicity (SuccMonotonicity ZeroLTSucc))) 
    (⍃ 
      (S (S (S Z))) 

$proof = 
  (SuccMonotonicity (SuccMonotonicity (SuccMonotonicity ZeroLTSucc)))
      (S (S (S (S (S (S (S Z)))))))))
]
;;;; Prove that P→Q using only base rule with only one piece of evidence
<span class="ansi38-013099040"
>  !=====

</span>

Deterministic: =====
[=====]
<span class="ansi38-013099040"
>  !(synthesize 
    (: $proof 
      (≞ 
        (→ P Q) $etv)) kb rb 
    (fromNumber 1))

</span>

NDet Result(1): (: (IDIBase P2 Q2) (≞ (→ P Q) (ETV (:: (S (S Z)) ∅) (STV 0 0.5))))[
  (: 
    (IDIBase P2 Q2) 
    (≞ 
      (→ P Q) 
      (ETV 
        (:: 
          (S (S Z)) ∅) 

$proof = (IDIBase P2 Q2)
$etv = 
  (ETV 
    (:: 
      (S (S Z)) ∅) 
    (direct-introduction-base-formula False))
        (STV 0 0.5))))


NDet Result(2): (: (IDIBase P2 Q2) (≞ (→ P Q) (ETV (:: (S (S Z)) ∅) (STV 0 0.5)))), 
  (: 
    (IDIBase P2 Q2) 
    (≞ 
      (→ P Q) 
      (ETV 
        (:: 
          (S (S Z)) ∅) 

$proof = (IDIBase P2 Q2)
$etv = 
  (ETV 
    (:: 
      (S (S Z)) ∅) 
    (direct-introduction-base-formula False))
        (STV 0 0.5))))


NDet Result(3): (: (IDIBase P3 Q3) (≞ (→ P Q) (ETV (:: (S (S (S Z))) ∅) (STV 1 0.5)))), 
  (: 
    (IDIBase P3 Q3) 
    (≞ 
      (→ P Q) 
      (ETV 
        (:: 
          (S (S (S Z))) ∅) 

$proof = (IDIBase P3 Q3)
$etv = 
  (ETV 
    (:: 
      (S (S (S Z))) ∅) 
    (direct-introduction-base-formula True))
        (STV 1 0.5))))


NDet Result(4): (: (IDIBase P3 Q3) (≞ (→ P Q) (ETV (:: (S (S (S Z))) ∅) (STV 1 0.5)))), 
  (: 
    (IDIBase P3 Q3) 
    (≞ 
      (→ P Q) 
      (ETV 
        (:: 
          (S (S (S Z))) ∅) 

$proof = (IDIBase P3 Q3)
$etv = 
  (ETV 
    (:: 
      (S (S (S Z))) ∅) 
    (direct-introduction-base-formula True))
        (STV 1 0.5))))


NDet Result(5): (: (IDIBase P7 Q7) (≞ (→ P Q) (ETV (:: (S (S (S (S (S (S (S Z))))))) ∅) (STV 1 0.5)))), 
  (: 
    (IDIBase P7 Q7) 
    (≞ 
      (→ P Q) 
      (ETV 
        (:: 
          (S (S (S (S (S (S (S Z))))))) ∅) 

$proof = (IDIBase P7 Q7)
$etv = 
  (ETV 
    (:: 
      (S (S (S (S (S (S (S Z))))))) ∅) 
    (direct-introduction-base-formula True))
        (STV 1 0.5))))


NDet Result(6): (: (IDIBase P7 Q7) (≞ (→ P Q) (ETV (:: (S (S (S (S (S (S (S Z))))))) ∅) (STV 1 0.5)))), 
  (: 
    (IDIBase P7 Q7) 
    (≞ 
      (→ P Q) 
      (ETV 
        (:: 
          (S (S (S (S (S (S (S Z))))))) ∅) 

$proof = (IDIBase P7 Q7)
$etv = 
  (ETV 
    (:: 
      (S (S (S (S (S (S (S Z))))))) ∅) 
    (direct-introduction-base-formula True))
        (STV 1 0.5))))
]
;;;; Prove that P→Q using one, two and three pieces of evidence.
;;;;
;;;; The synthesizer should build proof trees using one, two and
;;;; ultimate three pieces of evidence.  The proof tree using three
;;;; pieces of evidences is displayed below:
;;;;
;;;;                                                                                                ----(ZeroLTSucc)        ----(ZeroLTSucc)
;;;;                                                                                                0 ⍃ 1                   0 ⍃ 4
;;;;                                                            --------(P2)     --------(Q2)       ----(SuccMonotonicity)  ----(SuccMonotonicity)
;;;;                                                            (P 2) = ⊤        (Q 2) = ⊥          1 ⍃ 2                   1 ⍃ 5
;;;;                             --------(P3)     --------(Q3)  -------------------------(IDIBase)  ----(SuccMonotonicity)  ----(SuccMonotonicity)
;;;;                             (P 3) = ⊤        (Q 3) = ⊥     P → Q ≞ (:: 2 ∅), <0 0.5>)          2 ⍃ 3                   2 ⍃ 6
;;;; --------(P7)  --------(Q7)  -----------------------------------------------------------------------(IDIRecursive)      ----(SuccMonotonicity)
;;;; (P 7) = ⊤     (Q 7) = ⊤              P → Q ≞ ((:: 3 (:: 2 ∅)), <0.5 0.6666666666666666>)                                       3 ⍃ 7
;;;; ---------------------------------------------------------------------------------------------------------------------------(IDIRecursive)
;;;;                                  P → Q ≞ ((:: 7 (:: 5 (:: 2 ∅))), <0.6666666666666666 0.75>)
;;;;
;;;; Or, in MeTTa format
;;;;
;;;; (: (IDIRecursive
;;;;      P7
;;;;      Q7
;;;;      (IDIRecursive
;;;;        P3
;;;;        Q3
;;;;        (IDIBase P2 Q2)
;;;;        (SuccMonotonicity (SuccMonotonicity ZeroLTSucc)))
;;;;      (SuccMonotonicity (SuccMonotonicity (SuccMonotonicity ZeroLTSucc))))
;;;;    (≞ (→ P Q)
;;;;       (ETV (:: (S (S (S (S (S (S (S Z))))))) (:: (S (S (S Z))) (:: (S (S Z)) ∅)))
;;;;            (STV 0.6666666666666666 0.75))))
<span class="ansi38-013099040"
>  !=====

</span>

Deterministic: =====
[=====]
<span class="ansi38-013099040"
>  !(synthesize 
    (: $proof 
      (≞ 
        (→ P Q) $etv)) kb rb 
    (fromNumber 4))

</span>

NDet Result(1): (: (IDIBase P2 Q2) (≞ (→ P Q) (ETV (:: (S (S Z)) ∅) (STV 0 0.5))))[
  (: 
    (IDIBase P2 Q2) 
    (≞ 
      (→ P Q) 
      (ETV 
        (:: 
          (S (S Z)) ∅) 

$proof = (IDIBase P2 Q2)
$etv = 
  (ETV 
    (:: 
      (S (S Z)) ∅) 
    (direct-introduction-base-formula False))
        (STV 0 0.5))))


NDet Result(2): (: (IDIBase P2 Q2) (≞ (→ P Q) (ETV (:: (S (S Z)) ∅) (STV 0 0.5)))), 
  (: 
    (IDIBase P2 Q2) 
    (≞ 
      (→ P Q) 
      (ETV 
        (:: 
          (S (S Z)) ∅) 

$proof = (IDIBase P2 Q2)
$etv = 
  (ETV 
    (:: 
      (S (S Z)) ∅) 
    (direct-introduction-base-formula False))
        (STV 0 0.5))))


NDet Result(3): (: (IDIBase P3 Q3) (≞ (→ P Q) (ETV (:: (S (S (S Z))) ∅) (STV 1 0.5)))), 
  (: 
    (IDIBase P3 Q3) 
    (≞ 
      (→ P Q) 
      (ETV 
        (:: 
          (S (S (S Z))) ∅) 

$proof = (IDIBase P3 Q3)
$etv = 
  (ETV 
    (:: 
      (S (S (S Z))) ∅) 
    (direct-introduction-base-formula True))
        (STV 1 0.5))))


NDet Result(4): (: (IDIBase P3 Q3) (≞ (→ P Q) (ETV (:: (S (S (S Z))) ∅) (STV 1 0.5)))), 
  (: 
    (IDIBase P3 Q3) 
    (≞ 
      (→ P Q) 
      (ETV 
        (:: 
          (S (S (S Z))) ∅) 

$proof = (IDIBase P3 Q3)
$etv = 
  (ETV 
    (:: 
      (S (S (S Z))) ∅) 
    (direct-introduction-base-formula True))
        (STV 1 0.5))))


NDet Result(5): (: (IDIBase P7 Q7) (≞ (→ P Q) (ETV (:: (S (S (S (S (S (S (S Z))))))) ∅) (STV 1 0.5)))), 
  (: 
    (IDIBase P7 Q7) 
    (≞ 
      (→ P Q) 
      (ETV 
        (:: 
          (S (S (S (S (S (S (S Z))))))) ∅) 

$proof = (IDIBase P7 Q7)
$etv = 
  (ETV 
    (:: 
      (S (S (S (S (S (S (S Z))))))) ∅) 
    (direct-introduction-base-formula True))
        (STV 1 0.5))))


NDet Result(6): (: (IDIBase P7 Q7) (≞ (→ P Q) (ETV (:: (S (S (S (S (S (S (S Z))))))) ∅) (STV 1 0.5)))), 
  (: 
    (IDIBase P7 Q7) 
    (≞ 
      (→ P Q) 
      (ETV 
        (:: 
          (S (S (S (S (S (S (S Z))))))) ∅) 

$proof = (IDIBase P7 Q7)
$etv = 
  (ETV 
    (:: 
      (S (S (S (S (S (S (S Z))))))) ∅) 
    (direct-introduction-base-formula True))
        (STV 1 0.5))))
]
<span class="ansi32"
>% 185,440,773 inferences, 32.861 CPU in 32.863 seconds (100% CPU, 5643159 Lips)
</span>P;HTML|
;                         (= /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/dependent-types/ImplicationDirectIntroductionDTLTest.metta  0)
<br/> <a href="#" onclick="window.history.back(); return false;"
>Return to summaries</a><br/>
P;HTML|
;           (is_cmd_option  execute halt --halt=true true)
P;HTML|
;            (set_option_value  halt true)
P;HTML|
;            (is_cmd_option  execute stdin --stdin=tty tty)
P;HTML|
;            (set_option_value  stdin tty)
P;HTML|
;            (is_cmd_option  execute stdout --stdout=tty tty)
P;HTML|
;             (set_option_value  stdout tty)
P;HTML|
;            (is_cmd_option  execute stderr --stderr=tty tty)
P;HTML|
;             (set_option_value  stderr tty)
P;HTML|
;           (set_option_value  prolog false)
P;HTML|
;           (set_option_value  compat auto)
P;HTML|
;           (set_option_value  compatio true)

Script done on 2024-09-20 01:14:48+00:00 [COMMAND_EXIT_CODE="7"]

</pre>
</body>

</html>
\033[0;32mCompleted successfully (EXITCODE=7) Under 40 seconds: ./mettalog '--output=./reports/tests_output/baseline-compat-2024-09-20T00:33:03/' --timeout=40 --html --repl=false  --test "tests/extended_compat/hyperon-pln/metta/dependent-types/ImplicationDirectIntroductionDTLTest.metta" --halt=true\033[0m

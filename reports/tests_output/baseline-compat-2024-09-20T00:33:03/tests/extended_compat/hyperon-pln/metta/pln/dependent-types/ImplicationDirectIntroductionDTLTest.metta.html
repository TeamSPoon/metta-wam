<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"
>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"
>
<title></title>
<style type="text/css"
>
.ansi2html-content { display: inline; white-space: pre-wrap; word-wrap: break-word; }
.body_foreground { color: #AAAAAA; }
.body_background { background-color: #000000; }
.inv_foreground { color: #000000; }
.inv_background { background-color: #AAAAAA; }
.ansi1 { font-weight: bold; }
.ansi31 { color: #aa0000; }
.ansi36 { color: #00aaaa; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165009 { color: #FFA509; }
.ansi38-255238088 { color: #FFEE58; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165009 { color: #FFA509; }
.ansi38-255238088 { color: #FFEE58; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165009 { color: #FFA509; }
.ansi38-255238088 { color: #FFEE58; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165009 { color: #FFA509; }
.ansi38-255238088 { color: #FFEE58; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165009 { color: #FFA509; }
.ansi38-255238088 { color: #FFEE58; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165009 { color: #FFA509; }
.ansi38-255238088 { color: #FFEE58; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165009 { color: #FFA509; }
.ansi38-255238088 { color: #FFEE58; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165009 { color: #FFA509; }
.ansi38-255238088 { color: #FFEE58; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165009 { color: #FFA509; }
.ansi38-255238088 { color: #FFEE58; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165009 { color: #FFA509; }
.ansi38-255238088 { color: #FFEE58; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165009 { color: #FFA509; }
.ansi38-255238088 { color: #FFEE58; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165009 { color: #FFA509; }
.ansi38-255238088 { color: #FFEE58; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165009 { color: #FFA509; }
.ansi38-255238088 { color: #FFEE58; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165009 { color: #FFA509; }
.ansi38-255238088 { color: #FFEE58; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165009 { color: #FFA509; }
.ansi38-255238088 { color: #FFEE58; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165009 { color: #FFA509; }
.ansi38-255238088 { color: #FFEE58; }
.ansi38-013099040 { color: #0D6328; }
</style>
</head>
<body class="body_foreground body_background" style="font-size: normal;" >
<pre class="ansi2html-content"
>
Script started on 2024-09-20 01:19:49+00:00 [TERM="xterm-256color" TTY="/dev/pts/0" COLUMNS="-1" LINES="-1"]
P;HTML|
;           (set_option_value  prolog false)

P;HTML|
;           (set_option_value  compat auto)

P;HTML|
;           (set_option_value  compatio true)
P;HTML|
;            (is_cmd_option  prescan halt --halt=true true)
P;HTML|
;            (set_option_value  halt true)
P;HTML|
;            (is_cmd_option  prescan stdin --stdin=tty tty)
P;HTML|
;             (set_option_value  stdin tty)
P;HTML|
;            (is_cmd_option  prescan stdout --stdout=tty tty)
P;HTML|
;             (set_option_value  stdout tty)
P;HTML|
;            (is_cmd_option  prescan stderr --stderr=tty tty)
P;HTML|
;             (set_option_value  stderr tty)
P;HTML|
;            (set_option_value  prolog false)
P;HTML|
;            (set_option_value  compat auto)
P;HTML|
;            (set_option_value  compatio true)
P;HTML|
;          (is_cmd_option  execute python --python=enable enable)
P;HTML|
;           (set_option_value  python enable)
P;HTML|
;          (is_cmd_option  execute timeout --timeout=40 40)
P;HTML|
;           (set_option_value  timeout 40)
P;HTML|
;           (is_cmd_option  execute output --output=./reports/tests_output/baseline-compat-2024-09-20T00:33:03/ ./reports/tests_output/baseline-compat-2024-09-20T00:33:03/)
P;HTML|
;           (set_option_value  output ./reports/tests_output/baseline-compat-2024-09-20T00:33:03/)
P;HTML|
;           (is_cmd_option  execute html --html true)
P;HTML|
;            (set_option_value  html true)
P;HTML|
;           (is_cmd_option  execute test --test true)
P;HTML|
;            (set_option_value  test true)

; (load_metta_file  &self tests/extended_compat/hyperon-pln/metta/pln/dependent-types/ImplicationDirectIntroductionDTLTest.metta)
P;HTML|
;                         (track_load_into_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/pln/dependent-types/ImplicationDirectIntroductionDTLTest.metta)
P;HTML|
;                                          (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/pln/dependent-types/ImplicationDirectIntroductionDTLTest.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/pln/dependent-types/ImplicationDirectIntroductionDTLTest.metta)
P;HTML|
;                                           (= 1  "Doing: timeout --foreground --kill-after=5 --signal=SIGINT 61 time metta /opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/hyperon-wam/reports/extended_compat/hyperon-pln/metta/pln/dependent-types/ImplicationDirectIntroductionDTLTest.metta")
P;HTML|
;                                           (= 1  "[()]")
P;HTML|
;                                           (= 2  "[()]")
P;HTML|
;                                           (= 3  "[\"===== Test base rule (built-in type checker) =====\"]")
P;HTML|
;                                           (= 4  "[(base_prf)]")
P;HTML|
;                                           (= 5  "[(≞ (→ P Q) (ETV (:: (S (S Z)) ∅) (STV 0 0.5)))]")
P;HTML|
;                                           (= 6  "[\"===== Test recursive rule (built-in type checker) =====\"]")
P;HTML|
;                                           (= 7  "[(recursive_prf)]")
P;HTML|
;                                           (= 8  "[(≞ (→ P Q) $etv#923)]")
P;HTML|
;                                           (= 9  "[\"===== Prove that 2 < 7 (synthesizer) =====\"]")
P;HTML|
;                                           (= 10  "[(: (SuccMonotonicity (SuccMonotonicity ZeroLTSucc)) (⍃ (S (S Z)) (S (S (S (S (S (S (S Z)))))))))]")
P;HTML|
;                                           (= 11  "[\"===== Prove that 2 < 3 (synthesizer) =====\"]")
P;HTML|
;                                           (= 12  "[(: (SuccMonotonicity (SuccMonotonicity ZeroLTSucc)) (⍃ (S (S Z)) (S (S (S Z)))))]")
P;HTML|
;                                           (= 13  "[\"===== Prove that 5 < 7 (synthesizer) =====\"]")
P;HTML|
;                                           (= 14  "[(: (SuccMonotonicity (SuccMonotonicity (SuccMonotonicity ZeroLTSucc))) (⍃ (S (S (S Z))) (S (S (S (S (S (S (S Z)))))))))]")
P;HTML|
;                                           (= 15  "[\"===== Prove P→Q using base rule (synthesizer) =====\"]")
P;HTML|
;                                           (= 16  "[(let* (((: $proof2#26359 (⊷ Q (S (S Z)) True)) (synthesize (: $proof2#26359 (⊷ Q (S (S Z)) True)) kb rb Z)) ((: $proof3#26360 (≞ (→ P Q) (ETV (:: $h#26365 $t#26366) (STV $s#26367 $conf#26368)))) (synthesize (: $proof3#26360 (≞ (→ P Q) (ETV (:: $h#26365 $t#26366) (STV $s#26367 $conf#26368)))) kb rb Z)) ((: $proof4#26361 (⍃ $h#26365 (S (S Z)))) (synthesize (: $proof4#26361 (⍃ $h#26365 (S (S Z)))) kb rb Z))) (: (IDIRecursive P2 $proof2#26359 $proof3#26360 $proof4#26361) (≞ (→ P Q) (ETV (:: (S (S Z)) (:: $h#26365 $t#26366)) (STV (/ (+ (* $s#26367 (if (<= (if (< (- 1.0 $conf#26368) 0) (* -1 (- 1.0 $conf#26368)) (- 1.0 $conf#26368)) 1e-09) (max-count) (/ (* $conf#26368 (lookahead)) (- 1.0 $conf#26368)))) 1) (+ (if (<= (if (< (- 1.0 $conf#26368) 0) (* -1 (- 1.0 $conf#26368)) (- 1.0 $conf#26368)) 1e-09) (max-count) (/ (* $conf#26368 (lookahead)) (- 1.0 $conf#26368))) 1)) (/ (+ (if (<= (if (< (- 1.0 $conf#26368) 0) (* -1 (- 1.0 $conf#26368)) (- 1.0 $conf#26368)) 1e-09) (max-count) (/ (* $conf#26368 (lookahead)) (- 1.0 $conf#26368))) 1) (+ (+ (if (<= (if (< (- 1.0 $conf#26368) 0) (* -1 (- 1.0 $conf#26368)) (- 1.0 $conf#26368)) 1e-09) (max-count) (/ (* $conf#26368 (lookahead)) (- 1.0 $conf#26368))) 1) 1.0))))))), (let* (((: $proof3#26360 (≞ (→ P Q) (ETV (:: $h#26365 $t#26366) (STV $s#26367 $conf#26368)))) (synthesize (: $proof3#26360 (≞ (→ P Q) (ETV (:: $h#26365 $t#26366) (STV $s#26367 $conf#26368)))) kb rb Z)) ((: $proof4#26361 (⍃ $h#26365 (S (S (S Z))))) (synthesize (: $proof4#26361 (⍃ $h#26365 (S (S (S Z))))) kb rb Z))) (: (IDIRecursive P3 Q3 $proof3#26360 $proof4#26361) (≞ (→ P Q) (ETV (:: (S (S (S Z))) (:: $h#26365 $t#26366)) (STV (/ (+ (* $s#26367 (if (<= (if (< (- 1.0 $conf#26368) 0) (* -1 (- 1.0 $conf#26368)) (- 1.0 $conf#26368)) 1e-09) (max-count) (/ (* $conf#26368 (lookahead)) (- 1.0 $conf#26368)))) 1) (+ (if (<= (if (< (- 1.0 $conf#26368) 0) (* -1 (- 1.0 $conf#26368)) (- 1.0 $conf#26368)) 1e-09) (max-count) (/ (* $conf#26368 (lookahead)) (- 1.0 $conf#26368))) 1)) (/ (+ (if (<= (if (< (- 1.0 $conf#26368) 0) (* -1 (- 1.0 $conf#26368)) (- 1.0 $conf#26368)) 1e-09) (max-count) (/ (* $conf#26368 (lookahead)) (- 1.0 $conf#26368))) 1) (+ (+ (if (<= (if (< (- 1.0 $conf#26368) 0) (* -1 (- 1.0 $conf#26368)) (- 1.0 $conf#26368)) 1e-09) (max-count) (/ (* $conf#26368 (lookahead)) (- 1.0 $conf#26368))) 1) 1.0))))))), (let* (((: $proof3#26360 (≞ (→ P Q) (ETV (:: $h#26365 $t#26366) (STV $s#26367 $conf#26368)))) (synthesize (: $proof3#26360 (≞ (→ P Q) (ETV (:: $h#26365 $t#26366) (STV $s#26367 $conf#26368)))) kb rb Z)) ((: $proof4#26361 (⍃ $h#26365 (S (S (S (S (S (S (S Z))))))))) (synthesize (: $proof4#26361 (⍃ $h#26365 (S (S (S (S (S (S (S Z))))))))) kb rb Z))) (: (IDIRecursive P7 Q7 $proof3#26360 $proof4#26361) (≞ (→ P Q) (ETV (:: (S (S (S (S (S (S (S Z))))))) (:: $h#26365 $t#26366)) (STV (/ (+ (* $s#26367 (if (<= (if (< (- 1.0 $conf#26368) 0) (* -1 (- 1.0 $conf#26368)) (- 1.0 $conf#26368)) 1e-09) (max-count) (/ (* $conf#26368 (lookahead)) (- 1.0 $conf#26368)))) 1) (+ (if (<= (if (< (- 1.0 $conf#26368) 0) (* -1 (- 1.0 $conf#26368)) (- 1.0 $conf#26368)) 1e-09) (max-count) (/ (* $conf#26368 (lookahead)) (- 1.0 $conf#26368))) 1)) (/ (+ (if (<= (if (< (- 1.0 $conf#26368) 0) (* -1 (- 1.0 $conf#26368)) (- 1.0 $conf#26368)) 1e-09) (max-count) (/ (* $conf#26368 (lookahead)) (- 1.0 $conf#26368))) 1) (+ (+ (if (<= (if (< (- 1.0 $conf#26368) 0) (* -1 (- 1.0 $conf#26368)) (- 1.0 $conf#26368)) 1e-09) (max-count) (/ (* $conf#26368 (lookahead)) (- 1.0 $conf#26368))) 1) 1.0))))))), (let* (((: $proof3#27352 (≞ (→ P Q) (ETV (:: $h#27357 $t#27358) (STV $PQs#27359 $PQc#27360)))) (synthesize (: $proof3#27352 (≞ (→ P Q) (ETV (:: $h#27357 $t#27358) (STV $PQs#27359 $PQc#27360)))) kb rb Z)) ((: $proof4#27353 (⍃ $h#27357 (S (S Z)))) (synthesize (: $proof4#27353 (⍃ $h#27357 (S (S Z)))) kb rb Z))) (: (IDIRecursive P2 Q2 $proof3#27352 $proof4#27353) (≞ (→ P Q) (ETV (:: (S (S Z)) (:: $h#27357 $t#27358)) (STV (/ (* $PQs#27359 (if (<= (if (< (- 1.0 $PQc#27360) 0) (* -1 (- 1.0 $PQc#27360)) (- 1.0 $PQc#27360)) 1e-09) (max-count) (/ (* $PQc#27360 (lookahead)) (- 1.0 $PQc#27360)))) (+ (if (<= (if (< (- 1.0 $PQc#27360) 0) (* -1 (- 1.0 $PQc#27360)) (- 1.0 $PQc#27360)) 1e-09) (max-count) (/ (* $PQc#27360 (lookahead)) (- 1.0 $PQc#27360))) 1)) (/ (+ (if (<= (if (< (- 1.0 $PQc#27360) 0) (* -1 (- 1.0 $PQc#27360)) (- 1.0 $PQc#27360)) 1e-09) (max-count) (/ (* $PQc#27360 (lookahead)) (- 1.0 $PQc#27360))) 1) (+ (+ (if (<= (if (< (- 1.0 $PQc#27360) 0) (* -1 (- 1.0 $PQc#27360)) (- 1.0 $PQc#27360)) 1e-09) (max-count) (/ (* $PQc#27360 (lookahead)) (- 1.0 $PQc#27360))) 1) 1.0))))))), (let* (((: $proof2#27351 (⊷ Q (S (S (S Z))) False)) (synthesize (: $proof2#27351 (⊷ Q (S (S (S Z))) False)) kb rb Z)) ((: $proof3#27352 (≞ (→ P Q) (ETV (:: $h#27357 $t#27358) (STV $PQs#27359 $PQc#27360)))) (synthesize (: $proof3#27352 (≞ (→ P Q) (ETV (:: $h#27357 $t#27358) (STV $PQs#27359 $PQc#27360)))) kb rb Z)) ((: $proof4#27353 (⍃ $h#27357 (S (S (S Z))))) (synthesize (: $proof4#27353 (⍃ $h#27357 (S (S (S Z))))) kb rb Z))) (: (IDIRecursive P3 $proof2#27351 $proof3#27352 $proof4#27353) (≞ (→ P Q) (ETV (:: (S (S (S Z))) (:: $h#27357 $t#27358)) (STV (/ (* $PQs#27359 (if (<= (if (< (- 1.0 $PQc#27360) 0) (* -1 (- 1.0 $PQc#27360)) (- 1.0 $PQc#27360)) 1e-09) (max-count) (/ (* $PQc#27360 (lookahead)) (- 1.0 $PQc#27360)))) (+ (if (<= (if (< (- 1.0 $PQc#27360) 0) (* -1 (- 1.0 $PQc#27360)) (- 1.0 $PQc#27360)) 1e-09) (max-count) (/ (* $PQc#27360 (lookahead)) (- 1.0 $PQc#27360))) 1)) (/ (+ (if (<= (if (< (- 1.0 $PQc#27360) 0) (* -1 (- 1.0 $PQc#27360)) (- 1.0 $PQc#27360)) 1e-09) (max-count) (/ (* $PQc#27360 (lookahead)) (- 1.0 $PQc#27360))) 1) (+ (+ (if (<= (if (< (- 1.0 $PQc#27360) 0) (* -1 (- 1.0 $PQc#27360)) (- 1.0 $PQc#27360)) 1e-09) (max-count) (/ (* $PQc#27360 (lookahead)) (- 1.0 $PQc#27360))) 1) 1.0))))))), (let* (((: $proof2#27351 (⊷ Q (S (S (S (S (S (S (S Z))))))) False)) (synthesize (: $proof2#27351 (⊷ Q (S (S (S (S (S (S (S Z))))))) False)) kb rb Z)) ((: $proof3#27352 (≞ (→ P Q) (ETV (:: $h#27357 $t#27358) (STV $PQs#27359 $PQc#27360)))) (synthesize (: $proof3#27352 (≞ (→ P Q) (ETV (:: $h#27357 $t#27358) (STV $PQs#27359 $PQc#27360)))) kb rb Z)) ((: $proof4#27353 (⍃ $h#27357 (S (S (S (S (S (S (S Z))))))))) (synthesize (: $proof4#27353 (⍃ $h#27357 (S (S (S (S (S (S (S Z))))))))) kb rb Z))) (: (IDIRecursive P7 $proof2#27351 $proof3#27352 $proof4#27353) (≞ (→ P Q) (ETV (:: (S (S (S (S (S (S (S Z))))))) (:: $h#27357 $t#27358)) (STV (/ (* $PQs#27359 (if (<= (if (< (- 1.0 $PQc#27360) 0) (* -1 (- 1.0 $PQc#27360)) (- 1.0 $PQc#27360)) 1e-09) (max-count) (/ (* $PQc#27360 (lookahead)) (- 1.0 $PQc#27360)))) (+ (if (<= (if (< (- 1.0 $PQc#27360) 0) (* -1 (- 1.0 $PQc#27360)) (- 1.0 $PQc#27360)) 1e-09) (max-count) (/ (* $PQc#27360 (lookahead)) (- 1.0 $PQc#27360))) 1)) (/ (+ (if (<= (if (< (- 1.0 $PQc#27360) 0) (* -1 (- 1.0 $PQc#27360)) (- 1.0 $PQc#27360)) 1e-09) (max-count) (/ (* $PQc#27360 (lookahead)) (- 1.0 $PQc#27360))) 1) (+ (+ (if (<= (if (< (- 1.0 $PQc#27360) 0) (* -1 (- 1.0 $PQc#27360)) (- 1.0 $PQc#27360)) 1e-09) (max-count) (/ (* $PQc#27360 (lookahead)) (- 1.0 $PQc#27360))) 1) 1.0))))))), (: (IDIBase P2 Q2) (≞ (→ P Q) (ETV (:: (S (S Z)) ∅) (STV 0 0.5)))), (let* (((: $proof2#28198 (⊷ Q (S (S (S Z))) False)) (synthesize (: $proof2#28198 (⊷ Q (S (S (S Z))) False)) kb rb Z))) (: (IDIBase P3 $proof2#28198) (≞ (→ P Q) (ETV (:: (S (S (S Z))) ∅) (STV 0 0.5))))), (let* (((: $proof2#28198 (⊷ Q (S (S (S (S (S (S (S Z))))))) False)) (synthesize (: $proof2#28198 (⊷ Q (S (S (S (S (S (S (S Z))))))) False)) kb rb Z))) (: (IDIBase P7 $proof2#28198) (≞ (→ P Q) (ETV (:: (S (S (S (S (S (S (S Z))))))) ∅) (STV 0 0.5))))), (let* (((: $proof2#28961 (⊷ Q (S (S Z)) True)) (synthesize (: $proof2#28961 (⊷ Q (S (S Z)) True)) kb rb Z))) (: (IDIBase P2 $proof2#28961) (≞ (→ P Q) (ETV (:: (S (S Z)) ∅) (STV 1 0.5))))), (: (IDIBase P3 Q3) (≞ (→ P Q) (ETV (:: (S (S (S Z))) ∅) (STV 1 0.5)))), (: (IDIBase P7 Q7) (≞ (→ P Q) (ETV (:: (S (S (S (S (S (S (S Z))))))) ∅) (STV 1 0.5))))]")
P;HTML|
;                                           (= 17  "[\"===== Prove P→Q using base, recursive and order rules (synthesizer) =====\"]")
P;HTML|
;                                           (= 18  "[(let* (((: $proof2#34807 (⊷ Q (S (S Z)) True)) (synthesize (: $proof2#34807 (⊷ Q (S (S Z)) True)) kb rb (S (S (S Z))))) ((: $proof3#34808 (≞ (→ P Q) (ETV (:: $h#34813 $t#34814) (STV $s#34815 $c#34816)))) (synthesize (: $proof3#34808 (≞ (→ P Q) (ETV (:: $h#34813 $t#34814) (STV $s#34815 $c#34816)))) kb rb (S (S (S Z))))) ((: $proof4#34809 (⍃ $h#34813 (S (S Z)))) (synthesize (: $proof4#34809 (⍃ $h#34813 (S (S Z)))) kb rb (S (S (S Z)))))) (: (IDIRecursive P2 $proof2#34807 $proof3#34808 $proof4#34809) (≞ (→ P Q) (ETV (:: (S (S Z)) (:: $h#34813 $t#34814)) (STV (/ (+ (* $s#34815 (if (<= (if (< (- 1.0 $c#34816) 0) (* -1 (- 1.0 $c#34816)) (- 1.0 $c#34816)) 1e-09) (max-count) (/ (* $c#34816 (lookahead)) (- 1.0 $c#34816)))) 1) (+ (if (<= (if (< (- 1.0 $c#34816) 0) (* -1 (- 1.0 $c#34816)) (- 1.0 $c#34816)) 1e-09) (max-count) (/ (* $c#34816 (lookahead)) (- 1.0 $c#34816))) 1)) (/ (+ (if (<= (if (< (- 1.0 $c#34816) 0) (* -1 (- 1.0 $c#34816)) (- 1.0 $c#34816)) 1e-09) (max-count) (/ (* $c#34816 (lookahead)) (- 1.0 $c#34816))) 1) (+ (+ (if (<= (if (< (- 1.0 $c#34816) 0) (* -1 (- 1.0 $c#34816)) (- 1.0 $c#34816)) 1e-09) (max-count) (/ (* $c#34816 (lookahead)) (- 1.0 $c#34816))) 1) 1.0))))))), (: (IDIRecursive P3 Q3 (IDIBase P2 Q2) (SuccMonotonicity (SuccMonotonicity ZeroLTSucc))) (≞ (→ P Q) (ETV (:: (S (S (S Z))) (:: (S (S Z)) ∅)) (STV 0.5 0.6666666666666666)))), (: (IDIRecursive P7 Q7 (IDIRecursive P3 Q3 (IDIBase P2 Q2) (SuccMonotonicity (SuccMonotonicity ZeroLTSucc))) (SuccMonotonicity (SuccMonotonicity (SuccMonotonicity ZeroLTSucc)))) (≞ (→ P Q) (ETV (:: (S (S (S (S (S (S (S Z))))))) (:: (S (S (S Z))) (:: (S (S Z)) ∅))) (STV 0.6666666666666666 0.75)))), (: (IDIRecursive P7 Q7 (IDIBase P2 Q2) (SuccMonotonicity (SuccMonotonicity ZeroLTSucc))) (≞ (→ P Q) (ETV (:: (S (S (S (S (S (S (S Z))))))) (:: (S (S Z)) ∅)) (STV 0.5 0.6666666666666666)))), (: (IDIRecursive P7 Q7 (IDIBase P3 Q3) (SuccMonotonicity (SuccMonotonicity (SuccMonotonicity ZeroLTSucc)))) (≞ (→ P Q) (ETV (:: (S (S (S (S (S (S (S Z))))))) (:: (S (S (S Z))) ∅)) (STV 1.0 0.6666666666666666)))), (let* (((: $proof4#150034 (⍃ (S (S (S Z))) (S (S Z)))) (synthesize (: $proof4#150034 (⍃ (S (S (S Z))) (S (S Z)))) kb rb (S (S (S Z)))))) (: (IDIRecursive P2 Q2 (IDIRecursive P3 Q3 (IDIBase P2 Q2) (SuccMonotonicity (SuccMonotonicity ZeroLTSucc))) $proof4#150034) (≞ (→ P Q) (ETV (:: (S (S Z)) (:: (S (S (S Z))) (:: (S (S Z)) ∅))) (STV (/ (* 0.5 (if (<= (if (< (- 1.0 0.6666666666666666) 0) (* -1 (- 1.0 0.6666666666666666)) (- 1.0 0.6666666666666666)) 1e-09) (max-count) (/ (* 0.6666666666666666 (lookahead)) (- 1.0 0.6666666666666666)))) (+ (if (<= (if (< (- 1.0 0.6666666666666666) 0) (* -1 (- 1.0 0.6666666666666666)) (- 1.0 0.6666666666666666)) 1e-09) (max-count) (/ (* 0.6666666666666666 (lookahead)) (- 1.0 0.6666666666666666))) 1)) (/ (+ (if (<= (if (< (- 1.0 0.6666666666666666) 0) (* -1 (- 1.0 0.6666666666666666)) (- 1.0 0.6666666666666666)) 1e-09) (max-count) (/ (* 0.6666666666666666 (lookahead)) (- 1.0 0.6666666666666666))) 1) (+ (+ (if (<= (if (< (- 1.0 0.6666666666666666) 0) (* -1 (- 1.0 0.6666666666666666)) (- 1.0 0.6666666666666666)) 1e-09) (max-count) (/ (* 0.6666666666666666 (lookahead)) (- 1.0 0.6666666666666666))) 1) 1.0))))))), (let* (((: $proof4#150034 (⍃ (S (S (S (S (S (S (S Z))))))) (S (S Z)))) (synthesize (: $proof4#150034 (⍃ (S (S (S (S (S (S (S Z))))))) (S (S Z)))) kb rb (S (S (S Z)))))) (: (IDIRecursive P2 Q2 (IDIRecursive P7 Q7 (IDIBase P2 Q2) (SuccMonotonicity (SuccMonotonicity ZeroLTSucc))) $proof4#150034) (≞ (→ P Q) (ETV (:: (S (S Z)) (:: (S (S (S (S (S (S (S Z))))))) (:: (S (S Z)) ∅))) (STV (/ (* 0.5 (if (<= (if (< (- 1.0 0.6666666666666666) 0) (* -1 (- 1.0 0.6666666666666666)) (- 1.0 0.6666666666666666)) 1e-09) (max-count) (/ (* 0.6666666666666666 (lookahead)) (- 1.0 0.6666666666666666)))) (+ (if (<= (if (< (- 1.0 0.6666666666666666) 0) (* -1 (- 1.0 0.6666666666666666)) (- 1.0 0.6666666666666666)) 1e-09) (max-count) (/ (* 0.6666666666666666 (lookahead)) (- 1.0 0.6666666666666666))) 1)) (/ (+ (if (<= (if (< (- 1.0 0.6666666666666666) 0) (* -1 (- 1.0 0.6666666666666666)) (- 1.0 0.6666666666666666)) 1e-09) (max-count) (/ (* 0.6666666666666666 (lookahead)) (- 1.0 0.6666666666666666))) 1) (+ (+ (if (<= (if (< (- 1.0 0.6666666666666666) 0) (* -1 (- 1.0 0.6666666666666666)) (- 1.0 0.6666666666666666)) 1e-09) (max-count) (/ (* 0.6666666666666666 (lookahead)) (- 1.0 0.6666666666666666))) 1) 1.0))))))), (let* (((: $proof4#150034 (⍃ (S (S Z)) (S (S Z)))) (synthesize (: $proof4#150034 (⍃ (S (S Z)) (S (S Z)))) kb rb (S (S (S Z)))))) (: (IDIRecursive P2 Q2 (IDIBase P2 Q2) $proof4#150034) (≞ (→ P Q) (ETV (:: (S (S Z)) (:: (S (S Z)) ∅)) (STV (/ (* 0 (if (<= (if (< (- 1.0 0.5) 0) (* -1 (- 1.0 0.5)) (- 1.0 0.5)) 1e-09) (max-count) (/ (* 0.5 (lookahead)) (- 1.0 0.5)))) (+ (if (<= (if (< (- 1.0 0.5) 0) (* -1 (- 1.0 0.5)) (- 1.0 0.5)) 1e-09) (max-count) (/ (* 0.5 (lookahead)) (- 1.0 0.5))) 1)) (/ (+ (if (<= (if (< (- 1.0 0.5) 0) (* -1 (- 1.0 0.5)) (- 1.0 0.5)) 1e-09) (max-count) (/ (* 0.5 (lookahead)) (- 1.0 0.5))) 1) (+ (+ (if (<= (if (< (- 1.0 0.5) 0) (* -1 (- 1.0 0.5)) (- 1.0 0.5)) 1e-09) (max-count) (/ (* 0.5 (lookahead)) (- 1.0 0.5))) 1) 1.0))))))), (let* (((: $proof4#150034 (⍃ (S (S (S Z))) (S (S Z)))) (synthesize (: $proof4#150034 (⍃ (S (S (S Z))) (S (S Z)))) kb rb (S (S (S Z)))))) (: (IDIRecursive P2 Q2 (IDIBase P3 Q3) $proof4#150034) (≞ (→ P Q) (ETV (:: (S (S Z)) (:: (S (S (S Z))) ∅)) (STV (/ (* 1 (if (<= (if (< (- 1.0 0.5) 0) (* -1 (- 1.0 0.5)) (- 1.0 0.5)) 1e-09) (max-count) (/ (* 0.5 (lookahead)) (- 1.0 0.5)))) (+ (if (<= (if (< (- 1.0 0.5) 0) (* -1 (- 1.0 0.5)) (- 1.0 0.5)) 1e-09) (max-count) (/ (* 0.5 (lookahead)) (- 1.0 0.5))) 1)) (/ (+ (if (<= (if (< (- 1.0 0.5) 0) (* -1 (- 1.0 0.5)) (- 1.0 0.5)) 1e-09) (max-count) (/ (* 0.5 (lookahead)) (- 1.0 0.5))) 1) (+ (+ (if (<= (if (< (- 1.0 0.5) 0) (* -1 (- 1.0 0.5)) (- 1.0 0.5)) 1e-09) (max-count) (/ (* 0.5 (lookahead)) (- 1.0 0.5))) 1) 1.0))))))), (let* (((: $proof4#150034 (⍃ (S (S (S (S (S (S (S Z))))))) (S (S Z)))) (synthesize (: $proof4#150034 (⍃ (S (S (S (S (S (S (S Z))))))) (S (S Z)))) kb rb (S (S (S Z)))))) (: (IDIRecursive P2 Q2 (IDIBase P7 Q7) $proof4#150034) (≞ (→ P Q) (ETV (:: (S (S Z)) (:: (S (S (S (S (S (S (S Z))))))) ∅)) (STV (/ (* 1 (if (<= (if (< (- 1.0 0.5) 0) (* -1 (- 1.0 0.5)) (- 1.0 0.5)) 1e-09) (max-count) (/ (* 0.5 (lookahead)) (- 1.0 0.5)))) (+ (if (<= (if (< (- 1.0 0.5) 0) (* -1 (- 1.0 0.5)) (- 1.0 0.5)) 1e-09) (max-count) (/ (* 0.5 (lookahead)) (- 1.0 0.5))) 1)) (/ (+ (if (<= (if (< (- 1.0 0.5) 0) (* -1 (- 1.0 0.5)) (- 1.0 0.5)) 1e-09) (max-count) (/ (* 0.5 (lookahead)) (- 1.0 0.5))) 1) (+ (+ (if (<= (if (< (- 1.0 0.5) 0) (* -1 (- 1.0 0.5)) (- 1.0 0.5)) 1e-09) (max-count) (/ (* 0.5 (lookahead)) (- 1.0 0.5))) 1) 1.0))))))), (let* (((: $proof2#150032 (⊷ Q (S (S (S Z))) False)) (synthesize (: $proof2#150032 (⊷ Q (S (S (S Z))) False)) kb rb (S (S (S Z))))) ((: $proof3#150033 (≞ (→ P Q) (ETV (:: $h#150038 $t#150039) (STV $PQs#150040 $y#150041)))) (synthesize (: $proof3#150033 (≞ (→ P Q) (ETV (:: $h#150038 $t#150039) (STV $PQs#150040 $y#150041)))) kb rb (S (S (S Z))))) ((: $proof4#150034 (⍃ $h#150038 (S (S (S Z))))) (synthesize (: $proof4#150034 (⍃ $h#150038 (S (S (S Z))))) kb rb (S (S (S Z)))))) (: (IDIRecursive P3 $proof2#150032 $proof3#150033 $proof4#150034) (≞ (→ P Q) (ETV (:: (S (S (S Z))) (:: $h#150038 $t#150039)) (STV (/ (* $PQs#150040 (if (<= (if (< (- 1.0 $y#150041) 0) (* -1 (- 1.0 $y#150041)) (- 1.0 $y#150041)) 1e-09) (max-count) (/ (* $y#150041 (lookahead)) (- 1.0 $y#150041)))) (+ (if (<= (if (< (- 1.0 $y#150041) 0) (* -1 (- 1.0 $y#150041)) (- 1.0 $y#150041)) 1e-09) (max-count) (/ (* $y#150041 (lookahead)) (- 1.0 $y#150041))) 1)) (/ (+ (if (<= (if (< (- 1.0 $y#150041) 0) (* -1 (- 1.0 $y#150041)) (- 1.0 $y#150041)) 1e-09) (max-count) (/ (* $y#150041 (lookahead)) (- 1.0 $y#150041))) 1) (+ (+ (if (<= (if (< (- 1.0 $y#150041) 0) (* -1 (- 1.0 $y#150041)) (- 1.0 $y#150041)) 1e-09) (max-count) (/ (* $y#150041 (lookahead)) (- 1.0 $y#150041))) 1) 1.0))))))), (let* (((: $proof2#150032 (⊷ Q (S (S (S (S (S (S (S Z))))))) False)) (synthesize (: $proof2#150032 (⊷ Q (S (S (S (S (S (S (S Z))))))) False)) kb rb (S (S (S Z))))) ((: $proof3#150033 (≞ (→ P Q) (ETV (:: $h#150038 $t#150039) (STV $PQs#150040 $y#150041)))) (synthesize (: $proof3#150033 (≞ (→ P Q) (ETV (:: $h#150038 $t#150039) (STV $PQs#150040 $y#150041)))) kb rb (S (S (S Z))))) ((: $proof4#150034 (⍃ $h#150038 (S (S (S (S (S (S (S Z))))))))) (synthesize (: $proof4#150034 (⍃ $h#150038 (S (S (S (S (S (S (S Z))))))))) kb rb (S (S (S Z)))))) (: (IDIRecursive P7 $proof2#150032 $proof3#150033 $proof4#150034) (≞ (→ P Q) (ETV (:: (S (S (S (S (S (S (S Z))))))) (:: $h#150038 $t#150039)) (STV (/ (* $PQs#150040 (if (<= (if (< (- 1.0 $y#150041) 0) (* -1 (- 1.0 $y#150041)) (- 1.0 $y#150041)) 1e-09) (max-count) (/ (* $y#150041 (lookahead)) (- 1.0 $y#150041)))) (+ (if (<= (if (< (- 1.0 $y#150041) 0) (* -1 (- 1.0 $y#150041)) (- 1.0 $y#150041)) 1e-09) (max-count) (/ (* $y#150041 (lookahead)) (- 1.0 $y#150041))) 1)) (/ (+ (if (<= (if (< (- 1.0 $y#150041) 0) (* -1 (- 1.0 $y#150041)) (- 1.0 $y#150041)) 1e-09) (max-count) (/ (* $y#150041 (lookahead)) (- 1.0 $y#150041))) 1) (+ (+ (if (<= (if (< (- 1.0 $y#150041) 0) (* -1 (- 1.0 $y#150041)) (- 1.0 $y#150041)) 1e-09) (max-count) (/ (* $y#150041 (lookahead)) (- 1.0 $y#150041))) 1) 1.0))))))), (: (IDIBase P2 Q2) (≞ (→ P Q) (ETV (:: (S (S Z)) ∅) (STV 0 0.5)))), (let* (((: $proof2#252203 (⊷ Q (S (S (S Z))) False)) (synthesize (: $proof2#252203 (⊷ Q (S (S (S Z))) False)) kb rb (S (S (S Z)))))) (: (IDIBase P3 $proof2#252203) (≞ (→ P Q) (ETV (:: (S (S (S Z))) ∅) (STV 0 0.5))))), (let* (((: $proof2#252203 (⊷ Q (S (S (S (S (S (S (S Z))))))) False)) (synthesize (: $proof2#252203 (⊷ Q (S (S (S (S (S (S (S Z))))))) False)) kb rb (S (S (S Z)))))) (: (IDIBase P7 $proof2#252203) (≞ (→ P Q) (ETV (:: (S (S (S (S (S (S (S Z))))))) ∅) (STV 0 0.5))))), (let* (((: $proof2#255197 (⊷ Q (S (S Z)) True)) (synthesize (: $proof2#255197 (⊷ Q (S (S Z)) True)) kb rb (S (S (S Z)))))) (: (IDIBase P2 $proof2#255197) (≞ (→ P Q) (ETV (:: (S (S Z)) ∅) (STV 1 0.5))))), (: (IDIBase P3 Q3) (≞ (→ P Q) (ETV (:: (S (S (S Z))) ∅) (STV 1 0.5)))), (: (IDIBase P7 Q7) (≞ (→ P Q) (ETV (:: (S (S (S (S (S (S (S Z))))))) ∅) (STV 1 0.5))))]")
P;HTML|
;                                          (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/pln/dependent-types/ImplicationDirectIntroductionDTLTest.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/pln/dependent-types/ImplicationDirectIntroductionDTLTest.metta)

;;;; Test Implication Direct Introduction DTL Rule
;;;; Import modules
<span class="ansi38-013099040"
>  !(import! &self ImplicationDirectIntroductionDTL.metta)

</span>[P;HTML|
;                                           (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/pln/dependent-types/ImplicationDirectIntroductionDTL.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/pln/dependent-types/ImplicationDirectIntroductionDTL.metta)
P;HTML|
;                                           (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/pln/dependent-types/ImplicationDirectIntroductionDTL.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/pln/dependent-types/ImplicationDirectIntroductionDTL.metta)

;;;; MeTTa port of the Implication Direct Introduction PLN rule, encoded
;;;; as dependent types, i.e. propositions as types.
;;;;
;;;; See ImplicationDirectIntroductionEntail.metta for more detail on a
;;;; pseudo formal description.
;;;;
;;;; In the case of dependent types, inference rules are constructors of
;;;; the propositions to be proven.  Then a proof is an tree composed of
;;;; calls of such constructors.
;;;;
;;;; For instance assuming two inference rules
;;;;
;;;; ImplicationDirectIntroduction (IDI, for short)
;;;; Deduction (DED, for short)
;;;;
;;;; The following inference tree
;;;;
;;;; ...            ...
;;;; -----(IDI)     -----(IDI)
;;;; P → Q          Q → R
;;;; ---------------------(DED)
;;;;         P → R
;;;;
;;;; is represented by the following MeTTa expression
;;;;
;;;; (Deduction
;;;;    (ImplicationDirectIntroduction ...)
;;;;    (ImplicationDirectIntroduction ...))
;;;;
;;;; where the premises of ImplicationDirectIntroduction are left
;;;; undefined for now.
;;;;
;;;; How such propositions as types can be defined still remains to be
;;;; determined but ideally it may look something like
;;;;
;;;; (: Deduction
;;;;    (-> (≞ (→ $P $Q) $TV1)
;;;;        (≞ (→ $Q $R) $TV2)
;;;;        (≞ (→ $P $R) (deduction-formula $TV1 $TV2))))
;;;;
;;;; where ≞, → are dependent types, and formula is just a regular metta
;;;; function.
;;;; Import modules
<span class="ansi38-013099040"
>  !(import! &self ../../common/truthvalue/EvidentialTruthValue.metta)

</span>P;HTML|
;                                           (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/truthvalue/EvidentialTruthValue.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/truthvalue/EvidentialTruthValue.metta)
P;HTML|
;                                           (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/truthvalue/EvidentialTruthValue.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/truthvalue/EvidentialTruthValue.metta)

;;;; Evidential truth value type. Represent a truth value alongside its
;;;; evidence.
<span class="ansi38-013099040"
>  !(import! &self TruthValue.metta)

</span>P;HTML|
;                                           (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/truthvalue/TruthValue.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/truthvalue/TruthValue.metta)
P;HTML|
;                                           (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/truthvalue/TruthValue.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/truthvalue/TruthValue.metta)

;;;; Truth value type definition
;;;; Import modules
<span class="ansi38-013099040"
>  !(import! &self ../Num.metta)

</span>P;HTML|
;                                           (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/Num.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/Num.metta)
P;HTML|
;                                           (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/Num.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/Num.metta)

;;;; Collection of functions operating on numbers
;;;; Define max
<span class="ansi38-255165000"
>  (: max 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (max $x $y) 
    (if 
      (> $x $y) $x $y))
</span>;;;; Define min
<span class="ansi38-255165000"
>  (: min 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (min $x $y) 
    (if 
      (< $x $y) $x $y))
</span>;;;; Clamp a number to be within a certain range
<span class="ansi38-255165000"
>  (: clamp 
    (-> $a $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (clamp $x $l $u) 
    (max $l 
      (min $u $x)))
</span>;;;; Define abs
<span class="ansi38-255165000"
>  (: abs 
    (-> $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (abs $x) 
    (if 
      (< $x 0) 
      (* -1 $x) $x))
</span>;;;; Define <=
<span class="ansi38-255165000"
>  (: <= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (<= $x $y) 
    (or 
      (< $x $y) 
      (== $x $y)))
</span>;;;; Define >=
<span class="ansi38-255165000"
>  (: >= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (>= $x $y) 
    (or 
      (> $x $y) 
      (== $x $y)))
</span>;;;; Define approximately equal
<span class="ansi38-255165000"
>  (: approxEq 
    (-> $a $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (approxEq $x $y $epsilon) 
    (<= 
      (abs (- $x $y)) $epsilon))
</span>;;;; Define Nat
<span class="ansi38-255165000"
>  (: Nat Type)
</span><span class="ansi38-255165000"
>  (: Z Nat)
</span><span class="ansi38-255165000"
>  (: S 
    (-> Nat Nat))
</span>;;;; Define cast functions between Nat and Number
<span class="ansi38-255165000"
>  (: fromNumber 
    (-> Number Nat))
</span><span class="ansi38-255165000"
>  (= 
    (fromNumber $n) 
    (if 
      (<= $n 0) Z 
      (S (fromNumber (- $n 1)))))
</span><span class="ansi38-255165000"
>  (: fromNat 
    (-> Nat Number))
</span><span class="ansi38-255165000"
>  (= 
    (fromNat Z) 0)
</span><span class="ansi38-255165000"
>  (= 
    (fromNat (S $k)) 
    (+ 1 
      (fromNat $k)))
</span>;;;; Define a generic less than operator, ⩻, for Nat.  < cannot be used
;;;; because it is a built-in, its type is hardwired and cannot be
;;;; overloaded.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Nat Nat Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $ Z) False)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ Z 
      (S $)) True)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ 
      (S $x) 
      (S $y)) 
    (⩻ $x $y))
</span>;;;; Overload ⩻ for Number.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Number Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $x $y) 
    (< $x $y))
</span>;;;; Return the ceiling of a non negative number.  If the number is
;;;; negative it returns 1.
<span class="ansi38-255165000"
>  (: ceil 
    (-> Number Number))
</span><span class="ansi38-255165000"
>  (= 
    (ceil $n) 
    (fromNat (fromNumber $n)))
</span>;;;; Convert Number to Bool.  Anything above 0 converts to True.
<span class="ansi38-255165000"
>  (: number->bool 
    (-> Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (number->bool $x) 
    (< 0 $x))
</span>;;;; Convert Bool to Number.  False converts to 0, True converts to 1.
<span class="ansi38-255165000"
>  (: bool->number 
    (-> Bool Number))
</span><span class="ansi38-255165000"
>  (= 
    (bool->number False) 0)
</span><span class="ansi38-255165000"
>  (= 
    (bool->number True) 1)
</span>;;;; Define a less than type.  Note that it is purposefully different
;;;; than ⩻ as it is a type, not an operator.  Inhabitants of (⍃ x y)
;;;; are proofs that x ⩻ y == True.  For now ⍃ is only axiomatized for
;;;; Nat.
<span class="ansi38-255165000"
>  (: ⍃ 
    (-> $t $t Type))
</span>;;;; Zero is always less than the successor of something
<span class="ansi38-255165000"
>  (: 
    (zero-lt-succ-axiom) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (zero-lt-succ-axiom) 
    (: ZeroLTSucc 
      (⍃ Z 
        (S $k))))
</span>;;;; If x ⍃ y then (S x) ⍃ (S y)
<span class="ansi38-255165000"
>  (: 
    (succ-monotonicity-rule) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (succ-monotonicity-rule) 
    (: SuccMonotonicity 
      (-> 
        (⍃ $x $y) 
        (⍃ 
          (S $x) 
          (S $y)))))
</span>
Deterministic: ()
;;;;;;;;;;;;
;;;; Type ;;
;;;;;;;;;;;;
<span class="ansi38-255165000"
>  (: TruthValue Type)
</span>;;;;;;;;;;;;;;;;;;;;
;;;; Constructors ;;
;;;;;;;;;;;;;;;;;;;;
;;;; Boolean TV constructor
;;;; TODO: alternatively we could have (: ⊤ TruthValue) and (: ⊥ TruthValue)
<span class="ansi38-255165000"
>  (: Bl 
    (-> Bool TruthValue))
</span>;;;; First order probability TV constructor, i.e. mere probability.
<span class="ansi38-255165000"
>  (: Pr 
    (-> Number TruthValue))
</span>;;;; Simple Truth Value.  A Second order probability TV constructor,
;;;; i.e. probability and confidence.  The probability is in fact the
;;;; mode of the corresponding beta distribution.
<span class="ansi38-255165000"
>  (: STV 
    (-> Number Number TruthValue))
</span>;;;;;;;;;;;;;;;;;
;;;; Constants ;;
;;;;;;;;;;;;;;;;;
;;;; For now the underlying beta distributions have a Jeffreys prior,
;;;; i.e. the prior alpha and beta are 0.5.
<span class="ansi38-255165000"
>  (: prior-alpha 
    (-> Number))
</span><span class="ansi38-255165000"
>  (= 
    (prior-alpha) 0.5)
</span><span class="ansi38-255165000"
>  (: prior-beta 
    (-> Number))
</span><span class="ansi38-255165000"
>  (= 
    (prior-beta) 0.5)
</span>;;;; Lookahead
<span class="ansi38-255165000"
>  (: lookahead 
    (-> Number))
</span><span class="ansi38-255165000"
>  (= 
    (lookahead) 1.0)
</span>;;;; Maximum supported count (till +inf is supported, possibly).
<span class="ansi38-255165000"
>  (: max-count 
    (-> Number))
</span><span class="ansi38-255165000"
>  (= 
    (max-count) 1000000000.0)
</span>;;;;;;;;;;;;;;;
;;;; Methods ;;
;;;;;;;;;;;;;;;
;;;; Convert count to confidence using the formula
;;;;
;;;; confidence = count / (count + lookahead)
<span class="ansi38-255165000"
>  (: count->confidence 
    (-> Number Number))
</span><span class="ansi38-255165000"
>  (= 
    (count->confidence $cnt) 
    (/ $cnt 
      (+ $cnt 
        (lookahead))))
</span>;;;; Convert confidence to count using the formula
;;;;
;;;; count = (confidence * lookahead) / (1 - confidence)
<span class="ansi38-255165000"
>  (: confidence->count 
    (-> Number Number))
</span><span class="ansi38-255165000"
>  (= 
    (confidence->count $conf) 
    (if 
      (approxEq 1.0 $conf 1.0e-9) 
      (max-count) 
      (/ 
        (* $conf 
          (lookahead)) 
        (- 1.0 $conf))))
</span>;;;; Increment the negative count of a given truth value, by
;;;; incrementing its total count without incrementing the positive
;;;; count.
<span class="ansi38-255165000"
>  (: inc-neg-count 
    (-> TruthValue TruthValue))
</span><span class="ansi38-255165000"
>  (= 
    (inc-neg-count (STV $s $c)) 
    (let* 
      ( ($tot_cnt (confidence->count $c)) 
        ($pos_cnt (* $s $tot_cnt)) 
        ($new_tot_cnt (+ $tot_cnt 1))) 
      (STV 
        (/ $pos_cnt $new_tot_cnt) 
        (count->confidence $new_tot_cnt))))
</span>;;;; Increment the positive count of a given truth value, by
;;;; incrementing its total count and its positive count.
<span class="ansi38-255165000"
>  (: inc-pos-count 
    (-> TruthValue TruthValue))
</span><span class="ansi38-255165000"
>  (= 
    (inc-pos-count (STV $s $c)) 
    (let* 
      ( ($tot_cnt (confidence->count $c)) 
        ($pos_cnt (* $s $tot_cnt)) 
        ($new_pos_cnt (+ $pos_cnt 1)) 
        ($new_tot_cnt (+ $tot_cnt 1))) 
      (STV 
        (/ $new_pos_cnt $new_tot_cnt) 
        (count->confidence $new_tot_cnt))))
</span>;;;; Return the first order probability mode of the second order
;;;; distribution associated to a truth value.
<span class="ansi38-255165000"
>  (: mode 
    (-> TruthValue Number))
</span><span class="ansi38-255165000"
>  (= 
    (mode (Bl True)) 1.0)
</span><span class="ansi38-255165000"
>  (= 
    (mode (Bl False)) 0.0)
</span><span class="ansi38-255165000"
>  (= 
    (mode (Pr $pr)) $pr)
</span><span class="ansi38-255165000"
>  (= 
    (mode (STV $pr $)) $pr)
</span>;;;; Return the total count of a truth value.  For truth values not
;;;; capturing a notion of confidence, such as Bl or Pr then the count
;;;; is assumed to be a very large number (cause +inf does not seem to
;;;; be supported at the moment).
<span class="ansi38-255165000"
>  (: count 
    (-> TruthValue Number))
</span><span class="ansi38-255165000"
>  (= 
    (count (Bl $)) 
    (max-count))
</span><span class="ansi38-255165000"
>  (= 
    (count (Pr $)) 
    (max-count))
</span><span class="ansi38-255165000"
>  (= 
    (count (STV $ $conf)) 
    (confidence->count $conf))
</span>;;;; Return the confidence of a truth value.  For truth values not
;;;; capturing a notion of confidence, such as Bl or Pr then the
;;;; confidence is assumed to be 1.0.  For truth values capturing a
;;;; notion of confidence, such as STV, the formula to convert a count
;;;; into confidence is as follows
;;;;
;;;; confidence = count / (count + lookahead)
<span class="ansi38-255165000"
>  (: confidence 
    (-> TruthValue Number))
</span><span class="ansi38-255165000"
>  (= 
    (confidence (Bl $)) 1.0)
</span><span class="ansi38-255165000"
>  (= 
    (confidence (Pr $)) 1.0)
</span><span class="ansi38-255165000"
>  (= 
    (confidence (STV $ $conf)) $conf)
</span>;;;; Return the positive count of a truth value.
<span class="ansi38-255165000"
>  (: pos-count 
    (-> TruthValue Number))
</span><span class="ansi38-255165000"
>  (= 
    (pos-count $tv) 
    (* 
      (mode $tv) 
      (count $tv)))
</span>;;;; Return the negative count of a truth value.
<span class="ansi38-255165000"
>  (: neg-count 
    (-> TruthValue Number))
</span><span class="ansi38-255165000"
>  (= 
    (neg-count $tv) 
    (* 
      (- 1 
        (mode $tv)) 
      (count $tv)))
</span>;;;; Return the posterior alpha of a truth value
<span class="ansi38-255165000"
>  (: post-alpha 
    (-> TruthValue Number))
</span><span class="ansi38-255165000"
>  (= 
    (post-alpha $tv) 
    (+ 
      (prior-alpha) 
      (pos-count $tv)))
</span>;;;; Return the posterior beta of a truth value
<span class="ansi38-255165000"
>  (: post-beta 
    (-> TruthValue Number))
</span><span class="ansi38-255165000"
>  (= 
    (post-beta $tv) 
    (+ 
      (prior-beta) 
      (neg-count $tv)))
</span>;;;; Return the first order probability mean of the second order
;;;; distribution associated to a truth value.  For truth values not
;;;; capturing a notion of confidence, such as Bl or Pr then the
;;;; confidence is assumed to be 1.0.  For truth values capturing a
;;;; notion of confidence, such as STV, a beta distribution is assumed.
<span class="ansi38-255165000"
>  (: mean 
    (-> TruthValue Number))
</span><span class="ansi38-255165000"
>  (= 
    (mean (Bl True)) 1.0)
</span><span class="ansi38-255165000"
>  (= 
    (mean (Bl False)) 0.0)
</span><span class="ansi38-255165000"
>  (= 
    (mean (Pr $pr)) $pr)
</span><span class="ansi38-255165000"
>  (= 
    (mean (STV $pr $conf)) 
    (let* 
      ( ($a (post-alpha (STV $pr $conf))) ($b (post-beta (STV $pr $conf)))) 
      (/ $a 
        (+ $a $b))))
</span>
Last Result(2): ()
<span class="ansi38-013099040"
>  !(import! &self ../OrderedSet.metta)

</span>P;HTML|
;                                           (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/OrderedSet.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/OrderedSet.metta)
P;HTML|
;                                           (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/OrderedSet.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/OrderedSet.metta)

;;;; Import modules
<span class="ansi38-013099040"
>  !(import! &self Num.metta)

</span>P;HTML|
;                                           (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/Num.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/Num.metta)
P;HTML|
;                                           (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/Num.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/Num.metta)

;;;; Collection of functions operating on numbers
;;;; Define max
<span class="ansi38-255165000"
>  (: max 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (max $x $y) 
    (if 
      (> $x $y) $x $y))
</span>;;;; Define min
<span class="ansi38-255165000"
>  (: min 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (min $x $y) 
    (if 
      (< $x $y) $x $y))
</span>;;;; Clamp a number to be within a certain range
<span class="ansi38-255165000"
>  (: clamp 
    (-> $a $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (clamp $x $l $u) 
    (max $l 
      (min $u $x)))
</span>;;;; Define abs
<span class="ansi38-255165000"
>  (: abs 
    (-> $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (abs $x) 
    (if 
      (< $x 0) 
      (* -1 $x) $x))
</span>;;;; Define <=
<span class="ansi38-255165000"
>  (: <= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (<= $x $y) 
    (or 
      (< $x $y) 
      (== $x $y)))
</span>;;;; Define >=
<span class="ansi38-255165000"
>  (: >= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (>= $x $y) 
    (or 
      (> $x $y) 
      (== $x $y)))
</span>;;;; Define approximately equal
<span class="ansi38-255165000"
>  (: approxEq 
    (-> $a $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (approxEq $x $y $epsilon) 
    (<= 
      (abs (- $x $y)) $epsilon))
</span>;;;; Define Nat
<span class="ansi38-255165000"
>  (: Nat Type)
</span><span class="ansi38-255165000"
>  (: Z Nat)
</span><span class="ansi38-255165000"
>  (: S 
    (-> Nat Nat))
</span>;;;; Define cast functions between Nat and Number
<span class="ansi38-255165000"
>  (: fromNumber 
    (-> Number Nat))
</span><span class="ansi38-255165000"
>  (= 
    (fromNumber $n) 
    (if 
      (<= $n 0) Z 
      (S (fromNumber (- $n 1)))))
</span><span class="ansi38-255165000"
>  (: fromNat 
    (-> Nat Number))
</span><span class="ansi38-255165000"
>  (= 
    (fromNat Z) 0)
</span><span class="ansi38-255165000"
>  (= 
    (fromNat (S $k)) 
    (+ 1 
      (fromNat $k)))
</span>;;;; Define a generic less than operator, ⩻, for Nat.  < cannot be used
;;;; because it is a built-in, its type is hardwired and cannot be
;;;; overloaded.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Nat Nat Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $ Z) False)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ Z 
      (S $)) True)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ 
      (S $x) 
      (S $y)) 
    (⩻ $x $y))
</span>;;;; Overload ⩻ for Number.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Number Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $x $y) 
    (< $x $y))
</span>;;;; Return the ceiling of a non negative number.  If the number is
;;;; negative it returns 1.
<span class="ansi38-255165000"
>  (: ceil 
    (-> Number Number))
</span><span class="ansi38-255165000"
>  (= 
    (ceil $n) 
    (fromNat (fromNumber $n)))
</span>;;;; Convert Number to Bool.  Anything above 0 converts to True.
<span class="ansi38-255165000"
>  (: number->bool 
    (-> Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (number->bool $x) 
    (< 0 $x))
</span>;;;; Convert Bool to Number.  False converts to 0, True converts to 1.
<span class="ansi38-255165000"
>  (: bool->number 
    (-> Bool Number))
</span><span class="ansi38-255165000"
>  (= 
    (bool->number False) 0)
</span><span class="ansi38-255165000"
>  (= 
    (bool->number True) 1)
</span>;;;; Define a less than type.  Note that it is purposefully different
;;;; than ⩻ as it is a type, not an operator.  Inhabitants of (⍃ x y)
;;;; are proofs that x ⩻ y == True.  For now ⍃ is only axiomatized for
;;;; Nat.
<span class="ansi38-255165000"
>  (: ⍃ 
    (-> $t $t Type))
</span>;;;; Zero is always less than the successor of something
<span class="ansi38-255165000"
>  (: 
    (zero-lt-succ-axiom) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (zero-lt-succ-axiom) 
    (: ZeroLTSucc 
      (⍃ Z 
        (S $k))))
</span>;;;; If x ⍃ y then (S x) ⍃ (S y)
<span class="ansi38-255165000"
>  (: 
    (succ-monotonicity-rule) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (succ-monotonicity-rule) 
    (: SuccMonotonicity 
      (-> 
        (⍃ $x $y) 
        (⍃ 
          (S $x) 
          (S $y)))))
</span>;;;; Collection of functions operating on numbers
;;;; Define max
<span class="ansi38-255165000"
>  (: max 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (max $x $y) 
    (if 
      (> $x $y) $x $y))
</span>;;;; Define min
<span class="ansi38-255165000"
>  (: min 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (min $x $y) 
    (if 
      (< $x $y) $x $y))
</span>;;;; Clamp a number to be within a certain range
<span class="ansi38-255165000"
>  (: clamp 
    (-> $a $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (clamp $x $l $u) 
    (max $l 
      (min $u $x)))
</span>;;;; Define abs
<span class="ansi38-255165000"
>  (: abs 
    (-> $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (abs $x) 
    (if 
      (< $x 0) 
      (* -1 $x) $x))
</span>;;;; Define <=
<span class="ansi38-255165000"
>  (: <= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (<= $x $y) 
    (or 
      (< $x $y) 
      (== $x $y)))
</span>;;;; Define >=
<span class="ansi38-255165000"
>  (: >= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (>= $x $y) 
    (or 
      (> $x $y) 
      (== $x $y)))
</span>;;;; Define approximately equal
<span class="ansi38-255165000"
>  (: approxEq 
    (-> $a $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (approxEq $x $y $epsilon) 
    (<= 
      (abs (- $x $y)) $epsilon))
</span>;;;; Define Nat
<span class="ansi38-255165000"
>  (: Nat Type)
</span><span class="ansi38-255165000"
>  (: Z Nat)
</span><span class="ansi38-255165000"
>  (: S 
    (-> Nat Nat))
</span>;;;; Define cast functions between Nat and Number
<span class="ansi38-255165000"
>  (: fromNumber 
    (-> Number Nat))
</span><span class="ansi38-255165000"
>  (= 
    (fromNumber $n) 
    (if 
      (<= $n 0) Z 
      (S (fromNumber (- $n 1)))))
</span><span class="ansi38-255165000"
>  (: fromNat 
    (-> Nat Number))
</span><span class="ansi38-255165000"
>  (= 
    (fromNat Z) 0)
</span><span class="ansi38-255165000"
>  (= 
    (fromNat (S $k)) 
    (+ 1 
      (fromNat $k)))
</span>;;;; Define a generic less than operator, ⩻, for Nat.  < cannot be used
;;;; because it is a built-in, its type is hardwired and cannot be
;;;; overloaded.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Nat Nat Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $ Z) False)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ Z 
      (S $)) True)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ 
      (S $x) 
      (S $y)) 
    (⩻ $x $y))
</span>;;;; Overload ⩻ for Number.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Number Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $x $y) 
    (< $x $y))
</span>;;;; Return the ceiling of a non negative number.  If the number is
;;;; negative it returns 1.
<span class="ansi38-255165000"
>  (: ceil 
    (-> Number Number))
</span><span class="ansi38-255165000"
>  (= 
    (ceil $n) 
    (fromNat (fromNumber $n)))
</span>;;;; Convert Number to Bool.  Anything above 0 converts to True.
<span class="ansi38-255165000"
>  (: number->bool 
    (-> Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (number->bool $x) 
    (< 0 $x))
</span>;;;; Convert Bool to Number.  False converts to 0, True converts to 1.
<span class="ansi38-255165000"
>  (: bool->number 
    (-> Bool Number))
</span><span class="ansi38-255165000"
>  (= 
    (bool->number False) 0)
</span><span class="ansi38-255165000"
>  (= 
    (bool->number True) 1)
</span>;;;; Define a less than type.  Note that it is purposefully different
;;;; than ⩻ as it is a type, not an operator.  Inhabitants of (⍃ x y)
;;;; are proofs that x ⩻ y == True.  For now ⍃ is only axiomatized for
;;;; Nat.
<span class="ansi38-255165000"
>  (: ⍃ 
    (-> $t $t Type))
</span>;;;; Zero is always less than the successor of something
<span class="ansi38-255165000"
>  (: 
    (zero-lt-succ-axiom) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (zero-lt-succ-axiom) 
    (: ZeroLTSucc 
      (⍃ Z 
        (S $k))))
</span>;;;; If x ⍃ y then (S x) ⍃ (S y)
<span class="ansi38-255165000"
>  (: 
    (succ-monotonicity-rule) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (succ-monotonicity-rule) 
    (: SuccMonotonicity 
      (-> 
        (⍃ $x $y) 
        (⍃ 
          (S $x) 
          (S $y)))))
</span>
Deterministic: ()
;;;; Definition of a set data structure.  Under the hood it is a sorted
;;;; list without duplicates, thus called OrderedSet.  For now its
;;;; constructor :: is unconstrained, meaning it does not guaranty that
;;;; the constructed OrderedSet are sorted and without duplicates.
;;;; Rather this is delegated to the insert function defined below.  In
;;;; order to guaranty that it is sorted without duplicates, the
;;;; constructor :: would need to take an additional argument encoding a
;;;; proof that the element to prepend is less than the head of the set
;;;; to be prepended to.
<span class="ansi38-255165000"
>  (: OrderedSet 
    (-> $a Type))
</span><span class="ansi38-255165000"
>  (: ∅ 
    (OrderedSet $a))
</span><span class="ansi38-255165000"
>  (: :: 
    (-> $a 
      (OrderedSet $a) 
      (OrderedSet $a)))
</span>;;;; Check if an element is in a set.  TODO: optimize assuming it is
;;;; ordered.
<span class="ansi38-255165000"
>  (: elem 
    (-> $a 
      (OrderedSet $a) Bool))
</span><span class="ansi38-255165000"
>  (= 
    (elem $x ∅) False)
</span><span class="ansi38-255165000"
>  (= 
    (elem $x 
      (:: $h $t)) 
    (if 
      (== $x $h) True 
      (elem $x $t)))
</span>;;;; Insert an element into a set.  Only insert if the element is not
;;;; already in the set as to produce an ordered set.
<span class="ansi38-255165000"
>  (: insert 
    (-> $a 
      (OrderedSet $a) 
      (OrderedSet $a)))
</span><span class="ansi38-255165000"
>  (= 
    (insert $x ∅) 
    (:: $x ∅))
</span>;;; Base case
;;; Recursive step
;;; Present, no need to insert
;;; Use generic <
;;; Safely insert since $x < $h
<span class="ansi38-255165000"
>  (= 
    (insert $x 
      (:: $h $t)) 
    (if 
      (== $x $h) 
      (:: $h $t) 
      (if 
        (⩻ $x $h) 
        (:: $x 
          (:: $h $t)) 
        (:: $h 
          (insert $x $t)))))
</span>;;; Recursive call

Last Result(2): ()
;;;;;;;;;;;;
;;;; Type ;;
;;;;;;;;;;;;
<span class="ansi38-255165000"
>  (: EvidentialTruthValue Type)
</span>;;;;;;;;;;;;;;;;;;;;
;;;; Constructor ;;
;;;;;;;;;;;;;;;;;;;;
;;;; Takes an evidence set ascribed to a truth value to form an
;;;; evidential truth value.
<span class="ansi38-255165000"
>  (: ETV 
    (-> 
      (OrderedSet $a) TruthValue EvidentialTruthValue))
</span>;;;;;;;;;;;;;;;
;;;; Methods ;;
;;;;;;;;;;;;;;;
;;;; Access the truth value of an evidential truth value.
<span class="ansi38-255165000"
>  (: tv 
    (-> EvidentialTruthValue TruthValue))
</span><span class="ansi38-255165000"
>  (= 
    (tv (ETV $ev $tv)) $tv)
</span>;;;; Return the first order probability mode of the second order
;;;; distribution associated to an evidential truth value.
<span class="ansi38-255165000"
>  (: mode 
    (-> EvidentialTruthValue Number))
</span><span class="ansi38-255165000"
>  (= 
    (mode (ETV $ev $tv)) 
    (mode $tv))
</span>;;;; Return the total count of an evidential truth value.
<span class="ansi38-255165000"
>  (: count 
    (-> EvidentialTruthValue Number))
</span><span class="ansi38-255165000"
>  (= 
    (count (ETV $ev $tv)) 
    (count $tv))
</span>;;;; Return the positive count of a truth value.
<span class="ansi38-255165000"
>  (: pos_count 
    (-> EvidentialTruthValue Number))
</span><span class="ansi38-255165000"
>  (= 
    (pos_count (ETV $ev $tv)) 
    (* 
      (mode $tv) 
      (count $tv)))
</span>;;;; Return the negative count of a truth value.
<span class="ansi38-255165000"
>  (: neg_count 
    (-> EvidentialTruthValue Number))
</span><span class="ansi38-255165000"
>  (= 
    (neg_count (ETV $ev $tv)) 
    (* 
      (- 1 
        (mode $tv)) 
      (count $tv)))
</span>;;;; Return the posterior alpha of a truth value
<span class="ansi38-255165000"
>  (: post_alpha 
    (-> EvidentialTruthValue Number))
</span><span class="ansi38-255165000"
>  (= 
    (post_alpha (ETV $ev $tv)) 
    (+ 
      (prior_alpha) 
      (pos_count $tv)))
</span>;;;; Return the posterior beta of a truth value
<span class="ansi38-255165000"
>  (: post_beta 
    (-> EvidentialTruthValue Number))
</span><span class="ansi38-255165000"
>  (= 
    (post_beta (ETV $ev $tv)) 
    (+ 
      (prior_beta) 
      (neg_count $tv)))
</span>;;;; Return the first order probability mean of the second order
;;;; distribution associated to an evidential truth value.
<span class="ansi38-255165000"
>  (: mean 
    (-> EvidentialTruthValue Number))
</span><span class="ansi38-255165000"
>  (= 
    (mean (ETV $ev $tv)) 
    (mean $tv))
</span>;;;; Return the confidence of an evidential truth value.
<span class="ansi38-255165000"
>  (: confidence 
    (-> EvidentialTruthValue Number))
</span><span class="ansi38-255165000"
>  (= 
    (confidence (ETV $ev $tv)) 
    (confidence $tv))
</span>
Last Result(3): ()
<span class="ansi38-013099040"
>  !(import! &self ../../common/formula/ImplicationDirectIntroductionFormula.metta)

</span>P;HTML|
;                                           (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/formula/ImplicationDirectIntroductionFormula.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/formula/ImplicationDirectIntroductionFormula.metta)
P;HTML|
;                                           (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/formula/ImplicationDirectIntroductionFormula.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/formula/ImplicationDirectIntroductionFormula.metta)

;;;; Formula for the inductive Implication Direct Introduction rule.
;;;; Import modules
<span class="ansi38-013099040"
>  !(import! &self ../truthvalue/TruthValue.metta)

</span>P;HTML|
;                                           (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/truthvalue/TruthValue.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/truthvalue/TruthValue.metta)
P;HTML|
;                                           (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/truthvalue/TruthValue.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/truthvalue/TruthValue.metta)

;;;; Truth value type definition
;;;; Import modules
<span class="ansi38-013099040"
>  !(import! &self ../Num.metta)

</span>P;HTML|
;                                           (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/Num.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/Num.metta)
P;HTML|
;                                           (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/Num.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/Num.metta)

;;;; Collection of functions operating on numbers
;;;; Define max
<span class="ansi38-255165000"
>  (: max 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (max $x $y) 
    (if 
      (> $x $y) $x $y))
</span>;;;; Define min
<span class="ansi38-255165000"
>  (: min 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (min $x $y) 
    (if 
      (< $x $y) $x $y))
</span>;;;; Clamp a number to be within a certain range
<span class="ansi38-255165000"
>  (: clamp 
    (-> $a $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (clamp $x $l $u) 
    (max $l 
      (min $u $x)))
</span>;;;; Define abs
<span class="ansi38-255165000"
>  (: abs 
    (-> $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (abs $x) 
    (if 
      (< $x 0) 
      (* -1 $x) $x))
</span>;;;; Define <=
<span class="ansi38-255165000"
>  (: <= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (<= $x $y) 
    (or 
      (< $x $y) 
      (== $x $y)))
</span>;;;; Define >=
<span class="ansi38-255165000"
>  (: >= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (>= $x $y) 
    (or 
      (> $x $y) 
      (== $x $y)))
</span>;;;; Define approximately equal
<span class="ansi38-255165000"
>  (: approxEq 
    (-> $a $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (approxEq $x $y $epsilon) 
    (<= 
      (abs (- $x $y)) $epsilon))
</span>;;;; Define Nat
<span class="ansi38-255165000"
>  (: Nat Type)
</span><span class="ansi38-255165000"
>  (: Z Nat)
</span><span class="ansi38-255165000"
>  (: S 
    (-> Nat Nat))
</span>;;;; Define cast functions between Nat and Number
<span class="ansi38-255165000"
>  (: fromNumber 
    (-> Number Nat))
</span><span class="ansi38-255165000"
>  (= 
    (fromNumber $n) 
    (if 
      (<= $n 0) Z 
      (S (fromNumber (- $n 1)))))
</span><span class="ansi38-255165000"
>  (: fromNat 
    (-> Nat Number))
</span><span class="ansi38-255165000"
>  (= 
    (fromNat Z) 0)
</span><span class="ansi38-255165000"
>  (= 
    (fromNat (S $k)) 
    (+ 1 
      (fromNat $k)))
</span>;;;; Define a generic less than operator, ⩻, for Nat.  < cannot be used
;;;; because it is a built-in, its type is hardwired and cannot be
;;;; overloaded.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Nat Nat Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $ Z) False)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ Z 
      (S $)) True)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ 
      (S $x) 
      (S $y)) 
    (⩻ $x $y))
</span>;;;; Overload ⩻ for Number.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Number Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $x $y) 
    (< $x $y))
</span>;;;; Return the ceiling of a non negative number.  If the number is
;;;; negative it returns 1.
<span class="ansi38-255165000"
>  (: ceil 
    (-> Number Number))
</span><span class="ansi38-255165000"
>  (= 
    (ceil $n) 
    (fromNat (fromNumber $n)))
</span>;;;; Convert Number to Bool.  Anything above 0 converts to True.
<span class="ansi38-255165000"
>  (: number->bool 
    (-> Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (number->bool $x) 
    (< 0 $x))
</span>;;;; Convert Bool to Number.  False converts to 0, True converts to 1.
<span class="ansi38-255165000"
>  (: bool->number 
    (-> Bool Number))
</span><span class="ansi38-255165000"
>  (= 
    (bool->number False) 0)
</span><span class="ansi38-255165000"
>  (= 
    (bool->number True) 1)
</span>;;;; Define a less than type.  Note that it is purposefully different
;;;; than ⩻ as it is a type, not an operator.  Inhabitants of (⍃ x y)
;;;; are proofs that x ⩻ y == True.  For now ⍃ is only axiomatized for
;;;; Nat.
<span class="ansi38-255165000"
>  (: ⍃ 
    (-> $t $t Type))
</span>;;;; Zero is always less than the successor of something
<span class="ansi38-255165000"
>  (: 
    (zero-lt-succ-axiom) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (zero-lt-succ-axiom) 
    (: ZeroLTSucc 
      (⍃ Z 
        (S $k))))
</span>;;;; If x ⍃ y then (S x) ⍃ (S y)
<span class="ansi38-255165000"
>  (: 
    (succ-monotonicity-rule) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (succ-monotonicity-rule) 
    (: SuccMonotonicity 
      (-> 
        (⍃ $x $y) 
        (⍃ 
          (S $x) 
          (S $y)))))
</span>;;;; Collection of functions operating on numbers
;;;; Define max
<span class="ansi38-255165000"
>  (: max 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (max $x $y) 
    (if 
      (> $x $y) $x $y))
</span>;;;; Define min
<span class="ansi38-255165000"
>  (: min 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (min $x $y) 
    (if 
      (< $x $y) $x $y))
</span>;;;; Clamp a number to be within a certain range
<span class="ansi38-255165000"
>  (: clamp 
    (-> $a $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (clamp $x $l $u) 
    (max $l 
      (min $u $x)))
</span>;;;; Define abs
<span class="ansi38-255165000"
>  (: abs 
    (-> $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (abs $x) 
    (if 
      (< $x 0) 
      (* -1 $x) $x))
</span>;;;; Define <=
<span class="ansi38-255165000"
>  (: <= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (<= $x $y) 
    (or 
      (< $x $y) 
      (== $x $y)))
</span>;;;; Define >=
<span class="ansi38-255165000"
>  (: >= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (>= $x $y) 
    (or 
      (> $x $y) 
      (== $x $y)))
</span>;;;; Define approximately equal
<span class="ansi38-255165000"
>  (: approxEq 
    (-> $a $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (approxEq $x $y $epsilon) 
    (<= 
      (abs (- $x $y)) $epsilon))
</span>;;;; Define Nat
<span class="ansi38-255165000"
>  (: Nat Type)
</span><span class="ansi38-255165000"
>  (: Z Nat)
</span><span class="ansi38-255165000"
>  (: S 
    (-> Nat Nat))
</span>;;;; Define cast functions between Nat and Number
<span class="ansi38-255165000"
>  (: fromNumber 
    (-> Number Nat))
</span><span class="ansi38-255165000"
>  (= 
    (fromNumber $n) 
    (if 
      (<= $n 0) Z 
      (S (fromNumber (- $n 1)))))
</span><span class="ansi38-255165000"
>  (: fromNat 
    (-> Nat Number))
</span><span class="ansi38-255165000"
>  (= 
    (fromNat Z) 0)
</span><span class="ansi38-255165000"
>  (= 
    (fromNat (S $k)) 
    (+ 1 
      (fromNat $k)))
</span>;;;; Define a generic less than operator, ⩻, for Nat.  < cannot be used
;;;; because it is a built-in, its type is hardwired and cannot be
;;;; overloaded.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Nat Nat Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $ Z) False)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ Z 
      (S $)) True)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ 
      (S $x) 
      (S $y)) 
    (⩻ $x $y))
</span>;;;; Overload ⩻ for Number.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Number Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $x $y) 
    (< $x $y))
</span>;;;; Return the ceiling of a non negative number.  If the number is
;;;; negative it returns 1.
<span class="ansi38-255165000"
>  (: ceil 
    (-> Number Number))
</span><span class="ansi38-255165000"
>  (= 
    (ceil $n) 
    (fromNat (fromNumber $n)))
</span>;;;; Convert Number to Bool.  Anything above 0 converts to True.
<span class="ansi38-255165000"
>  (: number->bool 
    (-> Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (number->bool $x) 
    (< 0 $x))
</span>;;;; Convert Bool to Number.  False converts to 0, True converts to 1.
<span class="ansi38-255165000"
>  (: bool->number 
    (-> Bool Number))
</span><span class="ansi38-255165000"
>  (= 
    (bool->number False) 0)
</span><span class="ansi38-255165000"
>  (= 
    (bool->number True) 1)
</span>;;;; Define a less than type.  Note that it is purposefully different
;;;; than ⩻ as it is a type, not an operator.  Inhabitants of (⍃ x y)
;;;; are proofs that x ⩻ y == True.  For now ⍃ is only axiomatized for
;;;; Nat.
<span class="ansi38-255165000"
>  (: ⍃ 
    (-> $t $t Type))
</span>;;;; Zero is always less than the successor of something
<span class="ansi38-255165000"
>  (: 
    (zero-lt-succ-axiom) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (zero-lt-succ-axiom) 
    (: ZeroLTSucc 
      (⍃ Z 
        (S $k))))
</span>;;;; If x ⍃ y then (S x) ⍃ (S y)
<span class="ansi38-255165000"
>  (: 
    (succ-monotonicity-rule) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (succ-monotonicity-rule) 
    (: SuccMonotonicity 
      (-> 
        (⍃ $x $y) 
        (⍃ 
          (S $x) 
          (S $y)))))
</span>;;;; Collection of functions operating on numbers
;;;; Define max
<span class="ansi38-255165000"
>  (: max 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (max $x $y) 
    (if 
      (> $x $y) $x $y))
</span>;;;; Define min
<span class="ansi38-255165000"
>  (: min 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (min $x $y) 
    (if 
      (< $x $y) $x $y))
</span>;;;; Clamp a number to be within a certain range
<span class="ansi38-255165000"
>  (: clamp 
    (-> $a $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (clamp $x $l $u) 
    (max $l 
      (min $u $x)))
</span>;;;; Define abs
<span class="ansi38-255165000"
>  (: abs 
    (-> $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (abs $x) 
    (if 
      (< $x 0) 
      (* -1 $x) $x))
</span>;;;; Define <=
<span class="ansi38-255165000"
>  (: <= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (<= $x $y) 
    (or 
      (< $x $y) 
      (== $x $y)))
</span>;;;; Define >=
<span class="ansi38-255165000"
>  (: >= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (>= $x $y) 
    (or 
      (> $x $y) 
      (== $x $y)))
</span>;;;; Define approximately equal
<span class="ansi38-255165000"
>  (: approxEq 
    (-> $a $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (approxEq $x $y $epsilon) 
    (<= 
      (abs (- $x $y)) $epsilon))
</span>;;;; Define Nat
<span class="ansi38-255165000"
>  (: Nat Type)
</span><span class="ansi38-255165000"
>  (: Z Nat)
</span><span class="ansi38-255165000"
>  (: S 
    (-> Nat Nat))
</span>;;;; Define cast functions between Nat and Number
<span class="ansi38-255165000"
>  (: fromNumber 
    (-> Number Nat))
</span><span class="ansi38-255165000"
>  (= 
    (fromNumber $n) 
    (if 
      (<= $n 0) Z 
      (S (fromNumber (- $n 1)))))
</span><span class="ansi38-255165000"
>  (: fromNat 
    (-> Nat Number))
</span><span class="ansi38-255165000"
>  (= 
    (fromNat Z) 0)
</span><span class="ansi38-255165000"
>  (= 
    (fromNat (S $k)) 
    (+ 1 
      (fromNat $k)))
</span>;;;; Define a generic less than operator, ⩻, for Nat.  < cannot be used
;;;; because it is a built-in, its type is hardwired and cannot be
;;;; overloaded.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Nat Nat Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $ Z) False)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ Z 
      (S $)) True)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ 
      (S $x) 
      (S $y)) 
    (⩻ $x $y))
</span>;;;; Overload ⩻ for Number.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Number Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $x $y) 
    (< $x $y))
</span>;;;; Return the ceiling of a non negative number.  If the number is
;;;; negative it returns 1.
<span class="ansi38-255165000"
>  (: ceil 
    (-> Number Number))
</span><span class="ansi38-255165000"
>  (= 
    (ceil $n) 
    (fromNat (fromNumber $n)))
</span>;;;; Convert Number to Bool.  Anything above 0 converts to True.
<span class="ansi38-255165000"
>  (: number->bool 
    (-> Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (number->bool $x) 
    (< 0 $x))
</span>;;;; Convert Bool to Number.  False converts to 0, True converts to 1.
<span class="ansi38-255165000"
>  (: bool->number 
    (-> Bool Number))
</span><span class="ansi38-255165000"
>  (= 
    (bool->number False) 0)
</span><span class="ansi38-255165000"
>  (= 
    (bool->number True) 1)
</span>;;;; Define a less than type.  Note that it is purposefully different
;;;; than ⩻ as it is a type, not an operator.  Inhabitants of (⍃ x y)
;;;; are proofs that x ⩻ y == True.  For now ⍃ is only axiomatized for
;;;; Nat.
<span class="ansi38-255165000"
>  (: ⍃ 
    (-> $t $t Type))
</span>;;;; Zero is always less than the successor of something
<span class="ansi38-255165000"
>  (: 
    (zero-lt-succ-axiom) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (zero-lt-succ-axiom) 
    (: ZeroLTSucc 
      (⍃ Z 
        (S $k))))
</span>;;;; If x ⍃ y then (S x) ⍃ (S y)
<span class="ansi38-255165000"
>  (: 
    (succ-monotonicity-rule) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (succ-monotonicity-rule) 
    (: SuccMonotonicity 
      (-> 
        (⍃ $x $y) 
        (⍃ 
          (S $x) 
          (S $y)))))
</span>
Deterministic: ()
;;;;;;;;;;;;
;;;; Type ;;
;;;;;;;;;;;;
<span class="ansi38-255165000"
>  (: TruthValue Type)
</span>;;;;;;;;;;;;;;;;;;;;
;;;; Constructors ;;
;;;;;;;;;;;;;;;;;;;;
;;;; Boolean TV constructor
;;;; TODO: alternatively we could have (: ⊤ TruthValue) and (: ⊥ TruthValue)
<span class="ansi38-255165000"
>  (: Bl 
    (-> Bool TruthValue))
</span>;;;; First order probability TV constructor, i.e. mere probability.
<span class="ansi38-255165000"
>  (: Pr 
    (-> Number TruthValue))
</span>;;;; Simple Truth Value.  A Second order probability TV constructor,
;;;; i.e. probability and confidence.  The probability is in fact the
;;;; mode of the corresponding beta distribution.
<span class="ansi38-255165000"
>  (: STV 
    (-> Number Number TruthValue))
</span>;;;;;;;;;;;;;;;;;
;;;; Constants ;;
;;;;;;;;;;;;;;;;;
;;;; For now the underlying beta distributions have a Jeffreys prior,
;;;; i.e. the prior alpha and beta are 0.5.
<span class="ansi38-255165000"
>  (: prior-alpha 
    (-> Number))
</span><span class="ansi38-255165000"
>  (= 
    (prior-alpha) 0.5)
</span><span class="ansi38-255165000"
>  (: prior-beta 
    (-> Number))
</span><span class="ansi38-255165000"
>  (= 
    (prior-beta) 0.5)
</span>;;;; Lookahead
<span class="ansi38-255165000"
>  (: lookahead 
    (-> Number))
</span><span class="ansi38-255165000"
>  (= 
    (lookahead) 1.0)
</span>;;;; Maximum supported count (till +inf is supported, possibly).
<span class="ansi38-255165000"
>  (: max-count 
    (-> Number))
</span><span class="ansi38-255165000"
>  (= 
    (max-count) 1000000000.0)
</span>;;;;;;;;;;;;;;;
;;;; Methods ;;
;;;;;;;;;;;;;;;
;;;; Convert count to confidence using the formula
;;;;
;;;; confidence = count / (count + lookahead)
<span class="ansi38-255165000"
>  (: count->confidence 
    (-> Number Number))
</span><span class="ansi38-255165000"
>  (= 
    (count->confidence $cnt) 
    (/ $cnt 
      (+ $cnt 
        (lookahead))))
</span>;;;; Convert confidence to count using the formula
;;;;
;;;; count = (confidence * lookahead) / (1 - confidence)
<span class="ansi38-255165000"
>  (: confidence->count 
    (-> Number Number))
</span><span class="ansi38-255165000"
>  (= 
    (confidence->count $conf) 
    (if 
      (approxEq 1.0 $conf 1.0e-9) 
      (max-count) 
      (/ 
        (* $conf 
          (lookahead)) 
        (- 1.0 $conf))))
</span>;;;; Increment the negative count of a given truth value, by
;;;; incrementing its total count without incrementing the positive
;;;; count.
<span class="ansi38-255165000"
>  (: inc-neg-count 
    (-> TruthValue TruthValue))
</span><span class="ansi38-255165000"
>  (= 
    (inc-neg-count (STV $s $c)) 
    (let* 
      ( ($tot_cnt (confidence->count $c)) 
        ($pos_cnt (* $s $tot_cnt)) 
        ($new_tot_cnt (+ $tot_cnt 1))) 
      (STV 
        (/ $pos_cnt $new_tot_cnt) 
        (count->confidence $new_tot_cnt))))
</span>;;;; Increment the positive count of a given truth value, by
;;;; incrementing its total count and its positive count.
<span class="ansi38-255165000"
>  (: inc-pos-count 
    (-> TruthValue TruthValue))
</span><span class="ansi38-255165000"
>  (= 
    (inc-pos-count (STV $s $c)) 
    (let* 
      ( ($tot_cnt (confidence->count $c)) 
        ($pos_cnt (* $s $tot_cnt)) 
        ($new_pos_cnt (+ $pos_cnt 1)) 
        ($new_tot_cnt (+ $tot_cnt 1))) 
      (STV 
        (/ $new_pos_cnt $new_tot_cnt) 
        (count->confidence $new_tot_cnt))))
</span>;;;; Return the first order probability mode of the second order
;;;; distribution associated to a truth value.
<span class="ansi38-255165000"
>  (: mode 
    (-> TruthValue Number))
</span><span class="ansi38-255165000"
>  (= 
    (mode (Bl True)) 1.0)
</span><span class="ansi38-255165000"
>  (= 
    (mode (Bl False)) 0.0)
</span><span class="ansi38-255165000"
>  (= 
    (mode (Pr $pr)) $pr)
</span><span class="ansi38-255165000"
>  (= 
    (mode (STV $pr $)) $pr)
</span>;;;; Return the total count of a truth value.  For truth values not
;;;; capturing a notion of confidence, such as Bl or Pr then the count
;;;; is assumed to be a very large number (cause +inf does not seem to
;;;; be supported at the moment).
<span class="ansi38-255165000"
>  (: count 
    (-> TruthValue Number))
</span><span class="ansi38-255165000"
>  (= 
    (count (Bl $)) 
    (max-count))
</span><span class="ansi38-255165000"
>  (= 
    (count (Pr $)) 
    (max-count))
</span><span class="ansi38-255165000"
>  (= 
    (count (STV $ $conf)) 
    (confidence->count $conf))
</span>;;;; Return the confidence of a truth value.  For truth values not
;;;; capturing a notion of confidence, such as Bl or Pr then the
;;;; confidence is assumed to be 1.0.  For truth values capturing a
;;;; notion of confidence, such as STV, the formula to convert a count
;;;; into confidence is as follows
;;;;
;;;; confidence = count / (count + lookahead)
<span class="ansi38-255165000"
>  (: confidence 
    (-> TruthValue Number))
</span><span class="ansi38-255165000"
>  (= 
    (confidence (Bl $)) 1.0)
</span><span class="ansi38-255165000"
>  (= 
    (confidence (Pr $)) 1.0)
</span><span class="ansi38-255165000"
>  (= 
    (confidence (STV $ $conf)) $conf)
</span>;;;; Return the positive count of a truth value.
<span class="ansi38-255165000"
>  (: pos-count 
    (-> TruthValue Number))
</span><span class="ansi38-255165000"
>  (= 
    (pos-count $tv) 
    (* 
      (mode $tv) 
      (count $tv)))
</span>;;;; Return the negative count of a truth value.
<span class="ansi38-255165000"
>  (: neg-count 
    (-> TruthValue Number))
</span><span class="ansi38-255165000"
>  (= 
    (neg-count $tv) 
    (* 
      (- 1 
        (mode $tv)) 
      (count $tv)))
</span>;;;; Return the posterior alpha of a truth value
<span class="ansi38-255165000"
>  (: post-alpha 
    (-> TruthValue Number))
</span><span class="ansi38-255165000"
>  (= 
    (post-alpha $tv) 
    (+ 
      (prior-alpha) 
      (pos-count $tv)))
</span>;;;; Return the posterior beta of a truth value
<span class="ansi38-255165000"
>  (: post-beta 
    (-> TruthValue Number))
</span><span class="ansi38-255165000"
>  (= 
    (post-beta $tv) 
    (+ 
      (prior-beta) 
      (neg-count $tv)))
</span>;;;; Return the first order probability mean of the second order
;;;; distribution associated to a truth value.  For truth values not
;;;; capturing a notion of confidence, such as Bl or Pr then the
;;;; confidence is assumed to be 1.0.  For truth values capturing a
;;;; notion of confidence, such as STV, a beta distribution is assumed.
<span class="ansi38-255165000"
>  (: mean 
    (-> TruthValue Number))
</span><span class="ansi38-255165000"
>  (= 
    (mean (Bl True)) 1.0)
</span><span class="ansi38-255165000"
>  (= 
    (mean (Bl False)) 0.0)
</span><span class="ansi38-255165000"
>  (= 
    (mean (Pr $pr)) $pr)
</span><span class="ansi38-255165000"
>  (= 
    (mean (STV $pr $conf)) 
    (let* 
      ( ($a (post-alpha (STV $pr $conf))) ($b (post-beta (STV $pr $conf)))) 
      (/ $a 
        (+ $a $b))))
</span>;;;; Truth value type definition
;;;; Import modules
<span class="ansi38-013099040"
>  !(import! &self ../Num.metta)

</span>P;HTML|
;                                           (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/Num.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/Num.metta)
P;HTML|
;                                           (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/Num.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/Num.metta)

;;;; Collection of functions operating on numbers
;;;; Define max
<span class="ansi38-255165000"
>  (: max 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (max $x $y) 
    (if 
      (> $x $y) $x $y))
</span>;;;; Define min
<span class="ansi38-255165000"
>  (: min 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (min $x $y) 
    (if 
      (< $x $y) $x $y))
</span>;;;; Clamp a number to be within a certain range
<span class="ansi38-255165000"
>  (: clamp 
    (-> $a $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (clamp $x $l $u) 
    (max $l 
      (min $u $x)))
</span>;;;; Define abs
<span class="ansi38-255165000"
>  (: abs 
    (-> $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (abs $x) 
    (if 
      (< $x 0) 
      (* -1 $x) $x))
</span>;;;; Define <=
<span class="ansi38-255165000"
>  (: <= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (<= $x $y) 
    (or 
      (< $x $y) 
      (== $x $y)))
</span>;;;; Define >=
<span class="ansi38-255165000"
>  (: >= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (>= $x $y) 
    (or 
      (> $x $y) 
      (== $x $y)))
</span>;;;; Define approximately equal
<span class="ansi38-255165000"
>  (: approxEq 
    (-> $a $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (approxEq $x $y $epsilon) 
    (<= 
      (abs (- $x $y)) $epsilon))
</span>;;;; Define Nat
<span class="ansi38-255165000"
>  (: Nat Type)
</span><span class="ansi38-255165000"
>  (: Z Nat)
</span><span class="ansi38-255165000"
>  (: S 
    (-> Nat Nat))
</span>;;;; Define cast functions between Nat and Number
<span class="ansi38-255165000"
>  (: fromNumber 
    (-> Number Nat))
</span><span class="ansi38-255165000"
>  (= 
    (fromNumber $n) 
    (if 
      (<= $n 0) Z 
      (S (fromNumber (- $n 1)))))
</span><span class="ansi38-255165000"
>  (: fromNat 
    (-> Nat Number))
</span><span class="ansi38-255165000"
>  (= 
    (fromNat Z) 0)
</span><span class="ansi38-255165000"
>  (= 
    (fromNat (S $k)) 
    (+ 1 
      (fromNat $k)))
</span>;;;; Define a generic less than operator, ⩻, for Nat.  < cannot be used
;;;; because it is a built-in, its type is hardwired and cannot be
;;;; overloaded.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Nat Nat Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $ Z) False)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ Z 
      (S $)) True)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ 
      (S $x) 
      (S $y)) 
    (⩻ $x $y))
</span>;;;; Overload ⩻ for Number.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Number Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $x $y) 
    (< $x $y))
</span>;;;; Return the ceiling of a non negative number.  If the number is
;;;; negative it returns 1.
<span class="ansi38-255165000"
>  (: ceil 
    (-> Number Number))
</span><span class="ansi38-255165000"
>  (= 
    (ceil $n) 
    (fromNat (fromNumber $n)))
</span>;;;; Convert Number to Bool.  Anything above 0 converts to True.
<span class="ansi38-255165000"
>  (: number->bool 
    (-> Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (number->bool $x) 
    (< 0 $x))
</span>;;;; Convert Bool to Number.  False converts to 0, True converts to 1.
<span class="ansi38-255165000"
>  (: bool->number 
    (-> Bool Number))
</span><span class="ansi38-255165000"
>  (= 
    (bool->number False) 0)
</span><span class="ansi38-255165000"
>  (= 
    (bool->number True) 1)
</span>;;;; Define a less than type.  Note that it is purposefully different
;;;; than ⩻ as it is a type, not an operator.  Inhabitants of (⍃ x y)
;;;; are proofs that x ⩻ y == True.  For now ⍃ is only axiomatized for
;;;; Nat.
<span class="ansi38-255165000"
>  (: ⍃ 
    (-> $t $t Type))
</span>;;;; Zero is always less than the successor of something
<span class="ansi38-255165000"
>  (: 
    (zero-lt-succ-axiom) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (zero-lt-succ-axiom) 
    (: ZeroLTSucc 
      (⍃ Z 
        (S $k))))
</span>;;;; If x ⍃ y then (S x) ⍃ (S y)
<span class="ansi38-255165000"
>  (: 
    (succ-monotonicity-rule) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (succ-monotonicity-rule) 
    (: SuccMonotonicity 
      (-> 
        (⍃ $x $y) 
        (⍃ 
          (S $x) 
          (S $y)))))
</span>;;;; Collection of functions operating on numbers
;;;; Define max
<span class="ansi38-255165000"
>  (: max 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (max $x $y) 
    (if 
      (> $x $y) $x $y))
</span>;;;; Define min
<span class="ansi38-255165000"
>  (: min 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (min $x $y) 
    (if 
      (< $x $y) $x $y))
</span>;;;; Clamp a number to be within a certain range
<span class="ansi38-255165000"
>  (: clamp 
    (-> $a $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (clamp $x $l $u) 
    (max $l 
      (min $u $x)))
</span>;;;; Define abs
<span class="ansi38-255165000"
>  (: abs 
    (-> $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (abs $x) 
    (if 
      (< $x 0) 
      (* -1 $x) $x))
</span>;;;; Define <=
<span class="ansi38-255165000"
>  (: <= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (<= $x $y) 
    (or 
      (< $x $y) 
      (== $x $y)))
</span>;;;; Define >=
<span class="ansi38-255165000"
>  (: >= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (>= $x $y) 
    (or 
      (> $x $y) 
      (== $x $y)))
</span>;;;; Define approximately equal
<span class="ansi38-255165000"
>  (: approxEq 
    (-> $a $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (approxEq $x $y $epsilon) 
    (<= 
      (abs (- $x $y)) $epsilon))
</span>;;;; Define Nat
<span class="ansi38-255165000"
>  (: Nat Type)
</span><span class="ansi38-255165000"
>  (: Z Nat)
</span><span class="ansi38-255165000"
>  (: S 
    (-> Nat Nat))
</span>;;;; Define cast functions between Nat and Number
<span class="ansi38-255165000"
>  (: fromNumber 
    (-> Number Nat))
</span><span class="ansi38-255165000"
>  (= 
    (fromNumber $n) 
    (if 
      (<= $n 0) Z 
      (S (fromNumber (- $n 1)))))
</span><span class="ansi38-255165000"
>  (: fromNat 
    (-> Nat Number))
</span><span class="ansi38-255165000"
>  (= 
    (fromNat Z) 0)
</span><span class="ansi38-255165000"
>  (= 
    (fromNat (S $k)) 
    (+ 1 
      (fromNat $k)))
</span>;;;; Define a generic less than operator, ⩻, for Nat.  < cannot be used
;;;; because it is a built-in, its type is hardwired and cannot be
;;;; overloaded.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Nat Nat Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $ Z) False)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ Z 
      (S $)) True)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ 
      (S $x) 
      (S $y)) 
    (⩻ $x $y))
</span>;;;; Overload ⩻ for Number.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Number Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $x $y) 
    (< $x $y))
</span>;;;; Return the ceiling of a non negative number.  If the number is
;;;; negative it returns 1.
<span class="ansi38-255165000"
>  (: ceil 
    (-> Number Number))
</span><span class="ansi38-255165000"
>  (= 
    (ceil $n) 
    (fromNat (fromNumber $n)))
</span>;;;; Convert Number to Bool.  Anything above 0 converts to True.
<span class="ansi38-255165000"
>  (: number->bool 
    (-> Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (number->bool $x) 
    (< 0 $x))
</span>;;;; Convert Bool to Number.  False converts to 0, True converts to 1.
<span class="ansi38-255165000"
>  (: bool->number 
    (-> Bool Number))
</span><span class="ansi38-255165000"
>  (= 
    (bool->number False) 0)
</span><span class="ansi38-255165000"
>  (= 
    (bool->number True) 1)
</span>;;;; Define a less than type.  Note that it is purposefully different
;;;; than ⩻ as it is a type, not an operator.  Inhabitants of (⍃ x y)
;;;; are proofs that x ⩻ y == True.  For now ⍃ is only axiomatized for
;;;; Nat.
<span class="ansi38-255165000"
>  (: ⍃ 
    (-> $t $t Type))
</span>;;;; Zero is always less than the successor of something
<span class="ansi38-255165000"
>  (: 
    (zero-lt-succ-axiom) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (zero-lt-succ-axiom) 
    (: ZeroLTSucc 
      (⍃ Z 
        (S $k))))
</span>;;;; If x ⍃ y then (S x) ⍃ (S y)
<span class="ansi38-255165000"
>  (: 
    (succ-monotonicity-rule) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (succ-monotonicity-rule) 
    (: SuccMonotonicity 
      (-> 
        (⍃ $x $y) 
        (⍃ 
          (S $x) 
          (S $y)))))
</span>;;;; Collection of functions operating on numbers
;;;; Define max
<span class="ansi38-255165000"
>  (: max 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (max $x $y) 
    (if 
      (> $x $y) $x $y))
</span>;;;; Define min
<span class="ansi38-255165000"
>  (: min 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (min $x $y) 
    (if 
      (< $x $y) $x $y))
</span>;;;; Clamp a number to be within a certain range
<span class="ansi38-255165000"
>  (: clamp 
    (-> $a $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (clamp $x $l $u) 
    (max $l 
      (min $u $x)))
</span>;;;; Define abs
<span class="ansi38-255165000"
>  (: abs 
    (-> $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (abs $x) 
    (if 
      (< $x 0) 
      (* -1 $x) $x))
</span>;;;; Define <=
<span class="ansi38-255165000"
>  (: <= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (<= $x $y) 
    (or 
      (< $x $y) 
      (== $x $y)))
</span>;;;; Define >=
<span class="ansi38-255165000"
>  (: >= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (>= $x $y) 
    (or 
      (> $x $y) 
      (== $x $y)))
</span>;;;; Define approximately equal
<span class="ansi38-255165000"
>  (: approxEq 
    (-> $a $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (approxEq $x $y $epsilon) 
    (<= 
      (abs (- $x $y)) $epsilon))
</span>;;;; Define Nat
<span class="ansi38-255165000"
>  (: Nat Type)
</span><span class="ansi38-255165000"
>  (: Z Nat)
</span><span class="ansi38-255165000"
>  (: S 
    (-> Nat Nat))
</span>;;;; Define cast functions between Nat and Number
<span class="ansi38-255165000"
>  (: fromNumber 
    (-> Number Nat))
</span><span class="ansi38-255165000"
>  (= 
    (fromNumber $n) 
    (if 
      (<= $n 0) Z 
      (S (fromNumber (- $n 1)))))
</span><span class="ansi38-255165000"
>  (: fromNat 
    (-> Nat Number))
</span><span class="ansi38-255165000"
>  (= 
    (fromNat Z) 0)
</span><span class="ansi38-255165000"
>  (= 
    (fromNat (S $k)) 
    (+ 1 
      (fromNat $k)))
</span>;;;; Define a generic less than operator, ⩻, for Nat.  < cannot be used
;;;; because it is a built-in, its type is hardwired and cannot be
;;;; overloaded.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Nat Nat Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $ Z) False)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ Z 
      (S $)) True)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ 
      (S $x) 
      (S $y)) 
    (⩻ $x $y))
</span>;;;; Overload ⩻ for Number.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Number Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $x $y) 
    (< $x $y))
</span>;;;; Return the ceiling of a non negative number.  If the number is
;;;; negative it returns 1.
<span class="ansi38-255165000"
>  (: ceil 
    (-> Number Number))
</span><span class="ansi38-255165000"
>  (= 
    (ceil $n) 
    (fromNat (fromNumber $n)))
</span>;;;; Convert Number to Bool.  Anything above 0 converts to True.
<span class="ansi38-255165000"
>  (: number->bool 
    (-> Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (number->bool $x) 
    (< 0 $x))
</span>;;;; Convert Bool to Number.  False converts to 0, True converts to 1.
<span class="ansi38-255165000"
>  (: bool->number 
    (-> Bool Number))
</span><span class="ansi38-255165000"
>  (= 
    (bool->number False) 0)
</span><span class="ansi38-255165000"
>  (= 
    (bool->number True) 1)
</span>;;;; Define a less than type.  Note that it is purposefully different
;;;; than ⩻ as it is a type, not an operator.  Inhabitants of (⍃ x y)
;;;; are proofs that x ⩻ y == True.  For now ⍃ is only axiomatized for
;;;; Nat.
<span class="ansi38-255165000"
>  (: ⍃ 
    (-> $t $t Type))
</span>;;;; Zero is always less than the successor of something
<span class="ansi38-255165000"
>  (: 
    (zero-lt-succ-axiom) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (zero-lt-succ-axiom) 
    (: ZeroLTSucc 
      (⍃ Z 
        (S $k))))
</span>;;;; If x ⍃ y then (S x) ⍃ (S y)
<span class="ansi38-255165000"
>  (: 
    (succ-monotonicity-rule) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (succ-monotonicity-rule) 
    (: SuccMonotonicity 
      (-> 
        (⍃ $x $y) 
        (⍃ 
          (S $x) 
          (S $y)))))
</span>;;;; Collection of functions operating on numbers
;;;; Define max
<span class="ansi38-255165000"
>  (: max 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (max $x $y) 
    (if 
      (> $x $y) $x $y))
</span>;;;; Define min
<span class="ansi38-255165000"
>  (: min 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (min $x $y) 
    (if 
      (< $x $y) $x $y))
</span>;;;; Clamp a number to be within a certain range
<span class="ansi38-255165000"
>  (: clamp 
    (-> $a $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (clamp $x $l $u) 
    (max $l 
      (min $u $x)))
</span>;;;; Define abs
<span class="ansi38-255165000"
>  (: abs 
    (-> $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (abs $x) 
    (if 
      (< $x 0) 
      (* -1 $x) $x))
</span>;;;; Define <=
<span class="ansi38-255165000"
>  (: <= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (<= $x $y) 
    (or 
      (< $x $y) 
      (== $x $y)))
</span>;;;; Define >=
<span class="ansi38-255165000"
>  (: >= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (>= $x $y) 
    (or 
      (> $x $y) 
      (== $x $y)))
</span>;;;; Define approximately equal
<span class="ansi38-255165000"
>  (: approxEq 
    (-> $a $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (approxEq $x $y $epsilon) 
    (<= 
      (abs (- $x $y)) $epsilon))
</span>;;;; Define Nat
<span class="ansi38-255165000"
>  (: Nat Type)
</span><span class="ansi38-255165000"
>  (: Z Nat)
</span><span class="ansi38-255165000"
>  (: S 
    (-> Nat Nat))
</span>;;;; Define cast functions between Nat and Number
<span class="ansi38-255165000"
>  (: fromNumber 
    (-> Number Nat))
</span><span class="ansi38-255165000"
>  (= 
    (fromNumber $n) 
    (if 
      (<= $n 0) Z 
      (S (fromNumber (- $n 1)))))
</span><span class="ansi38-255165000"
>  (: fromNat 
    (-> Nat Number))
</span><span class="ansi38-255165000"
>  (= 
    (fromNat Z) 0)
</span><span class="ansi38-255165000"
>  (= 
    (fromNat (S $k)) 
    (+ 1 
      (fromNat $k)))
</span>;;;; Define a generic less than operator, ⩻, for Nat.  < cannot be used
;;;; because it is a built-in, its type is hardwired and cannot be
;;;; overloaded.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Nat Nat Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $ Z) False)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ Z 
      (S $)) True)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ 
      (S $x) 
      (S $y)) 
    (⩻ $x $y))
</span>;;;; Overload ⩻ for Number.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Number Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $x $y) 
    (< $x $y))
</span>;;;; Return the ceiling of a non negative number.  If the number is
;;;; negative it returns 1.
<span class="ansi38-255165000"
>  (: ceil 
    (-> Number Number))
</span><span class="ansi38-255165000"
>  (= 
    (ceil $n) 
    (fromNat (fromNumber $n)))
</span>;;;; Convert Number to Bool.  Anything above 0 converts to True.
<span class="ansi38-255165000"
>  (: number->bool 
    (-> Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (number->bool $x) 
    (< 0 $x))
</span>;;;; Convert Bool to Number.  False converts to 0, True converts to 1.
<span class="ansi38-255165000"
>  (: bool->number 
    (-> Bool Number))
</span><span class="ansi38-255165000"
>  (= 
    (bool->number False) 0)
</span><span class="ansi38-255165000"
>  (= 
    (bool->number True) 1)
</span>;;;; Define a less than type.  Note that it is purposefully different
;;;; than ⩻ as it is a type, not an operator.  Inhabitants of (⍃ x y)
;;;; are proofs that x ⩻ y == True.  For now ⍃ is only axiomatized for
;;;; Nat.
<span class="ansi38-255165000"
>  (: ⍃ 
    (-> $t $t Type))
</span>;;;; Zero is always less than the successor of something
<span class="ansi38-255165000"
>  (: 
    (zero-lt-succ-axiom) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (zero-lt-succ-axiom) 
    (: ZeroLTSucc 
      (⍃ Z 
        (S $k))))
</span>;;;; If x ⍃ y then (S x) ⍃ (S y)
<span class="ansi38-255165000"
>  (: 
    (succ-monotonicity-rule) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (succ-monotonicity-rule) 
    (: SuccMonotonicity 
      (-> 
        (⍃ $x $y) 
        (⍃ 
          (S $x) 
          (S $y)))))
</span>
Deterministic: ()
;;;;;;;;;;;;
;;;; Type ;;
;;;;;;;;;;;;
<span class="ansi38-255165000"
>  (: TruthValue Type)
</span>;;;;;;;;;;;;;;;;;;;;
;;;; Constructors ;;
;;;;;;;;;;;;;;;;;;;;
;;;; Boolean TV constructor
;;;; TODO: alternatively we could have (: ⊤ TruthValue) and (: ⊥ TruthValue)
<span class="ansi38-255165000"
>  (: Bl 
    (-> Bool TruthValue))
</span>;;;; First order probability TV constructor, i.e. mere probability.
<span class="ansi38-255165000"
>  (: Pr 
    (-> Number TruthValue))
</span>;;;; Simple Truth Value.  A Second order probability TV constructor,
;;;; i.e. probability and confidence.  The probability is in fact the
;;;; mode of the corresponding beta distribution.
<span class="ansi38-255165000"
>  (: STV 
    (-> Number Number TruthValue))
</span>;;;;;;;;;;;;;;;;;
;;;; Constants ;;
;;;;;;;;;;;;;;;;;
;;;; For now the underlying beta distributions have a Jeffreys prior,
;;;; i.e. the prior alpha and beta are 0.5.
<span class="ansi38-255165000"
>  (: prior-alpha 
    (-> Number))
</span><span class="ansi38-255165000"
>  (= 
    (prior-alpha) 0.5)
</span><span class="ansi38-255165000"
>  (: prior-beta 
    (-> Number))
</span><span class="ansi38-255165000"
>  (= 
    (prior-beta) 0.5)
</span>;;;; Lookahead
<span class="ansi38-255165000"
>  (: lookahead 
    (-> Number))
</span><span class="ansi38-255165000"
>  (= 
    (lookahead) 1.0)
</span>;;;; Maximum supported count (till +inf is supported, possibly).
<span class="ansi38-255165000"
>  (: max-count 
    (-> Number))
</span><span class="ansi38-255165000"
>  (= 
    (max-count) 1000000000.0)
</span>;;;;;;;;;;;;;;;
;;;; Methods ;;
;;;;;;;;;;;;;;;
;;;; Convert count to confidence using the formula
;;;;
;;;; confidence = count / (count + lookahead)
<span class="ansi38-255165000"
>  (: count->confidence 
    (-> Number Number))
</span><span class="ansi38-255165000"
>  (= 
    (count->confidence $cnt) 
    (/ $cnt 
      (+ $cnt 
        (lookahead))))
</span>;;;; Convert confidence to count using the formula
;;;;
;;;; count = (confidence * lookahead) / (1 - confidence)
<span class="ansi38-255165000"
>  (: confidence->count 
    (-> Number Number))
</span><span class="ansi38-255165000"
>  (= 
    (confidence->count $conf) 
    (if 
      (approxEq 1.0 $conf 1.0e-9) 
      (max-count) 
      (/ 
        (* $conf 
          (lookahead)) 
        (- 1.0 $conf))))
</span>;;;; Increment the negative count of a given truth value, by
;;;; incrementing its total count without incrementing the positive
;;;; count.
<span class="ansi38-255165000"
>  (: inc-neg-count 
    (-> TruthValue TruthValue))
</span><span class="ansi38-255165000"
>  (= 
    (inc-neg-count (STV $s $c)) 
    (let* 
      ( ($tot_cnt (confidence->count $c)) 
        ($pos_cnt (* $s $tot_cnt)) 
        ($new_tot_cnt (+ $tot_cnt 1))) 
      (STV 
        (/ $pos_cnt $new_tot_cnt) 
        (count->confidence $new_tot_cnt))))
</span>;;;; Increment the positive count of a given truth value, by
;;;; incrementing its total count and its positive count.
<span class="ansi38-255165000"
>  (: inc-pos-count 
    (-> TruthValue TruthValue))
</span><span class="ansi38-255165000"
>  (= 
    (inc-pos-count (STV $s $c)) 
    (let* 
      ( ($tot_cnt (confidence->count $c)) 
        ($pos_cnt (* $s $tot_cnt)) 
        ($new_pos_cnt (+ $pos_cnt 1)) 
        ($new_tot_cnt (+ $tot_cnt 1))) 
      (STV 
        (/ $new_pos_cnt $new_tot_cnt) 
        (count->confidence $new_tot_cnt))))
</span>;;;; Return the first order probability mode of the second order
;;;; distribution associated to a truth value.
<span class="ansi38-255165000"
>  (: mode 
    (-> TruthValue Number))
</span><span class="ansi38-255165000"
>  (= 
    (mode (Bl True)) 1.0)
</span><span class="ansi38-255165000"
>  (= 
    (mode (Bl False)) 0.0)
</span><span class="ansi38-255165000"
>  (= 
    (mode (Pr $pr)) $pr)
</span><span class="ansi38-255165000"
>  (= 
    (mode (STV $pr $)) $pr)
</span>;;;; Return the total count of a truth value.  For truth values not
;;;; capturing a notion of confidence, such as Bl or Pr then the count
;;;; is assumed to be a very large number (cause +inf does not seem to
;;;; be supported at the moment).
<span class="ansi38-255165000"
>  (: count 
    (-> TruthValue Number))
</span><span class="ansi38-255165000"
>  (= 
    (count (Bl $)) 
    (max-count))
</span><span class="ansi38-255165000"
>  (= 
    (count (Pr $)) 
    (max-count))
</span><span class="ansi38-255165000"
>  (= 
    (count (STV $ $conf)) 
    (confidence->count $conf))
</span>;;;; Return the confidence of a truth value.  For truth values not
;;;; capturing a notion of confidence, such as Bl or Pr then the
;;;; confidence is assumed to be 1.0.  For truth values capturing a
;;;; notion of confidence, such as STV, the formula to convert a count
;;;; into confidence is as follows
;;;;
;;;; confidence = count / (count + lookahead)
<span class="ansi38-255165000"
>  (: confidence 
    (-> TruthValue Number))
</span><span class="ansi38-255165000"
>  (= 
    (confidence (Bl $)) 1.0)
</span><span class="ansi38-255165000"
>  (= 
    (confidence (Pr $)) 1.0)
</span><span class="ansi38-255165000"
>  (= 
    (confidence (STV $ $conf)) $conf)
</span>;;;; Return the positive count of a truth value.
<span class="ansi38-255165000"
>  (: pos-count 
    (-> TruthValue Number))
</span><span class="ansi38-255165000"
>  (= 
    (pos-count $tv) 
    (* 
      (mode $tv) 
      (count $tv)))
</span>;;;; Return the negative count of a truth value.
<span class="ansi38-255165000"
>  (: neg-count 
    (-> TruthValue Number))
</span><span class="ansi38-255165000"
>  (= 
    (neg-count $tv) 
    (* 
      (- 1 
        (mode $tv)) 
      (count $tv)))
</span>;;;; Return the posterior alpha of a truth value
<span class="ansi38-255165000"
>  (: post-alpha 
    (-> TruthValue Number))
</span><span class="ansi38-255165000"
>  (= 
    (post-alpha $tv) 
    (+ 
      (prior-alpha) 
      (pos-count $tv)))
</span>;;;; Return the posterior beta of a truth value
<span class="ansi38-255165000"
>  (: post-beta 
    (-> TruthValue Number))
</span><span class="ansi38-255165000"
>  (= 
    (post-beta $tv) 
    (+ 
      (prior-beta) 
      (neg-count $tv)))
</span>;;;; Return the first order probability mean of the second order
;;;; distribution associated to a truth value.  For truth values not
;;;; capturing a notion of confidence, such as Bl or Pr then the
;;;; confidence is assumed to be 1.0.  For truth values capturing a
;;;; notion of confidence, such as STV, a beta distribution is assumed.
<span class="ansi38-255165000"
>  (: mean 
    (-> TruthValue Number))
</span><span class="ansi38-255165000"
>  (= 
    (mean (Bl True)) 1.0)
</span><span class="ansi38-255165000"
>  (= 
    (mean (Bl False)) 0.0)
</span><span class="ansi38-255165000"
>  (= 
    (mean (Pr $pr)) $pr)
</span><span class="ansi38-255165000"
>  (= 
    (mean (STV $pr $conf)) 
    (let* 
      ( ($a (post-alpha (STV $pr $conf))) ($b (post-beta (STV $pr $conf)))) 
      (/ $a 
        (+ $a $b))))
</span>
Last Result(2): ()
;;;; Alternate implication direct introduction formula assuming Boolean
;;;; evidence.  Base case, meaning there is only one piece of evidence.
<span class="ansi38-255165000"
>  (: direct-introduction-base-formula 
    (-> Bool TruthValue))
</span><span class="ansi38-255165000"
>  (= 
    (direct-introduction-base-formula $qa) 
    (STV 
      (bool->number $qa) 
      (count->confidence 1)))
</span>;;;; Alternate implication direct introduction formula.  Inductive case,
;;;; meaning the piece of evidence gets aggregated to another truth
;;;; value.
<span class="ansi38-255165000"
>  (: direct-introduction-recursive-formula 
    (-> Bool TruthValue TruthValue))
</span><span class="ansi38-255165000"
>  (= 
    (direct-introduction-recursive-formula False 
      (STV $PQs $PQc)) 
    (inc-neg-count (STV $PQs $PQc)))
</span><span class="ansi38-255165000"
>  (= 
    (direct-introduction-recursive-formula True 
      (STV $PQs $PQc)) 
    (inc-pos-count (STV $PQs $PQc)))
</span>
Last Result(3): ()
;;;;;;;;;;;;;;;;;;;;;;;
;;;; Rule Definition ;;
;;;;;;;;;;;;;;;;;;;;;;;
;;;; All rules are implemented as constructors of propositions encoded
;;;; as types.
;;;; To deal with an abritrary number of pieces of evidence the rule is
;;;; defined inductively.
;;;; Base case (one piece of evidence):
;;;;
;;;; (p a) = True
;;;; (q a) = qa
;;;; ⊢
;;;; p→q ≞ (ETV (:: a ∅) tv)
;;;;
;;;; where tv is calculated according to the direct introduction
;;;; formula.  Note that we don't bother to take into account pieces of
;;;; evidence that is not True on (p a), because it has no impact on the
;;;; resulting truth value otherwise.
;;;;
;;;; To avoid prematurely reducing (p a) = pa to pa = pa, the following
;;;; representation is used instead
;;;;
;;;; (⊷ p a pa)
;;;;
;;;; which can be read as "under p, the image of a is pa".
;;;;
;;;; ⊷ is essentially the Atomese equivalent of ExecutionLink.  It has
;;;; description: IMAGE OF, hexadecimal code: 0x22B7, unicode-math code:
;;;; \imageof and latex code: \multimapdotbothB.
<span class="ansi38-255165000"
>  (: implication-direct-introduction-base-rule 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (implication-direct-introduction-base-rule) 
    (: IDIBase 
      (-> 
        (⊷ $p $a True) 
        (⊷ $q $a $qa) 
        (≞ 
          (→ $p $q) 
          (ETV 
            (:: $a ∅) 
            (direct-introduction-base-formula $qa))))))
</span>;;;; Recursive step (more than one piece of evidence):
;;;;
;;;; (p a) = True
;;;; (q a) = qa
;;;; p→q ≞ (ETV (:: h t) pqtv)
;;;; h < a
;;;; ⊢
;;;; p→q ≞ (ETV (:: a (:: h t)) tv)
;;;;
;;;; where tv is calculated using the direct introduction formula.  Note
;;;; that we don't bother to take into account pieces of evidence that
;;;; is not True on (p a), because it has no impact on the resulting
;;;; truth value otherwise.
;;;;
;;;; To avoid prematurely reducing (p a) = pa to pa = pa, the following
;;;; representation is used instead
;;;;
;;;; (⊷ p a pa)
;;;;
;;;; which can be read as "under p, the image of a is pa".
;;;;
;;;; For a similar reason, the premise h < a is represented as
;;;;
;;;; h ⍃ a
;;;;
;;;; ⍃ is the axiomatized version of <.  It is defined in Num.metta.
;;;; The box around the less than sign is here to manifest its
;;;; axiomatic, as opposed to computational, nature.  It has
;;;; description: APL FUNCTIONAL SYMBOL QUAD LESS-THAN and hexadecimal
;;;; code: 0x2343.
;;;;
;;;; The h ⍃ a premise is there to garanty that evidence is not double
;;;; counted.
;;;;
;;;; Historical note: initially the premise
;;;;
;;;; h ⍃ a
;;;;
;;;; was replaced by
;;;;
;;;; a ∉ (:: h t)
;;;;
;;;; But then it was realized that it is far more efficient to enforce
;;;; the order in which evidence can be pilled up, than to prove that a
;;;; new piece of evidence does not belongs to an existing evidence set.
;;;; And now you know why time is the way it is.
<span class="ansi38-255165000"
>  (: implication-direct-introduction-recursive-rule 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (implication-direct-introduction-recursive-rule) 
    (: IDIRecursive 
      (-> 
        (⊷ $p $a True) 
        (⊷ $q $a $qa) 
        (≞ 
          (→ $p $q) 
          (ETV 
            (:: $h $t) $pqtv)) 
        (⍃ $h $a) 
        (≞ 
          (→ $p $q) 
          (ETV 
            (:: $a 
              (:: $h $t)) 
            (direct-introduction-recursive-formula $qa $pqtv))))))
</span>;;;; Convert an EvidenceTruthValue to a TruthValue (i.e. elimate the
;;;; evidential part).
;;;;
;;;; (ETV evidence tv)
;;;; ⊢
;;;; tv
<span class="ansi38-255165000"
>  (: evidence-elimination-rule 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (evidence-elimination-rule) 
    (: EvidenceElimination 
      (-> 
        (≞ $a 
          (ETV $evidence $tv)) 
        (≞ $a $tv))))
</span>
Last Result(4): ()
()]
<span class="ansi38-013099040"
>  !(import! &self ../../synthesis/Synthesize.metta)

</span>[P;HTML|
;                                           (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/synthesis/Synthesize.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/synthesis/Synthesize.metta)
P;HTML|
;                                           (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/synthesis/Synthesize.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/synthesis/Synthesize.metta)

;;;; Import modules
<span class="ansi38-013099040"
>  !(import! &self ../common/Num.metta)

</span>P;HTML|
;                                           (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/Num.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/Num.metta)
P;HTML|
;                                           (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/Num.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/Num.metta)

;;;; Collection of functions operating on numbers
;;;; Define max
<span class="ansi38-255165000"
>  (: max 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (max $x $y) 
    (if 
      (> $x $y) $x $y))
</span>;;;; Define min
<span class="ansi38-255165000"
>  (: min 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (min $x $y) 
    (if 
      (< $x $y) $x $y))
</span>;;;; Clamp a number to be within a certain range
<span class="ansi38-255165000"
>  (: clamp 
    (-> $a $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (clamp $x $l $u) 
    (max $l 
      (min $u $x)))
</span>;;;; Define abs
<span class="ansi38-255165000"
>  (: abs 
    (-> $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (abs $x) 
    (if 
      (< $x 0) 
      (* -1 $x) $x))
</span>;;;; Define <=
<span class="ansi38-255165000"
>  (: <= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (<= $x $y) 
    (or 
      (< $x $y) 
      (== $x $y)))
</span>;;;; Define >=
<span class="ansi38-255165000"
>  (: >= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (>= $x $y) 
    (or 
      (> $x $y) 
      (== $x $y)))
</span>;;;; Define approximately equal
<span class="ansi38-255165000"
>  (: approxEq 
    (-> $a $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (approxEq $x $y $epsilon) 
    (<= 
      (abs (- $x $y)) $epsilon))
</span>;;;; Define Nat
<span class="ansi38-255165000"
>  (: Nat Type)
</span><span class="ansi38-255165000"
>  (: Z Nat)
</span><span class="ansi38-255165000"
>  (: S 
    (-> Nat Nat))
</span>;;;; Define cast functions between Nat and Number
<span class="ansi38-255165000"
>  (: fromNumber 
    (-> Number Nat))
</span><span class="ansi38-255165000"
>  (= 
    (fromNumber $n) 
    (if 
      (<= $n 0) Z 
      (S (fromNumber (- $n 1)))))
</span><span class="ansi38-255165000"
>  (: fromNat 
    (-> Nat Number))
</span><span class="ansi38-255165000"
>  (= 
    (fromNat Z) 0)
</span><span class="ansi38-255165000"
>  (= 
    (fromNat (S $k)) 
    (+ 1 
      (fromNat $k)))
</span>;;;; Define a generic less than operator, ⩻, for Nat.  < cannot be used
;;;; because it is a built-in, its type is hardwired and cannot be
;;;; overloaded.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Nat Nat Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $ Z) False)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ Z 
      (S $)) True)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ 
      (S $x) 
      (S $y)) 
    (⩻ $x $y))
</span>;;;; Overload ⩻ for Number.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Number Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $x $y) 
    (< $x $y))
</span>;;;; Return the ceiling of a non negative number.  If the number is
;;;; negative it returns 1.
<span class="ansi38-255165000"
>  (: ceil 
    (-> Number Number))
</span><span class="ansi38-255165000"
>  (= 
    (ceil $n) 
    (fromNat (fromNumber $n)))
</span>;;;; Convert Number to Bool.  Anything above 0 converts to True.
<span class="ansi38-255165000"
>  (: number->bool 
    (-> Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (number->bool $x) 
    (< 0 $x))
</span>;;;; Convert Bool to Number.  False converts to 0, True converts to 1.
<span class="ansi38-255165000"
>  (: bool->number 
    (-> Bool Number))
</span><span class="ansi38-255165000"
>  (= 
    (bool->number False) 0)
</span><span class="ansi38-255165000"
>  (= 
    (bool->number True) 1)
</span>;;;; Define a less than type.  Note that it is purposefully different
;;;; than ⩻ as it is a type, not an operator.  Inhabitants of (⍃ x y)
;;;; are proofs that x ⩻ y == True.  For now ⍃ is only axiomatized for
;;;; Nat.
<span class="ansi38-255165000"
>  (: ⍃ 
    (-> $t $t Type))
</span>;;;; Zero is always less than the successor of something
<span class="ansi38-255165000"
>  (: 
    (zero-lt-succ-axiom) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (zero-lt-succ-axiom) 
    (: ZeroLTSucc 
      (⍃ Z 
        (S $k))))
</span>;;;; If x ⍃ y then (S x) ⍃ (S y)
<span class="ansi38-255165000"
>  (: 
    (succ-monotonicity-rule) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (succ-monotonicity-rule) 
    (: SuccMonotonicity 
      (-> 
        (⍃ $x $y) 
        (⍃ 
          (S $x) 
          (S $y)))))
</span>;;;; Collection of functions operating on numbers
;;;; Define max
<span class="ansi38-255165000"
>  (: max 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (max $x $y) 
    (if 
      (> $x $y) $x $y))
</span>;;;; Define min
<span class="ansi38-255165000"
>  (: min 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (min $x $y) 
    (if 
      (< $x $y) $x $y))
</span>;;;; Clamp a number to be within a certain range
<span class="ansi38-255165000"
>  (: clamp 
    (-> $a $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (clamp $x $l $u) 
    (max $l 
      (min $u $x)))
</span>;;;; Define abs
<span class="ansi38-255165000"
>  (: abs 
    (-> $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (abs $x) 
    (if 
      (< $x 0) 
      (* -1 $x) $x))
</span>;;;; Define <=
<span class="ansi38-255165000"
>  (: <= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (<= $x $y) 
    (or 
      (< $x $y) 
      (== $x $y)))
</span>;;;; Define >=
<span class="ansi38-255165000"
>  (: >= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (>= $x $y) 
    (or 
      (> $x $y) 
      (== $x $y)))
</span>;;;; Define approximately equal
<span class="ansi38-255165000"
>  (: approxEq 
    (-> $a $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (approxEq $x $y $epsilon) 
    (<= 
      (abs (- $x $y)) $epsilon))
</span>;;;; Define Nat
<span class="ansi38-255165000"
>  (: Nat Type)
</span><span class="ansi38-255165000"
>  (: Z Nat)
</span><span class="ansi38-255165000"
>  (: S 
    (-> Nat Nat))
</span>;;;; Define cast functions between Nat and Number
<span class="ansi38-255165000"
>  (: fromNumber 
    (-> Number Nat))
</span><span class="ansi38-255165000"
>  (= 
    (fromNumber $n) 
    (if 
      (<= $n 0) Z 
      (S (fromNumber (- $n 1)))))
</span><span class="ansi38-255165000"
>  (: fromNat 
    (-> Nat Number))
</span><span class="ansi38-255165000"
>  (= 
    (fromNat Z) 0)
</span><span class="ansi38-255165000"
>  (= 
    (fromNat (S $k)) 
    (+ 1 
      (fromNat $k)))
</span>;;;; Define a generic less than operator, ⩻, for Nat.  < cannot be used
;;;; because it is a built-in, its type is hardwired and cannot be
;;;; overloaded.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Nat Nat Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $ Z) False)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ Z 
      (S $)) True)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ 
      (S $x) 
      (S $y)) 
    (⩻ $x $y))
</span>;;;; Overload ⩻ for Number.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Number Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $x $y) 
    (< $x $y))
</span>;;;; Return the ceiling of a non negative number.  If the number is
;;;; negative it returns 1.
<span class="ansi38-255165000"
>  (: ceil 
    (-> Number Number))
</span><span class="ansi38-255165000"
>  (= 
    (ceil $n) 
    (fromNat (fromNumber $n)))
</span>;;;; Convert Number to Bool.  Anything above 0 converts to True.
<span class="ansi38-255165000"
>  (: number->bool 
    (-> Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (number->bool $x) 
    (< 0 $x))
</span>;;;; Convert Bool to Number.  False converts to 0, True converts to 1.
<span class="ansi38-255165000"
>  (: bool->number 
    (-> Bool Number))
</span><span class="ansi38-255165000"
>  (= 
    (bool->number False) 0)
</span><span class="ansi38-255165000"
>  (= 
    (bool->number True) 1)
</span>;;;; Define a less than type.  Note that it is purposefully different
;;;; than ⩻ as it is a type, not an operator.  Inhabitants of (⍃ x y)
;;;; are proofs that x ⩻ y == True.  For now ⍃ is only axiomatized for
;;;; Nat.
<span class="ansi38-255165000"
>  (: ⍃ 
    (-> $t $t Type))
</span>;;;; Zero is always less than the successor of something
<span class="ansi38-255165000"
>  (: 
    (zero-lt-succ-axiom) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (zero-lt-succ-axiom) 
    (: ZeroLTSucc 
      (⍃ Z 
        (S $k))))
</span>;;;; If x ⍃ y then (S x) ⍃ (S y)
<span class="ansi38-255165000"
>  (: 
    (succ-monotonicity-rule) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (succ-monotonicity-rule) 
    (: SuccMonotonicity 
      (-> 
        (⍃ $x $y) 
        (⍃ 
          (S $x) 
          (S $y)))))
</span>;;;; Collection of functions operating on numbers
;;;; Define max
<span class="ansi38-255165000"
>  (: max 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (max $x $y) 
    (if 
      (> $x $y) $x $y))
</span>;;;; Define min
<span class="ansi38-255165000"
>  (: min 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (min $x $y) 
    (if 
      (< $x $y) $x $y))
</span>;;;; Clamp a number to be within a certain range
<span class="ansi38-255165000"
>  (: clamp 
    (-> $a $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (clamp $x $l $u) 
    (max $l 
      (min $u $x)))
</span>;;;; Define abs
<span class="ansi38-255165000"
>  (: abs 
    (-> $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (abs $x) 
    (if 
      (< $x 0) 
      (* -1 $x) $x))
</span>;;;; Define <=
<span class="ansi38-255165000"
>  (: <= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (<= $x $y) 
    (or 
      (< $x $y) 
      (== $x $y)))
</span>;;;; Define >=
<span class="ansi38-255165000"
>  (: >= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (>= $x $y) 
    (or 
      (> $x $y) 
      (== $x $y)))
</span>;;;; Define approximately equal
<span class="ansi38-255165000"
>  (: approxEq 
    (-> $a $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (approxEq $x $y $epsilon) 
    (<= 
      (abs (- $x $y)) $epsilon))
</span>;;;; Define Nat
<span class="ansi38-255165000"
>  (: Nat Type)
</span><span class="ansi38-255165000"
>  (: Z Nat)
</span><span class="ansi38-255165000"
>  (: S 
    (-> Nat Nat))
</span>;;;; Define cast functions between Nat and Number
<span class="ansi38-255165000"
>  (: fromNumber 
    (-> Number Nat))
</span><span class="ansi38-255165000"
>  (= 
    (fromNumber $n) 
    (if 
      (<= $n 0) Z 
      (S (fromNumber (- $n 1)))))
</span><span class="ansi38-255165000"
>  (: fromNat 
    (-> Nat Number))
</span><span class="ansi38-255165000"
>  (= 
    (fromNat Z) 0)
</span><span class="ansi38-255165000"
>  (= 
    (fromNat (S $k)) 
    (+ 1 
      (fromNat $k)))
</span>;;;; Define a generic less than operator, ⩻, for Nat.  < cannot be used
;;;; because it is a built-in, its type is hardwired and cannot be
;;;; overloaded.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Nat Nat Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $ Z) False)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ Z 
      (S $)) True)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ 
      (S $x) 
      (S $y)) 
    (⩻ $x $y))
</span>;;;; Overload ⩻ for Number.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Number Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $x $y) 
    (< $x $y))
</span>;;;; Return the ceiling of a non negative number.  If the number is
;;;; negative it returns 1.
<span class="ansi38-255165000"
>  (: ceil 
    (-> Number Number))
</span><span class="ansi38-255165000"
>  (= 
    (ceil $n) 
    (fromNat (fromNumber $n)))
</span>;;;; Convert Number to Bool.  Anything above 0 converts to True.
<span class="ansi38-255165000"
>  (: number->bool 
    (-> Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (number->bool $x) 
    (< 0 $x))
</span>;;;; Convert Bool to Number.  False converts to 0, True converts to 1.
<span class="ansi38-255165000"
>  (: bool->number 
    (-> Bool Number))
</span><span class="ansi38-255165000"
>  (= 
    (bool->number False) 0)
</span><span class="ansi38-255165000"
>  (= 
    (bool->number True) 1)
</span>;;;; Define a less than type.  Note that it is purposefully different
;;;; than ⩻ as it is a type, not an operator.  Inhabitants of (⍃ x y)
;;;; are proofs that x ⩻ y == True.  For now ⍃ is only axiomatized for
;;;; Nat.
<span class="ansi38-255165000"
>  (: ⍃ 
    (-> $t $t Type))
</span>;;;; Zero is always less than the successor of something
<span class="ansi38-255165000"
>  (: 
    (zero-lt-succ-axiom) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (zero-lt-succ-axiom) 
    (: ZeroLTSucc 
      (⍃ Z 
        (S $k))))
</span>;;;; If x ⍃ y then (S x) ⍃ (S y)
<span class="ansi38-255165000"
>  (: 
    (succ-monotonicity-rule) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (succ-monotonicity-rule) 
    (: SuccMonotonicity 
      (-> 
        (⍃ $x $y) 
        (⍃ 
          (S $x) 
          (S $y)))))
</span>;;;; Collection of functions operating on numbers
;;;; Define max
<span class="ansi38-255165000"
>  (: max 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (max $x $y) 
    (if 
      (> $x $y) $x $y))
</span>;;;; Define min
<span class="ansi38-255165000"
>  (: min 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (min $x $y) 
    (if 
      (< $x $y) $x $y))
</span>;;;; Clamp a number to be within a certain range
<span class="ansi38-255165000"
>  (: clamp 
    (-> $a $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (clamp $x $l $u) 
    (max $l 
      (min $u $x)))
</span>;;;; Define abs
<span class="ansi38-255165000"
>  (: abs 
    (-> $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (abs $x) 
    (if 
      (< $x 0) 
      (* -1 $x) $x))
</span>;;;; Define <=
<span class="ansi38-255165000"
>  (: <= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (<= $x $y) 
    (or 
      (< $x $y) 
      (== $x $y)))
</span>;;;; Define >=
<span class="ansi38-255165000"
>  (: >= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (>= $x $y) 
    (or 
      (> $x $y) 
      (== $x $y)))
</span>;;;; Define approximately equal
<span class="ansi38-255165000"
>  (: approxEq 
    (-> $a $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (approxEq $x $y $epsilon) 
    (<= 
      (abs (- $x $y)) $epsilon))
</span>;;;; Define Nat
<span class="ansi38-255165000"
>  (: Nat Type)
</span><span class="ansi38-255165000"
>  (: Z Nat)
</span><span class="ansi38-255165000"
>  (: S 
    (-> Nat Nat))
</span>;;;; Define cast functions between Nat and Number
<span class="ansi38-255165000"
>  (: fromNumber 
    (-> Number Nat))
</span><span class="ansi38-255165000"
>  (= 
    (fromNumber $n) 
    (if 
      (<= $n 0) Z 
      (S (fromNumber (- $n 1)))))
</span><span class="ansi38-255165000"
>  (: fromNat 
    (-> Nat Number))
</span><span class="ansi38-255165000"
>  (= 
    (fromNat Z) 0)
</span><span class="ansi38-255165000"
>  (= 
    (fromNat (S $k)) 
    (+ 1 
      (fromNat $k)))
</span>;;;; Define a generic less than operator, ⩻, for Nat.  < cannot be used
;;;; because it is a built-in, its type is hardwired and cannot be
;;;; overloaded.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Nat Nat Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $ Z) False)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ Z 
      (S $)) True)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ 
      (S $x) 
      (S $y)) 
    (⩻ $x $y))
</span>;;;; Overload ⩻ for Number.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Number Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $x $y) 
    (< $x $y))
</span>;;;; Return the ceiling of a non negative number.  If the number is
;;;; negative it returns 1.
<span class="ansi38-255165000"
>  (: ceil 
    (-> Number Number))
</span><span class="ansi38-255165000"
>  (= 
    (ceil $n) 
    (fromNat (fromNumber $n)))
</span>;;;; Convert Number to Bool.  Anything above 0 converts to True.
<span class="ansi38-255165000"
>  (: number->bool 
    (-> Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (number->bool $x) 
    (< 0 $x))
</span>;;;; Convert Bool to Number.  False converts to 0, True converts to 1.
<span class="ansi38-255165000"
>  (: bool->number 
    (-> Bool Number))
</span><span class="ansi38-255165000"
>  (= 
    (bool->number False) 0)
</span><span class="ansi38-255165000"
>  (= 
    (bool->number True) 1)
</span>;;;; Define a less than type.  Note that it is purposefully different
;;;; than ⩻ as it is a type, not an operator.  Inhabitants of (⍃ x y)
;;;; are proofs that x ⩻ y == True.  For now ⍃ is only axiomatized for
;;;; Nat.
<span class="ansi38-255165000"
>  (: ⍃ 
    (-> $t $t Type))
</span>;;;; Zero is always less than the successor of something
<span class="ansi38-255165000"
>  (: 
    (zero-lt-succ-axiom) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (zero-lt-succ-axiom) 
    (: ZeroLTSucc 
      (⍃ Z 
        (S $k))))
</span>;;;; If x ⍃ y then (S x) ⍃ (S y)
<span class="ansi38-255165000"
>  (: 
    (succ-monotonicity-rule) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (succ-monotonicity-rule) 
    (: SuccMonotonicity 
      (-> 
        (⍃ $x $y) 
        (⍃ 
          (S $x) 
          (S $y)))))
</span>;;;; Collection of functions operating on numbers
;;;; Define max
<span class="ansi38-255165000"
>  (: max 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (max $x $y) 
    (if 
      (> $x $y) $x $y))
</span>;;;; Define min
<span class="ansi38-255165000"
>  (: min 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (min $x $y) 
    (if 
      (< $x $y) $x $y))
</span>;;;; Clamp a number to be within a certain range
<span class="ansi38-255165000"
>  (: clamp 
    (-> $a $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (clamp $x $l $u) 
    (max $l 
      (min $u $x)))
</span>;;;; Define abs
<span class="ansi38-255165000"
>  (: abs 
    (-> $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (abs $x) 
    (if 
      (< $x 0) 
      (* -1 $x) $x))
</span>;;;; Define <=
<span class="ansi38-255165000"
>  (: <= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (<= $x $y) 
    (or 
      (< $x $y) 
      (== $x $y)))
</span>;;;; Define >=
<span class="ansi38-255165000"
>  (: >= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (>= $x $y) 
    (or 
      (> $x $y) 
      (== $x $y)))
</span>;;;; Define approximately equal
<span class="ansi38-255165000"
>  (: approxEq 
    (-> $a $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (approxEq $x $y $epsilon) 
    (<= 
      (abs (- $x $y)) $epsilon))
</span>;;;; Define Nat
<span class="ansi38-255165000"
>  (: Nat Type)
</span><span class="ansi38-255165000"
>  (: Z Nat)
</span><span class="ansi38-255165000"
>  (: S 
    (-> Nat Nat))
</span>;;;; Define cast functions between Nat and Number
<span class="ansi38-255165000"
>  (: fromNumber 
    (-> Number Nat))
</span><span class="ansi38-255165000"
>  (= 
    (fromNumber $n) 
    (if 
      (<= $n 0) Z 
      (S (fromNumber (- $n 1)))))
</span><span class="ansi38-255165000"
>  (: fromNat 
    (-> Nat Number))
</span><span class="ansi38-255165000"
>  (= 
    (fromNat Z) 0)
</span><span class="ansi38-255165000"
>  (= 
    (fromNat (S $k)) 
    (+ 1 
      (fromNat $k)))
</span>;;;; Define a generic less than operator, ⩻, for Nat.  < cannot be used
;;;; because it is a built-in, its type is hardwired and cannot be
;;;; overloaded.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Nat Nat Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $ Z) False)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ Z 
      (S $)) True)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ 
      (S $x) 
      (S $y)) 
    (⩻ $x $y))
</span>;;;; Overload ⩻ for Number.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Number Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $x $y) 
    (< $x $y))
</span>;;;; Return the ceiling of a non negative number.  If the number is
;;;; negative it returns 1.
<span class="ansi38-255165000"
>  (: ceil 
    (-> Number Number))
</span><span class="ansi38-255165000"
>  (= 
    (ceil $n) 
    (fromNat (fromNumber $n)))
</span>;;;; Convert Number to Bool.  Anything above 0 converts to True.
<span class="ansi38-255165000"
>  (: number->bool 
    (-> Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (number->bool $x) 
    (< 0 $x))
</span>;;;; Convert Bool to Number.  False converts to 0, True converts to 1.
<span class="ansi38-255165000"
>  (: bool->number 
    (-> Bool Number))
</span><span class="ansi38-255165000"
>  (= 
    (bool->number False) 0)
</span><span class="ansi38-255165000"
>  (= 
    (bool->number True) 1)
</span>;;;; Define a less than type.  Note that it is purposefully different
;;;; than ⩻ as it is a type, not an operator.  Inhabitants of (⍃ x y)
;;;; are proofs that x ⩻ y == True.  For now ⍃ is only axiomatized for
;;;; Nat.
<span class="ansi38-255165000"
>  (: ⍃ 
    (-> $t $t Type))
</span>;;;; Zero is always less than the successor of something
<span class="ansi38-255165000"
>  (: 
    (zero-lt-succ-axiom) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (zero-lt-succ-axiom) 
    (: ZeroLTSucc 
      (⍃ Z 
        (S $k))))
</span>;;;; If x ⍃ y then (S x) ⍃ (S y)
<span class="ansi38-255165000"
>  (: 
    (succ-monotonicity-rule) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (succ-monotonicity-rule) 
    (: SuccMonotonicity 
      (-> 
        (⍃ $x $y) 
        (⍃ 
          (S $x) 
          (S $y)))))
</span>
Deterministic: ()
;;;; !(import! &self Unify.metta)
;;;; Enumerate all programs up to a given depth that are consistent with
;;;; the query, using the given axiom non-deterministic functions and rules.
;;;;
;;;; The arguments are:
;;;;
;;;; $query: an Atom under the form (: TERM TYPE).  The atom may contain
;;;;         free variables within TERM and TYPE to form various sort of
;;;;         queries, such as:
;;;;         1. Backward chaining: (: $term (Inheritance $x Mammal))
;;;;         2. Forward chaining: (: ($rule $premise AXIOM) $type)
;;;;         3. Mixed chaining: (: ($rule $premise AXIOM) (Inheritance $x Mammal))
;;;;         4. Type checking: (: TERM TYPE)
;;;;         5. Type inference: (: TERM $type)
;;;;
;;;; $kb: a nullary function to axiom, to non-deterministically pick up
;;;;      an axiom.  An axiom is an Atom of the form (: TERM TYPE).
;;;;
;;;; $rb: a nullary function to rule, to non-deterministically pick up a
;;;;      rule.  A rule is a function mapping premises to conclusion,
;;;;      where premises and conclusion have the form (: TERM TYPE).
;;;;
;;;; $depth: a Nat representing the maximum depth of the generated
;;;;         programs.
;;;;
;;;; TODO: recurse over curried rules instead of duplicating code over
;;;; tuples.
<span class="ansi38-255165000"
>  (: synthesize 
    (-> $a 
      (-> $kt) 
      (-> $rt) Nat $a))
</span>;;;; Nullary rule (axiom)
<span class="ansi38-255165000"
>  (= 
    (synthesize $query $kb $rb $depth) 
    (let $query 
      ($kb) $query))
</span>;;;; Unary rule
<span class="ansi38-255165000"
>  (= 
    (synthesize $query $kb $rb 
      (S $k)) 
    (let* 
      ( ( (: $ructor 
            (-> $premise $conclusion)) ($rb)) 
        ( (: 
            ($ructor $proof) $conclusion) $query) 
        ( (: $proof $premise) (synthesize (: $proof $premise) $kb $rb $k))) $query))
</span>;;;; Binary rule
<span class="ansi38-255165000"
>  (= 
    (synthesize $query $kb $rb 
      (S $k)) 
    (let* 
      ( ( (: $ructor 
            (-> $premise1 $premise2 $conclusion)) ($rb)) 
        ( (: 
            ($ructor $proof1 $proof2) $conclusion) $query) 
        ( (: $proof1 $premise1) (synthesize (: $proof1 $premise1) $kb $rb $k)) 
        ( (: $proof2 $premise2) (synthesize (: $proof2 $premise2) $kb $rb $k))) $query))
</span>;;;; Trinary rule
<span class="ansi38-255165000"
>  (= 
    (synthesize $query $kb $rb 
      (S $k)) 
    (let* 
      ( ( (: $ructor 
            (-> $premise1 $premise2 $premise3 $conclusion)) ($rb)) 
        ( (: 
            ($ructor $proof1 $proof2 $proof3) $conclusion) $query) 
        ( (: $proof1 $premise1) (synthesize (: $proof1 $premise1) $kb $rb $k)) 
        ( (: $proof2 $premise2) (synthesize (: $proof2 $premise2) $kb $rb $k)) 
        ( (: $proof3 $premise3) (synthesize (: $proof3 $premise3) $kb $rb $k))) $query))
</span>;;;; Quaternary rule
<span class="ansi38-255165000"
>  (= 
    (synthesize $query $kb $rb 
      (S $k)) 
    (let* 
      ( ( (: $ructor 
            (-> $premise1 $premise2 $premise3 $premise4 $conclusion)) ($rb)) 
        ( (: 
            ($ructor $proof1 $proof2 $proof3 $proof4) $conclusion) $query) 
        ( (: $proof1 $premise1) (synthesize (: $proof1 $premise1) $kb $rb $k)) 
        ( (: $proof2 $premise2) (synthesize (: $proof2 $premise2) $kb $rb $k)) 
        ( (: $proof3 $premise3) (synthesize (: $proof3 $premise3) $kb $rb $k)) 
        ( (: $proof4 $premise4) (synthesize (: $proof4 $premise4) $kb $rb $k))) $query))
</span>;;;; Quintenary rule
<span class="ansi38-255165000"
>  (= 
    (synthesize $query $kb $rb 
      (S $k)) 
    (let* 
      ( ( (: $ructor 
            (-> $premise1 $premise2 $premise3 $premise4 $premise5 $conclusion)) ($rb)) 
        ( (: 
            ($ructor $proof1 $proof2 $proof3 $proof4 $proof5) $conclusion) $query) 
        ( (: $proof1 $premise1) (synthesize (: $proof1 $premise1) $kb $rb $k)) 
        ( (: $proof2 $premise2) (synthesize (: $proof2 $premise2) $kb $rb $k)) 
        ( (: $proof3 $premise3) (synthesize (: $proof3 $premise3) $kb $rb $k)) 
        ( (: $proof4 $premise4) (synthesize (: $proof4 $premise4) $kb $rb $k)) 
        ( (: $proof5 $premise5) (synthesize (: $proof5 $premise5) $kb $rb $k))) $query))
</span>
Last Result(2): ()
()]
;;;; Knowledge base
<span class="ansi38-255165000"
>  (: kb 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (kb) 
    (superpose ((: P2 (⊷ P (fromNumber 2) True)) (: Q2 (⊷ Q (fromNumber 2) False)) (: P3 (⊷ P (fromNumber 3) True)) (: Q3 (⊷ Q (fromNumber 3) True)) (: P5 (⊷ P (fromNumber 5) False)) (: Q5 (⊷ Q (fromNumber 5) True)) (: P7 (⊷ P (fromNumber 7) True)) (: Q7 (⊷ Q (fromNumber 7) True)))))
</span>;;;; Axioms are placed in the kb as well
<span class="ansi38-255165000"
>  (= 
    (kb) 
    (zero-lt-succ-axiom))
</span>;;;; Rule base
<span class="ansi38-255165000"
>  (: rb 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (rb) 
    (superpose ((succ-monotonicity-rule) (implication-direct-introduction-base-rule) (implication-direct-introduction-recursive-rule))))
</span>;;;; Test base rule (one piece of evidence)
;;;;
;;;; Build the following inference tree
;;;;
;;;; --------(P2)     --------(Q2)
;;;; (P 2) = ⊤        (Q 2) = ⊥
;;;; --------------------------(IDIBase)
;;;; P → Q ≞ ((:: 2 ∅), <0 0.5>)
<span class="ansi38-255165009"
>;; In file as:  
</span><span class="ansi1 ansi38-255238088"
>  !=====
</span>;; To unit test case:
<span class="ansi38-013099040"
>  !(assertEqualToResult ===== 
    ("===== Test base rule (built-in type checker) ====="))

</span>[

;<h3 id="DEPENDENT-TYPES.IMPLICATIONDIRECTINTRODUCTIONDTLTEST.01"
>;; DEPENDENT-TYPES.IMPLICATIONDIRECTINTRODUCTIONDTLTEST.01</h3>
; 
; EVAL TEST
; took 0.000017 secs. (16.50 microseconds) 

  !(assertEqualToResult ===== 
    ("===== Test base rule (built-in type checker) ====="))

<span class="ansi31"
>  (loonit_failureR  
    (equal_enough_for_test  
      (=====) 
      ("===== Test base rule (built-in type checker) =====")))
</span>
Deterministic: ((Error  (got  (=====)) (expected  ("===== Test base rule (built-in type checker) ====="))))
((Error  (got  (=====)) (expected  ("===== Test base rule (built-in type checker) ====="))))]
<span class="ansi38-255165000"
>  (: base_prf 
    (≞ 
      (→ P Q) 
      (ETV 
        (:: 
          (fromNumber 2) ∅) 
        (STV 0 
          (count->confidence 1)))))
</span><span class="ansi38-255165000"
>  (= base_prf IDIBase)
</span><span class="ansi38-255165009"
>;; In file as:  
</span><span class="ansi1 ansi38-255238088"
>  !(base_prf)
</span>;; To unit test case:
<span class="ansi38-013099040"
>  !(assertEqualToResult 
    (base_prf) 
    ( (base_prf)))

</span>[

;<h3 id="DEPENDENT-TYPES.IMPLICATIONDIRECTINTRODUCTIONDTLTEST.02"
>;; DEPENDENT-TYPES.IMPLICATIONDIRECTINTRODUCTIONDTLTEST.02</h3>
; 
; EVAL TEST
; took 0.000342 secs. (342.35 microseconds) 

  !(assertEqualToResult 
    (base_prf) 
    ( (base_prf)))

<span class="ansi36"
>  (loonit_success  
    (equal_enough_for_test  
      ( (base_prf)) 
      ( (base_prf))))
</span>
Deterministic: ()
()]
<span class="ansi38-255165009"
>;; In file as:  
</span><span class="ansi1 ansi38-255238088"
>  !(get-type base_prf)
</span>;; To unit test case:
<span class="ansi38-013099040"
>  !(assertEqualToResult 
    (get-type base_prf) 
    ( (≞ 
        (→ P Q) 
        (ETV 
          (:: 
            (S (S Z)) ∅) 
          (STV 0 0.5)))))

</span>[

;<h3 id="DEPENDENT-TYPES.IMPLICATIONDIRECTINTRODUCTIONDTLTEST.03"
>;; DEPENDENT-TYPES.IMPLICATIONDIRECTINTRODUCTIONDTLTEST.03</h3>
; 
; EVAL TEST
; took 0.010 secs. (9.87 milliseconds) 

  !(assertEqualToResult 
    (get-type base_prf) 
    ( (≞ 
        (→ P Q) 
        (ETV 
          (:: 
            (S (S Z)) ∅) 
          (STV 0 0.5)))))

<span class="ansi36"
>  (loonit_success  
    (equal_enough_for_test  
      ( (≞ 
          (→ P Q) 
          (ETV 
            (:: 
              (S (S Z)) ∅) 
            (STV 0 0.5))) (≞ (→ P Q) (ETV (:: (S (S Z)) ∅) (STV 0 0.5)))) 
      ( (≞ 
          (→ P Q) 
          (ETV 
            (:: 
              (S (S Z)) ∅) 
            (STV 0 0.5))))))
</span>
Deterministic: ()
()]
;;;; Test recursive rule
;;;;
;;;; Build the following inference tree
;;;;
;;;;                 --------(P2)     --------(Q2)
;;;;                 (P 2) = ⊤        (Q 2) = ⊥
;;;;                 --------------------------(IDIBase)
;;;;                 P → Q ≞ ((:: 2 ∅), <0 0.5>)
;;;;                              |               -----(ZeroLTSucc)
;;;;                              |               0 ⍃ 5
;;;;                              |               -----(SuccMonotonicity)
;;;;                              |               1 ⍃ 6
;;;; --------(P7)  --------(Q7)   |               -----(SuccMonotonicity)
;;;; (P 7) = ⊤     (Q 7) = ⊤      |               2 ⍃ 7
;;;; --------------------------------------------------(IDIRecursive)
;;;;           P → Q ≞ ((:: 7 (:: 2 ∅)), <0.5 0.6667>)
<span class="ansi38-255165009"
>;; In file as:  
</span><span class="ansi1 ansi38-255238088"
>  !=====
</span>;; To unit test case:
<span class="ansi38-013099040"
>  !(assertEqualToResult ===== 
    ("===== Test recursive rule (built-in type checker) ====="))

</span>[

;<h3 id="DEPENDENT-TYPES.IMPLICATIONDIRECTINTRODUCTIONDTLTEST.04"
>;; DEPENDENT-TYPES.IMPLICATIONDIRECTINTRODUCTIONDTLTEST.04</h3>
; 
; EVAL TEST
; took 0.000014 secs. (13.98 microseconds) 

  !(assertEqualToResult ===== 
    ("===== Test recursive rule (built-in type checker) ====="))

<span class="ansi31"
>  (loonit_failureR  
    (equal_enough_for_test  
      (=====) 
      ("===== Test recursive rule (built-in type checker) =====")))
</span>
Deterministic: ((Error  (got  (=====)) (expected  ("===== Test recursive rule (built-in type checker) ====="))))
((Error  (got  (=====)) (expected  ("===== Test recursive rule (built-in type checker) ====="))))]
<span class="ansi38-255165000"
>  (: recursive_prf 
    (≞ 
      (→ P Q) $etv))
</span><span class="ansi38-255165000"
>  (= recursive_prf 
    (IDIRecursive P7 Q7 
      (IDIBase P2 Q2) 
      (SuccMonotonicity (SuccMonotonicity ZeroLTSucc))))
</span><span class="ansi38-255165009"
>;; In file as:  
</span><span class="ansi1 ansi38-255238088"
>  !(recursive_prf)
</span>;; To unit test case:
<span class="ansi38-013099040"
>  !(assertEqualToResult 
    (recursive_prf) 
    ( (recursive_prf)))

</span>[

;<h3 id="DEPENDENT-TYPES.IMPLICATIONDIRECTINTRODUCTIONDTLTEST.05"
>;; DEPENDENT-TYPES.IMPLICATIONDIRECTINTRODUCTIONDTLTEST.05</h3>
; 
; EVAL TEST
; took 0.000272 secs. (271.85 microseconds) 

  !(assertEqualToResult 
    (recursive_prf) 
    ( (recursive_prf)))

<span class="ansi36"
>  (loonit_success  
    (equal_enough_for_test  
      ( (recursive_prf)) 
      ( (recursive_prf))))
</span>
Deterministic: ()
()]
<span class="ansi38-255165009"
>;; In file as:  
</span><span class="ansi1 ansi38-255238088"
>  !(get-type recursive_prf)
</span>;; To unit test case:
<span class="ansi38-013099040"
>  !(assertEqualToResult 
    (get-type recursive_prf) 
    ( (≞ 
        (→ P Q) $etv#923)))

</span>[

;<h3 id="DEPENDENT-TYPES.IMPLICATIONDIRECTINTRODUCTIONDTLTEST.06"
>;; DEPENDENT-TYPES.IMPLICATIONDIRECTINTRODUCTIONDTLTEST.06</h3>
; 
; EVAL TEST
; took 0.000461 secs. (460.67 microseconds) 

  !(assertEqualToResult 
    (get-type recursive_prf) 
    ( (≞ 
        (→ P Q) $etv#923)))

<span class="ansi36"
>  (loonit_success  
    (equal_enough_for_test  
      ( (≞ 
          (→ P Q) $_197510)) 
      ( (≞ 
          (→ P Q) $_187168))))
</span>
Deterministic: ()
()]
;;;; Test synthesizer
<span class="ansi38-255165009"
>;; In file as:  
</span><span class="ansi1 ansi38-255238088"
>  !=====
</span>;; To unit test case:
<span class="ansi38-013099040"
>  !(assertEqualToResult ===== 
    ("===== Prove that 2 < 7 (synthesizer) ====="))

</span>[

;<h3 id="DEPENDENT-TYPES.IMPLICATIONDIRECTINTRODUCTIONDTLTEST.07"
>;; DEPENDENT-TYPES.IMPLICATIONDIRECTINTRODUCTIONDTLTEST.07</h3>
; 
; EVAL TEST
; took 0.000021 secs. (20.77 microseconds) 

  !(assertEqualToResult ===== 
    ("===== Prove that 2 < 7 (synthesizer) ====="))

<span class="ansi31"
>  (loonit_failureR  
    (equal_enough_for_test  
      (=====) 
      ("===== Prove that 2 < 7 (synthesizer) =====")))
</span>
Deterministic: ((Error  (got  (=====)) (expected  ("===== Prove that 2 < 7 (synthesizer) ====="))))
((Error  (got  (=====)) (expected  ("===== Prove that 2 < 7 (synthesizer) ====="))))]
<span class="ansi38-255165009"
>;; In file as:  
</span><span class="ansi1 ansi38-255238088"
>  !(synthesize 
    (: $proof 
      (⍃ 
        (fromNumber 2) 
        (fromNumber 7))) kb rb 
    (fromNumber 2))
</span>;; To unit test case:
<span class="ansi38-013099040"
>  !(assertEqualToResult 
    (synthesize 
      (: $proof 
        (⍃ 
          (fromNumber 2) 
          (fromNumber 7))) kb rb 
      (fromNumber 2)) 
    ( (: 
        (SuccMonotonicity (SuccMonotonicity ZeroLTSucc)) 
        (⍃ 
          (S (S Z)) 
          (S (S (S (S (S (S (S Z)))))))))))

</span>[

;<h3 id="DEPENDENT-TYPES.IMPLICATIONDIRECTINTRODUCTIONDTLTEST.08"
>;; DEPENDENT-TYPES.IMPLICATIONDIRECTINTRODUCTIONDTLTEST.08</h3>
; 
; EVAL TEST
; took 0.227 secs. (226.81 milliseconds) 

  !(assertEqualToResult 
    (synthesize 
      (: $proof 
        (⍃ 
          (fromNumber 2) 
          (fromNumber 7))) kb rb 
      (fromNumber 2)) 
    ( (: 
        (SuccMonotonicity (SuccMonotonicity ZeroLTSucc)) 
        (⍃ 
          (S (S Z)) 
          (S (S (S (S (S (S (S Z)))))))))))

<span class="ansi36"
>  (loonit_success  
    (equal_enough_for_test  
      ( (: 
          (SuccMonotonicity (SuccMonotonicity ZeroLTSucc)) 
          (⍃ 
            (S (S Z)) 
            (S (S (S (S (S (S (S Z)))))))))) 
      ( (: 
          (SuccMonotonicity (SuccMonotonicity ZeroLTSucc)) 
          (⍃ 
            (S (S Z)) 
            (S (S (S (S (S (S (S Z))))))))))))
</span>
Deterministic: ()
()]
<span class="ansi38-255165009"
>;; In file as:  
</span><span class="ansi1 ansi38-255238088"
>  !=====
</span>;; To unit test case:
<span class="ansi38-013099040"
>  !(assertEqualToResult ===== 
    ("===== Prove that 2 < 3 (synthesizer) ====="))

</span>[

;<h3 id="DEPENDENT-TYPES.IMPLICATIONDIRECTINTRODUCTIONDTLTEST.09"
>;; DEPENDENT-TYPES.IMPLICATIONDIRECTINTRODUCTIONDTLTEST.09</h3>
; 
; EVAL TEST
; took 0.000015 secs. (14.85 microseconds) 

  !(assertEqualToResult ===== 
    ("===== Prove that 2 < 3 (synthesizer) ====="))

<span class="ansi31"
>  (loonit_failureR  
    (equal_enough_for_test  
      (=====) 
      ("===== Prove that 2 < 3 (synthesizer) =====")))
</span>
Deterministic: ((Error  (got  (=====)) (expected  ("===== Prove that 2 < 3 (synthesizer) ====="))))
((Error  (got  (=====)) (expected  ("===== Prove that 2 < 3 (synthesizer) ====="))))]
<span class="ansi38-255165009"
>;; In file as:  
</span><span class="ansi1 ansi38-255238088"
>  !(synthesize 
    (: $proof 
      (⍃ 
        (fromNumber 2) 
        (fromNumber 3))) kb rb 
    (fromNumber 2))
</span>;; To unit test case:
<span class="ansi38-013099040"
>  !(assertEqualToResult 
    (synthesize 
      (: $proof 
        (⍃ 
          (fromNumber 2) 
          (fromNumber 3))) kb rb 
      (fromNumber 2)) 
    ( (: 
        (SuccMonotonicity (SuccMonotonicity ZeroLTSucc)) 
        (⍃ 
          (S (S Z)) 
          (S (S (S Z)))))))

</span>[

;<h3 id="DEPENDENT-TYPES.IMPLICATIONDIRECTINTRODUCTIONDTLTEST.10"
>;; DEPENDENT-TYPES.IMPLICATIONDIRECTINTRODUCTIONDTLTEST.10</h3>
; 
; EVAL TEST
; took 0.211 secs. (210.99 milliseconds) 

  !(assertEqualToResult 
    (synthesize 
      (: $proof 
        (⍃ 
          (fromNumber 2) 
          (fromNumber 3))) kb rb 
      (fromNumber 2)) 
    ( (: 
        (SuccMonotonicity (SuccMonotonicity ZeroLTSucc)) 
        (⍃ 
          (S (S Z)) 
          (S (S (S Z)))))))

<span class="ansi36"
>  (loonit_success  
    (equal_enough_for_test  
      ( (: 
          (SuccMonotonicity (SuccMonotonicity ZeroLTSucc)) 
          (⍃ 
            (S (S Z)) 
            (S (S (S Z)))))) 
      ( (: 
          (SuccMonotonicity (SuccMonotonicity ZeroLTSucc)) 
          (⍃ 
            (S (S Z)) 
            (S (S (S Z))))))))
</span>
Deterministic: ()
()]
<span class="ansi38-255165009"
>;; In file as:  
</span><span class="ansi1 ansi38-255238088"
>  !=====
</span>;; To unit test case:
<span class="ansi38-013099040"
>  !(assertEqualToResult ===== 
    ("===== Prove that 5 < 7 (synthesizer) ====="))

</span>[

;<h3 id="DEPENDENT-TYPES.IMPLICATIONDIRECTINTRODUCTIONDTLTEST.11"
>;; DEPENDENT-TYPES.IMPLICATIONDIRECTINTRODUCTIONDTLTEST.11</h3>
; 
; EVAL TEST
; took 0.000014 secs. (14.50 microseconds) 

  !(assertEqualToResult ===== 
    ("===== Prove that 5 < 7 (synthesizer) ====="))

<span class="ansi31"
>  (loonit_failureR  
    (equal_enough_for_test  
      (=====) 
      ("===== Prove that 5 < 7 (synthesizer) =====")))
</span>
Deterministic: ((Error  (got  (=====)) (expected  ("===== Prove that 5 < 7 (synthesizer) ====="))))
((Error  (got  (=====)) (expected  ("===== Prove that 5 < 7 (synthesizer) ====="))))]
<span class="ansi38-255165009"
>;; In file as:  
</span><span class="ansi1 ansi38-255238088"
>  !(synthesize 
    (: $proof 
      (⍃ 
        (fromNumber 3) 
        (fromNumber 7))) kb rb 
    (fromNumber 3))
</span>;; To unit test case:
<span class="ansi38-013099040"
>  !(assertEqualToResult 
    (synthesize 
      (: $proof 
        (⍃ 
          (fromNumber 3) 
          (fromNumber 7))) kb rb 
      (fromNumber 3)) 
    ( (: 
        (SuccMonotonicity (SuccMonotonicity (SuccMonotonicity ZeroLTSucc))) 
        (⍃ 
          (S (S (S Z))) 
          (S (S (S (S (S (S (S Z)))))))))))

</span>[

;<h3 id="DEPENDENT-TYPES.IMPLICATIONDIRECTINTRODUCTIONDTLTEST.12"
>;; DEPENDENT-TYPES.IMPLICATIONDIRECTINTRODUCTIONDTLTEST.12</h3>
; 
; EVAL TEST
; took 0.304 secs. (303.57 milliseconds) 

  !(assertEqualToResult 
    (synthesize 
      (: $proof 
        (⍃ 
          (fromNumber 3) 
          (fromNumber 7))) kb rb 
      (fromNumber 3)) 
    ( (: 
        (SuccMonotonicity (SuccMonotonicity (SuccMonotonicity ZeroLTSucc))) 
        (⍃ 
          (S (S (S Z))) 
          (S (S (S (S (S (S (S Z)))))))))))

<span class="ansi36"
>  (loonit_success  
    (equal_enough_for_test  
      ( (: 
          (SuccMonotonicity (SuccMonotonicity (SuccMonotonicity ZeroLTSucc))) 
          (⍃ 
            (S (S (S Z))) 
            (S (S (S (S (S (S (S Z)))))))))) 
      ( (: 
          (SuccMonotonicity (SuccMonotonicity (SuccMonotonicity ZeroLTSucc))) 
          (⍃ 
            (S (S (S Z))) 
            (S (S (S (S (S (S (S Z))))))))))))
</span>
Deterministic: ()
()]
;;;; Prove that P→Q using only base rule with only one piece of evidence
<span class="ansi38-255165009"
>;; In file as:  
</span><span class="ansi1 ansi38-255238088"
>  !=====
</span>;; To unit test case:
<span class="ansi38-013099040"
>  !(assertEqualToResult ===== 
    ("===== Prove P→Q using base rule (synthesizer) ====="))

</span>[

;<h3 id="DEPENDENT-TYPES.IMPLICATIONDIRECTINTRODUCTIONDTLTEST.13"
>;; DEPENDENT-TYPES.IMPLICATIONDIRECTINTRODUCTIONDTLTEST.13</h3>
; 
; EVAL TEST
; took 0.000015 secs. (14.69 microseconds) 

  !(assertEqualToResult ===== 
    ("===== Prove P→Q using base rule (synthesizer) ====="))

<span class="ansi31"
>  (loonit_failureR  
    (equal_enough_for_test  
      (=====) 
      ("===== Prove P→Q using base rule (synthesizer) =====")))
</span>
Deterministic: ((Error  (got  (=====)) (expected  ("===== Prove P→Q using base rule (synthesizer) ====="))))
((Error  (got  (=====)) (expected  ("===== Prove P→Q using base rule (synthesizer) ====="))))]
<span class="ansi38-255165009"
>;; In file as:  
</span><span class="ansi1 ansi38-255238088"
>  !(synthesize 
    (: $proof 
      (≞ 
        (→ P Q) $etv)) kb rb 
    (fromNumber 1))
</span>;; To unit test case:
<span class="ansi38-013099040"
>  !(assertEqualToResult 
    (synthesize 
      (: $proof 
        (≞ 
          (→ P Q) $etv)) kb rb 
      (fromNumber 1)) 
    ( (let* 
        ( ( (: $proof2#26359 
              (⊷ Q 
                (S (S Z)) True)) (synthesize (: $proof2#26359 (⊷ Q (S (S Z)) True)) kb rb Z)) 
          ( (: $proof3#26360 
              (≞ 
                (→ P Q) 
                (ETV 
                  (:: $h#26365 $t#26366) 
                  (STV $s#26367 $conf#26368)))) (synthesize (: $proof3#26360 (≞ (→ P Q) (ETV (:: $h#26365 $t#26366) (STV $s#26367 $conf#26368)))) kb rb Z)) 
          ( (: $proof4#26361 
              (⍃ $h#26365 
                (S (S Z)))) (synthesize (: $proof4#26361 (⍃ $h#26365 (S (S Z)))) kb rb Z))) 
        (: 
          (IDIRecursive P2 $proof2#26359 $proof3#26360 $proof4#26361) 
          (≞ 
            (→ P Q) 
            (ETV 
              (:: 
                (S (S Z)) 
                (:: $h#26365 $t#26366)) 
              (STV 
                (/ 
                  (+ 
                    (* $s#26367 
                      (if 
                        (<= 
                          (if 
                            (< 
                              (- 1.0 $conf#26368) 0) 
                            (* -1 
                              (- 1.0 $conf#26368)) 
                            (- 1.0 $conf#26368)) 1.0e-9) 
                        (max-count) 
                        (/ 
                          (* $conf#26368 
                            (lookahead)) 
                          (- 1.0 $conf#26368)))) 1) 
                  (+ 
                    (if 
                      (<= 
                        (if 
                          (< 
                            (- 1.0 $conf#26368) 0) 
                          (* -1 
                            (- 1.0 $conf#26368)) 
                          (- 1.0 $conf#26368)) 1.0e-9) 
                      (max-count) 
                      (/ 
                        (* $conf#26368 
                          (lookahead)) 
                        (- 1.0 $conf#26368))) 1)) 
                (/ 
                  (+ 
                    (if 
                      (<= 
                        (if 
                          (< 
                            (- 1.0 $conf#26368) 0) 
                          (* -1 
                            (- 1.0 $conf#26368)) 
                          (- 1.0 $conf#26368)) 1.0e-9) 
                      (max-count) 
                      (/ 
                        (* $conf#26368 
                          (lookahead)) 
                        (- 1.0 $conf#26368))) 1) 
                  (+ 
                    (+ 
                      (if 
                        (<= 
                          (if 
                            (< 
                              (- 1.0 $conf#26368) 0) 
                            (* -1 
                              (- 1.0 $conf#26368)) 
                            (- 1.0 $conf#26368)) 1.0e-9) 
                        (max-count) 
                        (/ 
                          (* $conf#26368 
                            (lookahead)) 
                          (- 1.0 $conf#26368))) 1) 1.0))))))) 
      (let* 
        ( ( (: $proof3#26360 
              (≞ 
                (→ P Q) 
                (ETV 
                  (:: $h#26365 $t#26366) 
                  (STV $s#26367 $conf#26368)))) (synthesize (: $proof3#26360 (≞ (→ P Q) (ETV (:: $h#26365 $t#26366) (STV $s#26367 $conf#26368)))) kb rb Z)) ((: $proof4#26361 (⍃ $h#26365 (S (S (S Z))))) (synthesize (: $proof4#26361 (⍃ $h#26365 (S (S (S Z))))) kb rb Z))) 
        (: 
          (IDIRecursive P3 Q3 $proof3#26360 $proof4#26361) 
          (≞ 
            (→ P Q) 
            (ETV 
              (:: 
                (S (S (S Z))) 
                (:: $h#26365 $t#26366)) 
              (STV 
                (/ 
                  (+ 
                    (* $s#26367 
                      (if 
                        (<= 
                          (if 
                            (< 
                              (- 1.0 $conf#26368) 0) 
                            (* -1 
                              (- 1.0 $conf#26368)) 
                            (- 1.0 $conf#26368)) 1.0e-9) 
                        (max-count) 
                        (/ 
                          (* $conf#26368 
                            (lookahead)) 
                          (- 1.0 $conf#26368)))) 1) 
                  (+ 
                    (if 
                      (<= 
                        (if 
                          (< 
                            (- 1.0 $conf#26368) 0) 
                          (* -1 
                            (- 1.0 $conf#26368)) 
                          (- 1.0 $conf#26368)) 1.0e-9) 
                      (max-count) 
                      (/ 
                        (* $conf#26368 
                          (lookahead)) 
                        (- 1.0 $conf#26368))) 1)) 
                (/ 
                  (+ 
                    (if 
                      (<= 
                        (if 
                          (< 
                            (- 1.0 $conf#26368) 0) 
                          (* -1 
                            (- 1.0 $conf#26368)) 
                          (- 1.0 $conf#26368)) 1.0e-9) 
                      (max-count) 
                      (/ 
                        (* $conf#26368 
                          (lookahead)) 
                        (- 1.0 $conf#26368))) 1) 
                  (+ 
                    (+ 
                      (if 
                        (<= 
                          (if 
                            (< 
                              (- 1.0 $conf#26368) 0) 
                            (* -1 
                              (- 1.0 $conf#26368)) 
                            (- 1.0 $conf#26368)) 1.0e-9) 
                        (max-count) 
                        (/ 
                          (* $conf#26368 
                            (lookahead)) 
                          (- 1.0 $conf#26368))) 1) 1.0))))))) 
      (let* 
        ( ( (: $proof3#26360 
              (≞ 
                (→ P Q) 
                (ETV 
                  (:: $h#26365 $t#26366) 
                  (STV $s#26367 $conf#26368)))) (synthesize (: $proof3#26360 (≞ (→ P Q) (ETV (:: $h#26365 $t#26366) (STV $s#26367 $conf#26368)))) kb rb Z)) ((: $proof4#26361 (⍃ $h#26365 (S (S (S (S (S (S (S Z))))))))) (synthesize (: $proof4#26361 (⍃ $h#26365 (S (S (S (S (S (S (S Z))))))))) kb rb Z))) 
        (: 
          (IDIRecursive P7 Q7 $proof3#26360 $proof4#26361) 
          (≞ 
            (→ P Q) 
            (ETV 
              (:: 
                (S (S (S (S (S (S (S Z))))))) 
                (:: $h#26365 $t#26366)) 
              (STV 
                (/ 
                  (+ 
                    (* $s#26367 
                      (if 
                        (<= 
                          (if 
                            (< 
                              (- 1.0 $conf#26368) 0) 
                            (* -1 
                              (- 1.0 $conf#26368)) 
                            (- 1.0 $conf#26368)) 1.0e-9) 
                        (max-count) 
                        (/ 
                          (* $conf#26368 
                            (lookahead)) 
                          (- 1.0 $conf#26368)))) 1) 
                  (+ 
                    (if 
                      (<= 
                        (if 
                          (< 
                            (- 1.0 $conf#26368) 0) 
                          (* -1 
                            (- 1.0 $conf#26368)) 
                          (- 1.0 $conf#26368)) 1.0e-9) 
                      (max-count) 
                      (/ 
                        (* $conf#26368 
                          (lookahead)) 
                        (- 1.0 $conf#26368))) 1)) 
                (/ 
                  (+ 
                    (if 
                      (<= 
                        (if 
                          (< 
                            (- 1.0 $conf#26368) 0) 
                          (* -1 
                            (- 1.0 $conf#26368)) 
                          (- 1.0 $conf#26368)) 1.0e-9) 
                      (max-count) 
                      (/ 
                        (* $conf#26368 
                          (lookahead)) 
                        (- 1.0 $conf#26368))) 1) 
                  (+ 
                    (+ 
                      (if 
                        (<= 
                          (if 
                            (< 
                              (- 1.0 $conf#26368) 0) 
                            (* -1 
                              (- 1.0 $conf#26368)) 
                            (- 1.0 $conf#26368)) 1.0e-9) 
                        (max-count) 
                        (/ 
                          (* $conf#26368 
                            (lookahead)) 
                          (- 1.0 $conf#26368))) 1) 1.0))))))) 
      (let* 
        ( ( (: $proof3#27352 
              (≞ 
                (→ P Q) 
                (ETV 
                  (:: $h#27357 $t#27358) 
                  (STV $PQs#27359 $PQc#27360)))) (synthesize (: $proof3#27352 (≞ (→ P Q) (ETV (:: $h#27357 $t#27358) (STV $PQs#27359 $PQc#27360)))) kb rb Z)) ((: $proof4#27353 (⍃ $h#27357 (S (S Z)))) (synthesize (: $proof4#27353 (⍃ $h#27357 (S (S Z)))) kb rb Z))) 
        (: 
          (IDIRecursive P2 Q2 $proof3#27352 $proof4#27353) 
          (≞ 
            (→ P Q) 
            (ETV 
              (:: 
                (S (S Z)) 
                (:: $h#27357 $t#27358)) 
              (STV 
                (/ 
                  (* $PQs#27359 
                    (if 
                      (<= 
                        (if 
                          (< 
                            (- 1.0 $PQc#27360) 0) 
                          (* -1 
                            (- 1.0 $PQc#27360)) 
                          (- 1.0 $PQc#27360)) 1.0e-9) 
                      (max-count) 
                      (/ 
                        (* $PQc#27360 
                          (lookahead)) 
                        (- 1.0 $PQc#27360)))) 
                  (+ 
                    (if 
                      (<= 
                        (if 
                          (< 
                            (- 1.0 $PQc#27360) 0) 
                          (* -1 
                            (- 1.0 $PQc#27360)) 
                          (- 1.0 $PQc#27360)) 1.0e-9) 
                      (max-count) 
                      (/ 
                        (* $PQc#27360 
                          (lookahead)) 
                        (- 1.0 $PQc#27360))) 1)) 
                (/ 
                  (+ 
                    (if 
                      (<= 
                        (if 
                          (< 
                            (- 1.0 $PQc#27360) 0) 
                          (* -1 
                            (- 1.0 $PQc#27360)) 
                          (- 1.0 $PQc#27360)) 1.0e-9) 
                      (max-count) 
                      (/ 
                        (* $PQc#27360 
                          (lookahead)) 
                        (- 1.0 $PQc#27360))) 1) 
                  (+ 
                    (+ 
                      (if 
                        (<= 
                          (if 
                            (< 
                              (- 1.0 $PQc#27360) 0) 
                            (* -1 
                              (- 1.0 $PQc#27360)) 
                            (- 1.0 $PQc#27360)) 1.0e-9) 
                        (max-count) 
                        (/ 
                          (* $PQc#27360 
                            (lookahead)) 
                          (- 1.0 $PQc#27360))) 1) 1.0))))))) 
      (let* 
        ( ( (: $proof2#27351 
              (⊷ Q 
                (S (S (S Z))) False)) (synthesize (: $proof2#27351 (⊷ Q (S (S (S Z))) False)) kb rb Z)) 
          ( (: $proof3#27352 
              (≞ 
                (→ P Q) 
                (ETV 
                  (:: $h#27357 $t#27358) 
                  (STV $PQs#27359 $PQc#27360)))) (synthesize (: $proof3#27352 (≞ (→ P Q) (ETV (:: $h#27357 $t#27358) (STV $PQs#27359 $PQc#27360)))) kb rb Z)) 
          ( (: $proof4#27353 
              (⍃ $h#27357 
                (S (S (S Z))))) (synthesize (: $proof4#27353 (⍃ $h#27357 (S (S (S Z))))) kb rb Z))) 
        (: 
          (IDIRecursive P3 $proof2#27351 $proof3#27352 $proof4#27353) 
          (≞ 
            (→ P Q) 
            (ETV 
              (:: 
                (S (S (S Z))) 
                (:: $h#27357 $t#27358)) 
              (STV 
                (/ 
                  (* $PQs#27359 
                    (if 
                      (<= 
                        (if 
                          (< 
                            (- 1.0 $PQc#27360) 0) 
                          (* -1 
                            (- 1.0 $PQc#27360)) 
                          (- 1.0 $PQc#27360)) 1.0e-9) 
                      (max-count) 
                      (/ 
                        (* $PQc#27360 
                          (lookahead)) 
                        (- 1.0 $PQc#27360)))) 
                  (+ 
                    (if 
                      (<= 
                        (if 
                          (< 
                            (- 1.0 $PQc#27360) 0) 
                          (* -1 
                            (- 1.0 $PQc#27360)) 
                          (- 1.0 $PQc#27360)) 1.0e-9) 
                      (max-count) 
                      (/ 
                        (* $PQc#27360 
                          (lookahead)) 
                        (- 1.0 $PQc#27360))) 1)) 
                (/ 
                  (+ 
                    (if 
                      (<= 
                        (if 
                          (< 
                            (- 1.0 $PQc#27360) 0) 
                          (* -1 
                            (- 1.0 $PQc#27360)) 
                          (- 1.0 $PQc#27360)) 1.0e-9) 
                      (max-count) 
                      (/ 
                        (* $PQc#27360 
                          (lookahead)) 
                        (- 1.0 $PQc#27360))) 1) 
                  (+ 
                    (+ 
                      (if 
                        (<= 
                          (if 
                            (< 
                              (- 1.0 $PQc#27360) 0) 
                            (* -1 
                              (- 1.0 $PQc#27360)) 
                            (- 1.0 $PQc#27360)) 1.0e-9) 
                        (max-count) 
                        (/ 
                          (* $PQc#27360 
                            (lookahead)) 
                          (- 1.0 $PQc#27360))) 1) 1.0))))))) 
      (let* 
        ( ( (: $proof2#27351 
              (⊷ Q 
                (S (S (S (S (S (S (S Z))))))) False)) (synthesize (: $proof2#27351 (⊷ Q (S (S (S (S (S (S (S Z))))))) False)) kb rb Z)) 
          ( (: $proof3#27352 
              (≞ 
                (→ P Q) 
                (ETV 
                  (:: $h#27357 $t#27358) 
                  (STV $PQs#27359 $PQc#27360)))) (synthesize (: $proof3#27352 (≞ (→ P Q) (ETV (:: $h#27357 $t#27358) (STV $PQs#27359 $PQc#27360)))) kb rb Z)) 
          ( (: $proof4#27353 
              (⍃ $h#27357 
                (S (S (S (S (S (S (S Z))))))))) (synthesize (: $proof4#27353 (⍃ $h#27357 (S (S (S (S (S (S (S Z))))))))) kb rb Z))) 
        (: 
          (IDIRecursive P7 $proof2#27351 $proof3#27352 $proof4#27353) 
          (≞ 
            (→ P Q) 
            (ETV 
              (:: 
                (S (S (S (S (S (S (S Z))))))) 
                (:: $h#27357 $t#27358)) 
              (STV 
                (/ 
                  (* $PQs#27359 
                    (if 
                      (<= 
                        (if 
                          (< 
                            (- 1.0 $PQc#27360) 0) 
                          (* -1 
                            (- 1.0 $PQc#27360)) 
                          (- 1.0 $PQc#27360)) 1.0e-9) 
                      (max-count) 
                      (/ 
                        (* $PQc#27360 
                          (lookahead)) 
                        (- 1.0 $PQc#27360)))) 
                  (+ 
                    (if 
                      (<= 
                        (if 
                          (< 
                            (- 1.0 $PQc#27360) 0) 
                          (* -1 
                            (- 1.0 $PQc#27360)) 
                          (- 1.0 $PQc#27360)) 1.0e-9) 
                      (max-count) 
                      (/ 
                        (* $PQc#27360 
                          (lookahead)) 
                        (- 1.0 $PQc#27360))) 1)) 
                (/ 
                  (+ 
                    (if 
                      (<= 
                        (if 
                          (< 
                            (- 1.0 $PQc#27360) 0) 
                          (* -1 
                            (- 1.0 $PQc#27360)) 
                          (- 1.0 $PQc#27360)) 1.0e-9) 
                      (max-count) 
                      (/ 
                        (* $PQc#27360 
                          (lookahead)) 
                        (- 1.0 $PQc#27360))) 1) 
                  (+ 
                    (+ 
                      (if 
                        (<= 
                          (if 
                            (< 
                              (- 1.0 $PQc#27360) 0) 
                            (* -1 
                              (- 1.0 $PQc#27360)) 
                            (- 1.0 $PQc#27360)) 1.0e-9) 
                        (max-count) 
                        (/ 
                          (* $PQc#27360 
                            (lookahead)) 
                          (- 1.0 $PQc#27360))) 1) 1.0))))))) 
      (: 
        (IDIBase P2 Q2) 
        (≞ 
          (→ P Q) 
          (ETV 
            (:: 
              (S (S Z)) ∅) 
            (STV 0 0.5)))) 
      (let* 
        ( ( (: $proof2#28198 
              (⊷ Q 
                (S (S (S Z))) False)) (synthesize (: $proof2#28198 (⊷ Q (S (S (S Z))) False)) kb rb Z))) 
        (: 
          (IDIBase P3 $proof2#28198) 
          (≞ 
            (→ P Q) 
            (ETV 
              (:: 
                (S (S (S Z))) ∅) 
              (STV 0 0.5))))) 
      (let* 
        ( ( (: $proof2#28198 
              (⊷ Q 
                (S (S (S (S (S (S (S Z))))))) False)) (synthesize (: $proof2#28198 (⊷ Q (S (S (S (S (S (S (S Z))))))) False)) kb rb Z))) 
        (: 
          (IDIBase P7 $proof2#28198) 
          (≞ 
            (→ P Q) 
            (ETV 
              (:: 
                (S (S (S (S (S (S (S Z))))))) ∅) 
              (STV 0 0.5))))) 
      (let* 
        ( ( (: $proof2#28961 
              (⊷ Q 
                (S (S Z)) True)) (synthesize (: $proof2#28961 (⊷ Q (S (S Z)) True)) kb rb Z))) 
        (: 
          (IDIBase P2 $proof2#28961) 
          (≞ 
            (→ P Q) 
            (ETV 
              (:: 
                (S (S Z)) ∅) 
              (STV 1 0.5))))) 
      (: 
        (IDIBase P3 Q3) 
        (≞ 
          (→ P Q) 
          (ETV 
            (:: 
              (S (S (S Z))) ∅) 
            (STV 1 0.5)))) 
      (: 
        (IDIBase P7 Q7) 
        (≞ 
          (→ P Q) 
          (ETV 
            (:: 
              (S (S (S (S (S (S (S Z))))))) ∅) 
            (STV 1 0.5))))))

</span>[

;<h3 id="DEPENDENT-TYPES.IMPLICATIONDIRECTINTRODUCTIONDTLTEST.14"
>;; DEPENDENT-TYPES.IMPLICATIONDIRECTINTRODUCTIONDTLTEST.14</h3>
; 
; EVAL TEST
; took 0.798 secs. (797.97 milliseconds) 

  !(assertEqualToResult 
    (synthesize 
      (: $proof 
        (≞ 
          (→ P Q) $etv)) kb rb 
      (fromNumber 1)) 
    ( (let* 
        ( ( (: $proof2#26359 
              (⊷ Q 
                (S (S Z)) True)) (synthesize (: $proof2#26359 (⊷ Q (S (S Z)) True)) kb rb Z)) 
          ( (: $proof3#26360 
              (≞ 
                (→ P Q) 
                (ETV 
                  (:: $h#26365 $t#26366) 
                  (STV $s#26367 $conf#26368)))) (synthesize (: $proof3#26360 (≞ (→ P Q) (ETV (:: $h#26365 $t#26366) (STV $s#26367 $conf#26368)))) kb rb Z)) 
          ( (: $proof4#26361 
              (⍃ $h#26365 
                (S (S Z)))) (synthesize (: $proof4#26361 (⍃ $h#26365 (S (S Z)))) kb rb Z))) 
        (: 
          (IDIRecursive P2 $proof2#26359 $proof3#26360 $proof4#26361) 
          (≞ 
            (→ P Q) 
            (ETV 
              (:: 
                (S (S Z)) 
                (:: $h#26365 $t#26366)) 
              (STV 
                (/ 
                  (+ 
                    (* $s#26367 
                      (if 
                        (<= 
                          (if 
                            (< 
                              (- 1.0 $conf#26368) 0) 
                            (* -1 
                              (- 1.0 $conf#26368)) 
                            (- 1.0 $conf#26368)) 1.0e-9) 
                        (max-count) 
                        (/ 
                          (* $conf#26368 
                            (lookahead)) 
                          (- 1.0 $conf#26368)))) 1) 
                  (+ 
                    (if 
                      (<= 
                        (if 
                          (< 
                            (- 1.0 $conf#26368) 0) 
                          (* -1 
                            (- 1.0 $conf#26368)) 
                          (- 1.0 $conf#26368)) 1.0e-9) 
                      (max-count) 
                      (/ 
                        (* $conf#26368 
                          (lookahead)) 
                        (- 1.0 $conf#26368))) 1)) 
                (/ 
                  (+ 
                    (if 
                      (<= 
                        (if 
                          (< 
                            (- 1.0 $conf#26368) 0) 
                          (* -1 
                            (- 1.0 $conf#26368)) 
                          (- 1.0 $conf#26368)) 1.0e-9) 
                      (max-count) 
                      (/ 
                        (* $conf#26368 
                          (lookahead)) 
                        (- 1.0 $conf#26368))) 1) 
                  (+ 
                    (+ 
                      (if 
                        (<= 
                          (if 
                            (< 
                              (- 1.0 $conf#26368) 0) 
                            (* -1 
                              (- 1.0 $conf#26368)) 
                            (- 1.0 $conf#26368)) 1.0e-9) 
                        (max-count) 
                        (/ 
                          (* $conf#26368 
                            (lookahead)) 
                          (- 1.0 $conf#26368))) 1) 1.0))))))) 
      (let* 
        ( ( (: $proof3#26360 
              (≞ 
                (→ P Q) 
                (ETV 
                  (:: $h#26365 $t#26366) 
                  (STV $s#26367 $conf#26368)))) (synthesize (: $proof3#26360 (≞ (→ P Q) (ETV (:: $h#26365 $t#26366) (STV $s#26367 $conf#26368)))) kb rb Z)) ((: $proof4#26361 (⍃ $h#26365 (S (S (S Z))))) (synthesize (: $proof4#26361 (⍃ $h#26365 (S (S (S Z))))) kb rb Z))) 
        (: 
          (IDIRecursive P3 Q3 $proof3#26360 $proof4#26361) 
          (≞ 
            (→ P Q) 
            (ETV 
              (:: 
                (S (S (S Z))) 
                (:: $h#26365 $t#26366)) 
              (STV 
                (/ 
                  (+ 
                    (* $s#26367 
                      (if 
                        (<= 
                          (if 
                            (< 
                              (- 1.0 $conf#26368) 0) 
                            (* -1 
                              (- 1.0 $conf#26368)) 
                            (- 1.0 $conf#26368)) 1.0e-9) 
                        (max-count) 
                        (/ 
                          (* $conf#26368 
                            (lookahead)) 
                          (- 1.0 $conf#26368)))) 1) 
                  (+ 
                    (if 
                      (<= 
                        (if 
                          (< 
                            (- 1.0 $conf#26368) 0) 
                          (* -1 
                            (- 1.0 $conf#26368)) 
                          (- 1.0 $conf#26368)) 1.0e-9) 
                      (max-count) 
                      (/ 
                        (* $conf#26368 
                          (lookahead)) 
                        (- 1.0 $conf#26368))) 1)) 
                (/ 
                  (+ 
                    (if 
                      (<= 
                        (if 
                          (< 
                            (- 1.0 $conf#26368) 0) 
                          (* -1 
                            (- 1.0 $conf#26368)) 
                          (- 1.0 $conf#26368)) 1.0e-9) 
                      (max-count) 
                      (/ 
                        (* $conf#26368 
                          (lookahead)) 
                        (- 1.0 $conf#26368))) 1) 
                  (+ 
                    (+ 
                      (if 
                        (<= 
                          (if 
                            (< 
                              (- 1.0 $conf#26368) 0) 
                            (* -1 
                              (- 1.0 $conf#26368)) 
                            (- 1.0 $conf#26368)) 1.0e-9) 
                        (max-count) 
                        (/ 
                          (* $conf#26368 
                            (lookahead)) 
                          (- 1.0 $conf#26368))) 1) 1.0))))))) 
      (let* 
        ( ( (: $proof3#26360 
              (≞ 
                (→ P Q) 
                (ETV 
                  (:: $h#26365 $t#26366) 
                  (STV $s#26367 $conf#26368)))) (synthesize (: $proof3#26360 (≞ (→ P Q) (ETV (:: $h#26365 $t#26366) (STV $s#26367 $conf#26368)))) kb rb Z)) ((: $proof4#26361 (⍃ $h#26365 (S (S (S (S (S (S (S Z))))))))) (synthesize (: $proof4#26361 (⍃ $h#26365 (S (S (S (S (S (S (S Z))))))))) kb rb Z))) 
        (: 
          (IDIRecursive P7 Q7 $proof3#26360 $proof4#26361) 
          (≞ 
            (→ P Q) 
            (ETV 
              (:: 
                (S (S (S (S (S (S (S Z))))))) 
                (:: $h#26365 $t#26366)) 
              (STV 
                (/ 
                  (+ 
                    (* $s#26367 
                      (if 
                        (<= 
                          (if 
                            (< 
                              (- 1.0 $conf#26368) 0) 
                            (* -1 
                              (- 1.0 $conf#26368)) 
                            (- 1.0 $conf#26368)) 1.0e-9) 
                        (max-count) 
                        (/ 
                          (* $conf#26368 
                            (lookahead)) 
                          (- 1.0 $conf#26368)))) 1) 
                  (+ 
                    (if 
                      (<= 
                        (if 
                          (< 
                            (- 1.0 $conf#26368) 0) 
                          (* -1 
                            (- 1.0 $conf#26368)) 
                          (- 1.0 $conf#26368)) 1.0e-9) 
                      (max-count) 
                      (/ 
                        (* $conf#26368 
                          (lookahead)) 
                        (- 1.0 $conf#26368))) 1)) 
                (/ 
                  (+ 
                    (if 
                      (<= 
                        (if 
                          (< 
                            (- 1.0 $conf#26368) 0) 
                          (* -1 
                            (- 1.0 $conf#26368)) 
                          (- 1.0 $conf#26368)) 1.0e-9) 
                      (max-count) 
                      (/ 
                        (* $conf#26368 
                          (lookahead)) 
                        (- 1.0 $conf#26368))) 1) 
                  (+ 
                    (+ 
                      (if 
                        (<= 
                          (if 
                            (< 
                              (- 1.0 $conf#26368) 0) 
                            (* -1 
                              (- 1.0 $conf#26368)) 
                            (- 1.0 $conf#26368)) 1.0e-9) 
                        (max-count) 
                        (/ 
                          (* $conf#26368 
                            (lookahead)) 
                          (- 1.0 $conf#26368))) 1) 1.0))))))) 
      (let* 
        ( ( (: $proof3#27352 
              (≞ 
                (→ P Q) 
                (ETV 
                  (:: $h#27357 $t#27358) 
                  (STV $PQs#27359 $PQc#27360)))) (synthesize (: $proof3#27352 (≞ (→ P Q) (ETV (:: $h#27357 $t#27358) (STV $PQs#27359 $PQc#27360)))) kb rb Z)) ((: $proof4#27353 (⍃ $h#27357 (S (S Z)))) (synthesize (: $proof4#27353 (⍃ $h#27357 (S (S Z)))) kb rb Z))) 
        (: 
          (IDIRecursive P2 Q2 $proof3#27352 $proof4#27353) 
          (≞ 
            (→ P Q) 
            (ETV 
              (:: 
                (S (S Z)) 
                (:: $h#27357 $t#27358)) 
              (STV 
                (/ 
                  (* $PQs#27359 
                    (if 
                      (<= 
                        (if 
                          (< 
                            (- 1.0 $PQc#27360) 0) 
                          (* -1 
                            (- 1.0 $PQc#27360)) 
                          (- 1.0 $PQc#27360)) 1.0e-9) 
                      (max-count) 
                      (/ 
                        (* $PQc#27360 
                          (lookahead)) 
                        (- 1.0 $PQc#27360)))) 
                  (+ 
                    (if 
                      (<= 
                        (if 
                          (< 
                            (- 1.0 $PQc#27360) 0) 
                          (* -1 
                            (- 1.0 $PQc#27360)) 
                          (- 1.0 $PQc#27360)) 1.0e-9) 
                      (max-count) 
                      (/ 
                        (* $PQc#27360 
                          (lookahead)) 
                        (- 1.0 $PQc#27360))) 1)) 
                (/ 
                  (+ 
                    (if 
                      (<= 
                        (if 
                          (< 
                            (- 1.0 $PQc#27360) 0) 
                          (* -1 
                            (- 1.0 $PQc#27360)) 
                          (- 1.0 $PQc#27360)) 1.0e-9) 
                      (max-count) 
                      (/ 
                        (* $PQc#27360 
                          (lookahead)) 
                        (- 1.0 $PQc#27360))) 1) 
                  (+ 
                    (+ 
                      (if 
                        (<= 
                          (if 
                            (< 
                              (- 1.0 $PQc#27360) 0) 
                            (* -1 
                              (- 1.0 $PQc#27360)) 
                            (- 1.0 $PQc#27360)) 1.0e-9) 
                        (max-count) 
                        (/ 
                          (* $PQc#27360 
                            (lookahead)) 
                          (- 1.0 $PQc#27360))) 1) 1.0))))))) 
      (let* 
        ( ( (: $proof2#27351 
              (⊷ Q 
                (S (S (S Z))) False)) (synthesize (: $proof2#27351 (⊷ Q (S (S (S Z))) False)) kb rb Z)) 
          ( (: $proof3#27352 
              (≞ 
                (→ P Q) 
                (ETV 
                  (:: $h#27357 $t#27358) 
                  (STV $PQs#27359 $PQc#27360)))) (synthesize (: $proof3#27352 (≞ (→ P Q) (ETV (:: $h#27357 $t#27358) (STV $PQs#27359 $PQc#27360)))) kb rb Z)) 
          ( (: $proof4#27353 
              (⍃ $h#27357 
                (S (S (S Z))))) (synthesize (: $proof4#27353 (⍃ $h#27357 (S (S (S Z))))) kb rb Z))) 
        (: 
          (IDIRecursive P3 $proof2#27351 $proof3#27352 $proof4#27353) 
          (≞ 
            (→ P Q) 
            (ETV 
              (:: 
                (S (S (S Z))) 
                (:: $h#27357 $t#27358)) 
              (STV 
                (/ 
                  (* $PQs#27359 
                    (if 
                      (<= 
                        (if 
                          (< 
                            (- 1.0 $PQc#27360) 0) 
                          (* -1 
                            (- 1.0 $PQc#27360)) 
                          (- 1.0 $PQc#27360)) 1.0e-9) 
                      (max-count) 
                      (/ 
                        (* $PQc#27360 
                          (lookahead)) 
                        (- 1.0 $PQc#27360)))) 
                  (+ 
                    (if 
                      (<= 
                        (if 
                          (< 
                            (- 1.0 $PQc#27360) 0) 
                          (* -1 
                            (- 1.0 $PQc#27360)) 
                          (- 1.0 $PQc#27360)) 1.0e-9) 
                      (max-count) 
                      (/ 
                        (* $PQc#27360 
                          (lookahead)) 
                        (- 1.0 $PQc#27360))) 1)) 
                (/ 
                  (+ 
                    (if 
                      (<= 
                        (if 
                          (< 
                            (- 1.0 $PQc#27360) 0) 
                          (* -1 
                            (- 1.0 $PQc#27360)) 
                          (- 1.0 $PQc#27360)) 1.0e-9) 
                      (max-count) 
                      (/ 
                        (* $PQc#27360 
                          (lookahead)) 
                        (- 1.0 $PQc#27360))) 1) 
                  (+ 
                    (+ 
                      (if 
                        (<= 
                          (if 
                            (< 
                              (- 1.0 $PQc#27360) 0) 
                            (* -1 
                              (- 1.0 $PQc#27360)) 
                            (- 1.0 $PQc#27360)) 1.0e-9) 
                        (max-count) 
                        (/ 
                          (* $PQc#27360 
                            (lookahead)) 
                          (- 1.0 $PQc#27360))) 1) 1.0))))))) 
      (let* 
        ( ( (: $proof2#27351 
              (⊷ Q 
                (S (S (S (S (S (S (S Z))))))) False)) (synthesize (: $proof2#27351 (⊷ Q (S (S (S (S (S (S (S Z))))))) False)) kb rb Z)) 
          ( (: $proof3#27352 
              (≞ 
                (→ P Q) 
                (ETV 
                  (:: $h#27357 $t#27358) 
                  (STV $PQs#27359 $PQc#27360)))) (synthesize (: $proof3#27352 (≞ (→ P Q) (ETV (:: $h#27357 $t#27358) (STV $PQs#27359 $PQc#27360)))) kb rb Z)) 
          ( (: $proof4#27353 
              (⍃ $h#27357 
                (S (S (S (S (S (S (S Z))))))))) (synthesize (: $proof4#27353 (⍃ $h#27357 (S (S (S (S (S (S (S Z))))))))) kb rb Z))) 
        (: 
          (IDIRecursive P7 $proof2#27351 $proof3#27352 $proof4#27353) 
          (≞ 
            (→ P Q) 
            (ETV 
              (:: 
                (S (S (S (S (S (S (S Z))))))) 
                (:: $h#27357 $t#27358)) 
              (STV 
                (/ 
                  (* $PQs#27359 
                    (if 
                      (<= 
                        (if 
                          (< 
                            (- 1.0 $PQc#27360) 0) 
                          (* -1 
                            (- 1.0 $PQc#27360)) 
                          (- 1.0 $PQc#27360)) 1.0e-9) 
                      (max-count) 
                      (/ 
                        (* $PQc#27360 
                          (lookahead)) 
                        (- 1.0 $PQc#27360)))) 
                  (+ 
                    (if 
                      (<= 
                        (if 
                          (< 
                            (- 1.0 $PQc#27360) 0) 
                          (* -1 
                            (- 1.0 $PQc#27360)) 
                          (- 1.0 $PQc#27360)) 1.0e-9) 
                      (max-count) 
                      (/ 
                        (* $PQc#27360 
                          (lookahead)) 
                        (- 1.0 $PQc#27360))) 1)) 
                (/ 
                  (+ 
                    (if 
                      (<= 
                        (if 
                          (< 
                            (- 1.0 $PQc#27360) 0) 
                          (* -1 
                            (- 1.0 $PQc#27360)) 
                          (- 1.0 $PQc#27360)) 1.0e-9) 
                      (max-count) 
                      (/ 
                        (* $PQc#27360 
                          (lookahead)) 
                        (- 1.0 $PQc#27360))) 1) 
                  (+ 
                    (+ 
                      (if 
                        (<= 
                          (if 
                            (< 
                              (- 1.0 $PQc#27360) 0) 
                            (* -1 
                              (- 1.0 $PQc#27360)) 
                            (- 1.0 $PQc#27360)) 1.0e-9) 
                        (max-count) 
                        (/ 
                          (* $PQc#27360 
                            (lookahead)) 
                          (- 1.0 $PQc#27360))) 1) 1.0))))))) 
      (: 
        (IDIBase P2 Q2) 
        (≞ 
          (→ P Q) 
          (ETV 
            (:: 
              (S (S Z)) ∅) 
            (STV 0 0.5)))) 
      (let* 
        ( ( (: $proof2#28198 
              (⊷ Q 
                (S (S (S Z))) False)) (synthesize (: $proof2#28198 (⊷ Q (S (S (S Z))) False)) kb rb Z))) 
        (: 
          (IDIBase P3 $proof2#28198) 
          (≞ 
            (→ P Q) 
            (ETV 
              (:: 
                (S (S (S Z))) ∅) 
              (STV 0 0.5))))) 
      (let* 
        ( ( (: $proof2#28198 
              (⊷ Q 
                (S (S (S (S (S (S (S Z))))))) False)) (synthesize (: $proof2#28198 (⊷ Q (S (S (S (S (S (S (S Z))))))) False)) kb rb Z))) 
        (: 
          (IDIBase P7 $proof2#28198) 
          (≞ 
            (→ P Q) 
            (ETV 
              (:: 
                (S (S (S (S (S (S (S Z))))))) ∅) 
              (STV 0 0.5))))) 
      (let* 
        ( ( (: $proof2#28961 
              (⊷ Q 
                (S (S Z)) True)) (synthesize (: $proof2#28961 (⊷ Q (S (S Z)) True)) kb rb Z))) 
        (: 
          (IDIBase P2 $proof2#28961) 
          (≞ 
            (→ P Q) 
            (ETV 
              (:: 
                (S (S Z)) ∅) 
              (STV 1 0.5))))) 
      (: 
        (IDIBase P3 Q3) 
        (≞ 
          (→ P Q) 
          (ETV 
            (:: 
              (S (S (S Z))) ∅) 
            (STV 1 0.5)))) 
      (: 
        (IDIBase P7 Q7) 
        (≞ 
          (→ P Q) 
          (ETV 
            (:: 
              (S (S (S (S (S (S (S Z))))))) ∅) 
            (STV 1 0.5))))))

<span class="ansi36"
>  (loonit_success  
    (equal_enough_for_test  
      ( (: 
          (IDIBase P2 Q2) 
          (≞ 
            (→ P Q) 
            (ETV 
              (:: 
                (S (S Z)) ∅) 
              (STV 0 0.5)))) 
        (: 
          (IDIBase P2 Q2) 
          (≞ 
            (→ P Q) 
            (ETV 
              (:: 
                (S (S Z)) ∅) 
              (STV 0 0.5)))) 
        (: 
          (IDIBase P3 Q3) 
          (≞ 
            (→ P Q) 
            (ETV 
              (:: 
                (S (S (S Z))) ∅) 
              (STV 1 0.5)))) 
        (: 
          (IDIBase P3 Q3) 
          (≞ 
            (→ P Q) 
            (ETV 
              (:: 
                (S (S (S Z))) ∅) 
              (STV 1 0.5)))) 
        (: 
          (IDIBase P7 Q7) 
          (≞ 
            (→ P Q) 
            (ETV 
              (:: 
                (S (S (S (S (S (S (S Z))))))) ∅) 
              (STV 1 0.5)))) 
        (: 
          (IDIBase P7 Q7) 
          (≞ 
            (→ P Q) 
            (ETV 
              (:: 
                (S (S (S (S (S (S (S Z))))))) ∅) 
              (STV 1 0.5))))) 
      ( (let* 
          ( ( (: $_32968 
                (⊷ Q 
                  (S (S Z)) True)) (synthesize (: $_32968 (⊷ Q (S (S Z)) True)) kb rb Z)) 
            ( (: $_33160 
                (≞ 
                  (→ P Q) 
                  (ETV 
                    (:: $_33238 $_33256) 
                    (STV $_33286 $_33304)))) (synthesize (: $_33160 (≞ (→ P Q) (ETV (:: $_33238 $_33256) (STV $_33286 $_33304)))) kb rb Z)) 
            ( (: $_33484 
                (⍃ $_33238 
                  (S (S Z)))) (synthesize (: $_33484 (⍃ $_33238 (S (S Z)))) kb rb Z))) 
          (: 
            (IDIRecursive P2 $_32968 $_33160 $_33484) 
            (≞ 
              (→ P Q) 
              (ETV 
                (:: 
                  (S (S Z)) 
                  (:: $_33238 $_33256)) 
                (STV 
                  (/ 
                    (+ 
                      (* $_33286 
                        (if 
                          (<= 
                            (if 
                              (< 
                                (- 1.0 $_33304) 0) 
                              (* -1 
                                (- 1.0 $_33304)) 
                              (- 1.0 $_33304)) 1.0e-9) 
                          (max-count) 
                          (/ 
                            (* $_33304 
                              (lookahead)) 
                            (- 1.0 $_33304)))) 1) 
                    (+ 
                      (if 
                        (<= 
                          (if 
                            (< 
                              (- 1.0 $_33304) 0) 
                            (* -1 
                              (- 1.0 $_33304)) 
                            (- 1.0 $_33304)) 1.0e-9) 
                        (max-count) 
                        (/ 
                          (* $_33304 
                            (lookahead)) 
                          (- 1.0 $_33304))) 1)) 
                  (/ 
                    (+ 
                      (if 
                        (<= 
                          (if 
                            (< 
                              (- 1.0 $_33304) 0) 
                            (* -1 
                              (- 1.0 $_33304)) 
                            (- 1.0 $_33304)) 1.0e-9) 
                        (max-count) 
                        (/ 
                          (* $_33304 
                            (lookahead)) 
                          (- 1.0 $_33304))) 1) 
                    (+ 
                      (+ 
                        (if 
                          (<= 
                            (if 
                              (< 
                                (- 1.0 $_33304) 0) 
                              (* -1 
                                (- 1.0 $_33304)) 
                              (- 1.0 $_33304)) 1.0e-9) 
                          (max-count) 
                          (/ 
                            (* $_33304 
                              (lookahead)) 
                            (- 1.0 $_33304))) 1) 1.0))))))) 
        (let 
          (: $_33160 
            (≞ 
              (→ P Q) 
              (ETV 
                (:: $_33238 $_33256) 
                (STV $_33286 $_33304)))) 
          (synthesize 
            (: $_33160 
              (≞ 
                (→ P Q) 
                (ETV 
                  (:: $_33238 $_33256) 
                  (STV $_33286 $_33304)))) kb rb Z) 
          (let 
            (: $_33484 
              (⍃ $_33238 
                (S (S (S Z))))) 
            (synthesize 
              (: $_33484 
                (⍃ $_33238 
                  (S (S (S Z))))) kb rb Z) 
            (: 
              (IDIRecursive P3 Q3 $_33160 $_33484) 
              (≞ 
                (→ P Q) 
                (ETV 
                  (:: 
                    (S (S (S Z))) 
                    (:: $_33238 $_33256)) 
                  (STV 
                    (/ 
                      (+ 
                        (* $_33286 
                          (if 
                            (<= 
                              (if 
                                (< 
                                  (- 1.0 $_33304) 0) 
                                (* -1 
                                  (- 1.0 $_33304)) 
                                (- 1.0 $_33304)) 1.0e-9) 
                            (max-count) 
                            (/ 
                              (* $_33304 
                                (lookahead)) 
                              (- 1.0 $_33304)))) 1) 
                      (+ 
                        (if 
                          (<= 
                            (if 
                              (< 
                                (- 1.0 $_33304) 0) 
                              (* -1 
                                (- 1.0 $_33304)) 
                              (- 1.0 $_33304)) 1.0e-9) 
                          (max-count) 
                          (/ 
                            (* $_33304 
                              (lookahead)) 
                            (- 1.0 $_33304))) 1)) 
                    (/ 
                      (+ 
                        (if 
                          (<= 
                            (if 
                              (< 
                                (- 1.0 $_33304) 0) 
                              (* -1 
                                (- 1.0 $_33304)) 
                              (- 1.0 $_33304)) 1.0e-9) 
                          (max-count) 
                          (/ 
                            (* $_33304 
                              (lookahead)) 
                            (- 1.0 $_33304))) 1) 
                      (+ 
                        (+ 
                          (if 
                            (<= 
                              (if 
                                (< 
                                  (- 1.0 $_33304) 0) 
                                (* -1 
                                  (- 1.0 $_33304)) 
                                (- 1.0 $_33304)) 1.0e-9) 
                            (max-count) 
                            (/ 
                              (* $_33304 
                                (lookahead)) 
                              (- 1.0 $_33304))) 1) 1.0)))))))) 
        (let 
          (: $_33160 
            (≞ 
              (→ P Q) 
              (ETV 
                (:: $_33238 $_33256) 
                (STV $_33286 $_33304)))) 
          (synthesize 
            (: $_33160 
              (≞ 
                (→ P Q) 
                (ETV 
                  (:: $_33238 $_33256) 
                  (STV $_33286 $_33304)))) kb rb Z) 
          (let 
            (: $_33484 
              (⍃ $_33238 
                (S (S (S (S (S (S (S Z))))))))) 
            (synthesize 
              (: $_33484 
                (⍃ $_33238 
                  (S (S (S (S (S (S (S Z))))))))) kb rb Z) 
            (: 
              (IDIRecursive P7 Q7 $_33160 $_33484) 
              (≞ 
                (→ P Q) 
                (ETV 
                  (:: 
                    (S (S (S (S (S (S (S Z))))))) 
                    (:: $_33238 $_33256)) 
                  (STV 
                    (/ 
                      (+ 
                        (* $_33286 
                          (if 
                            (<= 
                              (if 
                                (< 
                                  (- 1.0 $_33304) 0) 
                                (* -1 
                                  (- 1.0 $_33304)) 
                                (- 1.0 $_33304)) 1.0e-9) 
                            (max-count) 
                            (/ 
                              (* $_33304 
                                (lookahead)) 
                              (- 1.0 $_33304)))) 1) 
                      (+ 
                        (if 
                          (<= 
                            (if 
                              (< 
                                (- 1.0 $_33304) 0) 
                              (* -1 
                                (- 1.0 $_33304)) 
                              (- 1.0 $_33304)) 1.0e-9) 
                          (max-count) 
                          (/ 
                            (* $_33304 
                              (lookahead)) 
                            (- 1.0 $_33304))) 1)) 
                    (/ 
                      (+ 
                        (if 
                          (<= 
                            (if 
                              (< 
                                (- 1.0 $_33304) 0) 
                              (* -1 
                                (- 1.0 $_33304)) 
                              (- 1.0 $_33304)) 1.0e-9) 
                          (max-count) 
                          (/ 
                            (* $_33304 
                              (lookahead)) 
                            (- 1.0 $_33304))) 1) 
                      (+ 
                        (+ 
                          (if 
                            (<= 
                              (if 
                                (< 
                                  (- 1.0 $_33304) 0) 
                                (* -1 
                                  (- 1.0 $_33304)) 
                                (- 1.0 $_33304)) 1.0e-9) 
                            (max-count) 
                            (/ 
                              (* $_33304 
                                (lookahead)) 
                              (- 1.0 $_33304))) 1) 1.0)))))))) 
        (let 
          (: $_38452 
            (≞ 
              (→ P Q) 
              (ETV 
                (:: $_38530 $_38548) 
                (STV $_38578 $_38596)))) 
          (synthesize 
            (: $_38452 
              (≞ 
                (→ P Q) 
                (ETV 
                  (:: $_38530 $_38548) 
                  (STV $_38578 $_38596)))) kb rb Z) 
          (let 
            (: $_38776 
              (⍃ $_38530 
                (S (S Z)))) 
            (synthesize 
              (: $_38776 
                (⍃ $_38530 
                  (S (S Z)))) kb rb Z) 
            (: 
              (IDIRecursive P2 Q2 $_38452 $_38776) 
              (≞ 
                (→ P Q) 
                (ETV 
                  (:: 
                    (S (S Z)) 
                    (:: $_38530 $_38548)) 
                  (STV 
                    (/ 
                      (* $_38578 
                        (if 
                          (<= 
                            (if 
                              (< 
                                (- 1.0 $_38596) 0) 
                              (* -1 
                                (- 1.0 $_38596)) 
                              (- 1.0 $_38596)) 1.0e-9) 
                          (max-count) 
                          (/ 
                            (* $_38596 
                              (lookahead)) 
                            (- 1.0 $_38596)))) 
                      (+ 
                        (if 
                          (<= 
                            (if 
                              (< 
                                (- 1.0 $_38596) 0) 
                              (* -1 
                                (- 1.0 $_38596)) 
                              (- 1.0 $_38596)) 1.0e-9) 
                          (max-count) 
                          (/ 
                            (* $_38596 
                              (lookahead)) 
                            (- 1.0 $_38596))) 1)) 
                    (/ 
                      (+ 
                        (if 
                          (<= 
                            (if 
                              (< 
                                (- 1.0 $_38596) 0) 
                              (* -1 
                                (- 1.0 $_38596)) 
                              (- 1.0 $_38596)) 1.0e-9) 
                          (max-count) 
                          (/ 
                            (* $_38596 
                              (lookahead)) 
                            (- 1.0 $_38596))) 1) 
                      (+ 
                        (+ 
                          (if 
                            (<= 
                              (if 
                                (< 
                                  (- 1.0 $_38596) 0) 
                                (* -1 
                                  (- 1.0 $_38596)) 
                                (- 1.0 $_38596)) 1.0e-9) 
                            (max-count) 
                            (/ 
                              (* $_38596 
                                (lookahead)) 
                              (- 1.0 $_38596))) 1) 1.0)))))))) 
        (let 
          (: $_40174 
            (⊷ Q 
              (S (S (S Z))) False)) 
          (synthesize 
            (: $_40174 
              (⊷ Q 
                (S (S (S Z))) False)) kb rb Z) 
          (let 
            (: $_38452 
              (≞ 
                (→ P Q) 
                (ETV 
                  (:: $_38530 $_38548) 
                  (STV $_38578 $_38596)))) 
            (synthesize 
              (: $_38452 
                (≞ 
                  (→ P Q) 
                  (ETV 
                    (:: $_38530 $_38548) 
                    (STV $_38578 $_38596)))) kb rb Z) 
            (let 
              (: $_38776 
                (⍃ $_38530 
                  (S (S (S Z))))) 
              (synthesize 
                (: $_38776 
                  (⍃ $_38530 
                    (S (S (S Z))))) kb rb Z) 
              (: 
                (IDIRecursive P3 $_40174 $_38452 $_38776) 
                (≞ 
                  (→ P Q) 
                  (ETV 
                    (:: 
                      (S (S (S Z))) 
                      (:: $_38530 $_38548)) 
                    (STV 
                      (/ 
                        (* $_38578 
                          (if 
                            (<= 
                              (if 
                                (< 
                                  (- 1.0 $_38596) 0) 
                                (* -1 
                                  (- 1.0 $_38596)) 
                                (- 1.0 $_38596)) 1.0e-9) 
                            (max-count) 
                            (/ 
                              (* $_38596 
                                (lookahead)) 
                              (- 1.0 $_38596)))) 
                        (+ 
                          (if 
                            (<= 
                              (if 
                                (< 
                                  (- 1.0 $_38596) 0) 
                                (* -1 
                                  (- 1.0 $_38596)) 
                                (- 1.0 $_38596)) 1.0e-9) 
                            (max-count) 
                            (/ 
                              (* $_38596 
                                (lookahead)) 
                              (- 1.0 $_38596))) 1)) 
                      (/ 
                        (+ 
                          (if 
                            (<= 
                              (if 
                                (< 
                                  (- 1.0 $_38596) 0) 
                                (* -1 
                                  (- 1.0 $_38596)) 
                                (- 1.0 $_38596)) 1.0e-9) 
                            (max-count) 
                            (/ 
                              (* $_38596 
                                (lookahead)) 
                              (- 1.0 $_38596))) 1) 
                        (+ 
                          (+ 
                            (if 
                              (<= 
                                (if 
                                  (< 
                                    (- 1.0 $_38596) 0) 
                                  (* -1 
                                    (- 1.0 $_38596)) 
                                  (- 1.0 $_38596)) 1.0e-9) 
                              (max-count) 
                              (/ 
                                (* $_38596 
                                  (lookahead)) 
                                (- 1.0 $_38596))) 1) 1.0))))))))) 
        (let 
          (: $_40174 
            (⊷ Q 
              (S (S (S (S (S (S (S Z))))))) False)) 
          (synthesize 
            (: $_40174 
              (⊷ Q 
                (S (S (S (S (S (S (S Z))))))) False)) kb rb Z) 
          (let 
            (: $_38452 
              (≞ 
                (→ P Q) 
                (ETV 
                  (:: $_38530 $_38548) 
                  (STV $_38578 $_38596)))) 
            (synthesize 
              (: $_38452 
                (≞ 
                  (→ P Q) 
                  (ETV 
                    (:: $_38530 $_38548) 
                    (STV $_38578 $_38596)))) kb rb Z) 
            (let 
              (: $_38776 
                (⍃ $_38530 
                  (S (S (S (S (S (S (S Z))))))))) 
              (synthesize 
                (: $_38776 
                  (⍃ $_38530 
                    (S (S (S (S (S (S (S Z))))))))) kb rb Z) 
              (: 
                (IDIRecursive P7 $_40174 $_38452 $_38776) 
                (≞ 
                  (→ P Q) 
                  (ETV 
                    (:: 
                      (S (S (S (S (S (S (S Z))))))) 
                      (:: $_38530 $_38548)) 
                    (STV 
                      (/ 
                        (* $_38578 
                          (if 
                            (<= 
                              (if 
                                (< 
                                  (- 1.0 $_38596) 0) 
                                (* -1 
                                  (- 1.0 $_38596)) 
                                (- 1.0 $_38596)) 1.0e-9) 
                            (max-count) 
                            (/ 
                              (* $_38596 
                                (lookahead)) 
                              (- 1.0 $_38596)))) 
                        (+ 
                          (if 
                            (<= 
                              (if 
                                (< 
                                  (- 1.0 $_38596) 0) 
                                (* -1 
                                  (- 1.0 $_38596)) 
                                (- 1.0 $_38596)) 1.0e-9) 
                            (max-count) 
                            (/ 
                              (* $_38596 
                                (lookahead)) 
                              (- 1.0 $_38596))) 1)) 
                      (/ 
                        (+ 
                          (if 
                            (<= 
                              (if 
                                (< 
                                  (- 1.0 $_38596) 0) 
                                (* -1 
                                  (- 1.0 $_38596)) 
                                (- 1.0 $_38596)) 1.0e-9) 
                            (max-count) 
                            (/ 
                              (* $_38596 
                                (lookahead)) 
                              (- 1.0 $_38596))) 1) 
                        (+ 
                          (+ 
                            (if 
                              (<= 
                                (if 
                                  (< 
                                    (- 1.0 $_38596) 0) 
                                  (* -1 
                                    (- 1.0 $_38596)) 
                                  (- 1.0 $_38596)) 1.0e-9) 
                              (max-count) 
                              (/ 
                                (* $_38596 
                                  (lookahead)) 
                                (- 1.0 $_38596))) 1) 1.0))))))))) 
        (: 
          (IDIBase P2 Q2) 
          (≞ 
            (→ P Q) 
            (ETV 
              (:: 
                (S (S Z)) ∅) 
              (STV 0 0.5)))) 
        (let 
          (: $_44362 
            (⊷ Q 
              (S (S (S Z))) False)) 
          (synthesize 
            (: $_44362 
              (⊷ Q 
                (S (S (S Z))) False)) kb rb Z) 
          (: 
            (IDIBase P3 $_44362) 
            (≞ 
              (→ P Q) 
              (ETV 
                (:: 
                  (S (S (S Z))) ∅) 
                (STV 0 0.5))))) 
        (let 
          (: $_44362 
            (⊷ Q 
              (S (S (S (S (S (S (S Z))))))) False)) 
          (synthesize 
            (: $_44362 
              (⊷ Q 
                (S (S (S (S (S (S (S Z))))))) False)) kb rb Z) 
          (: 
            (IDIBase P7 $_44362) 
            (≞ 
              (→ P Q) 
              (ETV 
                (:: 
                  (S (S (S (S (S (S (S Z))))))) ∅) 
                (STV 0 0.5))))) 
        (let 
          (: $_45298 
            (⊷ Q 
              (S (S Z)) True)) 
          (synthesize 
            (: $_45298 
              (⊷ Q 
                (S (S Z)) True)) kb rb Z) 
          (: 
            (IDIBase P2 $_45298) 
            (≞ 
              (→ P Q) 
              (ETV 
                (:: 
                  (S (S Z)) ∅) 
                (STV 1 0.5))))) 
        (: 
          (IDIBase P3 Q3) 
          (≞ 
            (→ P Q) 
            (ETV 
              (:: 
                (S (S (S Z))) ∅) 
              (STV 1 0.5)))) 
        (: 
          (IDIBase P7 Q7) 
          (≞ 
            (→ P Q) 
            (ETV 
              (:: 
                (S (S (S (S (S (S (S Z))))))) ∅) 
              (STV 1 0.5)))))))
</span>
Deterministic: ()
()]
;;;; Prove that P→Q using one, two and three pieces of evidence.
;;;;
;;;; The synthesizer should build proof trees using one, two and
;;;; ultimate three pieces of evidence.  The proof tree using three
;;;; pieces of evidences is displayed below:
;;;;
;;;;                                                                                                ----(ZeroLTSucc)        ----(ZeroLTSucc)
;;;;                                                                                                0 ⍃ 1                   0 ⍃ 4
;;;;                                                            --------(P2)     --------(Q2)       ----(SuccMonotonicity)  ----(SuccMonotonicity)
;;;;                                                            (P 2) = ⊤        (Q 2) = ⊥          1 ⍃ 2                   1 ⍃ 5
;;;;                             --------(P3)     --------(Q3)  -------------------------(IDIBase)  ----(SuccMonotonicity)  ----(SuccMonotonicity)
;;;;                             (P 3) = ⊤        (Q 3) = ⊥     P → Q ≞ (:: 2 ∅), <0 0.5>)          2 ⍃ 3                   2 ⍃ 6
;;;; --------(P7)  --------(Q7)  -----------------------------------------------------------------------(IDIRecursive)      ----(SuccMonotonicity)
;;;; (P 7) = ⊤     (Q 7) = ⊤              P → Q ≞ ((:: 3 (:: 2 ∅)), <0.5 0.6666666666666666>)                                       3 ⍃ 7
;;;; ---------------------------------------------------------------------------------------------------------------------------(IDIRecursive)
;;;;                                  P → Q ≞ ((:: 7 (:: 5 (:: 2 ∅))), <0.6666666666666666 0.75>)
;;;;
;;;; Or, in MeTTa format
;;;;
;;;; (: (IDIRecursive
;;;;      P7
;;;;      Q7
;;;;      (IDIRecursive
;;;;        P3
;;;;        Q3
;;;;        (IDIBase P2 Q2)
;;;;        (SuccMonotonicity (SuccMonotonicity ZeroLTSucc)))
;;;;      (SuccMonotonicity (SuccMonotonicity (SuccMonotonicity ZeroLTSucc))))
;;;;    (≞ (→ P Q)
;;;;       (ETV (:: (S (S (S (S (S (S (S Z))))))) (:: (S (S (S Z))) (:: (S (S Z)) ∅)))
;;;;            (STV 0.6666666666666666 0.75))))
<span class="ansi38-255165009"
>;; In file as:  
</span><span class="ansi1 ansi38-255238088"
>  !=====
</span>;; To unit test case:
<span class="ansi38-013099040"
>  !(assertEqualToResult ===== 
    ("===== Prove P→Q using base , recursive and order rules (synthesizer) ====="))

</span>[

;<h3 id="DEPENDENT-TYPES.IMPLICATIONDIRECTINTRODUCTIONDTLTEST.15"
>;; DEPENDENT-TYPES.IMPLICATIONDIRECTINTRODUCTIONDTLTEST.15</h3>
; 
; EVAL TEST
; took 0.000025 secs. (25.33 microseconds) 

  !(assertEqualToResult ===== 
    ("===== Prove P→Q using base , recursive and order rules (synthesizer) ====="))

<span class="ansi31"
>  (loonit_failureR  
    (equal_enough_for_test  
      (=====) 
      ("===== Prove P→Q using base , recursive and order rules (synthesizer) =====")))
</span>
Deterministic: ((Error  (got  (=====)) (expected  ("===== Prove P→Q using base , recursive and order rules (synthesizer) ====="))))
((Error  (got  (=====)) (expected  ("===== Prove P→Q using base , recursive and order rules (synthesizer) ====="))))]
<span class="ansi38-255165009"
>;; In file as:  
</span><span class="ansi1 ansi38-255238088"
>  !(synthesize 
    (: $proof 
      (≞ 
        (→ P Q) $etv)) kb rb 
    (fromNumber 4))
</span>;; To unit test case:
<span class="ansi38-013099040"
>  !(assertEqualToResult 
    (synthesize 
      (: $proof 
        (≞ 
          (→ P Q) $etv)) kb rb 
      (fromNumber 4)) 
    ( (let* 
        ( ( (: $proof2#34807 
              (⊷ Q 
                (S (S Z)) True)) (synthesize (: $proof2#34807 (⊷ Q (S (S Z)) True)) kb rb (S (S (S Z))))) 
          ( (: $proof3#34808 
              (≞ 
                (→ P Q) 
                (ETV 
                  (:: $h#34813 $t#34814) 
                  (STV $s#34815 $c#34816)))) (synthesize (: $proof3#34808 (≞ (→ P Q) (ETV (:: $h#34813 $t#34814) (STV $s#34815 $c#34816)))) kb rb (S (S (S Z))))) 
          ( (: $proof4#34809 
              (⍃ $h#34813 
                (S (S Z)))) (synthesize (: $proof4#34809 (⍃ $h#34813 (S (S Z)))) kb rb (S (S (S Z)))))) 
        (: 
          (IDIRecursive P2 $proof2#34807 $proof3#34808 $proof4#34809) 
          (≞ 
            (→ P Q) 
            (ETV 
              (:: 
                (S (S Z)) 
                (:: $h#34813 $t#34814)) 
              (STV 
                (/ 
                  (+ 
                    (* $s#34815 
                      (if 
                        (<= 
                          (if 
                            (< 
                              (- 1.0 $c#34816) 0) 
                            (* -1 
                              (- 1.0 $c#34816)) 
                            (- 1.0 $c#34816)) 1.0e-9) 
                        (max-count) 
                        (/ 
                          (* $c#34816 
                            (lookahead)) 
                          (- 1.0 $c#34816)))) 1) 
                  (+ 
                    (if 
                      (<= 
                        (if 
                          (< 
                            (- 1.0 $c#34816) 0) 
                          (* -1 
                            (- 1.0 $c#34816)) 
                          (- 1.0 $c#34816)) 1.0e-9) 
                      (max-count) 
                      (/ 
                        (* $c#34816 
                          (lookahead)) 
                        (- 1.0 $c#34816))) 1)) 
                (/ 
                  (+ 
                    (if 
                      (<= 
                        (if 
                          (< 
                            (- 1.0 $c#34816) 0) 
                          (* -1 
                            (- 1.0 $c#34816)) 
                          (- 1.0 $c#34816)) 1.0e-9) 
                      (max-count) 
                      (/ 
                        (* $c#34816 
                          (lookahead)) 
                        (- 1.0 $c#34816))) 1) 
                  (+ 
                    (+ 
                      (if 
                        (<= 
                          (if 
                            (< 
                              (- 1.0 $c#34816) 0) 
                            (* -1 
                              (- 1.0 $c#34816)) 
                            (- 1.0 $c#34816)) 1.0e-9) 
                        (max-count) 
                        (/ 
                          (* $c#34816 
                            (lookahead)) 
                          (- 1.0 $c#34816))) 1) 1.0))))))) 
      (: 
        (IDIRecursive P3 Q3 
          (IDIBase P2 Q2) 
          (SuccMonotonicity (SuccMonotonicity ZeroLTSucc))) 
        (≞ 
          (→ P Q) 
          (ETV 
            (:: 
              (S (S (S Z))) 
              (:: 
                (S (S Z)) ∅)) 
            (STV 0.5 0.6666666666666666)))) 
      (: 
        (IDIRecursive P7 Q7 
          (IDIRecursive P3 Q3 
            (IDIBase P2 Q2) 
            (SuccMonotonicity (SuccMonotonicity ZeroLTSucc))) 
          (SuccMonotonicity (SuccMonotonicity (SuccMonotonicity ZeroLTSucc)))) 
        (≞ 
          (→ P Q) 
          (ETV 
            (:: 
              (S (S (S (S (S (S (S Z))))))) 
              (:: 
                (S (S (S Z))) 
                (:: 
                  (S (S Z)) ∅))) 
            (STV 0.6666666666666666 0.75)))) 
      (: 
        (IDIRecursive P7 Q7 
          (IDIBase P2 Q2) 
          (SuccMonotonicity (SuccMonotonicity ZeroLTSucc))) 
        (≞ 
          (→ P Q) 
          (ETV 
            (:: 
              (S (S (S (S (S (S (S Z))))))) 
              (:: 
                (S (S Z)) ∅)) 
            (STV 0.5 0.6666666666666666)))) 
      (: 
        (IDIRecursive P7 Q7 
          (IDIBase P3 Q3) 
          (SuccMonotonicity (SuccMonotonicity (SuccMonotonicity ZeroLTSucc)))) 
        (≞ 
          (→ P Q) 
          (ETV 
            (:: 
              (S (S (S (S (S (S (S Z))))))) 
              (:: 
                (S (S (S Z))) ∅)) 
            (STV 1.0 0.6666666666666666)))) 
      (let* 
        ( ( (: $proof4#150034 
              (⍃ 
                (S (S (S Z))) 
                (S (S Z)))) (synthesize (: $proof4#150034 (⍃ (S (S (S Z))) (S (S Z)))) kb rb (S (S (S Z)))))) 
        (: 
          (IDIRecursive P2 Q2 
            (IDIRecursive P3 Q3 
              (IDIBase P2 Q2) 
              (SuccMonotonicity (SuccMonotonicity ZeroLTSucc))) $proof4#150034) 
          (≞ 
            (→ P Q) 
            (ETV 
              (:: 
                (S (S Z)) 
                (:: 
                  (S (S (S Z))) 
                  (:: 
                    (S (S Z)) ∅))) 
              (STV 
                (/ 
                  (* 0.5 
                    (if 
                      (<= 
                        (if 
                          (< 
                            (- 1.0 0.6666666666666666) 0) 
                          (* -1 
                            (- 1.0 0.6666666666666666)) 
                          (- 1.0 0.6666666666666666)) 1.0e-9) 
                      (max-count) 
                      (/ 
                        (* 0.6666666666666666 
                          (lookahead)) 
                        (- 1.0 0.6666666666666666)))) 
                  (+ 
                    (if 
                      (<= 
                        (if 
                          (< 
                            (- 1.0 0.6666666666666666) 0) 
                          (* -1 
                            (- 1.0 0.6666666666666666)) 
                          (- 1.0 0.6666666666666666)) 1.0e-9) 
                      (max-count) 
                      (/ 
                        (* 0.6666666666666666 
                          (lookahead)) 
                        (- 1.0 0.6666666666666666))) 1)) 
                (/ 
                  (+ 
                    (if 
                      (<= 
                        (if 
                          (< 
                            (- 1.0 0.6666666666666666) 0) 
                          (* -1 
                            (- 1.0 0.6666666666666666)) 
                          (- 1.0 0.6666666666666666)) 1.0e-9) 
                      (max-count) 
                      (/ 
                        (* 0.6666666666666666 
                          (lookahead)) 
                        (- 1.0 0.6666666666666666))) 1) 
                  (+ 
                    (+ 
                      (if 
                        (<= 
                          (if 
                            (< 
                              (- 1.0 0.6666666666666666) 0) 
                            (* -1 
                              (- 1.0 0.6666666666666666)) 
                            (- 1.0 0.6666666666666666)) 1.0e-9) 
                        (max-count) 
                        (/ 
                          (* 0.6666666666666666 
                            (lookahead)) 
                          (- 1.0 0.6666666666666666))) 1) 1.0))))))) 
      (let* 
        ( ( (: $proof4#150034 
              (⍃ 
                (S (S (S (S (S (S (S Z))))))) 
                (S (S Z)))) (synthesize (: $proof4#150034 (⍃ (S (S (S (S (S (S (S Z))))))) (S (S Z)))) kb rb (S (S (S Z)))))) 
        (: 
          (IDIRecursive P2 Q2 
            (IDIRecursive P7 Q7 
              (IDIBase P2 Q2) 
              (SuccMonotonicity (SuccMonotonicity ZeroLTSucc))) $proof4#150034) 
          (≞ 
            (→ P Q) 
            (ETV 
              (:: 
                (S (S Z)) 
                (:: 
                  (S (S (S (S (S (S (S Z))))))) 
                  (:: 
                    (S (S Z)) ∅))) 
              (STV 
                (/ 
                  (* 0.5 
                    (if 
                      (<= 
                        (if 
                          (< 
                            (- 1.0 0.6666666666666666) 0) 
                          (* -1 
                            (- 1.0 0.6666666666666666)) 
                          (- 1.0 0.6666666666666666)) 1.0e-9) 
                      (max-count) 
                      (/ 
                        (* 0.6666666666666666 
                          (lookahead)) 
                        (- 1.0 0.6666666666666666)))) 
                  (+ 
                    (if 
                      (<= 
                        (if 
                          (< 
                            (- 1.0 0.6666666666666666) 0) 
                          (* -1 
                            (- 1.0 0.6666666666666666)) 
                          (- 1.0 0.6666666666666666)) 1.0e-9) 
                      (max-count) 
                      (/ 
                        (* 0.6666666666666666 
                          (lookahead)) 
                        (- 1.0 0.6666666666666666))) 1)) 
                (/ 
                  (+ 
                    (if 
                      (<= 
                        (if 
                          (< 
                            (- 1.0 0.6666666666666666) 0) 
                          (* -1 
                            (- 1.0 0.6666666666666666)) 
                          (- 1.0 0.6666666666666666)) 1.0e-9) 
                      (max-count) 
                      (/ 
                        (* 0.6666666666666666 
                          (lookahead)) 
                        (- 1.0 0.6666666666666666))) 1) 
                  (+ 
                    (+ 
                      (if 
                        (<= 
                          (if 
                            (< 
                              (- 1.0 0.6666666666666666) 0) 
                            (* -1 
                              (- 1.0 0.6666666666666666)) 
                            (- 1.0 0.6666666666666666)) 1.0e-9) 
                        (max-count) 
                        (/ 
                          (* 0.6666666666666666 
                            (lookahead)) 
                          (- 1.0 0.6666666666666666))) 1) 1.0))))))) 
      (let* 
        ( ( (: $proof4#150034 
              (⍃ 
                (S (S Z)) 
                (S (S Z)))) (synthesize (: $proof4#150034 (⍃ (S (S Z)) (S (S Z)))) kb rb (S (S (S Z)))))) 
        (: 
          (IDIRecursive P2 Q2 
            (IDIBase P2 Q2) $proof4#150034) 
          (≞ 
            (→ P Q) 
            (ETV 
              (:: 
                (S (S Z)) 
                (:: 
                  (S (S Z)) ∅)) 
              (STV 
                (/ 
                  (* 0 
                    (if 
                      (<= 
                        (if 
                          (< 
                            (- 1.0 0.5) 0) 
                          (* -1 
                            (- 1.0 0.5)) 
                          (- 1.0 0.5)) 1.0e-9) 
                      (max-count) 
                      (/ 
                        (* 0.5 
                          (lookahead)) 
                        (- 1.0 0.5)))) 
                  (+ 
                    (if 
                      (<= 
                        (if 
                          (< 
                            (- 1.0 0.5) 0) 
                          (* -1 
                            (- 1.0 0.5)) 
                          (- 1.0 0.5)) 1.0e-9) 
                      (max-count) 
                      (/ 
                        (* 0.5 
                          (lookahead)) 
                        (- 1.0 0.5))) 1)) 
                (/ 
                  (+ 
                    (if 
                      (<= 
                        (if 
                          (< 
                            (- 1.0 0.5) 0) 
                          (* -1 
                            (- 1.0 0.5)) 
                          (- 1.0 0.5)) 1.0e-9) 
                      (max-count) 
                      (/ 
                        (* 0.5 
                          (lookahead)) 
                        (- 1.0 0.5))) 1) 
                  (+ 
                    (+ 
                      (if 
                        (<= 
                          (if 
                            (< 
                              (- 1.0 0.5) 0) 
                            (* -1 
                              (- 1.0 0.5)) 
                            (- 1.0 0.5)) 1.0e-9) 
                        (max-count) 
                        (/ 
                          (* 0.5 
                            (lookahead)) 
                          (- 1.0 0.5))) 1) 1.0))))))) 
      (let* 
        ( ( (: $proof4#150034 
              (⍃ 
                (S (S (S Z))) 
                (S (S Z)))) (synthesize (: $proof4#150034 (⍃ (S (S (S Z))) (S (S Z)))) kb rb (S (S (S Z)))))) 
        (: 
          (IDIRecursive P2 Q2 
            (IDIBase P3 Q3) $proof4#150034) 
          (≞ 
            (→ P Q) 
            (ETV 
              (:: 
                (S (S Z)) 
                (:: 
                  (S (S (S Z))) ∅)) 
              (STV 
                (/ 
                  (* 1 
                    (if 
                      (<= 
                        (if 
                          (< 
                            (- 1.0 0.5) 0) 
                          (* -1 
                            (- 1.0 0.5)) 
                          (- 1.0 0.5)) 1.0e-9) 
                      (max-count) 
                      (/ 
                        (* 0.5 
                          (lookahead)) 
                        (- 1.0 0.5)))) 
                  (+ 
                    (if 
                      (<= 
                        (if 
                          (< 
                            (- 1.0 0.5) 0) 
                          (* -1 
                            (- 1.0 0.5)) 
                          (- 1.0 0.5)) 1.0e-9) 
                      (max-count) 
                      (/ 
                        (* 0.5 
                          (lookahead)) 
                        (- 1.0 0.5))) 1)) 
                (/ 
                  (+ 
                    (if 
                      (<= 
                        (if 
                          (< 
                            (- 1.0 0.5) 0) 
                          (* -1 
                            (- 1.0 0.5)) 
                          (- 1.0 0.5)) 1.0e-9) 
                      (max-count) 
                      (/ 
                        (* 0.5 
                          (lookahead)) 
                        (- 1.0 0.5))) 1) 
                  (+ 
                    (+ 
                      (if 
                        (<= 
                          (if 
                            (< 
                              (- 1.0 0.5) 0) 
                            (* -1 
                              (- 1.0 0.5)) 
                            (- 1.0 0.5)) 1.0e-9) 
                        (max-count) 
                        (/ 
                          (* 0.5 
                            (lookahead)) 
                          (- 1.0 0.5))) 1) 1.0))))))) 
      (let* 
        ( ( (: $proof4#150034 
              (⍃ 
                (S (S (S (S (S (S (S Z))))))) 
                (S (S Z)))) (synthesize (: $proof4#150034 (⍃ (S (S (S (S (S (S (S Z))))))) (S (S Z)))) kb rb (S (S (S Z)))))) 
        (: 
          (IDIRecursive P2 Q2 
            (IDIBase P7 Q7) $proof4#150034) 
          (≞ 
            (→ P Q) 
            (ETV 
              (:: 
                (S (S Z)) 
                (:: 
                  (S (S (S (S (S (S (S Z))))))) ∅)) 
              (STV 
                (/ 
                  (* 1 
                    (if 
                      (<= 
                        (if 
                          (< 
                            (- 1.0 0.5) 0) 
                          (* -1 
                            (- 1.0 0.5)) 
                          (- 1.0 0.5)) 1.0e-9) 
                      (max-count) 
                      (/ 
                        (* 0.5 
                          (lookahead)) 
                        (- 1.0 0.5)))) 
                  (+ 
                    (if 
                      (<= 
                        (if 
                          (< 
                            (- 1.0 0.5) 0) 
                          (* -1 
                            (- 1.0 0.5)) 
                          (- 1.0 0.5)) 1.0e-9) 
                      (max-count) 
                      (/ 
                        (* 0.5 
                          (lookahead)) 
                        (- 1.0 0.5))) 1)) 
                (/ 
                  (+ 
                    (if 
                      (<= 
                        (if 
                          (< 
                            (- 1.0 0.5) 0) 
                          (* -1 
                            (- 1.0 0.5)) 
                          (- 1.0 0.5)) 1.0e-9) 
                      (max-count) 
                      (/ 
                        (* 0.5 
                          (lookahead)) 
                        (- 1.0 0.5))) 1) 
                  (+ 
                    (+ 
                      (if 
                        (<= 
                          (if 
                            (< 
                              (- 1.0 0.5) 0) 
                            (* -1 
                              (- 1.0 0.5)) 
                            (- 1.0 0.5)) 1.0e-9) 
                        (max-count) 
                        (/ 
                          (* 0.5 
                            (lookahead)) 
                          (- 1.0 0.5))) 1) 1.0))))))) 
      (let* 
        ( ( (: $proof2#150032 
              (⊷ Q 
                (S (S (S Z))) False)) (synthesize (: $proof2#150032 (⊷ Q (S (S (S Z))) False)) kb rb (S (S (S Z))))) 
          ( (: $proof3#150033 
              (≞ 
                (→ P Q) 
                (ETV 
                  (:: $h#150038 $t#150039) 
                  (STV $PQs#150040 $y#150041)))) (synthesize (: $proof3#150033 (≞ (→ P Q) (ETV (:: $h#150038 $t#150039) (STV $PQs#150040 $y#150041)))) kb rb (S (S (S Z))))) 
          ( (: $proof4#150034 
              (⍃ $h#150038 
                (S (S (S Z))))) (synthesize (: $proof4#150034 (⍃ $h#150038 (S (S (S Z))))) kb rb (S (S (S Z)))))) 
        (: 
          (IDIRecursive P3 $proof2#150032 $proof3#150033 $proof4#150034) 
          (≞ 
            (→ P Q) 
            (ETV 
              (:: 
                (S (S (S Z))) 
                (:: $h#150038 $t#150039)) 
              (STV 
                (/ 
                  (* $PQs#150040 
                    (if 
                      (<= 
                        (if 
                          (< 
                            (- 1.0 $y#150041) 0) 
                          (* -1 
                            (- 1.0 $y#150041)) 
                          (- 1.0 $y#150041)) 1.0e-9) 
                      (max-count) 
                      (/ 
                        (* $y#150041 
                          (lookahead)) 
                        (- 1.0 $y#150041)))) 
                  (+ 
                    (if 
                      (<= 
                        (if 
                          (< 
                            (- 1.0 $y#150041) 0) 
                          (* -1 
                            (- 1.0 $y#150041)) 
                          (- 1.0 $y#150041)) 1.0e-9) 
                      (max-count) 
                      (/ 
                        (* $y#150041 
                          (lookahead)) 
                        (- 1.0 $y#150041))) 1)) 
                (/ 
                  (+ 
                    (if 
                      (<= 
                        (if 
                          (< 
                            (- 1.0 $y#150041) 0) 
                          (* -1 
                            (- 1.0 $y#150041)) 
                          (- 1.0 $y#150041)) 1.0e-9) 
                      (max-count) 
                      (/ 
                        (* $y#150041 
                          (lookahead)) 
                        (- 1.0 $y#150041))) 1) 
                  (+ 
                    (+ 
                      (if 
                        (<= 
                          (if 
                            (< 
                              (- 1.0 $y#150041) 0) 
                            (* -1 
                              (- 1.0 $y#150041)) 
                            (- 1.0 $y#150041)) 1.0e-9) 
                        (max-count) 
                        (/ 
                          (* $y#150041 
                            (lookahead)) 
                          (- 1.0 $y#150041))) 1) 1.0))))))) 
      (let* 
        ( ( (: $proof2#150032 
              (⊷ Q 
                (S (S (S (S (S (S (S Z))))))) False)) (synthesize (: $proof2#150032 (⊷ Q (S (S (S (S (S (S (S Z))))))) False)) kb rb (S (S (S Z))))) 
          ( (: $proof3#150033 
              (≞ 
                (→ P Q) 
                (ETV 
                  (:: $h#150038 $t#150039) 
                  (STV $PQs#150040 $y#150041)))) (synthesize (: $proof3#150033 (≞ (→ P Q) (ETV (:: $h#150038 $t#150039) (STV $PQs#150040 $y#150041)))) kb rb (S (S (S Z))))) 
          ( (: $proof4#150034 
              (⍃ $h#150038 
                (S (S (S (S (S (S (S Z))))))))) (synthesize (: $proof4#150034 (⍃ $h#150038 (S (S (S (S (S (S (S Z))))))))) kb rb (S (S (S Z)))))) 
        (: 
          (IDIRecursive P7 $proof2#150032 $proof3#150033 $proof4#150034) 
          (≞ 
            (→ P Q) 
            (ETV 
              (:: 
                (S (S (S (S (S (S (S Z))))))) 
                (:: $h#150038 $t#150039)) 
              (STV 
                (/ 
                  (* $PQs#150040 
                    (if 
                      (<= 
                        (if 
                          (< 
                            (- 1.0 $y#150041) 0) 
                          (* -1 
                            (- 1.0 $y#150041)) 
                          (- 1.0 $y#150041)) 1.0e-9) 
                      (max-count) 
                      (/ 
                        (* $y#150041 
                          (lookahead)) 
                        (- 1.0 $y#150041)))) 
                  (+ 
                    (if 
                      (<= 
                        (if 
                          (< 
                            (- 1.0 $y#150041) 0) 
                          (* -1 
                            (- 1.0 $y#150041)) 
                          (- 1.0 $y#150041)) 1.0e-9) 
                      (max-count) 
                      (/ 
                        (* $y#150041 
                          (lookahead)) 
                        (- 1.0 $y#150041))) 1)) 
                (/ 
                  (+ 
                    (if 
                      (<= 
                        (if 
                          (< 
                            (- 1.0 $y#150041) 0) 
                          (* -1 
                            (- 1.0 $y#150041)) 
                          (- 1.0 $y#150041)) 1.0e-9) 
                      (max-count) 
                      (/ 
                        (* $y#150041 
                          (lookahead)) 
                        (- 1.0 $y#150041))) 1) 
                  (+ 
                    (+ 
                      (if 
                        (<= 
                          (if 
                            (< 
                              (- 1.0 $y#150041) 0) 
                            (* -1 
                              (- 1.0 $y#150041)) 
                            (- 1.0 $y#150041)) 1.0e-9) 
                        (max-count) 
                        (/ 
                          (* $y#150041 
                            (lookahead)) 
                          (- 1.0 $y#150041))) 1) 1.0))))))) 
      (: 
        (IDIBase P2 Q2) 
        (≞ 
          (→ P Q) 
          (ETV 
            (:: 
              (S (S Z)) ∅) 
            (STV 0 0.5)))) 
      (let* 
        ( ( (: $proof2#252203 
              (⊷ Q 
                (S (S (S Z))) False)) (synthesize (: $proof2#252203 (⊷ Q (S (S (S Z))) False)) kb rb (S (S (S Z)))))) 
        (: 
          (IDIBase P3 $proof2#252203) 
          (≞ 
            (→ P Q) 
            (ETV 
              (:: 
                (S (S (S Z))) ∅) 
              (STV 0 0.5))))) 
      (let* 
        ( ( (: $proof2#252203 
              (⊷ Q 
                (S (S (S (S (S (S (S Z))))))) False)) (synthesize (: $proof2#252203 (⊷ Q (S (S (S (S (S (S (S Z))))))) False)) kb rb (S (S (S Z)))))) 
        (: 
          (IDIBase P7 $proof2#252203) 
          (≞ 
            (→ P Q) 
            (ETV 
              (:: 
                (S (S (S (S (S (S (S Z))))))) ∅) 
              (STV 0 0.5))))) 
      (let* 
        ( ( (: $proof2#255197 
              (⊷ Q 
                (S (S Z)) True)) (synthesize (: $proof2#255197 (⊷ Q (S (S Z)) True)) kb rb (S (S (S Z)))))) 
        (: 
          (IDIBase P2 $proof2#255197) 
          (≞ 
            (→ P Q) 
            (ETV 
              (:: 
                (S (S Z)) ∅) 
              (STV 1 0.5))))) 
      (: 
        (IDIBase P3 Q3) 
        (≞ 
          (→ P Q) 
          (ETV 
            (:: 
              (S (S (S Z))) ∅) 
            (STV 1 0.5)))) 
      (: 
        (IDIBase P7 Q7) 
        (≞ 
          (→ P Q) 
          (ETV 
            (:: 
              (S (S (S (S (S (S (S Z))))))) ∅) 
            (STV 1 0.5))))))

</span>[

;<h3 id="DEPENDENT-TYPES.IMPLICATIONDIRECTINTRODUCTIONDTLTEST.16"
>;; DEPENDENT-TYPES.IMPLICATIONDIRECTINTRODUCTIONDTLTEST.16</h3>

Script done on 2024-09-20 01:20:29+00:00 [COMMAND_EXIT_CODE="143"]

</pre>
</body>

</html>
\033[1;33mCompleted (EXITCODE=143) Under 40 seconds: ./mettalog '--output=./reports/tests_output/baseline-compat-2024-09-20T00:33:03/' --timeout=40 --html --repl=false  --test "tests/extended_compat/hyperon-pln/metta/pln/dependent-types/ImplicationDirectIntroductionDTLTest.metta" --halt=true\033[0m

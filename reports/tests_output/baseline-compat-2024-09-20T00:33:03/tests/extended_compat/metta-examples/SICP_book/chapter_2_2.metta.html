<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"
>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"
>
<title></title>
<style type="text/css"
>
.ansi2html-content { display: inline; white-space: pre-wrap; word-wrap: break-word; }
.body_foreground { color: #AAAAAA; }
.body_background { background-color: #000000; }
.inv_foreground { color: #000000; }
.inv_background { background-color: #AAAAAA; }
.ansi31 { color: #aa0000; }
.ansi36 { color: #00aaaa; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
</style>
</head>
<body class="body_foreground body_background" style="font-size: normal;" >
<pre class="ansi2html-content"
>
Script started on 2024-09-20 00:55:26+00:00 [TERM="xterm-256color" TTY="/dev/pts/0" COLUMNS="-1" LINES="-1"]
P;HTML|
;           (set_option_value  prolog false)

P;HTML|
;           (set_option_value  compat auto)

P;HTML|
;           (set_option_value  compatio true)
P;HTML|
;            (is_cmd_option  prescan halt --halt=true true)
P;HTML|
;            (set_option_value  halt true)
P;HTML|
;            (is_cmd_option  prescan stdin --stdin=tty tty)
P;HTML|
;             (set_option_value  stdin tty)
P;HTML|
;            (is_cmd_option  prescan stdout --stdout=tty tty)
P;HTML|
;             (set_option_value  stdout tty)
P;HTML|
;            (is_cmd_option  prescan stderr --stderr=tty tty)
P;HTML|
;             (set_option_value  stderr tty)
P;HTML|
;            (set_option_value  prolog false)
P;HTML|
;            (set_option_value  compat auto)
P;HTML|
;            (set_option_value  compatio true)
P;HTML|
;          (is_cmd_option  execute python --python=enable enable)
P;HTML|
;           (set_option_value  python enable)
P;HTML|
;          (is_cmd_option  execute timeout --timeout=40 40)
P;HTML|
;           (set_option_value  timeout 40)
P;HTML|
;           (is_cmd_option  execute output --output=./reports/tests_output/baseline-compat-2024-09-20T00:33:03/ ./reports/tests_output/baseline-compat-2024-09-20T00:33:03/)
P;HTML|
;           (set_option_value  output ./reports/tests_output/baseline-compat-2024-09-20T00:33:03/)
P;HTML|
;           (is_cmd_option  execute html --html true)
P;HTML|
;            (set_option_value  html true)
P;HTML|
;           (is_cmd_option  execute test --test true)
P;HTML|
;            (set_option_value  test true)

; (load_metta_file  &self tests/extended_compat/metta-examples/SICP_book/chapter_2_2.metta)
P;HTML|
;                         (track_load_into_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/metta-examples/SICP_book/chapter_2_2.metta)
P;HTML|
;                                          (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/metta-examples/SICP_book/chapter_2_2.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/metta-examples/SICP_book/chapter_2_2.metta)
P;HTML|
;                                           (= 1  "timeout: failed to run command 'time': No such file or directory")
P;HTML|
;                                          (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/metta-examples/SICP_book/chapter_2_2.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/metta-examples/SICP_book/chapter_2_2.metta)
P;HTML|
;                                           (= 1  "timeout: failed to run command 'time': No such file or directory")

;;; So apparently this is not in metta-style to use car-atom/cdr-atom/cons-atom to manipulate numeric lists/trees etc.
;;; because of that lists won't look like (1 2 3 4) but instead like (Cons 1 (Cons 2 (Cons 3 (Cons 4 Nil)))). So every
;;; exercise will use this notation for lists.
<span class="ansi38-255165000"
>  (= 
    (null? $expr) 
    (== $expr ()))
</span><span class="ansi38-255165000"
>  (= 
    (null-list? $list) 
    (== $list Nil))
</span><span class="ansi38-255165000"
>  (= 
    (list $expr) 
    (if 
      (null? $expr) Nil 
      (Cons 
        (car-atom $expr) 
        (list (cdr-atom $expr)))))
</span><span class="ansi38-255165000"
>  (= 
    (tree $expr) 
    (if 
      (null? $expr) Nil 
      (let* 
        ( ($head (car-atom $expr)) ($tail (cdr-atom $expr))) 
        (if 
          (== 
            (get-metatype $head) Expression) 
          (Cons 
            (tree $head) 
            (tree $tail)) 
          (Cons $head 
            (tree $tail))))))
</span><span class="ansi38-255165000"
>  (= 
    (one-through-four) 
    (list (1 2 3 4)))
</span><span class="ansi38-255165000"
>  (= 
    (car-list (Cons $x $xs)) $x)
</span><span class="ansi38-255165000"
>  (= 
    (car-list Nil) Nil)
</span><span class="ansi38-255165000"
>  (= 
    (cdr-list (Cons $x $xs)) $xs)
</span><span class="ansi38-255165000"
>  (= 
    (cdr-list Nil) Nil)
</span><span class="ansi38-255165000"
>  (= 
    (cadr-list $x) 
    (car-list (cdr-list $x)))
</span><span class="ansi38-255165000"
>  (= 
    (cddr-list $x) 
    (cdr-list (cdr-list $x)))
</span><span class="ansi38-255165000"
>  (= 
    (caddr-list $x) 
    (car-list (cddr-list $x)))
</span><span class="ansi38-255165000"
>  (= 
    (cdar-list $x) 
    (cdr-list (car-list $x)))
</span><span class="ansi38-013099040"
>  !(assertEqual 
    (one-through-four) 
    (Cons 1 
      (Cons 2 
        (Cons 3 
          (Cons 4 Nil)))))

</span>[

;<h3 id="SICP-BOOK.CHAPTER-2-2.01"
>;; SICP-BOOK.CHAPTER-2-2.01</h3>
; 
; EVAL TEST
; took 0.011 secs. (11.14 milliseconds) 

  !(assertEqual 
    (one-through-four) 
    (Cons 1 
      (Cons 2 
        (Cons 3 
          (Cons 4 Nil)))))

<span class="ansi36"
>  (loonit_success  
    (equal_enough_for_test  
      ( (Cons 1 
          (Cons 2 
            (Cons 3 
              (Cons 4 Nil))))) 
      ( (Cons 1 
          (Cons 2 
            (Cons 3 
              (Cons 4 Nil)))))))
</span>
Deterministic: ()
()]
<span class="ansi38-013099040"
>  !(assertEqual 
    (car-list (one-through-four)) 1)

</span>[

;<h3 id="SICP-BOOK.CHAPTER-2-2.02"
>;; SICP-BOOK.CHAPTER-2-2.02</h3>
; 
; EVAL TEST
; took 0.010 secs. (10.27 milliseconds) 

  !(assertEqual 
    (car-list (one-through-four)) 1)

<span class="ansi36"
>  (loonit_success  
    (equal_enough_for_test  
      (1) 
      (1)))
</span>
Deterministic: ()
()]
<span class="ansi38-013099040"
>  !(assertEqual 
    (cdr-list (one-through-four)) 
    (list (2 3 4)))

</span>[

;<h3 id="SICP-BOOK.CHAPTER-2-2.03"
>;; SICP-BOOK.CHAPTER-2-2.03</h3>
; 
; EVAL TEST
; took 0.017 secs. (17.46 milliseconds) 

  !(assertEqual 
    (cdr-list (one-through-four)) 
    (list (2 3 4)))

<span class="ansi36"
>  (loonit_success  
    (equal_enough_for_test  
      ( (Cons 2 
          (Cons 3 
            (Cons 4 Nil)))) 
      ( (Cons 2 
          (Cons 3 
            (Cons 4 Nil))))))
</span>
Deterministic: ()
()]
<span class="ansi38-013099040"
>  !(assertEqual 
    (Cons 10 
      (one-through-four)) 
    (list (10 1 2 3 4)))

</span>[

;<h3 id="SICP-BOOK.CHAPTER-2-2.04"
>;; SICP-BOOK.CHAPTER-2-2.04</h3>
; 
; EVAL TEST
; took 0.025 secs. (24.99 milliseconds) 

  !(assertEqual 
    (Cons 10 
      (one-through-four)) 
    (list (10 1 2 3 4)))

<span class="ansi36"
>  (loonit_success  
    (equal_enough_for_test  
      ( (Cons 10 
          (Cons 1 
            (Cons 2 
              (Cons 3 
                (Cons 4 Nil)))))) 
      ( (Cons 10 
          (Cons 1 
            (Cons 2 
              (Cons 3 
                (Cons 4 Nil))))))))
</span>
Deterministic: ()
()]
;;; Get n-th element from list:
<span class="ansi38-255165000"
>  (= 
    (list-ref $list $n) 
    (if 
      (null-list? $list) 
      (Error 
        (list-ref $list $n) "Index out of bounds") 
      (if 
        (== $n 0) 
        (car-list $list) 
        (list-ref 
          (cdr-list $list) 
          (- $n 1)))))
</span><span class="ansi38-255165000"
>  (= 
    (squares) 
    (list (1 4 9 16 25)))
</span><span class="ansi38-013099040"
>  !(assertEqual 
    (list-ref 
      (squares) 3) 16)

</span>[

;<h3 id="SICP-BOOK.CHAPTER-2-2.05"
>;; SICP-BOOK.CHAPTER-2-2.05</h3>
; 
; EVAL TEST
; took 0.029 secs. (28.65 milliseconds) 

  !(assertEqual 
    (list-ref 
      (squares) 3) 16)

<span class="ansi36"
>  (loonit_success  
    (equal_enough_for_test  
      (16) 
      (16)))
</span>
Deterministic: ()
()]
<span class="ansi38-013099040"
>  !(assertEqual 
    (list-ref 
      (squares) 5) 
    (Error 
      (list-ref Nil 0) "Index out of bounds"))

</span>[

;<h3 id="SICP-BOOK.CHAPTER-2-2.06"
>;; SICP-BOOK.CHAPTER-2-2.06</h3>
; 
; EVAL TEST
; took 0.031 secs. (30.94 milliseconds) 

  !(assertEqual 
    (list-ref 
      (squares) 5) 
    (Error 
      (list-ref Nil 0) "Index out of bounds"))

<span class="ansi36"
>  (loonit_success  
    (equal_enough_for_test  
      ( (Error 
          (list-ref Nil 0) "Index out of bounds")) 
      ( (Error 
          (list-ref Nil 0) "Index out of bounds"))))
</span>
Deterministic: ()
()]
;;; Get list's length:
<span class="ansi38-255165000"
>  (= 
    (length Nil) 0)
</span><span class="ansi38-255165000"
>  (= 
    (length (Cons $x $xs)) 
    (+ 1 
      (length $xs)))
</span><span class="ansi38-013099040"
>  !(assertEqual 
    (length (squares)) 5)

</span>[

;<h3 id="SICP-BOOK.CHAPTER-2-2.07"
>;; SICP-BOOK.CHAPTER-2-2.07</h3>
; 
; EVAL TEST
; took 0.014 secs. (13.93 milliseconds) 

  !(assertEqual 
    (length (squares)) 5)

<span class="ansi31"
>  (loonit_failureR  
    (equal_enough_for_test  
      (3) 
      (5)))
</span>
Deterministic: ((Error  (got  (3)) (expected  (5))))
((Error  (got  (3)) (expected  (5))))]
<span class="ansi38-255165000"
>  (= 
    (odds) 
    (list (1 3 5 7)))
</span><span class="ansi38-013099040"
>  !(assertEqual 
    (length (odds)) 4)

</span>[

;<h3 id="SICP-BOOK.CHAPTER-2-2.08"
>;; SICP-BOOK.CHAPTER-2-2.08</h3>
; 
; EVAL TEST
; took 0.010 secs. (10.02 milliseconds) 

  !(assertEqual 
    (length (odds)) 4)

<span class="ansi31"
>  (loonit_failureR  
    (equal_enough_for_test  
      (3) 
      (4)))
</span>
Deterministic: ((Error  (got  (3)) (expected  (4))))
((Error  (got  (3)) (expected  (4))))]
;;; Append one list to the end of another:
<span class="ansi38-255165000"
>  (= 
    (append Nil $list2) $list2)
</span><span class="ansi38-255165000"
>  (= 
    (append 
      (Cons $x $xs) $list2) 
    (Cons $x 
      (append $xs $list2)))
</span><span class="ansi38-013099040"
>  !(assertEqual 
    (append 
      (squares) 
      (odds)) 
    (list (1 4 9 16 25 1 3 5 7)))

</span>[

;<h3 id="SICP-BOOK.CHAPTER-2-2.09"
>;; SICP-BOOK.CHAPTER-2-2.09</h3>
; 
; EVAL TEST
; took 0.082 secs. (81.55 milliseconds) 

  !(assertEqual 
    (append 
      (squares) 
      (odds)) 
    (list (1 4 9 16 25 1 3 5 7)))

<span class="ansi36"
>  (loonit_success  
    (equal_enough_for_test  
      ( (Cons 1 
          (Cons 4 
            (Cons 9 
              (Cons 16 
                (Cons 25 
                  (Cons 1 
                    (Cons 3 
                      (Cons 5 
                        (Cons 7 Nil)))))))))) 
      ( (Cons 1 
          (Cons 4 
            (Cons 9 
              (Cons 16 
                (Cons 25 
                  (Cons 1 
                    (Cons 3 
                      (Cons 5 
                        (Cons 7 Nil))))))))))))
</span>
Deterministic: ()
()]
<span class="ansi38-013099040"
>  !(assertEqual 
    (append 
      (odds) 
      (squares)) 
    (list (1 3 5 7 1 4 9 16 25)))

</span>[

;<h3 id="SICP-BOOK.CHAPTER-2-2.10"
>;; SICP-BOOK.CHAPTER-2-2.10</h3>
; 
; EVAL TEST
; took 0.080 secs. (80.00 milliseconds) 

  !(assertEqual 
    (append 
      (odds) 
      (squares)) 
    (list (1 3 5 7 1 4 9 16 25)))

<span class="ansi36"
>  (loonit_success  
    (equal_enough_for_test  
      ( (Cons 1 
          (Cons 3 
            (Cons 5 
              (Cons 7 
                (Cons 1 
                  (Cons 4 
                    (Cons 9 
                      (Cons 16 
                        (Cons 25 Nil)))))))))) 
      ( (Cons 1 
          (Cons 3 
            (Cons 5 
              (Cons 7 
                (Cons 1 
                  (Cons 4 
                    (Cons 9 
                      (Cons 16 
                        (Cons 25 Nil))))))))))))
</span>
Deterministic: ()
()]
;;; Exercise 2.17.
;;; Define a procedure last-pair that returns the list that contains only the
;;; last element of a given (nonempty) list:
;;;
;;; Example: (last-pair (list 10 12 41 32)) -> 32
<span class="ansi38-255165000"
>  (= 
    (last-pair (Cons $x Nil)) $x)
</span><span class="ansi38-255165000"
>  (= 
    (last-pair (Cons $x (Cons $y $ys))) 
    (last-pair (Cons $y $ys)))
</span><span class="ansi38-013099040"
>  !(assertEqual 
    (last-pair (squares)) 25)

</span>[

;<h3 id="SICP-BOOK.CHAPTER-2-2.11"
>;; SICP-BOOK.CHAPTER-2-2.11</h3>
; 
; EVAL TEST
; took 0.016 secs. (16.37 milliseconds) 

  !(assertEqual 
    (last-pair (squares)) 25)

<span class="ansi36"
>  (loonit_success  
    (equal_enough_for_test  
      (25) 
      (25)))
</span>
Deterministic: ()
()]
;;; -----------------------End of Exercise 2.17---------------------------
;;; Exercise 2.18.
;;; Define a procedure reverse that takes a list as argument and returns a list of the same elements in reverse order:
;;;
;;; Example: (reverse (list 1 4 9 16 25)) -> (25 16 9 4 1)
<span class="ansi38-255165000"
>  (= 
    (reverse (Cons $x Nil)) 
    (Cons $x Nil))
</span><span class="ansi38-255165000"
>  (= 
    (reverse (Cons $x (Cons $y $ys))) 
    (append 
      (reverse (Cons $y $ys)) 
      (Cons $x Nil)))
</span><span class="ansi38-013099040"
>  !(assertEqual 
    (reverse (squares)) 
    (list (25 16 9 4 1)))

</span>[

;<h3 id="SICP-BOOK.CHAPTER-2-2.12"
>;; SICP-BOOK.CHAPTER-2-2.12</h3>
; 
; EVAL TEST
; took 0.045 secs. (44.77 milliseconds) 

  !(assertEqual 
    (reverse (squares)) 
    (list (25 16 9 4 1)))

<span class="ansi36"
>  (loonit_success  
    (equal_enough_for_test  
      ( (Cons 25 
          (Cons 16 
            (Cons 9 
              (Cons 4 
                (Cons 1 Nil)))))) 
      ( (Cons 25 
          (Cons 16 
            (Cons 9 
              (Cons 4 
                (Cons 1 Nil))))))))
</span>
Deterministic: ()
()]
;;; -----------------------End of Exercise 2.18---------------------------
;;; Exercise 2.19.
;;;
;;; Consider the change-counting program of section 1.2.2.
;;; It would be nice to be able to easily change the currency used by
;;; the program, so that we could compute the number of ways to change a
;;; British pound, for example. As the program is written, the knowledge of
;;; the currency is distributed partly into the procedure first-denomination
;;; and partly into the procedure count-change (which knows that there are five
;;; kinds of U.S. coins). It would be nicer to be able to supply a list of
;;; coins to be used for making change.
;;; We want to rewrite the procedure cc so that its second argument is a list of
;;; the values of the coins to use rather than an integer specifying which coins
;;; to use. We could then have lists that defined each kind of currency:
<span class="ansi38-255165000"
>  (= 
    (us-coins) 
    (list (50 25 10 5 1)))
</span><span class="ansi38-255165000"
>  (= 
    (uk-coins) 
    (list (100 50 20 10 5 2 1 0.5)))
</span>;;; We could then call cc as follows:
;;; !(cc 100 (us-coins)) ; 292
;;; To do this will require changing the program cc somewhat. It will still have
;;; the same form, but it will access its second argument differently, as follows:
<span class="ansi38-255165000"
>  (= 
    (cc $amount $coin-values) 
    (if 
      (== $amount 0) 1 
      (if 
        (or 
          (< $amount 0) 
          (no-more? $coin-values)) 0 
        (+ 
          (cc $amount 
            (except-first-denomination $coin-values)) 
          (cc 
            (- $amount 
              (first-denomination $coin-values)) $coin-values)))))
</span>;;; Define the procedures first-denomination, except-first-denomination, and no-more?
;;; in terms of primitive operations on list structures. Does the order of the list
;;; coin-values affect the answer produced by cc? Why or why not?
<span class="ansi38-255165000"
>  (= 
    (first-denomination $coin-values) 
    (car-list $coin-values))
</span><span class="ansi38-255165000"
>  (= 
    (except-first-denomination $coin-values) 
    (cdr-list $coin-values))
</span><span class="ansi38-255165000"
>  (= 
    (no-more? $coin-values) 
    (null-list? $coin-values))
</span><span class="ansi38-013099040"
>  !(assertEqual 
    (cc 20 
      (us-coins)) 9)

</span>[

;<h3 id="SICP-BOOK.CHAPTER-2-2.13"
>;; SICP-BOOK.CHAPTER-2-2.13</h3>

Script done on 2024-09-20 00:56:06+00:00 [COMMAND_EXIT_CODE="143"]

</pre>
</body>

</html>
\033[1;33mCompleted (EXITCODE=143) Under 40 seconds: ./mettalog '--output=./reports/tests_output/baseline-compat-2024-09-20T00:33:03/' --timeout=40 --html --repl=false  --test "tests/extended_compat/metta-examples/SICP_book/chapter_2_2.metta" --halt=true\033[0m

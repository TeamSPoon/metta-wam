<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"
>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"
>
<title></title>
<style type="text/css"
>
.ansi2html-content { display: inline; white-space: pre-wrap; word-wrap: break-word; }
.body_foreground { color: #AAAAAA; }
.body_background { background-color: #000000; }
.inv_foreground { color: #000000; }
.inv_background { background-color: #AAAAAA; }
.ansi1 { font-weight: bold; }
.ansi31 { color: #aa0000; }
.ansi32 { color: #00aa00; }
.ansi36 { color: #00aaaa; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165009 { color: #FFA509; }
.ansi38-255238088 { color: #FFEE58; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165009 { color: #FFA509; }
.ansi38-255238088 { color: #FFEE58; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165009 { color: #FFA509; }
.ansi38-255238088 { color: #FFEE58; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165009 { color: #FFA509; }
.ansi38-255238088 { color: #FFEE58; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165009 { color: #FFA509; }
.ansi38-255238088 { color: #FFEE58; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165009 { color: #FFA509; }
.ansi38-255238088 { color: #FFEE58; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165009 { color: #FFA509; }
.ansi38-255238088 { color: #FFEE58; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165009 { color: #FFA509; }
.ansi38-255238088 { color: #FFEE58; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165009 { color: #FFA509; }
.ansi38-255238088 { color: #FFEE58; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165009 { color: #FFA509; }
.ansi38-255238088 { color: #FFEE58; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165009 { color: #FFA509; }
.ansi38-255238088 { color: #FFEE58; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
</style>
</head>
<body class="body_foreground body_background" style="font-size: normal;" >
<pre class="ansi2html-content"
>
Script started on 2024-09-27 01:17:18+00:00 [TERM="xterm-256color" TTY="/dev/pts/0" COLUMNS="-1" LINES="-1"]
P;HTML|
;           (set_option_value  prolog false)

P;HTML|
;           (set_option_value  compat auto)

P;HTML|
;           (set_option_value  compatio true)
P;HTML|
;            (is_cmd_option  prescan halt --halt=true true)
P;HTML|
;            (set_option_value  halt true)
P;HTML|
;            (is_cmd_option  prescan stdin --stdin=tty tty)
P;HTML|
;             (set_option_value  stdin tty)
P;HTML|
;            (is_cmd_option  prescan stdout --stdout=tty tty)
P;HTML|
;             (set_option_value  stdout tty)
P;HTML|
;            (is_cmd_option  prescan stderr --stderr=tty tty)
P;HTML|
;             (set_option_value  stderr tty)
P;HTML|
;            (set_option_value  prolog false)
P;HTML|
;            (set_option_value  compat auto)
P;HTML|
;            (set_option_value  compatio true)
P;HTML|
;          (is_cmd_option  execute python --python=enable enable)
P;HTML|
;           (set_option_value  python enable)
P;HTML|
;          (is_cmd_option  execute timeout --timeout=40 40)
P;HTML|
;           (set_option_value  timeout 40)
P;HTML|
;           (is_cmd_option  execute output --output=./reports/tests_output/baseline-compat-2024-09-27T00:33:45/ ./reports/tests_output/baseline-compat-2024-09-27T00:33:45/)
P;HTML|
;           (set_option_value  output ./reports/tests_output/baseline-compat-2024-09-27T00:33:45/)
P;HTML|
;           (is_cmd_option  execute html --html true)
P;HTML|
;            (set_option_value  html true)
P;HTML|
;           (is_cmd_option  execute test --test true)
P;HTML|
;            (set_option_value  test true)

; (load_metta_file  &self tests/extended_compat/hyperon-pln/metta/hol/NatStandaloneTest.metta)
P;HTML|
;                         (track_load_into_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/hol/NatStandaloneTest.metta)
P;HTML|
;                                          (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/hol/NatStandaloneTest.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/hol/NatStandaloneTest.metta)
P;HTML|
;                                           (= 1  "+ '[' 0 -eq 1 ']'")
P;HTML|
;                                           (= 1  "+ echo 'Doing: timeout --foreground --kill-after=5 --signal=SIGINT 121 time metta /opt/logicmoo_opencog/hyperon-wam/examples/baseline_compat/hyperon-pln_metta/hol/NatStandaloneTest.metta'")
P;HTML|
;                                           (= 1  "Doing: timeout --foreground --kill-after=5 --signal=SIGINT 121 time metta /opt/logicmoo_opencog/hyperon-wam/examples/baseline_compat/hyperon-pln_metta/hol/NatStandaloneTest.metta")
P;HTML|
;                                           (= 1  "+ eval 'timeout --foreground --kill-after=5 --signal=SIGINT 121 time metta /opt/logicmoo_opencog/hyperon-wam/examples/baseline_compat/hyperon-pln_metta/hol/NatStandaloneTest.metta'")
P;HTML|
;                                           (= 1  "++ timeout --foreground --kill-after=5 --signal=SIGINT 121 time metta /opt/logicmoo_opencog/hyperon-wam/examples/baseline_compat/hyperon-pln_metta/hol/NatStandaloneTest.metta")
P;HTML|
;                                           (= 1  "[()]")
P;HTML|
;                                           (= 2  "[()]")
P;HTML|
;                                           (= 3  "[()]")
P;HTML|
;                                           (= 4  "[()]")
P;HTML|
;                                           (= 5  "[()]")
P;HTML|
;                                           (= 6  "[()]")
P;HTML|
;                                           (= 7  "[()]")
P;HTML|
;                                           (= 8  "[()]")
P;HTML|
;                                           (= 9  "[()]")
P;HTML|
;                                           (= 10  "[()]")
P;HTML|
;                                           (= 11  "[()]")
P;HTML|
;                                           (= 12  "[()]")
P;HTML|
;                                           (= 13  "[()]")
P;HTML|
;                                           (= 14  "[(let* (((: $prfarg#54187 (plus Z (=== (=== (plus $x Z) $x) (=== (plus (S $x) Z) (S $x))))) (bc (: $prfarg#54187 (plus Z (=== (=== (plus $x Z) $x) (=== (plus (S $x) Z) (S $x))))) (S (S Z))))) (: (((. Replace0) (Replace0 plusBase)) $prfarg#54187) (-> (=== (plus $x Z) $x) (=== (plus (S $x) Z) (S $x))))), (let* (((: $prfarg#54187 (=== (=== (plus (S $x) Z) (S $x)) (=== (plus $x Z) $x))) (bc (: $prfarg#54187 (=== (=== (plus (S $x) Z) (S $x)) (=== (plus $x Z) $x))) (S (S Z))))) (: (((. Replace0) Sym) $prfarg#54187) (-> (=== (plus $x Z) $x) (=== (plus (S $x) Z) (S $x))))), (let* (((: $prfarg#54187 (plus Z (-> (=== (plus $x Z) $x) (=== (plus (S $x) Z) (S $x))))) (bc (: $prfarg#54187 (plus Z (-> (=== (plus $x Z) $x) (=== (plus (S $x) Z) (S $x))))) (S (S Z))))) (: ((Replace0 plusBase) $prfarg#54187) (-> (=== (plus $x Z) $x) (=== (plus (S $x) Z) (S $x))))), (: ((. (Trans plusRec)) Cong) (-> (=== (plus $x Z) $x) (=== (plus (S $x) Z) (S $x)))), (let* (((: $prfarg#54187 (-> (=== (plus $x Z) $x) (plusRightId (S $x)))) (bc (: $prfarg#54187 (-> (=== (plus $x Z) $x) (plusRightId (S $x)))) (S (S Z))))) (: ((. (Replace0 plusRightIdProp)) $prfarg#54187) (-> (=== (plus $x Z) $x) (=== (plus (S $x) Z) (S $x))))), (let* (((: $prfarg#54187 (-> (=== (plus $x Z) $x) (plus Z (=== (plus (S $x) Z) (S $x))))) (bc (: $prfarg#54187 (-> (=== (plus $x Z) $x) (plus Z (=== (plus (S $x) Z) (S $x))))) (S (S Z))))) (: ((. (Replace0 plusBase)) $prfarg#54187) (-> (=== (plus $x Z) $x) (=== (plus (S $x) Z) (S $x))))), (let* (((: $prfarg#54187 (-> (=== (plus $x Z) $x) (=== (S $x) (plus (S $x) Z)))) (bc (: $prfarg#54187 (-> (=== (plus $x Z) $x) (=== (S $x) (plus (S $x) Z)))) (S (S Z))))) (: ((. Sym) $prfarg#54187) (-> (=== (plus $x Z) $x) (=== (plus (S $x) Z) (S $x))))), (let* (((: $prfarg#54187 (=== (=== (plus $x Z) $x) (=== (plus (S $x) Z) (S $x)))) (bc (: $prfarg#54187 (=== (=== (plus $x Z) $x) (=== (plus (S $x) Z) (S $x)))) (S (S Z))))) (: (Replace0 $prfarg#54187) (-> (=== (plus $x Z) $x) (=== (plus (S $x) Z) (S $x)))))]")
P;HTML|
;                                           (= 15  "[(: (Replace0 (Cong ((Trans plusRec) ((Trans (Cong plusBase)) (Cong (Sym plusRec)))))) (-> (plusRightId (plus (S Z) $x'#124505)) (plusRightId (S (plus (S Z) $x'#124505))))), (: (Replace0 (Cong ((Trans plusRec) ((Trans (Cong plusBase)) (Cong plusBase))))) (-> (plusRightId (plus (S Z) $x'#124505)) (plusRightId (S (plus (S Z) $x'#124505))))), (: (Replace0 (Cong ((Trans plusRec) ((Trans (Cong plusBase)) (Sym (Cong plusRec)))))) (-> (plusRightId (plus (S Z) $x'#124505)) (plusRightId (S (plus (S Z) $x'#124505))))), (: (Replace0 (Cong ((Trans plusRec) (Cong ((Trans plusBase) (Sym plusRec)))))) (-> (plusRightId (plus (S Z) $y#144144)) (plusRightId (S (plus (S Z) $y#144144))))), (: (Replace0 (Cong ((Trans plusRec) (Cong ((Trans plusBase) plusBase))))) (-> (plusRightId (plus (S Z) $y#144144)) (plusRightId (S (plus (S Z) $y#144144))))), (: (Replace0 (Cong ((Trans plusBase) ((Trans (Sym plusBase)) ((Trans plusBase) (Cong plusBase)))))) (-> (plusRightId (plus Z $y#187257)) (plusRightId (S (plus Z $y#187257))))), (: (Replace0 (Cong ((Trans plusBase) ((Trans (Sym plusBase)) ((Trans plusBase) plusRec))))) (-> (plusRightId (plus Z $y#187257)) (plusRightId (S (plus Z $y#187257))))), (: (Replace0 (Cong ((Trans plusBase) ((Trans (Sym plusBase)) ((Trans plusBase) plusBase))))) (-> (plusRightId (plus Z $y#187257)) (plusRightId (S (plus Z $y#187257))))), (: (Replace0 (Cong (Cong ((Trans (Sym plusBase)) ((Trans plusBase) (Cong plusRec)))))) (-> (plusRightId (S (S (plus $x#234949 $y#234950)))) (plusRightId (S (S (S (plus $x#234949 $y#234950))))))), (: (Replace0 (Cong (Cong ((Trans (Sym plusBase)) ((Trans plusBase) (Cong plusRightIdProp)))))) (-> (plusRightId (S (=== (plus $x#234951 Z) $x#234951))) (plusRightId (S (S (=== (plus $x#234951 Z) $x#234951)))))), (: (Replace0 (Cong (Cong ((Trans (Sym plusBase)) ((Trans plusBase) (Cong plusBase)))))) (-> (plusRightId (S $y#234250)) (plusRightId (S (S $y#234250))))), (: (Replace0 (Cong (Cong ((Trans (Sym plusBase)) ((Trans plusBase) plusRec))))) (-> (plusRightId (S (plus $x#235249 $y#235250))) (plusRightId (S (S (plus $x#235249 $y#235250)))))), (: (Replace0 (Cong (Cong ((Trans (Sym plusBase)) ((Trans plusBase) plusBase))))) (-> (plusRightId (S $y#234250)) (plusRightId (S (S $y#234250))))), (: (Replace0 (Cong ((Trans (Sym plusBase)) ((Trans plusBase) (Cong plusRec))))) (-> (plusRightId (S (plus $x#464500 $y#464501))) (plusRightId (S (S (plus $x#464500 $y#464501)))))), (: (Replace0 (Cong ((Trans (Sym plusBase)) ((Trans plusBase) (Cong plusRightIdProp))))) (-> (plusRightId (=== (plus $x#464502 Z) $x#464502)) (plusRightId (S (=== (plus $x#464502 Z) $x#464502))))), (: (Replace0 (Cong ((Trans (Sym plusBase)) ((Trans plusBase) (Cong plusBase))))) (-> (plusRightId $y#463801) (plusRightId (S $y#463801)))), (: (Replace0 (Cong ((Trans (Sym plusBase)) ((Trans plusBase) plusRec)))) (-> (plusRightId (plus $x#464800 $y#464801)) (plusRightId (S (plus $x#464800 $y#464801))))), (: (Replace0 (Cong ((Trans (Sym plusBase)) ((Trans plusBase) plusBase)))) (-> (plusRightId $y#463801) (plusRightId (S $y#463801)))), (: ((. (Replace0 (Sym plusRightIdProp))) ((. (Trans plusRec)) ((. Cong) (Replace0 plusRightIdProp)))) (-> (plusRightId $x) (plusRightId (S $x))))]")
P;HTML|
;                                           (= 16  "[()]")
P;HTML|
;                                          (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/hol/NatStandaloneTest.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/hol/NatStandaloneTest.metta)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; Definition of an omnichainer, Nat, plus and some proofs.            ;;
;;;;                                                                     ;;
;;;; The main proof of interest is that Z is the right identity of plus. ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; The omnichainer is expected to have the following properties:
;;;;
;;;; - Rules are curried.
;;;;
;;;; - There is no distinction between axioms and rules.
;;;;
;;;; - Rule composition, using the traditional composition operator `.`
;;;;   is included in the chaining process (whether it is embedded in
;;;;   the chainer implementation or is an external rule remains to be
;;;;   determined).
;;;;
;;;; Given such omnichainer, the inductive property that x + 0 = x
;;;; implies (S x) + 0 = (S x) should then have the following proof
;;;; abstraction:
;;;;
;;;; ------------------------------------(plusRec)
;;;; (=== (plus (S $x) Z) (S (plus $x Z)))
;;;; -------------------------------------------------------------(Trans)  -----------------------------------------------------(Cong)
;;;; (-> (=== (S (plus $x Z)) (S $x)) (=== (plus (S $x) Z) (S $x)))        (-> (=== (plus $x Z) $x) (=== (S (plus $x Z)) (S $x)))
;;;; ---------------------------------------------------------------------------------------------------------------------------(.)
;;;;                                  (-> (=== (plus $x Z) $x) (=== (plus (S $x) Z) (S $x)))
;;;;
;;;; or in MeTTa format:
;;;;
;;;; ((. (Trans plusRec)) Cong)
;;;;;;;;;;;
;;;; Nat ;;
;;;;;;;;;;;
;;;; Define Nat
<span class="ansi38-255165000"
>  (: Nat Type)
</span><span class="ansi38-255165000"
>  (: Z Nat)
</span><span class="ansi38-255165000"
>  (: S 
    (-> Nat Nat))
</span>;;;; Define <=
<span class="ansi38-255165000"
>  (: <= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (<= $x $y) 
    (or 
      (< $x $y) 
      (== $x $y)))
</span>;;;; Define cast functions between Nat and Number
<span class="ansi38-255165000"
>  (: fromNumber 
    (-> Number Nat))
</span><span class="ansi38-255165000"
>  (= 
    (fromNumber $n) 
    (if 
      (<= $n 0) Z 
      (S (fromNumber (- $n 1)))))
</span><span class="ansi38-255165000"
>  (: fromNat 
    (-> Nat Number))
</span><span class="ansi38-255165000"
>  (= 
    (fromNat Z) 0)
</span><span class="ansi38-255165000"
>  (= 
    (fromNat (S $k)) 
    (+ 1 
      (fromNat $k)))
</span>;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; Knowledge and rule base ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
<span class="ansi38-013099040"
>  !(bind! &kb 
    (new-space))

</span>

Deterministic: ()
[()]
;;;; Knowledge base
;;;; Refl is disabled because not necessary in all examples so far
;;;; ;; Equality is reflexive.  We use === instead of == to make sure it
;;;; ;; does not get reduced by the MeTTa interpreter.
;;;; !(add-atom &kb (: Refl (=== $x $x)))
;;;; Equality is transitive
;;; Premise 1
;;; Premise 2
<span class="ansi38-255165009"
>;; In file as:  
</span><span class="ansi1 ansi38-255238088"
>  !(add-atom &kb 
    (: Trans 
      (-> 
        (=== $x $y) 
        (-> 
          (=== $y $z) 
          (=== $x $z)))))
</span>;; To unit test case:
<span class="ansi38-013099040"
>  !(assertEqualToResult 
    (add-atom &kb 
      (: Trans 
        (-> 
          (=== $x $y) 
          (-> 
            (=== $y $z) 
            (=== $x $z))))) 
    (()))

</span>[

;<h3 id="HOL.NATSTANDALONETEST.01"
>;; HOL.NATSTANDALONETEST.01</h3>
<span class="ansi38-255165000"
>  (: Trans 
    (-> 
      (=== $_119758 $_119780) 
      (-> 
        (=== $_119780 $_119852) 
        (=== $_119758 $_119852))))
</span>; 
; EVAL TEST
; took 0.008 secs. (7.62 milliseconds) 

  !(assertEqualToResult 
    (add-atom &kb 
      (: Trans 
        (-> 
          (=== $x $y) 
          (-> 
            (=== $y $z) 
            (=== $x $z))))) 
    (()))

<span class="ansi36"
>  (loonit_success  
    (equal_enough_for_test  
      (()) 
      (())))
</span>
Deterministic: ()
()]
;;; Conclusion
;;;; Equality is symmetric
;;; Premise
<span class="ansi38-255165009"
>;; In file as:  
</span><span class="ansi1 ansi38-255238088"
>  !(add-atom &kb 
    (: Sym 
      (-> 
        (=== $x $y) 
        (=== $y $x))))
</span>;; To unit test case:
<span class="ansi38-013099040"
>  !(assertEqualToResult 
    (add-atom &kb 
      (: Sym 
        (-> 
          (=== $x $y) 
          (=== $y $x)))) 
    (()))

</span>[

;<h3 id="HOL.NATSTANDALONETEST.02"
>;; HOL.NATSTANDALONETEST.02</h3>
<span class="ansi38-255165000"
>  (: Sym 
    (-> 
      (=== $_150684 $_150706) 
      (=== $_150706 $_150684)))
</span>; 
; EVAL TEST
; took 0.005 secs. (5.41 milliseconds) 

  !(assertEqualToResult 
    (add-atom &kb 
      (: Sym 
        (-> 
          (=== $x $y) 
          (=== $y $x)))) 
    (()))

<span class="ansi36"
>  (loonit_success  
    (equal_enough_for_test  
      (()) 
      (())))
</span>
Deterministic: ()
()]
;;; Conclusion
;;;; Equality respects function application
;;; Premise
<span class="ansi38-255165009"
>;; In file as:  
</span><span class="ansi1 ansi38-255238088"
>  !(add-atom &kb 
    (: Cong 
      (-> 
        (=== $x $x') 
        (=== 
          ($op $x) 
          ($op $x')))))
</span>;; To unit test case:
<span class="ansi38-013099040"
>  !(assertEqualToResult 
    (add-atom &kb 
      (: Cong 
        (-> 
          (=== $x $x') 
          (=== 
            ($op $x) 
            ($op $x'))))) 
    (()))

</span>[

;<h3 id="HOL.NATSTANDALONETEST.03"
>;; HOL.NATSTANDALONETEST.03</h3>
<span class="ansi38-255165000"
>  (: Cong 
    (-> 
      (=== $_181406 $_181428) 
      (=== 
        ($_181474 $_181406) 
        ($_181474 $_181428))))
</span>; 
; EVAL TEST
; took 0.008 secs. (7.51 milliseconds) 

  !(assertEqualToResult 
    (add-atom &kb 
      (: Cong 
        (-> 
          (=== $x $x') 
          (=== 
            ($op $x) 
            ($op $x'))))) 
    (()))

<span class="ansi36"
>  (loonit_success  
    (equal_enough_for_test  
      (()) 
      (())))
</span>
Deterministic: ()
()]
;;; Conclusion
;;;; Rule of replacement (nullary operator)
;;;; TODO: could use Replace1 combine with identity function instead.
;;; Premise 1
;;; Premise 2
<span class="ansi38-255165009"
>;; In file as:  
</span><span class="ansi1 ansi38-255238088"
>  !(add-atom &kb 
    (: Replace0 
      (-> 
        (=== $x $x') 
        (-> $x $x'))))
</span>;; To unit test case:
<span class="ansi38-013099040"
>  !(assertEqualToResult 
    (add-atom &kb 
      (: Replace0 
        (-> 
          (=== $x $x') 
          (-> $x $x')))) 
    (()))

</span>[

;<h3 id="HOL.NATSTANDALONETEST.04"
>;; HOL.NATSTANDALONETEST.04</h3>
<span class="ansi38-255165000"
>  (: Replace0 
    (-> 
      (=== $_212246 $_212268) 
      (-> $_212246 $_212268)))
</span>; 
; EVAL TEST
; took 0.005 secs. (5.43 milliseconds) 

  !(assertEqualToResult 
    (add-atom &kb 
      (: Replace0 
        (-> 
          (=== $x $x') 
          (-> $x $x')))) 
    (()))

<span class="ansi36"
>  (loonit_success  
    (equal_enough_for_test  
      (()) 
      (())))
</span>
Deterministic: ()
()]
;;; Conclusion
;;;; The following replacement rules are disabled because not necessary
;;;; in the examples so far
;;;; ;; Rule of replacement (unary operator)
;;;; !(add-atom &kb (: Replace1 (-> (=== $x $x')      ; Premise 1
;;;;                                (-> ($op $x)      ; Premise 2
;;;;                                    ($op $x'))))) ; Conclusion
;;;; ;; Rule of replacement (binary operator)
;;;; !(add-atom &kb (: Replace2 (-> (=== $x $x')               ; Premise 1
;;;;                                (-> (=== $y $y')           ; Premise 2
;;;;                                    (-> ($op $x $y)        ; Premise 3
;;;;                                        ($op $x' $y')))))) ; Conclusion
;;;; Structural induction on Nat
;;; Premise 1 (base case)
;;; Premise 2 (inductive step)
<span class="ansi38-255165009"
>;; In file as:  
</span><span class="ansi1 ansi38-255238088"
>  !(add-atom &kb 
    (: NatInd 
      (-> 
        ($p Z) 
        (-> 
          (-> 
            ($p $x) 
            ($p (S $x))) 
          ($p $x')))))
</span>;; To unit test case:
<span class="ansi38-013099040"
>  !(assertEqualToResult 
    (add-atom &kb 
      (: NatInd 
        (-> 
          ($p Z) 
          (-> 
            (-> 
              ($p $x) 
              ($p (S $x))) 
            ($p $x'))))) 
    (()))

</span>[

;<h3 id="HOL.NATSTANDALONETEST.05"
>;; HOL.NATSTANDALONETEST.05</h3>
<span class="ansi38-255165000"
>  (: NatInd 
    (-> 
      ($_243068 Z) 
      (-> 
        (-> 
          ($_243068 $_243156) 
          ($_243068 (S $_243156))) 
        ($_243068 $_243264))))
</span>; 
; EVAL TEST
; took 0.009 secs. (8.88 milliseconds) 

  !(assertEqualToResult 
    (add-atom &kb 
      (: NatInd 
        (-> 
          ($p Z) 
          (-> 
            (-> 
              ($p $x) 
              ($p (S $x))) 
            ($p $x'))))) 
    (()))

<span class="ansi36"
>  (loonit_success  
    (equal_enough_for_test  
      (()) 
      (())))
</span>
Deterministic: ()
()]
;;; Conclusion
;;;; Definition of plus (base case)
<span class="ansi38-255165009"
>;; In file as:  
</span><span class="ansi1 ansi38-255238088"
>  !(add-atom &kb 
    (: plusBase 
      (=== 
        (plus Z $y) $y)))
</span>;; To unit test case:
<span class="ansi38-013099040"
>  !(assertEqualToResult 
    (add-atom &kb 
      (: plusBase 
        (=== 
          (plus Z $y) $y))) 
    (()))

</span>[

;<h3 id="HOL.NATSTANDALONETEST.06"
>;; HOL.NATSTANDALONETEST.06</h3>
<span class="ansi38-255165000"
>  (: plusBase 
    (=== 
      (plus Z $_274102) $_274102))
</span>; 
; EVAL TEST
; took 0.004 secs. (3.72 milliseconds) 

  !(assertEqualToResult 
    (add-atom &kb 
      (: plusBase 
        (=== 
          (plus Z $y) $y))) 
    (()))

<span class="ansi36"
>  (loonit_success  
    (equal_enough_for_test  
      (()) 
      (())))
</span>
Deterministic: ()
()]
;;;; Definition of plus (recursive step)
<span class="ansi38-255165009"
>;; In file as:  
</span><span class="ansi1 ansi38-255238088"
>  !(add-atom &kb 
    (: plusRec 
      (=== 
        (plus 
          (S $x) $y) 
        (S (plus $x $y)))))
</span>;; To unit test case:
<span class="ansi38-013099040"
>  !(assertEqualToResult 
    (add-atom &kb 
      (: plusRec 
        (=== 
          (plus 
            (S $x) $y) 
          (S (plus $x $y))))) 
    (()))

</span>[

;<h3 id="HOL.NATSTANDALONETEST.07"
>;; HOL.NATSTANDALONETEST.07</h3>
<span class="ansi38-255165000"
>  (: plusRec 
    (=== 
      (plus 
        (S $_304604) $_304626) 
      (S (plus $_304604 $_304626))))
</span>; 
; EVAL TEST
; took 0.006 secs. (5.69 milliseconds) 

  !(assertEqualToResult 
    (add-atom &kb 
      (: plusRec 
        (=== 
          (plus 
            (S $x) $y) 
          (S (plus $x $y))))) 
    (()))

<span class="ansi36"
>  (loonit_success  
    (equal_enough_for_test  
      (()) 
      (())))
</span>
Deterministic: ()
()]
;;;; ;; If Z is the right identity of plus for x then it is the right
;;;; ;; identity of plus for (S x).  NEXT: prove it.
;;;; !(add-atom &kb (: plusRightIdInd
;;;;                   (-> (plusRightId $x)        ; Premise
;;;;                       (plusRightId (S $x))))) ; Conclusion
;;;; Property expressing that for any natural, Z is the right identity
;;;; of plus.  Note that the property definition is the axiom, not the
;;;; property itself as it is what we attempt to prove.
<span class="ansi38-255165009"
>;; In file as:  
</span><span class="ansi1 ansi38-255238088"
>  !(add-atom &kb 
    (: plusRightIdProp 
      (=== 
        (plusRightId $x) 
        (=== 
          (plus $x Z) $x))))
</span>;; To unit test case:
<span class="ansi38-013099040"
>  !(assertEqualToResult 
    (add-atom &kb 
      (: plusRightIdProp 
        (=== 
          (plusRightId $x) 
          (=== 
            (plus $x Z) $x)))) 
    (()))

</span>[

;<h3 id="HOL.NATSTANDALONETEST.08"
>;; HOL.NATSTANDALONETEST.08</h3>
<span class="ansi38-255165000"
>  (: plusRightIdProp 
    (=== 
      (plusRightId $_335412) 
      (=== 
        (plus $_335412 Z) $_335412)))
</span>; 
; EVAL TEST
; took 0.005 secs. (4.69 milliseconds) 

  !(assertEqualToResult 
    (add-atom &kb 
      (: plusRightIdProp 
        (=== 
          (plusRightId $x) 
          (=== 
            (plus $x Z) $x)))) 
    (()))

<span class="ansi36"
>  (loonit_success  
    (equal_enough_for_test  
      (()) 
      (())))
</span>
Deterministic: ()
()]
;;;; Composition operator
;;; Premise 1
;;; Premise 2
<span class="ansi38-255165009"
>;; In file as:  
</span><span class="ansi1 ansi38-255238088"
>  !(add-atom &kb 
    (: . 
      (-> 
        (-> $b $c) 
        (-> 
          (-> $a $b) 
          (-> $a $c)))))
</span>;; To unit test case:
<span class="ansi38-013099040"
>  !(assertEqualToResult 
    (add-atom &kb 
      (: . 
        (-> 
          (-> $b $c) 
          (-> 
            (-> $a $b) 
            (-> $a $c))))) 
    (()))

</span>[

;<h3 id="HOL.NATSTANDALONETEST.09"
>;; HOL.NATSTANDALONETEST.09</h3>
<span class="ansi38-255165000"
>  (: . 
    (-> 
      (-> $_366198 $_366220) 
      (-> 
        (-> $_366274 $_366198) 
        (-> $_366274 $_366220))))
</span>; 
; EVAL TEST
; took 0.008 secs. (7.51 milliseconds) 

  !(assertEqualToResult 
    (add-atom &kb 
      (: . 
        (-> 
          (-> $b $c) 
          (-> 
            (-> $a $b) 
            (-> $a $c))))) 
    (()))

<span class="ansi36"
>  (loonit_success  
    (equal_enough_for_test  
      (()) 
      (())))
</span>
Deterministic: ()
()]
;;; Conclusion
;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; Backward DTL Curried ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; Similar to the traditional backward chaining DTL but rules are
;;;; curried.  This allows to partially apply rule which is useful for
;;;; inferring proof abstractions.
;;;; Base case
<span class="ansi38-255165000"
>  (: bc 
    (-> $a Nat $a))
</span><span class="ansi38-255165000"
>  (= 
    (bc 
      (: $prf $ccln) $) 
    (match &kb 
      (: $prf $ccln) 
      (: $prf $ccln)))
</span>;;;; Recursive step
<span class="ansi38-255165000"
>  (= 
    (bc 
      (: 
        ($prfabs $prfarg) $ccln) 
      (S $k)) 
    (let* 
      ( ( (: $prfabs 
            (-> $prms $ccln)) (bc (: $prfabs (-> $prms $ccln)) $k)) ((: $prfarg $prms) (bc (: $prfarg $prms) $k))) 
      (: 
        ($prfabs $prfarg) $ccln)))
</span>;;;;;;;;;;;;;;;;;
;;;; Reduction ;;
;;;;;;;;;;;;;;;;;
;;;; Reduction rules to simplify proofs and reduce redundancy
;;;; TODO: these rules should be proven first.  Then they could
;;;; automatically be inserted.
;;;; Involution of symmetry
<span class="ansi38-255165000"
>  (= 
    (Sym (Sym $prf)) $prf)
</span>;;;; Composition to application
<span class="ansi38-255165000"
>  (= 
    ( ( (. $g) $f) $x) 
    ($g ($f $x)))
</span>;;;;;;;;;;;;;;
;;;; Proofs ;;
;;;;;;;;;;;;;;
;;;; Prove that Z is left identity of plus
<span class="ansi38-013099040"
>  !(assertEqual 
    (bc 
      (: $prf 
        (=== 
          (plus Z $y) $y)) Z) 
    (: plusBase 
      (=== 
        (plus Z $y) $y)))

</span>[

;<h3 id="HOL.NATSTANDALONETEST.10"
>;; HOL.NATSTANDALONETEST.10</h3>
; 
; EVAL TEST
; took 0.001 secs. (1.18 milliseconds) 

  !(assertEqual 
    (bc 
      (: $prf 
        (=== 
          (plus Z $y) $y)) Z) 
    (: plusBase 
      (=== 
        (plus Z $y) $y)))

<span class="ansi31"
>  (loonit_failureR  
    (equal_enough_for_test  () 
      ( (: plusBase False))))
</span>
Deterministic: ((Error  (got  ()) (expected  ((: plusBase False)))))
((Error  (got  ()) (expected  ((: plusBase False)))))]
;;;; Prove that (=== (=== (plus Z Z) Z) (ZRID_plus Z)).
;;;;
;;;; The following proof tree is expected to prove that:
;;;;
;;;; -------------------------------------(plusRightIdProp)
;;;; (=== (plusRightId Z) (=== (plus Z Z) Z))
;;;; -------------------------------------(Sym)
;;;; (=== (=== (plus Z Z) Z) (plusRightId Z))
;;;;
;;;; on in MeTTa format:
;;;;
;;;; (Sym plusRightIdProp)
<span class="ansi38-013099040"
>  !(assertEqual 
    (bc 
      (: $prf 
        (=== 
          (=== 
            (plus Z Z) Z) 
          (plusRightId Z))) 
      (fromNumber 2)) 
    (: 
      (Sym plusRightIdProp) 
      (=== 
        (=== 
          (plus Z Z) Z) 
        (plusRightId Z))))

</span>[

;<h3 id="HOL.NATSTANDALONETEST.11"
>;; HOL.NATSTANDALONETEST.11</h3>
; 
; EVAL TEST
; took 0.005 secs. (5.43 milliseconds) 

  !(assertEqual 
    (bc 
      (: $prf 
        (=== 
          (=== 
            (plus Z Z) Z) 
          (plusRightId Z))) 
      (fromNumber 2)) 
    (: 
      (Sym plusRightIdProp) 
      (=== 
        (=== 
          (plus Z Z) Z) 
        (plusRightId Z))))

<span class="ansi31"
>  (loonit_failureR  
    (equal_enough_for_test  () 
      ( (: 
          (Sym plusRightIdProp) False))))
</span>
Deterministic: ((Error  (got  ()) (expected  ((: (Sym plusRightIdProp) False)))))
((Error  (got  ()) (expected  ((: (Sym plusRightIdProp) False)))))]
;;;; Prove that (plusRightId Z) holds.  Meaning that Z is the right
;;;; identity of plus for Z.
;;;;
;;;; The following proof tree does that:
;;;;
;;;; ---------------------------------------(plusRightIdProp)
;;;; (=== (plusRightId Z) (=== (plus Z Z) Z))
;;;; ---------------------------------------(Sym)  -----------------(plusBase)
;;;; (=== (=== (plus Z Z) Z) (plusRightId Z))      (=== (plus Z Z) Z)
;;;; ---------------------------------------------------------------(Replace0)
;;;;                        (plusRightId Z)
;;;;
;;;; or in MeTTa format:
;;;;
;;;; (Replace0 (Sym plusRightIdProp) plusBase)
;;;;
;;;; TODO: re-enable when assertContainResults is introduced
<span class="ansi38-013099040"
>  !(assertEqualToResult 
    (bc 
      (: $prf 
        (plusRightId Z)) 
      (fromNumber 4)) 
    ( (: 
        ( (Replace0 plusBase) ((Replace0 (Sym plusBase)) ((Replace0 (Sym plusRightIdProp)) plusBase))) 
        (plusRightId Z)) 
      (: 
        ( (Replace0 ((Trans plusBase) (Sym plusRightIdProp))) ((Replace0 (Sym plusBase)) plusBase)) 
        (plusRightId Z)) 
      (: 
        ( (Replace0 ((Trans plusRightIdProp) (Sym plusRightIdProp))) ((Replace0 (Sym plusRightIdProp)) plusBase)) 
        (plusRightId Z)) 
      (: 
        ( (Replace0 (Sym plusRightIdProp)) ((Trans (Sym plusBase)) ((Trans plusBase) plusBase))) 
        (plusRightId Z)) 
      (: 
        ( (Replace0 (Sym plusRightIdProp)) plusBase) 
        (plusRightId Z))))

</span>[

;<h3 id="HOL.NATSTANDALONETEST.12"
>;; HOL.NATSTANDALONETEST.12</h3>
; 
; EVAL TEST
; took 0.036 secs. (35.97 milliseconds) 

  !(assertEqualToResult 
    (bc 
      (: $prf 
        (plusRightId Z)) 
      (fromNumber 4)) 
    ( (: 
        ( (Replace0 plusBase) ((Replace0 (Sym plusBase)) ((Replace0 (Sym plusRightIdProp)) plusBase))) 
        (plusRightId Z)) 
      (: 
        ( (Replace0 ((Trans plusBase) (Sym plusRightIdProp))) ((Replace0 (Sym plusBase)) plusBase)) 
        (plusRightId Z)) 
      (: 
        ( (Replace0 ((Trans plusRightIdProp) (Sym plusRightIdProp))) ((Replace0 (Sym plusRightIdProp)) plusBase)) 
        (plusRightId Z)) 
      (: 
        ( (Replace0 (Sym plusRightIdProp)) ((Trans (Sym plusBase)) ((Trans plusBase) plusBase))) 
        (plusRightId Z)) 
      (: 
        ( (Replace0 (Sym plusRightIdProp)) plusBase) 
        (plusRightId Z))))

<span class="ansi31"
>  (loonit_failureR  
    (equal_enough_for_test  () 
      ( (: 
          ( (Replace0 plusBase) ((Replace0 (Sym plusBase)) ((Replace0 (Sym plusRightIdProp)) plusBase))) 
          (plusRightId Z)) 
        (: 
          ( (Replace0 ((Trans plusBase) (Sym plusRightIdProp))) ((Replace0 (Sym plusBase)) plusBase)) 
          (plusRightId Z)) 
        (: 
          ( (Replace0 ((Trans plusRightIdProp) (Sym plusRightIdProp))) ((Replace0 (Sym plusRightIdProp)) plusBase)) 
          (plusRightId Z)) 
        (: 
          ( (Replace0 (Sym plusRightIdProp)) ((Trans (Sym plusBase)) ((Trans plusBase) plusBase))) 
          (plusRightId Z)) 
        (: 
          ( (Replace0 (Sym plusRightIdProp)) plusBase) 
          (plusRightId Z)))))
</span>
Deterministic: ((Error  (got  ()) (expected  ((: ((Replace0 plusBase) ((Replace0 (Sym plusBase)) ((Replace0 (Sym plusRightIdProp)) plusBase))) (plusRightId Z)) (: ((Replace0 ((Trans plusBase) (Sym plusRightIdProp))) ((Replace0 (Sym plusBase)) plusBase)) (plusRightId Z)) (: ((Replace0 ((Trans plusRightIdProp) (Sym plusRightIdProp))) ((Replace0 (Sym plusRightIdProp)) plusBase)) (plusRightId Z)) (: ((Replace0 (Sym plusRightIdProp)) ((Trans (Sym plusBase)) ((Trans plusBase) plusBase))) (plusRightId Z)) (: ((Replace0 (Sym plusRightIdProp)) plusBase) (plusRightId Z))))))
((Error  (got  ()) (expected  ((: ((Replace0 plusBase) ((Replace0 (Sym plusBase)) ((Replace0 (Sym plusRightIdProp)) plusBase))) (plusRightId Z)) (: ((Replace0 ((Trans plusBase) (Sym plusRightIdProp))) ((Replace0 (Sym plusBase)) plusBase)) (plusRightId Z)) (: ((Replace0 ((Trans plusRightIdProp) (Sym plusRightIdProp))) ((Replace0 (Sym plusRightIdProp)) plusBase)) (plusRightId Z)) (: ((Replace0 (Sym plusRightIdProp)) ((Trans (Sym plusBase)) ((Trans plusBase) plusBase))) (plusRightId Z)) (: ((Replace0 (Sym plusRightIdProp)) plusBase) (plusRightId Z))))))]
;;;; Prove that (-> (=== (plus $x Z) $x) (=== (plus (S $x) Z) (S $x)))
;;;;
;;;; The proof tree should be:
;;;;
;;;; ------------------------------------(plusRec)
;;;; (=== (plus (S $x) Z) (S (plus $x Z)))
;;;; -------------------------------------------------------------(Trans)  -----------------------------------------------------(Cong)
;;;; (-> (=== (S (plus $x Z)) (S $x)) (=== (plus (S $x) Z) (S $x)))        (-> (=== (plus $x Z) $x) (=== (S (plus $x Z)) (S $x)))
;;;; ---------------------------------------------------------------------------------------------------------------------------(.)
;;;;                                  (-> (=== (plus $x Z) $x) (=== (plus (S $x) Z) (S $x)))
;;;;
;;;; or in MeTTa format:
;;;;
;;;; ((. (Trans plusRec)) Cong)
;;;;
;;;; TODO: re-enable when assertContainResults is introduced
;;;; !(assertEqualToResult
<span class="ansi38-255165009"
>;; In file as:  
</span><span class="ansi1 ansi38-255238088"
>  !(bc 
    (: $prf 
      (-> 
        (=== 
          (plus $x Z) $x) 
        (=== 
          (plus 
            (S $x) Z) 
          (S $x)))) 
    (fromNumber 3))
</span>;; To unit test case:
<span class="ansi38-013099040"
>  !(assertEqualToResult 
    (bc 
      (: $prf 
        (-> 
          (=== 
            (plus $x Z) $x) 
          (=== 
            (plus 
              (S $x) Z) 
            (S $x)))) 
      (fromNumber 3)) 
    ( (let* 
        ( ( (: $prfarg#54187 
              (plus Z 
                (=== 
                  (=== 
                    (plus $x Z) $x) 
                  (=== 
                    (plus 
                      (S $x) Z) 
                    (S $x))))) (bc (: $prfarg#54187 (plus Z (=== (=== (plus $x Z) $x) (=== (plus (S $x) Z) (S $x))))) (S (S Z))))) 
        (: 
          ( ( (. Replace0) (Replace0 plusBase)) $prfarg#54187) 
          (-> 
            (=== 
              (plus $x Z) $x) 
            (=== 
              (plus 
                (S $x) Z) 
              (S $x))))) 
      (let* 
        ( ( (: $prfarg#54187 
              (=== 
                (=== 
                  (plus 
                    (S $x) Z) 
                  (S $x)) 
                (=== 
                  (plus $x Z) $x))) (bc (: $prfarg#54187 (=== (=== (plus (S $x) Z) (S $x)) (=== (plus $x Z) $x))) (S (S Z))))) 
        (: 
          ( ( (. Replace0) Sym) $prfarg#54187) 
          (-> 
            (=== 
              (plus $x Z) $x) 
            (=== 
              (plus 
                (S $x) Z) 
              (S $x))))) 
      (let* 
        ( ( (: $prfarg#54187 
              (plus Z 
                (-> 
                  (=== 
                    (plus $x Z) $x) 
                  (=== 
                    (plus 
                      (S $x) Z) 
                    (S $x))))) (bc (: $prfarg#54187 (plus Z (-> (=== (plus $x Z) $x) (=== (plus (S $x) Z) (S $x))))) (S (S Z))))) 
        (: 
          ( (Replace0 plusBase) $prfarg#54187) 
          (-> 
            (=== 
              (plus $x Z) $x) 
            (=== 
              (plus 
                (S $x) Z) 
              (S $x))))) 
      (: 
        ( (. (Trans plusRec)) Cong) 
        (-> 
          (=== 
            (plus $x Z) $x) 
          (=== 
            (plus 
              (S $x) Z) 
            (S $x)))) 
      (let* 
        ( ( (: $prfarg#54187 
              (-> 
                (=== 
                  (plus $x Z) $x) 
                (plusRightId (S $x)))) (bc (: $prfarg#54187 (-> (=== (plus $x Z) $x) (plusRightId (S $x)))) (S (S Z))))) 
        (: 
          ( (. (Replace0 plusRightIdProp)) $prfarg#54187) 
          (-> 
            (=== 
              (plus $x Z) $x) 
            (=== 
              (plus 
                (S $x) Z) 
              (S $x))))) 
      (let* 
        ( ( (: $prfarg#54187 
              (-> 
                (=== 
                  (plus $x Z) $x) 
                (plus Z 
                  (=== 
                    (plus 
                      (S $x) Z) 
                    (S $x))))) (bc (: $prfarg#54187 (-> (=== (plus $x Z) $x) (plus Z (=== (plus (S $x) Z) (S $x))))) (S (S Z))))) 
        (: 
          ( (. (Replace0 plusBase)) $prfarg#54187) 
          (-> 
            (=== 
              (plus $x Z) $x) 
            (=== 
              (plus 
                (S $x) Z) 
              (S $x))))) 
      (let* 
        ( ( (: $prfarg#54187 
              (-> 
                (=== 
                  (plus $x Z) $x) 
                (=== 
                  (S $x) 
                  (plus 
                    (S $x) Z)))) (bc (: $prfarg#54187 (-> (=== (plus $x Z) $x) (=== (S $x) (plus (S $x) Z)))) (S (S Z))))) 
        (: 
          ( (. Sym) $prfarg#54187) 
          (-> 
            (=== 
              (plus $x Z) $x) 
            (=== 
              (plus 
                (S $x) Z) 
              (S $x))))) 
      (let* 
        ( ( (: $prfarg#54187 
              (=== 
                (=== 
                  (plus $x Z) $x) 
                (=== 
                  (plus 
                    (S $x) Z) 
                  (S $x)))) (bc (: $prfarg#54187 (=== (=== (plus $x Z) $x) (=== (plus (S $x) Z) (S $x)))) (S (S Z))))) 
        (: 
          (Replace0 $prfarg#54187) 
          (-> 
            (=== 
              (plus $x Z) $x) 
            (=== 
              (plus 
                (S $x) Z) 
              (S $x)))))))

</span>[

;<h3 id="HOL.NATSTANDALONETEST.13"
>;; HOL.NATSTANDALONETEST.13</h3>
; 
; EVAL TEST
; took 0.032 secs. (31.60 milliseconds) 

  !(assertEqualToResult 
    (bc 
      (: $prf 
        (-> 
          (=== 
            (plus $x Z) $x) 
          (=== 
            (plus 
              (S $x) Z) 
            (S $x)))) 
      (fromNumber 3)) 
    ( (let* 
        ( ( (: $prfarg#54187 
              (plus Z 
                (=== 
                  (=== 
                    (plus $x Z) $x) 
                  (=== 
                    (plus 
                      (S $x) Z) 
                    (S $x))))) (bc (: $prfarg#54187 (plus Z (=== (=== (plus $x Z) $x) (=== (plus (S $x) Z) (S $x))))) (S (S Z))))) 
        (: 
          ( ( (. Replace0) (Replace0 plusBase)) $prfarg#54187) 
          (-> 
            (=== 
              (plus $x Z) $x) 
            (=== 
              (plus 
                (S $x) Z) 
              (S $x))))) 
      (let* 
        ( ( (: $prfarg#54187 
              (=== 
                (=== 
                  (plus 
                    (S $x) Z) 
                  (S $x)) 
                (=== 
                  (plus $x Z) $x))) (bc (: $prfarg#54187 (=== (=== (plus (S $x) Z) (S $x)) (=== (plus $x Z) $x))) (S (S Z))))) 
        (: 
          ( ( (. Replace0) Sym) $prfarg#54187) 
          (-> 
            (=== 
              (plus $x Z) $x) 
            (=== 
              (plus 
                (S $x) Z) 
              (S $x))))) 
      (let* 
        ( ( (: $prfarg#54187 
              (plus Z 
                (-> 
                  (=== 
                    (plus $x Z) $x) 
                  (=== 
                    (plus 
                      (S $x) Z) 
                    (S $x))))) (bc (: $prfarg#54187 (plus Z (-> (=== (plus $x Z) $x) (=== (plus (S $x) Z) (S $x))))) (S (S Z))))) 
        (: 
          ( (Replace0 plusBase) $prfarg#54187) 
          (-> 
            (=== 
              (plus $x Z) $x) 
            (=== 
              (plus 
                (S $x) Z) 
              (S $x))))) 
      (: 
        ( (. (Trans plusRec)) Cong) 
        (-> 
          (=== 
            (plus $x Z) $x) 
          (=== 
            (plus 
              (S $x) Z) 
            (S $x)))) 
      (let* 
        ( ( (: $prfarg#54187 
              (-> 
                (=== 
                  (plus $x Z) $x) 
                (plusRightId (S $x)))) (bc (: $prfarg#54187 (-> (=== (plus $x Z) $x) (plusRightId (S $x)))) (S (S Z))))) 
        (: 
          ( (. (Replace0 plusRightIdProp)) $prfarg#54187) 
          (-> 
            (=== 
              (plus $x Z) $x) 
            (=== 
              (plus 
                (S $x) Z) 
              (S $x))))) 
      (let* 
        ( ( (: $prfarg#54187 
              (-> 
                (=== 
                  (plus $x Z) $x) 
                (plus Z 
                  (=== 
                    (plus 
                      (S $x) Z) 
                    (S $x))))) (bc (: $prfarg#54187 (-> (=== (plus $x Z) $x) (plus Z (=== (plus (S $x) Z) (S $x))))) (S (S Z))))) 
        (: 
          ( (. (Replace0 plusBase)) $prfarg#54187) 
          (-> 
            (=== 
              (plus $x Z) $x) 
            (=== 
              (plus 
                (S $x) Z) 
              (S $x))))) 
      (let* 
        ( ( (: $prfarg#54187 
              (-> 
                (=== 
                  (plus $x Z) $x) 
                (=== 
                  (S $x) 
                  (plus 
                    (S $x) Z)))) (bc (: $prfarg#54187 (-> (=== (plus $x Z) $x) (=== (S $x) (plus (S $x) Z)))) (S (S Z))))) 
        (: 
          ( (. Sym) $prfarg#54187) 
          (-> 
            (=== 
              (plus $x Z) $x) 
            (=== 
              (plus 
                (S $x) Z) 
              (S $x))))) 
      (let* 
        ( ( (: $prfarg#54187 
              (=== 
                (=== 
                  (plus $x Z) $x) 
                (=== 
                  (plus 
                    (S $x) Z) 
                  (S $x)))) (bc (: $prfarg#54187 (=== (=== (plus $x Z) $x) (=== (plus (S $x) Z) (S $x)))) (S (S Z))))) 
        (: 
          (Replace0 $prfarg#54187) 
          (-> 
            (=== 
              (plus $x Z) $x) 
            (=== 
              (plus 
                (S $x) Z) 
              (S $x)))))))

<span class="ansi31"
>  (loonit_failureR  
    (equal_enough_for_test  () 
      ( (let* 
          ( ( (: $_13058 
                (plus Z 
                  (=== 
                    (=== 
                      (plus $_12902 Z) $_12902) 
                    (=== 
                      (plus 
                        (S $_12902) Z) 
                      (S $_12902))))) (bc (: $_13058 (plus Z (=== (=== (plus $_12902 Z) $_12902) (=== (plus (S $_12902) Z) (S $_12902))))) (S (S Z))))) 
          (: 
            ( ( (. Replace0) (Replace0 plusBase)) $_13058) 
            (-> 
              (=== 
                (plus $_12902 Z) $_12902) 
              (=== 
                (plus 
                  (S $_12902) Z) 
                (S $_12902))))) 
        (let 
          (: $_13058 
            (=== 
              (=== 
                (plus 
                  (S $_12902) Z) 
                (S $_12902)) 
              (=== 
                (plus $_12902 Z) $_12902))) 
          (bc 
            (: $_13058 
              (=== 
                (=== 
                  (plus 
                    (S $_12902) Z) 
                  (S $_12902)) 
                (=== 
                  (plus $_12902 Z) $_12902))) 
            (S (S Z))) 
          (: 
            ( ( (. Replace0) Sym) $_13058) 
            (-> 
              (=== 
                (plus $_12902 Z) $_12902) 
              (=== 
                (plus 
                  (S $_12902) Z) 
                (S $_12902))))) 
        (let 
          (: $_13058 
            (plus Z 
              (-> 
                (=== 
                  (plus $_12902 Z) $_12902) 
                (=== 
                  (plus 
                    (S $_12902) Z) 
                  (S $_12902))))) 
          (bc 
            (: $_13058 
              (plus Z 
                (-> 
                  (=== 
                    (plus $_12902 Z) $_12902) 
                  (=== 
                    (plus 
                      (S $_12902) Z) 
                    (S $_12902))))) 
            (S (S Z))) 
          (: 
            ( (Replace0 plusBase) $_13058) 
            (-> 
              (=== 
                (plus $_12902 Z) $_12902) 
              (=== 
                (plus 
                  (S $_12902) Z) 
                (S $_12902))))) 
        (: 
          ( (. (Trans plusRec)) Cong) 
          (-> 
            (=== 
              (plus $_12902 Z) $_12902) 
            (=== 
              (plus 
                (S $_12902) Z) 
              (S $_12902)))) 
        (let 
          (: $_13058 
            (-> 
              (=== 
                (plus $_12902 Z) $_12902) 
              (plusRightId (S $_12902)))) 
          (bc 
            (: $_13058 
              (-> 
                (=== 
                  (plus $_12902 Z) $_12902) 
                (plusRightId (S $_12902)))) 
            (S (S Z))) 
          (: 
            ( (. (Replace0 plusRightIdProp)) $_13058) 
            (-> 
              (=== 
                (plus $_12902 Z) $_12902) 
              (=== 
                (plus 
                  (S $_12902) Z) 
                (S $_12902))))) 
        (let 
          (: $_13058 
            (-> 
              (=== 
                (plus $_12902 Z) $_12902) 
              (plus Z 
                (=== 
                  (plus 
                    (S $_12902) Z) 
                  (S $_12902))))) 
          (bc 
            (: $_13058 
              (-> 
                (=== 
                  (plus $_12902 Z) $_12902) 
                (plus Z 
                  (=== 
                    (plus 
                      (S $_12902) Z) 
                    (S $_12902))))) 
            (S (S Z))) 
          (: 
            ( (. (Replace0 plusBase)) $_13058) 
            (-> 
              (=== 
                (plus $_12902 Z) $_12902) 
              (=== 
                (plus 
                  (S $_12902) Z) 
                (S $_12902))))) 
        (let 
          (: $_13058 
            (-> 
              (=== 
                (plus $_12902 Z) $_12902) 
              (=== 
                (S $_12902) 
                (plus 
                  (S $_12902) Z)))) 
          (bc 
            (: $_13058 
              (-> 
                (=== 
                  (plus $_12902 Z) $_12902) 
                (=== 
                  (S $_12902) 
                  (plus 
                    (S $_12902) Z)))) 
            (S (S Z))) 
          (: 
            ( (. Sym) $_13058) 
            (-> 
              (=== 
                (plus $_12902 Z) $_12902) 
              (=== 
                (plus 
                  (S $_12902) Z) 
                (S $_12902))))) 
        (let 
          (: $_13058 
            (=== 
              (=== 
                (plus $_12902 Z) $_12902) 
              (=== 
                (plus 
                  (S $_12902) Z) 
                (S $_12902)))) 
          (bc 
            (: $_13058 
              (=== 
                (=== 
                  (plus $_12902 Z) $_12902) 
                (=== 
                  (plus 
                    (S $_12902) Z) 
                  (S $_12902)))) 
            (S (S Z))) 
          (: 
            (Replace0 $_13058) 
            (-> 
              (=== 
                (plus $_12902 Z) $_12902) 
              (=== 
                (plus 
                  (S $_12902) Z) 
                (S $_12902))))))))
</span>
Deterministic: ((Error  (got  ()) (expected  ((let* (((: $prfarg#54187 (plus Z (=== (=== (plus $x Z) $x) (=== (plus (S $x) Z) (S $x))))) (bc (: $prfarg#54187 (plus Z (=== (=== (plus $x Z) $x) (=== (plus (S $x) Z) (S $x))))) (S (S Z))))) (: (((. Replace0) (Replace0 plusBase)) $prfarg#54187) (-> (=== (plus $x Z) $x) (=== (plus (S $x) Z) (S $x))))) (let (: $prfarg#54187 (=== (=== (plus (S $x) Z) (S $x)) (=== (plus $x Z) $x))) (bc (: $prfarg#54187 (=== (=== (plus (S $x) Z) (S $x)) (=== (plus $x Z) $x))) (S (S Z))) (: (((. Replace0) Sym) $prfarg#54187) (-> (=== (plus $x Z) $x) (=== (plus (S $x) Z) (S $x))))) (let (: $prfarg#54187 (plus Z (-> (=== (plus $x Z) $x) (=== (plus (S $x) Z) (S $x))))) (bc (: $prfarg#54187 (plus Z (-> (=== (plus $x Z) $x) (=== (plus (S $x) Z) (S $x))))) (S (S Z))) (: ((Replace0 plusBase) $prfarg#54187) (-> (=== (plus $x Z) $x) (=== (plus (S $x) Z) (S $x))))) (: ((. (Trans plusRec)) Cong) (-> (=== (plus $x Z) $x) (=== (plus (S $x) Z) (S $x)))) (let (: $prfarg#54187 (-> (=== (plus $x Z) $x) (plusRightId (S $x)))) (bc (: $prfarg#54187 (-> (=== (plus $x Z) $x) (plusRightId (S $x)))) (S (S Z))) (: ((. (Replace0 plusRightIdProp)) $prfarg#54187) (-> (=== (plus $x Z) $x) (=== (plus (S $x) Z) (S $x))))) (let (: $prfarg#54187 (-> (=== (plus $x Z) $x) (plus Z (=== (plus (S $x) Z) (S $x))))) (bc (: $prfarg#54187 (-> (=== (plus $x Z) $x) (plus Z (=== (plus (S $x) Z) (S $x))))) (S (S Z))) (: ((. (Replace0 plusBase)) $prfarg#54187) (-> (=== (plus $x Z) $x) (=== (plus (S $x) Z) (S $x))))) (let (: $prfarg#54187 (-> (=== (plus $x Z) $x) (=== (S $x) (plus (S $x) Z)))) (bc (: $prfarg#54187 (-> (=== (plus $x Z) $x) (=== (S $x) (plus (S $x) Z)))) (S (S Z))) (: ((. Sym) $prfarg#54187) (-> (=== (plus $x Z) $x) (=== (plus (S $x) Z) (S $x))))) (let (: $prfarg#54187 (=== (=== (plus $x Z) $x) (=== (plus (S $x) Z) (S $x)))) (bc (: $prfarg#54187 (=== (=== (plus $x Z) $x) (=== (plus (S $x) Z) (S $x)))) (S (S Z))) (: (Replace0 $prfarg#54187) (-> (=== (plus $x Z) $x) (=== (plus (S $x) Z) (S $x)))))))))
  ( (Error  
      (got  ()) 
      (expected  
        ( (let* 
            ( ( (: $_13052 
                  (plus Z 
                    (=== 
                      (=== 
                        (plus $_12896 Z) $_12896) 
                      (=== 
                        (plus 
                          (S $_12896) Z) 
                        (S $_12896))))) (bc (: $_13052 (plus Z (=== (=== (plus $_12896 Z) $_12896) (=== (plus (S $_12896) Z) (S $_12896))))) (S (S Z))))) 
            (: 
              ( ( (. Replace0) (Replace0 plusBase)) $_13052) 
              (-> 
                (=== 
                  (plus $_12896 Z) $_12896) 
                (=== 
                  (plus 
                    (S $_12896) Z) 
                  (S $_12896))))) 
          (let 
            (: $_13052 
              (=== 
                (=== 
                  (plus 
                    (S $_12896) Z) 
                  (S $_12896)) 
                (=== 
                  (plus $_12896 Z) $_12896))) 
            (bc 
              (: $_13052 
                (=== 
                  (=== 
                    (plus 
                      (S $_12896) Z) 
                    (S $_12896)) 
                  (=== 
                    (plus $_12896 Z) $_12896))) 
              (S (S Z))) 
            (: 
              ( ( (. Replace0) Sym) $_13052) 
              (-> 
                (=== 
                  (plus $_12896 Z) $_12896) 
                (=== 
                  (plus 
                    (S $_12896) Z) 
                  (S $_12896))))) 
          (let 
            (: $_13052 
              (plus Z 
                (-> 
                  (=== 
                    (plus $_12896 Z) $_12896) 
                  (=== 
                    (plus 
                      (S $_12896) Z) 
                    (S $_12896))))) 
            (bc 
              (: $_13052 
                (plus Z 
                  (-> 
                    (=== 
                      (plus $_12896 Z) $_12896) 
                    (=== 
                      (plus 
                        (S $_12896) Z) 
                      (S $_12896))))) 
              (S (S Z))) 
            (: 
              ( (Replace0 plusBase) $_13052) 
              (-> 
                (=== 
                  (plus $_12896 Z) $_12896) 
                (=== 
                  (plus 
                    (S $_12896) Z) 
                  (S $_12896))))) 
          (: 
            ( (. (Trans plusRec)) Cong) 
            (-> 
              (=== 
                (plus $_12896 Z) $_12896) 
              (=== 
                (plus 
                  (S $_12896) Z) 
                (S $_12896)))) 
          (let 
            (: $_13052 
              (-> 
                (=== 
                  (plus $_12896 Z) $_12896) 
                (plusRightId (S $_12896)))) 
            (bc 
              (: $_13052 
                (-> 
                  (=== 
                    (plus $_12896 Z) $_12896) 
                  (plusRightId (S $_12896)))) 
              (S (S Z))) 
            (: 
              ( (. (Replace0 plusRightIdProp)) $_13052) 
              (-> 
                (=== 
                  (plus $_12896 Z) $_12896) 
                (=== 
                  (plus 
                    (S $_12896) Z) 
                  (S $_12896))))) 
          (let 
            (: $_13052 
              (-> 
                (=== 
                  (plus $_12896 Z) $_12896) 
                (plus Z 
                  (=== 
                    (plus 
                      (S $_12896) Z) 
                    (S $_12896))))) 
            (bc 
              (: $_13052 
                (-> 
                  (=== 
                    (plus $_12896 Z) $_12896) 
                  (plus Z 
                    (=== 
                      (plus 
                        (S $_12896) Z) 
                      (S $_12896))))) 
              (S (S Z))) 
            (: 
              ( (. (Replace0 plusBase)) $_13052) 
              (-> 
                (=== 
                  (plus $_12896 Z) $_12896) 
                (=== 
                  (plus 
                    (S $_12896) Z) 
                  (S $_12896))))) 
          (let 
            (: $_13052 
              (-> 
                (=== 
                  (plus $_12896 Z) $_12896) 
                (=== 
                  (S $_12896) 
                  (plus 
                    (S $_12896) Z)))) 
            (bc 
              (: $_13052 
                (-> 
                  (=== 
                    (plus $_12896 Z) $_12896) 
                  (=== 
                    (S $_12896) 
                    (plus 
                      (S $_12896) Z)))) 
              (S (S Z))) 
            (: 
              ( (. Sym) $_13052) 
              (-> 
                (=== 
                  (plus $_12896 Z) $_12896) 
                (=== 
                  (plus 
                    (S $_12896) Z) 
                  (S $_12896))))) 
          (let 
            (: $_13052 
              (=== 
                (=== 
                  (plus $_12896 Z) $_12896) 
                (=== 
                  (plus 
                    (S $_12896) Z) 
                  (S $_12896)))) 
            (bc 
              (: $_13052 
                (=== 
                  (=== 
                    (plus $_12896 Z) $_12896) 
                  (=== 
                    (plus 
                      (S $_12896) Z) 
                    (S $_12896)))) 
              (S (S Z))) 
            (: 
              (Replace0 $_13052) 
              (-> 
                (=== 
                  (plus $_12896 Z) $_12896) 
                (=== 
                  (plus 
                    (S $_12896) Z) 

                  (S $_12896)))))))))]
;;;; (: ((. (Trans plusRec)) Cong) (-> (=== (plus $x Z) $x) (=== (plus (S $x) Z) (S $x))))
;;;; Prove that (-> (plusRightId $x) (plusRightId (S $x)))
;;;;
;;;; The proof tree should be:
;;;;
;;;;                                                                                                                                       ------------------------------------(plusRec)
;;;;                                                                                                                                       (=== (plus (S $x) Z) (S (plus $x Z)))
;;;; ------------------------------------------(plusRightIdProp)  ------------------------------------------------------(plusRightIdProp)  -------------------------------------------------------------(Trans)  -----------------------------------------------------(Cong)
;;;; (=== (plusRightId $x) (=== (plus $x Z) $x))                  (=== (plusRightId (S $x)) (=== (plus (S $x) Z) (S $x)))                  (-> (=== (S (plus $x Z)) (S $x)) (=== (plus (S $x) Z) (S $x)))        (-> (=== (plus $x Z) $x) (=== (S (plus $x Z)) (S $x)))
;;;; ------------------------------------------(Sym)              ------------------------------------------------------(Sym)              ---------------------------------------------------------------------------------------------------------------------------(.)
;;;; (=== (=== (plus $x Z) $x) (plusRightId $x))                  (=== (=== (plus (S $x) Z) (S $x)) (plusRightId (S $x)))                                                   (-> (=== (plus $x Z) $x) (=== (plus (S $x) Z) (S $x)))
;;;; ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------(Replace2)
;;;;                                                                                                   (-> (plusRightId $x) (plusRightId (S $x)))
;;;;
;;;; or in MeTTa format:
;;;;
;;;; (((Replace2 (Sym plusRightIdProp)) (Sym plusRightIdProp)) ((. (Trans plusRec)) Cong))
;;;;
;;;; There is also a proof not involving Replace2, using two instances of Replace0 instead
;;;;
;;;; ((. (Replace0 (Sym plusRightIdProp))) ((. (Trans plusRec)) ((. Cong) (Replace0 plusRightIdProp))))
;;;;
;;;; It's a bit more verbose but requires a smaller rule base which
;;;; speeds up backward chaining, so we are aiming for that instead.
;;;;
;;;; TODO: re-enable when assertContainResults is introduced
;;;; !(assertEqualToResult
<span class="ansi38-255165009"
>;; In file as:  
</span><span class="ansi1 ansi38-255238088"
>  !(bc 
    (: $prf 
      (-> 
        (plusRightId $x) 
        (plusRightId (S $x)))) 
    (fromNumber 4))
</span>;; To unit test case:
<span class="ansi38-013099040"
>  !(assertEqualToResult 
    (bc 
      (: $prf 
        (-> 
          (plusRightId $x) 
          (plusRightId (S $x)))) 
      (fromNumber 4)) 
    ( (: 
        (Replace0 (Cong ((Trans plusRec) ((Trans (Cong plusBase)) (Cong (Sym plusRec)))))) 
        (-> 
          (plusRightId (plus (S Z) $x'#124505)) 
          (plusRightId (S (plus (S Z) $x'#124505))))) 
      (: 
        (Replace0 (Cong ((Trans plusRec) ((Trans (Cong plusBase)) (Cong plusBase))))) 
        (-> 
          (plusRightId (plus (S Z) $x'#124505)) 
          (plusRightId (S (plus (S Z) $x'#124505))))) 
      (: 
        (Replace0 (Cong ((Trans plusRec) ((Trans (Cong plusBase)) (Sym (Cong plusRec)))))) 
        (-> 
          (plusRightId (plus (S Z) $x'#124505)) 
          (plusRightId (S (plus (S Z) $x'#124505))))) 
      (: 
        (Replace0 (Cong ((Trans plusRec) (Cong ((Trans plusBase) (Sym plusRec)))))) 
        (-> 
          (plusRightId (plus (S Z) $y#144144)) 
          (plusRightId (S (plus (S Z) $y#144144))))) 
      (: 
        (Replace0 (Cong ((Trans plusRec) (Cong ((Trans plusBase) plusBase))))) 
        (-> 
          (plusRightId (plus (S Z) $y#144144)) 
          (plusRightId (S (plus (S Z) $y#144144))))) 
      (: 
        (Replace0 (Cong ((Trans plusBase) ((Trans (Sym plusBase)) ((Trans plusBase) (Cong plusBase)))))) 
        (-> 
          (plusRightId (plus Z $y#187257)) 
          (plusRightId (S (plus Z $y#187257))))) 
      (: 
        (Replace0 (Cong ((Trans plusBase) ((Trans (Sym plusBase)) ((Trans plusBase) plusRec))))) 
        (-> 
          (plusRightId (plus Z $y#187257)) 
          (plusRightId (S (plus Z $y#187257))))) 
      (: 
        (Replace0 (Cong ((Trans plusBase) ((Trans (Sym plusBase)) ((Trans plusBase) plusBase))))) 
        (-> 
          (plusRightId (plus Z $y#187257)) 
          (plusRightId (S (plus Z $y#187257))))) 
      (: 
        (Replace0 (Cong (Cong ((Trans (Sym plusBase)) ((Trans plusBase) (Cong plusRec)))))) 
        (-> 
          (plusRightId (S (S (plus $x#234949 $y#234950)))) 
          (plusRightId (S (S (S (plus $x#234949 $y#234950))))))) 
      (: 
        (Replace0 (Cong (Cong ((Trans (Sym plusBase)) ((Trans plusBase) (Cong plusRightIdProp)))))) 
        (-> 
          (plusRightId (S (=== (plus $x#234951 Z) $x#234951))) 
          (plusRightId (S (S (=== (plus $x#234951 Z) $x#234951)))))) 
      (: 
        (Replace0 (Cong (Cong ((Trans (Sym plusBase)) ((Trans plusBase) (Cong plusBase)))))) 
        (-> 
          (plusRightId (S $y#234250)) 
          (plusRightId (S (S $y#234250))))) 
      (: 
        (Replace0 (Cong (Cong ((Trans (Sym plusBase)) ((Trans plusBase) plusRec))))) 
        (-> 
          (plusRightId (S (plus $x#235249 $y#235250))) 
          (plusRightId (S (S (plus $x#235249 $y#235250)))))) 
      (: 
        (Replace0 (Cong (Cong ((Trans (Sym plusBase)) ((Trans plusBase) plusBase))))) 
        (-> 
          (plusRightId (S $y#234250)) 
          (plusRightId (S (S $y#234250))))) 
      (: 
        (Replace0 (Cong ((Trans (Sym plusBase)) ((Trans plusBase) (Cong plusRec))))) 
        (-> 
          (plusRightId (S (plus $x#464500 $y#464501))) 
          (plusRightId (S (S (plus $x#464500 $y#464501)))))) 
      (: 
        (Replace0 (Cong ((Trans (Sym plusBase)) ((Trans plusBase) (Cong plusRightIdProp))))) 
        (-> 
          (plusRightId (=== (plus $x#464502 Z) $x#464502)) 
          (plusRightId (S (=== (plus $x#464502 Z) $x#464502))))) 
      (: 
        (Replace0 (Cong ((Trans (Sym plusBase)) ((Trans plusBase) (Cong plusBase))))) 
        (-> 
          (plusRightId $y#463801) 
          (plusRightId (S $y#463801)))) 
      (: 
        (Replace0 (Cong ((Trans (Sym plusBase)) ((Trans plusBase) plusRec)))) 
        (-> 
          (plusRightId (plus $x#464800 $y#464801)) 
          (plusRightId (S (plus $x#464800 $y#464801))))) 
      (: 
        (Replace0 (Cong ((Trans (Sym plusBase)) ((Trans plusBase) plusBase)))) 
        (-> 
          (plusRightId $y#463801) 
          (plusRightId (S $y#463801)))) 
      (: 
        ( (. (Replace0 (Sym plusRightIdProp))) ((. (Trans plusRec)) ((. Cong) (Replace0 plusRightIdProp)))) 
        (-> 
          (plusRightId $x) 
          (plusRightId (S $x))))))

</span>[

;<h3 id="HOL.NATSTANDALONETEST.14"
>;; HOL.NATSTANDALONETEST.14</h3>
; 
; EVAL TEST
; took 0.126 secs. (126.42 milliseconds) 

  !(assertEqualToResult 
    (bc 
      (: $prf 
        (-> 
          (plusRightId $x) 
          (plusRightId (S $x)))) 
      (fromNumber 4)) 
    ( (: 
        (Replace0 (Cong ((Trans plusRec) ((Trans (Cong plusBase)) (Cong (Sym plusRec)))))) 
        (-> 
          (plusRightId (plus (S Z) $x'#124505)) 
          (plusRightId (S (plus (S Z) $x'#124505))))) 
      (: 
        (Replace0 (Cong ((Trans plusRec) ((Trans (Cong plusBase)) (Cong plusBase))))) 
        (-> 
          (plusRightId (plus (S Z) $x'#124505)) 
          (plusRightId (S (plus (S Z) $x'#124505))))) 
      (: 
        (Replace0 (Cong ((Trans plusRec) ((Trans (Cong plusBase)) (Sym (Cong plusRec)))))) 
        (-> 
          (plusRightId (plus (S Z) $x'#124505)) 
          (plusRightId (S (plus (S Z) $x'#124505))))) 
      (: 
        (Replace0 (Cong ((Trans plusRec) (Cong ((Trans plusBase) (Sym plusRec)))))) 
        (-> 
          (plusRightId (plus (S Z) $y#144144)) 
          (plusRightId (S (plus (S Z) $y#144144))))) 
      (: 
        (Replace0 (Cong ((Trans plusRec) (Cong ((Trans plusBase) plusBase))))) 
        (-> 
          (plusRightId (plus (S Z) $y#144144)) 
          (plusRightId (S (plus (S Z) $y#144144))))) 
      (: 
        (Replace0 (Cong ((Trans plusBase) ((Trans (Sym plusBase)) ((Trans plusBase) (Cong plusBase)))))) 
        (-> 
          (plusRightId (plus Z $y#187257)) 
          (plusRightId (S (plus Z $y#187257))))) 
      (: 
        (Replace0 (Cong ((Trans plusBase) ((Trans (Sym plusBase)) ((Trans plusBase) plusRec))))) 
        (-> 
          (plusRightId (plus Z $y#187257)) 
          (plusRightId (S (plus Z $y#187257))))) 
      (: 
        (Replace0 (Cong ((Trans plusBase) ((Trans (Sym plusBase)) ((Trans plusBase) plusBase))))) 
        (-> 
          (plusRightId (plus Z $y#187257)) 
          (plusRightId (S (plus Z $y#187257))))) 
      (: 
        (Replace0 (Cong (Cong ((Trans (Sym plusBase)) ((Trans plusBase) (Cong plusRec)))))) 
        (-> 
          (plusRightId (S (S (plus $x#234949 $y#234950)))) 
          (plusRightId (S (S (S (plus $x#234949 $y#234950))))))) 
      (: 
        (Replace0 (Cong (Cong ((Trans (Sym plusBase)) ((Trans plusBase) (Cong plusRightIdProp)))))) 
        (-> 
          (plusRightId (S (=== (plus $x#234951 Z) $x#234951))) 
          (plusRightId (S (S (=== (plus $x#234951 Z) $x#234951)))))) 
      (: 
        (Replace0 (Cong (Cong ((Trans (Sym plusBase)) ((Trans plusBase) (Cong plusBase)))))) 
        (-> 
          (plusRightId (S $y#234250)) 
          (plusRightId (S (S $y#234250))))) 
      (: 
        (Replace0 (Cong (Cong ((Trans (Sym plusBase)) ((Trans plusBase) plusRec))))) 
        (-> 
          (plusRightId (S (plus $x#235249 $y#235250))) 
          (plusRightId (S (S (plus $x#235249 $y#235250)))))) 
      (: 
        (Replace0 (Cong (Cong ((Trans (Sym plusBase)) ((Trans plusBase) plusBase))))) 
        (-> 
          (plusRightId (S $y#234250)) 
          (plusRightId (S (S $y#234250))))) 
      (: 
        (Replace0 (Cong ((Trans (Sym plusBase)) ((Trans plusBase) (Cong plusRec))))) 
        (-> 
          (plusRightId (S (plus $x#464500 $y#464501))) 
          (plusRightId (S (S (plus $x#464500 $y#464501)))))) 
      (: 
        (Replace0 (Cong ((Trans (Sym plusBase)) ((Trans plusBase) (Cong plusRightIdProp))))) 
        (-> 
          (plusRightId (=== (plus $x#464502 Z) $x#464502)) 
          (plusRightId (S (=== (plus $x#464502 Z) $x#464502))))) 
      (: 
        (Replace0 (Cong ((Trans (Sym plusBase)) ((Trans plusBase) (Cong plusBase))))) 
        (-> 
          (plusRightId $y#463801) 
          (plusRightId (S $y#463801)))) 
      (: 
        (Replace0 (Cong ((Trans (Sym plusBase)) ((Trans plusBase) plusRec)))) 
        (-> 
          (plusRightId (plus $x#464800 $y#464801)) 
          (plusRightId (S (plus $x#464800 $y#464801))))) 
      (: 
        (Replace0 (Cong ((Trans (Sym plusBase)) ((Trans plusBase) plusBase)))) 
        (-> 
          (plusRightId $y#463801) 
          (plusRightId (S $y#463801)))) 
      (: 
        ( (. (Replace0 (Sym plusRightIdProp))) ((. (Trans plusRec)) ((. Cong) (Replace0 plusRightIdProp)))) 
        (-> 
          (plusRightId $x) 
          (plusRightId (S $x))))))

<span class="ansi31"
>  (loonit_failureR  
    (equal_enough_for_test  () 
      ( (: 
          (Replace0 (Cong ((Trans plusRec) ((Trans (Cong plusBase)) (Cong (Sym plusRec)))))) 
          (-> 
            (plusRightId (plus (S Z) $_13526)) 
            (plusRightId (S (plus (S Z) $_13526))))) 
        (: 
          (Replace0 (Cong ((Trans plusRec) ((Trans (Cong plusBase)) (Cong plusBase))))) 
          (-> 
            (plusRightId (plus (S Z) $_13526)) 
            (plusRightId (S (plus (S Z) $_13526))))) 
        (: 
          (Replace0 (Cong ((Trans plusRec) ((Trans (Cong plusBase)) (Sym (Cong plusRec)))))) 
          (-> 
            (plusRightId (plus (S Z) $_13526)) 
            (plusRightId (S (plus (S Z) $_13526))))) 
        (: 
          (Replace0 (Cong ((Trans plusRec) (Cong ((Trans plusBase) (Sym plusRec)))))) 
          (-> 
            (plusRightId (plus (S Z) $_14252)) 
            (plusRightId (S (plus (S Z) $_14252))))) 
        (: 
          (Replace0 (Cong ((Trans plusRec) (Cong ((Trans plusBase) plusBase))))) 
          (-> 
            (plusRightId (plus (S Z) $_14252)) 
            (plusRightId (S (plus (S Z) $_14252))))) 
        (: 
          (Replace0 (Cong ((Trans plusBase) ((Trans (Sym plusBase)) ((Trans plusBase) (Cong plusBase)))))) 
          (-> 
            (plusRightId (plus Z $_14732)) 
            (plusRightId (S (plus Z $_14732))))) 
        (: 
          (Replace0 (Cong ((Trans plusBase) ((Trans (Sym plusBase)) ((Trans plusBase) plusRec))))) 
          (-> 
            (plusRightId (plus Z $_14732)) 
            (plusRightId (S (plus Z $_14732))))) 
        (: 
          (Replace0 (Cong ((Trans plusBase) ((Trans (Sym plusBase)) ((Trans plusBase) plusBase))))) 
          (-> 
            (plusRightId (plus Z $_14732)) 
            (plusRightId (S (plus Z $_14732))))) 
        (: 
          (Replace0 (Cong (Cong ((Trans (Sym plusBase)) ((Trans plusBase) (Cong plusRec)))))) 
          (-> 
            (plusRightId (S (S (plus $_15428 $_15446)))) 
            (plusRightId (S (S (S (plus $_15428 $_15446))))))) 
        (: 
          (Replace0 (Cong (Cong ((Trans (Sym plusBase)) ((Trans plusBase) (Cong plusRightIdProp)))))) 
          (-> 
            (plusRightId (S (=== (plus $_15722 Z) $_15722))) 
            (plusRightId (S (S (=== (plus $_15722 Z) $_15722)))))) 
        (: 
          (Replace0 (Cong (Cong ((Trans (Sym plusBase)) ((Trans plusBase) (Cong plusBase)))))) 
          (-> 
            (plusRightId (S $_15992)) 
            (plusRightId (S (S $_15992))))) 
        (: 
          (Replace0 (Cong (Cong ((Trans (Sym plusBase)) ((Trans plusBase) plusRec))))) 
          (-> 
            (plusRightId (S (plus $_16214 $_16232))) 
            (plusRightId (S (S (plus $_16214 $_16232)))))) 
        (: 
          (Replace0 (Cong (Cong ((Trans (Sym plusBase)) ((Trans plusBase) plusBase))))) 
          (-> 
            (plusRightId (S $_15992)) 
            (plusRightId (S (S $_15992))))) 
        (: 
          (Replace0 (Cong ((Trans (Sym plusBase)) ((Trans plusBase) (Cong plusRec))))) 
          (-> 
            (plusRightId (S (plus $_16670 $_16688))) 
            (plusRightId (S (S (plus $_16670 $_16688)))))) 
        (: 
          (Replace0 (Cong ((Trans (Sym plusBase)) ((Trans plusBase) (Cong plusRightIdProp))))) 
          (-> 
            (plusRightId (=== (plus $_16928 Z) $_16928)) 
            (plusRightId (S (=== (plus $_16928 Z) $_16928))))) 
        (: 
          (Replace0 (Cong ((Trans (Sym plusBase)) ((Trans plusBase) (Cong plusBase))))) 
          (-> 
            (plusRightId $_17162) 
            (plusRightId (S $_17162)))) 
        (: 
          (Replace0 (Cong ((Trans (Sym plusBase)) ((Trans plusBase) plusRec)))) 
          (-> 
            (plusRightId (plus $_17348 $_17366)) 
            (plusRightId (S (plus $_17348 $_17366))))) 
        (: 
          (Replace0 (Cong ((Trans (Sym plusBase)) ((Trans plusBase) plusBase)))) 
          (-> 
            (plusRightId $_17162) 
            (plusRightId (S $_17162)))) 
        (: 
          ( (. (Replace0 (Sym plusRightIdProp))) ((. (Trans plusRec)) ((. Cong) (Replace0 plusRightIdProp)))) 
          (-> 
            (plusRightId $_13274) 
            (plusRightId (S $_13274)))))))
</span>
Deterministic: ((Error  (got  ()) (expected  ((: (Replace0 (Cong ((Trans plusRec) ((Trans (Cong plusBase)) (Cong (Sym plusRec)))))) (-> (plusRightId (plus (S Z) $x'#124505)) (plusRightId (S (plus (S Z) $x'#124505))))) (: (Replace0 (Cong ((Trans plusRec) ((Trans (Cong plusBase)) (Cong plusBase))))) (-> (plusRightId (plus (S Z) $x'#124505)) (plusRightId (S (plus (S Z) $x'#124505))))) (: (Replace0 (Cong ((Trans plusRec) ((Trans (Cong plusBase)) (Sym (Cong plusRec)))))) (-> (plusRightId (plus (S Z) $x'#124505)) (plusRightId (S (plus (S Z) $x'#124505))))) (: (Replace0 (Cong ((Trans plusRec) (Cong ((Trans plusBase) (Sym plusRec)))))) (-> (plusRightId (plus (S Z) $y#144144)) (plusRightId (S (plus (S Z) $y#144144))))) (: (Replace0 (Cong ((Trans plusRec) (Cong ((Trans plusBase) plusBase))))) (-> (plusRightId (plus (S Z) $y#144144)) (plusRightId (S (plus (S Z) $y#144144))))) (: (Replace0 (Cong ((Trans plusBase) ((Trans (Sym plusBase)) ((Trans plusBase) (Cong plusBase)))))) (-> (plusRightId (plus Z $y#187257)) (plusRightId (S (plus Z $y#187257))))) (: (Replace0 (Cong ((Trans plusBase) ((Trans (Sym plusBase)) ((Trans plusBase) plusRec))))) (-> (plusRightId (plus Z $y#187257)) (plusRightId (S (plus Z $y#187257))))) (: (Replace0 (Cong ((Trans plusBase) ((Trans (Sym plusBase)) ((Trans plusBase) plusBase))))) (-> (plusRightId (plus Z $y#187257)) (plusRightId (S (plus Z $y#187257))))) (: (Replace0 (Cong (Cong ((Trans (Sym plusBase)) ((Trans plusBase) (Cong plusRec)))))) (-> (plusRightId (S (S (plus $x#234949 $y#234950)))) (plusRightId (S (S (S (plus $x#234949 $y#234950))))))) (: (Replace0 (Cong (Cong ((Trans (Sym plusBase)) ((Trans plusBase) (Cong plusRightIdProp)))))) (-> (plusRightId (S (=== (plus $x#234951 Z) $x#234951))) (plusRightId (S (S (=== (plus $x#234951 Z) $x#234951)))))) (: (Replace0 (Cong (Cong ((Trans (Sym plusBase)) ((Trans plusBase) (Cong plusBase)))))) (-> (plusRightId (S $y#234250)) (plusRightId (S (S $y#234250))))) (: (Replace0 (Cong (Cong ((Trans (Sym plusBase)) ((Trans plusBase) plusRec))))) (-> (plusRightId (S (plus $x#235249 $y#235250))) (plusRightId (S (S (plus $x#235249 $y#235250)))))) (: (Replace0 (Cong (Cong ((Trans (Sym plusBase)) ((Trans plusBase) plusBase))))) (-> (plusRightId (S $y#234250)) (plusRightId (S (S $y#234250))))) (: (Replace0 (Cong ((Trans (Sym plusBase)) ((Trans plusBase) (Cong plusRec))))) (-> (plusRightId (S (plus $x#464500 $y#464501))) (plusRightId (S (S (plus $x#464500 $y#464501)))))) (: (Replace0 (Cong ((Trans (Sym plusBase)) ((Trans plusBase) (Cong plusRightIdProp))))) (-> (plusRightId (=== (plus $x#464502 Z) $x#464502)) (plusRightId (S (=== (plus $x#464502 Z) $x#464502))))) (: (Replace0 (Cong ((Trans (Sym plusBase)) ((Trans plusBase) (Cong plusBase))))) (-> (plusRightId $y#463801) (plusRightId (S $y#463801)))) (: (Replace0 (Cong ((Trans (Sym plusBase)) ((Trans plusBase) plusRec)))) (-> (plusRightId (plus $x#464800 $y#464801)) (plusRightId (S (plus $x#464800 $y#464801))))) (: (Replace0 (Cong ((Trans (Sym plusBase)) ((Trans plusBase) plusBase)))) (-> (plusRightId $y#463801) (plusRightId (S $y#463801)))) (: ((. (Replace0 (Sym plusRightIdProp))) ((. (Trans plusRec)) ((. Cong) (Replace0 plusRightIdProp)))) (-> (plusRightId $x) (plusRightId (S $x))))))))
  ( (Error  
      (got  ()) 
      (expected  
        ( (: 
            (Replace0 (Cong ((Trans plusRec) ((Trans (Cong plusBase)) (Cong (Sym plusRec)))))) 
            (-> 
              (plusRightId (plus (S Z) $_13526)) 
              (plusRightId (S (plus (S Z) $_13526))))) 
          (: 
            (Replace0 (Cong ((Trans plusRec) ((Trans (Cong plusBase)) (Cong plusBase))))) 
            (-> 
              (plusRightId (plus (S Z) $_13526)) 
              (plusRightId (S (plus (S Z) $_13526))))) 
          (: 
            (Replace0 (Cong ((Trans plusRec) ((Trans (Cong plusBase)) (Sym (Cong plusRec)))))) 
            (-> 
              (plusRightId (plus (S Z) $_13526)) 
              (plusRightId (S (plus (S Z) $_13526))))) 
          (: 
            (Replace0 (Cong ((Trans plusRec) (Cong ((Trans plusBase) (Sym plusRec)))))) 
            (-> 
              (plusRightId (plus (S Z) $_14252)) 
              (plusRightId (S (plus (S Z) $_14252))))) 
          (: 
            (Replace0 (Cong ((Trans plusRec) (Cong ((Trans plusBase) plusBase))))) 
            (-> 
              (plusRightId (plus (S Z) $_14252)) 
              (plusRightId (S (plus (S Z) $_14252))))) 
          (: 
            (Replace0 (Cong ((Trans plusBase) ((Trans (Sym plusBase)) ((Trans plusBase) (Cong plusBase)))))) 
            (-> 
              (plusRightId (plus Z $_14732)) 
              (plusRightId (S (plus Z $_14732))))) 
          (: 
            (Replace0 (Cong ((Trans plusBase) ((Trans (Sym plusBase)) ((Trans plusBase) plusRec))))) 
            (-> 
              (plusRightId (plus Z $_14732)) 
              (plusRightId (S (plus Z $_14732))))) 
          (: 
            (Replace0 (Cong ((Trans plusBase) ((Trans (Sym plusBase)) ((Trans plusBase) plusBase))))) 
            (-> 
              (plusRightId (plus Z $_14732)) 
              (plusRightId (S (plus Z $_14732))))) 
          (: 
            (Replace0 (Cong (Cong ((Trans (Sym plusBase)) ((Trans plusBase) (Cong plusRec)))))) 
            (-> 
              (plusRightId (S (S (plus $_15428 $_15446)))) 
              (plusRightId (S (S (S (plus $_15428 $_15446))))))) 
          (: 
            (Replace0 (Cong (Cong ((Trans (Sym plusBase)) ((Trans plusBase) (Cong plusRightIdProp)))))) 
            (-> 
              (plusRightId (S (=== (plus $_15722 Z) $_15722))) 
              (plusRightId (S (S (=== (plus $_15722 Z) $_15722)))))) 
          (: 
            (Replace0 (Cong (Cong ((Trans (Sym plusBase)) ((Trans plusBase) (Cong plusBase)))))) 
            (-> 
              (plusRightId (S $_15992)) 
              (plusRightId (S (S $_15992))))) 
          (: 
            (Replace0 (Cong (Cong ((Trans (Sym plusBase)) ((Trans plusBase) plusRec))))) 
            (-> 
              (plusRightId (S (plus $_16214 $_16232))) 
              (plusRightId (S (S (plus $_16214 $_16232)))))) 
          (: 
            (Replace0 (Cong (Cong ((Trans (Sym plusBase)) ((Trans plusBase) plusBase))))) 
            (-> 
              (plusRightId (S $_15992)) 
              (plusRightId (S (S $_15992))))) 
          (: 
            (Replace0 (Cong ((Trans (Sym plusBase)) ((Trans plusBase) (Cong plusRec))))) 
            (-> 
              (plusRightId (S (plus $_16670 $_16688))) 
              (plusRightId (S (S (plus $_16670 $_16688)))))) 
          (: 
            (Replace0 (Cong ((Trans (Sym plusBase)) ((Trans plusBase) (Cong plusRightIdProp))))) 
            (-> 
              (plusRightId (=== (plus $_16928 Z) $_16928)) 
              (plusRightId (S (=== (plus $_16928 Z) $_16928))))) 
          (: 
            (Replace0 (Cong ((Trans (Sym plusBase)) ((Trans plusBase) (Cong plusBase))))) 
            (-> 
              (plusRightId $_17162) 
              (plusRightId (S $_17162)))) 
          (: 
            (Replace0 (Cong ((Trans (Sym plusBase)) ((Trans plusBase) plusRec)))) 
            (-> 
              (plusRightId (plus $_17348 $_17366)) 
              (plusRightId (S (plus $_17348 $_17366))))) 
          (: 
            (Replace0 (Cong ((Trans (Sym plusBase)) ((Trans plusBase) plusBase)))) 
            (-> 
              (plusRightId $_17162) 
              (plusRightId (S $_17162)))) 
          (: 
            ( (. (Replace0 (Sym plusRightIdProp))) ((. (Trans plusRec)) ((. Cong) (Replace0 plusRightIdProp)))) 
            (-> 
              (plusRightId $_13274) 

              (plusRightId (S $_13274))))))))]
;;;; (: ((. (Replace0 (Sym plusRightIdProp))) ((. (Trans plusRec)) ((. Cong) (Replace0 plusRightIdProp)))) (-> (plusRightId $x) (plusRightId (S $x))))
;;;; Prove that Z is the right identity of plus
;;;;
;;;; ---------------------------------------(plusRightIdProp)
;;;; (=== (plusRightId Z) (=== (plus Z Z) Z))
;;;; ---------------------------------------(Sym)  -----------------(plusBase)
;;;; (=== (=== (plus Z Z) Z) (plusRightId Z))      (=== (plus Z Z) Z)                   <PROOF IS PROVIDED ABOVE>
;;;; ---------------------------------------------------------------(Replace0)  -----------------------------------------(Replace2)
;;;;                        (plusRightId Z)                                     (-> (plusRightId $x) (plusRightId (S $x)))
;;;;                        ---------------------------------------------------------------------------------------------(NatInd)
;;;;                                                               (plusRightId $x)
;;;;
;;;; or in MeTTa format
;;;;
;;;; ((NatInd ((Replace0 (Sym plusRightIdProp)) plusBase)) ((. (Replace0 (Sym plusRightIdProp))) ((. (Trans plusRec)) ((. Cong) (Replace0 plusRightIdProp)))))
;;;;
;;;; We provide the clue that structural induction is to be so that the
;;;; backward chainer only has to find the base case and the inductive
;;;; step, otherwise the search takes too much memory (over 64GB).
<span class="ansi38-013099040"
>  !(assertEqual 
    (bc 
      (: 
        ( (NatInd $basecase) $indstep) 
        (plusRightId $x)) 
      (fromNumber 5)) 
    (: 
      ( (NatInd ((Replace0 (Sym plusRightIdProp)) plusBase)) ((. (Replace0 (Sym plusRightIdProp))) ((. (Trans plusRec)) ((. Cong) (Replace0 plusRightIdProp))))) 
      (plusRightId $x)))

</span>[

;<h3 id="HOL.NATSTANDALONETEST.15"
>;; HOL.NATSTANDALONETEST.15</h3>
; 
; EVAL TEST
; took 0.026 secs. (25.86 milliseconds) 

  !(assertEqual 
    (bc 
      (: 
        ( (NatInd $basecase) $indstep) 
        (plusRightId $x)) 
      (fromNumber 5)) 
    (: 
      ( (NatInd ((Replace0 (Sym plusRightIdProp)) plusBase)) ((. (Replace0 (Sym plusRightIdProp))) ((. (Trans plusRec)) ((. Cong) (Replace0 plusRightIdProp))))) 
      (plusRightId $x)))

<span class="ansi31"
>  (loonit_failureR  
    (equal_enough_for_test  () 
      ( (: 
          ( (NatInd ((Replace0 (Sym plusRightIdProp)) plusBase)) ((. (Replace0 (Sym plusRightIdProp))) ((. (Trans plusRec)) ((. Cong) (Replace0 plusRightIdProp))))) 
          (plusRightId $_41052)))))
</span>
Deterministic: ((Error  (got  ()) (expected  ((: ((NatInd ((Replace0 (Sym plusRightIdProp)) plusBase)) ((. (Replace0 (Sym plusRightIdProp))) ((. (Trans plusRec)) ((. Cong) (Replace0 plusRightIdProp))))) (plusRightId $_41052))))))
  ( (Error  
      (got  ()) 
      (expected  
        ( (: 
            ( (NatInd ((Replace0 (Sym plusRightIdProp)) plusBase)) ((. (Replace0 (Sym plusRightIdProp))) ((. (Trans plusRec)) ((. Cong) (Replace0 plusRightIdProp))))) 

            (plusRightId $_41052))))))]
;;;; TODO: try to reproduce
<span class="ansi32"
>% 5,320,496 inferences, 1.884 CPU in 1.884 seconds (100% CPU, 2824018 Lips)
</span>P;HTML|
;                         (= /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/hol/NatStandaloneTest.metta  0)
<span class="ansi1"
>LoonIt Report
</span>------------
<span class="ansi32"
>Successes: 9
</span><span class="ansi31"
>Failures: 6
</span><br/> <a href="#" onclick="window.history.back(); return false;"
>Return to summaries</a><br/>
P;HTML|
;           (is_cmd_option  execute halt --halt=true true)
P;HTML|
;            (set_option_value  halt true)
P;HTML|
;            (is_cmd_option  execute stdin --stdin=tty tty)
P;HTML|
;            (set_option_value  stdin tty)
P;HTML|
;            (is_cmd_option  execute stdout --stdout=tty tty)
P;HTML|
;             (set_option_value  stdout tty)
P;HTML|
;            (is_cmd_option  execute stderr --stderr=tty tty)
P;HTML|
;             (set_option_value  stderr tty)
P;HTML|
;           (set_option_value  prolog false)
P;HTML|
;           (set_option_value  compat auto)
P;HTML|
;           (set_option_value  compatio true)

Script done on 2024-09-27 01:17:24+00:00 [COMMAND_EXIT_CODE="7"]

</pre>
</body>

</html>
\033[0;32mCompleted successfully (EXITCODE=7) Under 40 seconds: ./mettalog '--output=./reports/tests_output/baseline-compat-2024-09-27T00:33:45/' --timeout=40 --html --repl=false  --test "tests/extended_compat/hyperon-pln/metta/hol/NatStandaloneTest.metta" --halt=true\033[0m

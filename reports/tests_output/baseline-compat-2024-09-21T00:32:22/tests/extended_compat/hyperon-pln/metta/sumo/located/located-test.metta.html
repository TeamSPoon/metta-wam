<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"
>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"
>
<title></title>
<style type="text/css"
>
.ansi2html-content { display: inline; white-space: pre-wrap; word-wrap: break-word; }
.body_foreground { color: #AAAAAA; }
.body_background { background-color: #000000; }
.inv_foreground { color: #000000; }
.inv_background { background-color: #AAAAAA; }
.ansi1 { font-weight: bold; }
.ansi31 { color: #aa0000; }
.ansi32 { color: #00aa00; }
.ansi36 { color: #00aaaa; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165009 { color: #FFA509; }
.ansi38-255238088 { color: #FFEE58; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165009 { color: #FFA509; }
.ansi38-255238088 { color: #FFEE58; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165009 { color: #FFA509; }
.ansi38-255238088 { color: #FFEE58; }
.ansi38-013099040 { color: #0D6328; }
</style>
</head>
<body class="body_foreground body_background" style="font-size: normal;" >
<pre class="ansi2html-content"
>
Script started on 2024-09-21 01:21:13+00:00 [TERM="xterm-256color" TTY="/dev/pts/0" COLUMNS="-1" LINES="-1"]
P;HTML|
;           (set_option_value  prolog false)

P;HTML|
;           (set_option_value  compat auto)

P;HTML|
;           (set_option_value  compatio true)
P;HTML|
;            (is_cmd_option  prescan halt --halt=true true)
P;HTML|
;            (set_option_value  halt true)
P;HTML|
;            (is_cmd_option  prescan stdin --stdin=tty tty)
P;HTML|
;             (set_option_value  stdin tty)
P;HTML|
;            (is_cmd_option  prescan stdout --stdout=tty tty)
P;HTML|
;             (set_option_value  stdout tty)
P;HTML|
;            (is_cmd_option  prescan stderr --stderr=tty tty)
P;HTML|
;             (set_option_value  stderr tty)
P;HTML|
;            (set_option_value  prolog false)
P;HTML|
;            (set_option_value  compat auto)
P;HTML|
;            (set_option_value  compatio true)
P;HTML|
;          (is_cmd_option  execute python --python=enable enable)
P;HTML|
;           (set_option_value  python enable)
P;HTML|
;          (is_cmd_option  execute timeout --timeout=40 40)
P;HTML|
;           (set_option_value  timeout 40)
P;HTML|
;           (is_cmd_option  execute output --output=./reports/tests_output/baseline-compat-2024-09-21T00:32:22/ ./reports/tests_output/baseline-compat-2024-09-21T00:32:22/)
P;HTML|
;           (set_option_value  output ./reports/tests_output/baseline-compat-2024-09-21T00:32:22/)
P;HTML|
;           (is_cmd_option  execute html --html true)
P;HTML|
;            (set_option_value  html true)
P;HTML|
;           (is_cmd_option  execute test --test true)
P;HTML|
;            (set_option_value  test true)

; (load_metta_file  &self tests/extended_compat/hyperon-pln/metta/sumo/located/located-test.metta)
P;HTML|
;                         (track_load_into_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/sumo/located/located-test.metta)
P;HTML|
;                                          (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/sumo/located/located-test.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/sumo/located/located-test.metta)
P;HTML|
;                                           (= 1  "+ '[' 0 -eq 1 ']'")
P;HTML|
;                                           (= 1  "+ echo 'Doing: timeout --foreground --kill-after=5 --signal=SIGINT 121 time metta /opt/logicmoo_opencog/hyperon-wam/examples/baseline_compat/hyperon-pln_metta/sumo/located/located-test.metta'")
P;HTML|
;                                           (= 1  "Doing: timeout --foreground --kill-after=5 --signal=SIGINT 121 time metta /opt/logicmoo_opencog/hyperon-wam/examples/baseline_compat/hyperon-pln_metta/sumo/located/located-test.metta")
P;HTML|
;                                           (= 1  "+ eval 'timeout --foreground --kill-after=5 --signal=SIGINT 121 time metta /opt/logicmoo_opencog/hyperon-wam/examples/baseline_compat/hyperon-pln_metta/sumo/located/located-test.metta'")
P;HTML|
;                                           (= 1  "++ timeout --foreground --kill-after=5 --signal=SIGINT 121 time metta /opt/logicmoo_opencog/hyperon-wam/examples/baseline_compat/hyperon-pln_metta/sumo/located/located-test.metta")
P;HTML|
;                                           (= 1  "[()]")
P;HTML|
;                                           (= 2  "[()]")
P;HTML|
;                                           (= 3  "[()]")
P;HTML|
;                                           (= 4  "[()]")
P;HTML|
;                                           (= 5  "[(), (), (), (), (), (), (), (), (), (), ()]")
P;HTML|
;                                           (= 6  "[(: (ModusPonens (WitnessOf (‚üπ (orientation John JohnsHouse Inside) (located John JohnsHouse))) (WitnessOf (orientation John JohnsHouse Inside))) (located John JohnsHouse)), (let* (((: $proof2#1231 (‚àß (located John $INST2#1312) (located $INST2#1312 JohnsHouse))) (synthesize (: $proof2#1231 (‚àß (located John $INST2#1312) (located $INST2#1312 JohnsHouse))) kb rb Z))) (: (ModusPonens (WitnessOf (‚üπ (‚àß (located John $INST2#1312) (located $INST2#1312 JohnsHouse)) (located John JohnsHouse))) $proof2#1231) (located John JohnsHouse)))]")
P;HTML|
;                                           (= 7  "[(let* (((: $proof2#3158 (orientation John SanJose Inside)) (synthesize (: $proof2#3158 (orientation John SanJose Inside)) kb rb (S (S Z))))) (: (ModusPonens (WitnessOf (‚üπ (orientation John SanJose Inside) (located John SanJose))) $proof2#3158) (located John SanJose))), (: (ModusPonens (WitnessOf (‚üπ (‚àß (located John JohnsHouse) (located JohnsHouse SanJose)) (located John SanJose))) (BinaryConjunctionIntroduction (ModusPonens (WitnessOf (‚üπ (orientation John JohnsHouse Inside) (located John JohnsHouse))) (WitnessOf (orientation John JohnsHouse Inside))) (WitnessOf (located JohnsHouse SanJose)))) (located John SanJose))]")
P;HTML|
;                                           (= 8  "1.19user 0.00system 0:01.19elapsed 100%CPU (0avgtext+0avgdata 32788maxresident)k")
P;HTML|
;                                           (= 8  "0inputs+0outputs (0major+5236minor)pagefaults 0swaps")
P;HTML|
;                                          (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/sumo/located/located-test.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/sumo/located/located-test.metta)

;;;; Test reasoning on located.kif.metta.
;;;; Import synthesizer
<span class="ansi38-013099040"
>  !(import! &self ../../synthesis/Synthesize.metta)

</span>[P;HTML|
;                                           (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/synthesis/Synthesize.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/synthesis/Synthesize.metta)
P;HTML|
;                                           (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/synthesis/Synthesize.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/synthesis/Synthesize.metta)

;;;; Import modules
<span class="ansi38-013099040"
>  !(import! &self ../common/Num.metta)

</span>P;HTML|
;                                           (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/Num.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/Num.metta)
P;HTML|
;                                           (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/Num.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/Num.metta)

;;;; Collection of functions operating on numbers
;;;; Define max
<span class="ansi38-255165000"
>  (: max 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (max $x $y) 
    (if 
      (> $x $y) $x $y))
</span>;;;; Define min
<span class="ansi38-255165000"
>  (: min 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (min $x $y) 
    (if 
      (< $x $y) $x $y))
</span>;;;; Clamp a number to be within a certain range
<span class="ansi38-255165000"
>  (: clamp 
    (-> $a $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (clamp $x $l $u) 
    (max $l 
      (min $u $x)))
</span>;;;; Define abs
<span class="ansi38-255165000"
>  (: abs 
    (-> $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (abs $x) 
    (if 
      (< $x 0) 
      (* -1 $x) $x))
</span>;;;; Define <=
<span class="ansi38-255165000"
>  (: <= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (<= $x $y) 
    (or 
      (< $x $y) 
      (== $x $y)))
</span>;;;; Define >=
<span class="ansi38-255165000"
>  (: >= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (>= $x $y) 
    (or 
      (> $x $y) 
      (== $x $y)))
</span>;;;; Define approximately equal
<span class="ansi38-255165000"
>  (: approxEq 
    (-> $a $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (approxEq $x $y $epsilon) 
    (<= 
      (abs (- $x $y)) $epsilon))
</span>;;;; Define Nat
<span class="ansi38-255165000"
>  (: Nat Type)
</span><span class="ansi38-255165000"
>  (: Z Nat)
</span><span class="ansi38-255165000"
>  (: S 
    (-> Nat Nat))
</span>;;;; Define cast functions between Nat and Number
<span class="ansi38-255165000"
>  (: fromNumber 
    (-> Number Nat))
</span><span class="ansi38-255165000"
>  (= 
    (fromNumber $n) 
    (if 
      (<= $n 0) Z 
      (S (fromNumber (- $n 1)))))
</span><span class="ansi38-255165000"
>  (: fromNat 
    (-> Nat Number))
</span><span class="ansi38-255165000"
>  (= 
    (fromNat Z) 0)
</span><span class="ansi38-255165000"
>  (= 
    (fromNat (S $k)) 
    (+ 1 
      (fromNat $k)))
</span>;;;; Define a generic less than operator, ‚©ª, for Nat.  < cannot be used
;;;; because it is a built-in, its type is hardwired and cannot be
;;;; overloaded.
<span class="ansi38-255165000"
>  (: ‚©ª 
    (-> Nat Nat Bool))
</span><span class="ansi38-255165000"
>  (= 
    (‚©ª $ Z) False)
</span><span class="ansi38-255165000"
>  (= 
    (‚©ª Z 
      (S $)) True)
</span><span class="ansi38-255165000"
>  (= 
    (‚©ª 
      (S $x) 
      (S $y)) 
    (‚©ª $x $y))
</span>;;;; Overload ‚©ª for Number.
<span class="ansi38-255165000"
>  (: ‚©ª 
    (-> Number Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (‚©ª $x $y) 
    (< $x $y))
</span>;;;; Return the ceiling of a non negative number.  If the number is
;;;; negative it returns 1.
<span class="ansi38-255165000"
>  (: ceil 
    (-> Number Number))
</span><span class="ansi38-255165000"
>  (= 
    (ceil $n) 
    (fromNat (fromNumber $n)))
</span>;;;; Convert Number to Bool.  Anything above 0 converts to True.
<span class="ansi38-255165000"
>  (: number->bool 
    (-> Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (number->bool $x) 
    (< 0 $x))
</span>;;;; Convert Bool to Number.  False converts to 0, True converts to 1.
<span class="ansi38-255165000"
>  (: bool->number 
    (-> Bool Number))
</span><span class="ansi38-255165000"
>  (= 
    (bool->number False) 0)
</span><span class="ansi38-255165000"
>  (= 
    (bool->number True) 1)
</span>;;;; Define a less than type.  Note that it is purposefully different
;;;; than ‚©ª as it is a type, not an operator.  Inhabitants of (‚çÉ x y)
;;;; are proofs that x ‚©ª y == True.  For now ‚çÉ is only axiomatized for
;;;; Nat.
<span class="ansi38-255165000"
>  (: ‚çÉ 
    (-> $t $t Type))
</span>;;;; Zero is always less than the successor of something
<span class="ansi38-255165000"
>  (: 
    (zero-lt-succ-axiom) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (zero-lt-succ-axiom) 
    (: ZeroLTSucc 
      (‚çÉ Z 
        (S $k))))
</span>;;;; If x ‚çÉ y then (S x) ‚çÉ (S y)
<span class="ansi38-255165000"
>  (: 
    (succ-monotonicity-rule) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (succ-monotonicity-rule) 
    (: SuccMonotonicity 
      (-> 
        (‚çÉ $x $y) 
        (‚çÉ 
          (S $x) 
          (S $y)))))
</span>
Deterministic: ()
;;;; !(import! &self Unify.metta)
;;;; Enumerate all programs up to a given depth that are consistent with
;;;; the query, using the given axiom non-deterministic functions and rules.
;;;;
;;;; The arguments are:
;;;;
;;;; $query: an Atom under the form (: TERM TYPE).  The atom may contain
;;;;         free variables within TERM and TYPE to form various sort of
;;;;         queries, such as:
;;;;         1. Backward chaining: (: $term (Inheritance $x Mammal))
;;;;         2. Forward chaining: (: ($rule $premise AXIOM) $type)
;;;;         3. Mixed chaining: (: ($rule $premise AXIOM) (Inheritance $x Mammal))
;;;;         4. Type checking: (: TERM TYPE)
;;;;         5. Type inference: (: TERM $type)
;;;;
;;;; $kb: a nullary function to axiom, to non-deterministically pick up
;;;;      an axiom.  An axiom is an Atom of the form (: TERM TYPE).
;;;;
;;;; $rb: a nullary function to rule, to non-deterministically pick up a
;;;;      rule.  A rule is a function mapping premises to conclusion,
;;;;      where premises and conclusion have the form (: TERM TYPE).
;;;;
;;;; $depth: a Nat representing the maximum depth of the generated
;;;;         programs.
;;;;
;;;; TODO: recurse over curried rules instead of duplicating code over
;;;; tuples.
<span class="ansi38-255165000"
>  (: synthesize 
    (-> $a 
      (-> $kt) 
      (-> $rt) Nat $a))
</span>;;;; Nullary rule (axiom)
<span class="ansi38-255165000"
>  (= 
    (synthesize $query $kb $rb $depth) 
    (let $query 
      ($kb) $query))
</span>;;;; Unary rule
<span class="ansi38-255165000"
>  (= 
    (synthesize $query $kb $rb 
      (S $k)) 
    (let* 
      ( ( (: $ructor 
            (-> $premise $conclusion)) ($rb)) 
        ( (: 
            ($ructor $proof) $conclusion) $query) 
        ( (: $proof $premise) (synthesize (: $proof $premise) $kb $rb $k))) $query))
</span>;;;; Binary rule
<span class="ansi38-255165000"
>  (= 
    (synthesize $query $kb $rb 
      (S $k)) 
    (let* 
      ( ( (: $ructor 
            (-> $premise1 $premise2 $conclusion)) ($rb)) 
        ( (: 
            ($ructor $proof1 $proof2) $conclusion) $query) 
        ( (: $proof1 $premise1) (synthesize (: $proof1 $premise1) $kb $rb $k)) 
        ( (: $proof2 $premise2) (synthesize (: $proof2 $premise2) $kb $rb $k))) $query))
</span>;;;; Trinary rule
<span class="ansi38-255165000"
>  (= 
    (synthesize $query $kb $rb 
      (S $k)) 
    (let* 
      ( ( (: $ructor 
            (-> $premise1 $premise2 $premise3 $conclusion)) ($rb)) 
        ( (: 
            ($ructor $proof1 $proof2 $proof3) $conclusion) $query) 
        ( (: $proof1 $premise1) (synthesize (: $proof1 $premise1) $kb $rb $k)) 
        ( (: $proof2 $premise2) (synthesize (: $proof2 $premise2) $kb $rb $k)) 
        ( (: $proof3 $premise3) (synthesize (: $proof3 $premise3) $kb $rb $k))) $query))
</span>;;;; Quaternary rule
<span class="ansi38-255165000"
>  (= 
    (synthesize $query $kb $rb 
      (S $k)) 
    (let* 
      ( ( (: $ructor 
            (-> $premise1 $premise2 $premise3 $premise4 $conclusion)) ($rb)) 
        ( (: 
            ($ructor $proof1 $proof2 $proof3 $proof4) $conclusion) $query) 
        ( (: $proof1 $premise1) (synthesize (: $proof1 $premise1) $kb $rb $k)) 
        ( (: $proof2 $premise2) (synthesize (: $proof2 $premise2) $kb $rb $k)) 
        ( (: $proof3 $premise3) (synthesize (: $proof3 $premise3) $kb $rb $k)) 
        ( (: $proof4 $premise4) (synthesize (: $proof4 $premise4) $kb $rb $k))) $query))
</span>;;;; Quintenary rule
<span class="ansi38-255165000"
>  (= 
    (synthesize $query $kb $rb 
      (S $k)) 
    (let* 
      ( ( (: $ructor 
            (-> $premise1 $premise2 $premise3 $premise4 $premise5 $conclusion)) ($rb)) 
        ( (: 
            ($ructor $proof1 $proof2 $proof3 $proof4 $proof5) $conclusion) $query) 
        ( (: $proof1 $premise1) (synthesize (: $proof1 $premise1) $kb $rb $k)) 
        ( (: $proof2 $premise2) (synthesize (: $proof2 $premise2) $kb $rb $k)) 
        ( (: $proof3 $premise3) (synthesize (: $proof3 $premise3) $kb $rb $k)) 
        ( (: $proof4 $premise4) (synthesize (: $proof4 $premise4) $kb $rb $k)) 
        ( (: $proof5 $premise5) (synthesize (: $proof5 $premise5) $kb $rb $k))) $query))
</span>
Last Result(2): ()
()]
;;;; Import knowledge base
<span class="ansi38-013099040"
>  !(import! &kb located.kif.metta)

</span>[P;HTML|
;                                           (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/sumo/located/located.kif.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/sumo/located/located.kif.metta)
P;HTML|
;                                           (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/sumo/located/located.kif.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/sumo/located/located.kif.metta)

;;;; Auto-generated by suo-kif-to-metta.sh
;;;; Self-contained SUO-KIF file extracted from
;;;;
;;;; https://github.com/ontologyportal/sumo/blob/master/Merge.kif
;;;;
;;;; containing knowledge about `located` and related symbols.
<span class="ansi38-255165000"
>  (subclass TransitiveRelation BinaryRelation)
</span><span class="ansi38-255165000"
>  (disjoint TransitiveRelation IntransitiveRelation)
</span><span class="ansi38-255165000"
>  (documentation TransitiveRelation EnglishLanguage "A &%BinaryRelation $REL is transitive\nif ($REL $INST1 $INST2) and ($REL $INST2 $INST3) imply ($REL $INST1 $INST3),\nfor all $INST1, $INST2, and $INST3.")
</span>;;;; TODO: re-enable when ($REL $INST1 $INST2) does not lead to an
;;;; infinite recursion.
;;;;
;;;; (‚üπ
;;;;    (instance $REL TransitiveRelation)
;;;;    (‚àÄ ($INST1 $INST2 $INST3)
;;;;       (‚üπ
;;;;          (‚àß
;;;;             ($REL $INST1 $INST2)
;;;;             ($REL $INST2 $INST3))
;;;;          ($REL $INST1 $INST3))))
;;;; In the meantime we manually instantiate the relation located.  We
;;;; remove the ‚àÄ in the process to avoid ($INST1 $INST2 $INST3) which
;;;; also leads to an infinite recursion, and is not actually mandatory
;;;; anymore.
<span class="ansi38-255165000"
>  (‚üπ 
    (‚àß 
      (located $INST1 $INST2) 
      (located $INST2 $INST3)) 
    (located $INST1 $INST3))
</span><span class="ansi38-255165000"
>  (instance located TransitiveRelation)
</span><span class="ansi38-255165000"
>  (‚üπ 
    (orientation $OBJ1 $OBJ2 Inside) 
    (located $OBJ1 $OBJ2))
</span>;;;; Add instances of `located`, extracted from
;;;;
;;;; https://github.com/ontologyportal/sumo/blob/master/tests/SP03.kif.tq
;;;;
;;;; to test it.
<span class="ansi38-255165000"
>  (instance JohnsHouse Building)
</span><span class="ansi38-255165000"
>  (instance John Human)
</span><span class="ansi38-255165000"
>  (instance SanJose City)
</span><span class="ansi38-255165000"
>  (orientation John JohnsHouse Inside)
</span><span class="ansi38-255165000"
>  (located JohnsHouse SanJose)
</span>;;;; An example of query would be

Deterministic: ()
()]
;;;; Import rule base
<span class="ansi38-013099040"
>  !(import! &rb ../rule-base.metta)

</span>[P;HTML|
;                                           (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/sumo/rule-base.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/sumo/rule-base.metta)
P;HTML|
;                                           (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/sumo/rule-base.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/sumo/rule-base.metta)

;;;;
;;;; (located John SanJose)
;;;; Inference rules to operate on SUMO
;;;; Binary Conjunction Introduction
;;;; Premises
;;;; Conclusion
<span class="ansi38-255165000"
>  (: BinaryConjunctionIntroduction 
    (-> $x $y 
      (‚àß $x $y)))
</span>;;;; Trinary Conjunction Introduction
;;;; Premises
;;;; Conclusion
<span class="ansi38-255165000"
>  (: TrinaryConjunctionIntroduction 
    (-> $x $y $z 
      (‚àß $x $y $z)))
</span>;;;; Quaternary Conjunction Introduction
;;;; Premises
;;;; Conclusion
<span class="ansi38-255165000"
>  (: QuaternaryConjunctionIntroduction 
    (-> $x $y $z $w 
      (‚àß $x $y $z $w)))
</span>;;;; Modus Ponens
;;;; Premises
;;;; Conclusion
<span class="ansi38-255165000"
>  (: ModusPonens 
    (-> 
      (‚üπ $x $y) $x $y))
</span>
Deterministic: ()
()]
;;;; Label each statement in the knowledge base as a witness of a type,
;;;; because that is what the synthesizer expects.  For now each witness
;;;; is defined by using the `WitnessOf` construct.  So for instance the
;;;; statement
;;;;
;;;; (instance A Object)
;;;;
;;;; has the corresponding witness
;;;;
;;;; (WitnessOf (instance A Object))
;;;;
;;;; Then add the labelled statement in the labelled-kb space.
<span class="ansi38-013099040"
>  !(bind! &labelled-kb 
    (new-space))

</span>

Deterministic: ()
[()]
<span class="ansi38-255165009"
>;; In file as:  
</span><span class="ansi1 ansi38-255238088"
>  !(match &kb $x 
    (add-atom &labelled-kb 
      (: 
        (WitnessOf $x) $x)))
</span>;; To unit test case:
<span class="ansi38-013099040"
>  !(assertEqualToResult 
    (match &kb $x 
      (add-atom &labelled-kb 
        (: 
          (WitnessOf $x) $x))) 
    (() () () () () () () () () () ()))

</span>[

;<h3 id="LOCATED.LOCATED-TEST.01"
>;; LOCATED.LOCATED-TEST.01</h3>
<span class="ansi38-255165000"
>  (: 
    (WitnessOf (subclass TransitiveRelation BinaryRelation)) 
    (subclass TransitiveRelation BinaryRelation))
</span><span class="ansi38-255165000"
>  (: 
    (WitnessOf (disjoint TransitiveRelation IntransitiveRelation)) 
    (disjoint TransitiveRelation IntransitiveRelation))
</span><span class="ansi38-255165000"
>  (: 
    (WitnessOf (documentation TransitiveRelation EnglishLanguage "A &%BinaryRelation $REL is transitive\nif ($REL $INST1 $INST2) and ($REL $INST2 $INST3) imply ($REL $INST1 $INST3),\nfor all $INST1, $INST2, and $INST3.")) 
    (documentation TransitiveRelation EnglishLanguage "A &%BinaryRelation $REL is transitive\nif ($REL $INST1 $INST2) and ($REL $INST2 $INST3) imply ($REL $INST1 $INST3),\nfor all $INST1, $INST2, and $INST3."))
</span><span class="ansi38-255165000"
>  (: 
    (WitnessOf (‚üπ (‚àß (located $_155006 $_155012) (located $_155012 $_155036)) (located $_155006 $_155036))) 
    (‚üπ 
      (‚àß 
        (located $_155006 $_155012) 
        (located $_155012 $_155036)) 
      (located $_155006 $_155036)))
</span><span class="ansi38-255165000"
>  (: 
    (WitnessOf (instance located TransitiveRelation)) 
    (instance located TransitiveRelation))
</span><span class="ansi38-255165000"
>  (: 
    (WitnessOf (‚üπ (orientation $_168824 $_168830 Inside) (located $_168824 $_168830))) 
    (‚üπ 
      (orientation $_168824 $_168830 Inside) 
      (located $_168824 $_168830)))
</span><span class="ansi38-255165000"
>  (: 
    (WitnessOf (instance JohnsHouse Building)) 
    (instance JohnsHouse Building))
</span><span class="ansi38-255165000"
>  (: 
    (WitnessOf (instance John Human)) 
    (instance John Human))
</span><span class="ansi38-255165000"
>  (: 
    (WitnessOf (instance SanJose City)) 
    (instance SanJose City))
</span><span class="ansi38-255165000"
>  (: 
    (WitnessOf (orientation John JohnsHouse Inside)) 
    (orientation John JohnsHouse Inside))
</span><span class="ansi38-255165000"
>  (: 
    (WitnessOf (located JohnsHouse SanJose)) 
    (located JohnsHouse SanJose))
</span>; 
; EVAL TEST
; took 0.035 secs. (34.58 milliseconds) 

  !(assertEqualToResult 
    (match &kb $x 
      (add-atom &labelled-kb 
        (: 
          (WitnessOf $x) $x))) 
    (() () () () () () () () () () ()))

<span class="ansi36"
>  (loonit_success  
    (equal_enough_for_test  
      (() () () () () () () () () () ()) 
      (() () () () () () () () () () ())))
</span>
Deterministic: ()
()]
;;;; Define knowledge base (called kb but different than &kb)
<span class="ansi38-255165000"
>  (: kb 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (kb) 
    (match &labelled-kb $x $x))
</span>;;;; Define rule base (called rb but different than &rb)
<span class="ansi38-255165000"
>  (: rb 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (rb) 
    (match &rb $x $x))
</span>;;;; Call synthesizer on query (located John JohnsHouse)
;;;;
;;;; It should generate the following proof
;;;;
;;;; -----------------------------------------------------------  ------------------------------------
;;;; (‚üπ (orientation $OBJ1 $OBJ2 Inside) (located $OBJ1 $OBJ2))  (orientation John JohnsHouse Inside)
;;;; -------------------------------------------------------------------------------------------------(ModusPonens)
;;;;                                          (located John JohnsHouse)
<span class="ansi38-255165009"
>;; In file as:  
</span><span class="ansi1 ansi38-255238088"
>  !(synthesize 
    (: $proof 
      (located John JohnsHouse)) kb rb 
    (S Z))
</span>;; To unit test case:
<span class="ansi38-013099040"
>  !(assertEqualToResult 
    (synthesize 
      (: $proof 
        (located John JohnsHouse)) kb rb 
      (S Z)) 
    ( (: 
        (ModusPonens 
          (WitnessOf (‚üπ (orientation John JohnsHouse Inside) (located John JohnsHouse))) 
          (WitnessOf (orientation John JohnsHouse Inside))) 
        (located John JohnsHouse)) (let* (((: $proof2#1231 (‚àß (located John $INST2#1312) (located $INST2#1312 JohnsHouse))) (synthesize (: $proof2#1231 (‚àß (located John $INST2#1312) (located $INST2#1312 JohnsHouse))) kb rb Z))) (: (ModusPonens (WitnessOf (‚üπ (‚àß (located John $INST2#1312) (located $INST2#1312 JohnsHouse)) (located John JohnsHouse))) $proof2#1231) (located John JohnsHouse)))))

</span>[

;<h3 id="LOCATED.LOCATED-TEST.02"
>;; LOCATED.LOCATED-TEST.02</h3>
; 
; EVAL TEST
; took 0.047 secs. (47.37 milliseconds) 

  !(assertEqualToResult 
    (synthesize 
      (: $proof 
        (located John JohnsHouse)) kb rb 
      (S Z)) 
    ( (: 
        (ModusPonens 
          (WitnessOf (‚üπ (orientation John JohnsHouse Inside) (located John JohnsHouse))) 
          (WitnessOf (orientation John JohnsHouse Inside))) 
        (located John JohnsHouse)) (let* (((: $proof2#1231 (‚àß (located John $INST2#1312) (located $INST2#1312 JohnsHouse))) (synthesize (: $proof2#1231 (‚àß (located John $INST2#1312) (located $INST2#1312 JohnsHouse))) kb rb Z))) (: (ModusPonens (WitnessOf (‚üπ (‚àß (located John $INST2#1312) (located $INST2#1312 JohnsHouse)) (located John JohnsHouse))) $proof2#1231) (located John JohnsHouse)))))

<span class="ansi31"
>  (loonit_failureR  
    (equal_enough_for_test  
      ( (: 
          (ModusPonens 
            (WitnessOf (‚üπ (orientation John JohnsHouse Inside) (located John JohnsHouse))) 
            (WitnessOf (orientation John JohnsHouse Inside))) 
          (located John JohnsHouse))) 
      ( (: 
          (ModusPonens 
            (WitnessOf (‚üπ (orientation John JohnsHouse Inside) (located John JohnsHouse))) 
            (WitnessOf (orientation John JohnsHouse Inside))) 
          (located John JohnsHouse)) (let (: $_5618 (‚àß (located John $_5666) (located $_5666 JohnsHouse))) (synthesize (: $_5618 (‚àß (located John $_5666) (located $_5666 JohnsHouse))) kb rb Z) (: (ModusPonens (WitnessOf (‚üπ (‚àß (located John $_5666) (located $_5666 JohnsHouse)) (located John JohnsHouse))) $_5618) (located John JohnsHouse))))))
</span>
Deterministic: ((Error  (got  ((: (ModusPonens (WitnessOf (‚üπ (orientation John JohnsHouse Inside) (located John JohnsHouse))) (WitnessOf (orientation John JohnsHouse Inside))) (located John JohnsHouse)))) (expected  ((: (ModusPonens (WitnessOf (‚üπ (orientation John JohnsHouse Inside) (located John JohnsHouse))) (WitnessOf (orientation John JohnsHouse Inside))) (located John JohnsHouse)) (let (: $proof2#1231 (‚àß (located John $INST2#1312) (located $INST2#1312 JohnsHouse))) (synthesize (: $proof2#1231 (‚àß (located John $INST2#1312) (located $INST2#1312 JohnsHouse))) kb rb Z) (: (ModusPonens (WitnessOf (‚üπ (‚àß (located John $INST2#1312) (located $INST2#1312 JohnsHouse)) (located John JohnsHouse))) $proof2#1231) (located John JohnsHouse)))))))
  ( (Error  
      (got  
        ( (: 
            (ModusPonens 
              (WitnessOf (‚üπ (orientation John JohnsHouse Inside) (located John JohnsHouse))) 
              (WitnessOf (orientation John JohnsHouse Inside))) 
            (located John JohnsHouse)))) 
      (expected  
        ( (: 
            (ModusPonens 
              (WitnessOf (‚üπ (orientation John JohnsHouse Inside) (located John JohnsHouse))) 
              (WitnessOf (orientation John JohnsHouse Inside))) 

            (located John JohnsHouse)) (let (: $_5618 (‚àß (located John $_5666) (located $_5666 JohnsHouse))) (synthesize (: $_5618 (‚àß (located John $_5666) (located $_5666 JohnsHouse))) kb rb Z) (: (ModusPonens (WitnessOf (‚üπ (‚àß (located John $_5666) (located $_5666 JohnsHouse)) (located John JohnsHouse))) $_5618) (located John JohnsHouse)))))))]
;;;; Call synthesizer on query (located John SanJose)
;;;;
;;;; It should generate the following proof
;;;;
;;;;                                                     -----------------------------------------------------------  ------------------------------------
;;;;                                                     (‚üπ (orientation $OBJ1 $OBJ2 Inside) (located $OBJ1 $OBJ2))  (orientation John JohnsHouse Inside)
;;;;                                                     -------------------------------------------------------------------------------------------------(ModusPonens)     ----------------------------
;;;;                                                                                         (located John JohnsHouse)                                                      (located JohnsHouse SanJose)
;;;; --------------------------------------------------------------------------------        ----------------------------------------------------------------------------------------------------------(ConjunctionIntroduction)
;;;; (‚üπ (‚àß (located $INST1 $INST2) (located $INST2 $INST3)) (located $INST1 $INST3))                                       (‚àß (located John JohnsHouse) (located JohnsHouse SanJose))
;;;; ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------(ModusPonens)
;;;;                                                                                 (located John SanJose)
<span class="ansi38-255165009"
>;; In file as:  
</span><span class="ansi1 ansi38-255238088"
>  !(synthesize 
    (: $proof 
      (located John SanJose)) kb rb 
    (fromNumber 3))
</span>;; To unit test case:
<span class="ansi38-013099040"
>  !(assertEqualToResult 
    (synthesize 
      (: $proof 
        (located John SanJose)) kb rb 
      (fromNumber 3)) 
    ( (let* 
        ( ( (: $proof2#3158 
              (orientation John SanJose Inside)) (synthesize (: $proof2#3158 (orientation John SanJose Inside)) kb rb (S (S Z))))) 
        (: 
          (ModusPonens 
            (WitnessOf (‚üπ (orientation John SanJose Inside) (located John SanJose))) $proof2#3158) 
          (located John SanJose))) (: (ModusPonens (WitnessOf (‚üπ (‚àß (located John JohnsHouse) (located JohnsHouse SanJose)) (located John SanJose))) (BinaryConjunctionIntroduction (ModusPonens (WitnessOf (‚üπ (orientation John JohnsHouse Inside) (located John JohnsHouse))) (WitnessOf (orientation John JohnsHouse Inside))) (WitnessOf (located JohnsHouse SanJose)))) (located John SanJose))))

</span>[

;<h3 id="LOCATED.LOCATED-TEST.03"
>;; LOCATED.LOCATED-TEST.03</h3>
; 
; EVAL TEST
; took 0.228 secs. (228.20 milliseconds) 

  !(assertEqualToResult 
    (synthesize 
      (: $proof 
        (located John SanJose)) kb rb 
      (fromNumber 3)) 
    ( (let* 
        ( ( (: $proof2#3158 
              (orientation John SanJose Inside)) (synthesize (: $proof2#3158 (orientation John SanJose Inside)) kb rb (S (S Z))))) 
        (: 
          (ModusPonens 
            (WitnessOf (‚üπ (orientation John SanJose Inside) (located John SanJose))) $proof2#3158) 
          (located John SanJose))) (: (ModusPonens (WitnessOf (‚üπ (‚àß (located John JohnsHouse) (located JohnsHouse SanJose)) (located John SanJose))) (BinaryConjunctionIntroduction (ModusPonens (WitnessOf (‚üπ (orientation John JohnsHouse Inside) (located John JohnsHouse))) (WitnessOf (orientation John JohnsHouse Inside))) (WitnessOf (located JohnsHouse SanJose)))) (located John SanJose))))

<span class="ansi36"
>  (loonit_success  
    (equal_enough_for_test  
      ( (: 
          (ModusPonens 
            (WitnessOf (‚üπ (‚àß (located John JohnsHouse) (located JohnsHouse SanJose)) (located John SanJose))) 
            (BinaryConjunctionIntroduction 
              (ModusPonens 
                (WitnessOf (‚üπ (orientation John JohnsHouse Inside) (located John JohnsHouse))) 
                (WitnessOf (orientation John JohnsHouse Inside))) 
              (WitnessOf (located JohnsHouse SanJose)))) 
          (located John SanJose))) 
      ( (let* 
          ( ( (: $_5606 
                (orientation John SanJose Inside)) (synthesize (: $_5606 (orientation John SanJose Inside)) kb rb (S (S Z))))) 
          (: 
            (ModusPonens 
              (WitnessOf (‚üπ (orientation John SanJose Inside) (located John SanJose))) $_5606) 
            (located John SanJose))) (: (ModusPonens (WitnessOf (‚üπ (‚àß (located John JohnsHouse) (located JohnsHouse SanJose)) (located John SanJose))) (BinaryConjunctionIntroduction (ModusPonens (WitnessOf (‚üπ (orientation John JohnsHouse Inside) (located John JohnsHouse))) (WitnessOf (orientation John JohnsHouse Inside))) (WitnessOf (located JohnsHouse SanJose)))) (located John SanJose)))))
</span>
Deterministic: ()
()]
<span class="ansi32"
>% 2,862,268 inferences, 0.584 CPU in 0.584 seconds (100% CPU, 4904736 Lips)
</span>P;HTML|
;                         (= /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/sumo/located/located-test.metta  0)
<span class="ansi1"
>LoonIt Report
</span>------------
<span class="ansi32"
>Successes: 2
</span><span class="ansi31"
>Failures: 1
</span><br/> <a href="#" onclick="window.history.back(); return false;"
>Return to summaries</a><br/>
P;HTML|
;           (is_cmd_option  execute halt --halt=true true)
P;HTML|
;            (set_option_value  halt true)
P;HTML|
;            (is_cmd_option  execute stdin --stdin=tty tty)
P;HTML|
;            (set_option_value  stdin tty)
P;HTML|
;            (is_cmd_option  execute stdout --stdout=tty tty)
P;HTML|
;             (set_option_value  stdout tty)
P;HTML|
;            (is_cmd_option  execute stderr --stderr=tty tty)
P;HTML|
;             (set_option_value  stderr tty)
P;HTML|
;           (set_option_value  prolog false)
P;HTML|
;           (set_option_value  compat auto)
P;HTML|
;           (set_option_value  compatio true)

Script done on 2024-09-21 01:21:17+00:00 [COMMAND_EXIT_CODE="7"]

</pre>
</body>

</html>
\033[0;32mCompleted successfully (EXITCODE=7) Under 40 seconds: ./mettalog '--output=./reports/tests_output/baseline-compat-2024-09-21T00:32:22/' --timeout=40 --html --repl=false  --test "tests/extended_compat/hyperon-pln/metta/sumo/located/located-test.metta" --halt=true\033[0m

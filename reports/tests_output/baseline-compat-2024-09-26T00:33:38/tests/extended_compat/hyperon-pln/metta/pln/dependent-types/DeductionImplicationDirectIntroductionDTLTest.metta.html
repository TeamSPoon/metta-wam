<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"
>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"
>
<title></title>
<style type="text/css"
>
.ansi2html-content { display: inline; white-space: pre-wrap; word-wrap: break-word; }
.body_foreground { color: #AAAAAA; }
.body_background { background-color: #000000; }
.inv_foreground { color: #000000; }
.inv_background { background-color: #AAAAAA; }
.ansi1 { font-weight: bold; }
.ansi31 { color: #aa0000; }
.ansi36 { color: #00aaaa; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165009 { color: #FFA509; }
.ansi38-255238088 { color: #FFEE58; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165009 { color: #FFA509; }
.ansi38-255238088 { color: #FFEE58; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165009 { color: #FFA509; }
.ansi38-255238088 { color: #FFEE58; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165009 { color: #FFA509; }
.ansi38-255238088 { color: #FFEE58; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165009 { color: #FFA509; }
.ansi38-255238088 { color: #FFEE58; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165009 { color: #FFA509; }
.ansi38-255238088 { color: #FFEE58; }
.ansi38-013099040 { color: #0D6328; }
</style>
</head>
<body class="body_foreground body_background" style="font-size: normal;" >
<pre class="ansi2html-content"
>
Script started on 2024-09-26 01:19:44+00:00 [TERM="xterm-256color" TTY="/dev/pts/0" COLUMNS="-1" LINES="-1"]
P;HTML|
;           (set_option_value  prolog false)

P;HTML|
;           (set_option_value  compat auto)

P;HTML|
;           (set_option_value  compatio true)
P;HTML|
;            (is_cmd_option  prescan halt --halt=true true)
P;HTML|
;            (set_option_value  halt true)
P;HTML|
;            (is_cmd_option  prescan stdin --stdin=tty tty)
P;HTML|
;             (set_option_value  stdin tty)
P;HTML|
;            (is_cmd_option  prescan stdout --stdout=tty tty)
P;HTML|
;             (set_option_value  stdout tty)
P;HTML|
;            (is_cmd_option  prescan stderr --stderr=tty tty)
P;HTML|
;             (set_option_value  stderr tty)
P;HTML|
;            (set_option_value  prolog false)
P;HTML|
;            (set_option_value  compat auto)
P;HTML|
;            (set_option_value  compatio true)
P;HTML|
;          (is_cmd_option  execute python --python=enable enable)
P;HTML|
;           (set_option_value  python enable)
P;HTML|
;          (is_cmd_option  execute timeout --timeout=40 40)
P;HTML|
;           (set_option_value  timeout 40)
P;HTML|
;           (is_cmd_option  execute output --output=./reports/tests_output/baseline-compat-2024-09-26T00:33:38/ ./reports/tests_output/baseline-compat-2024-09-26T00:33:38/)
P;HTML|
;           (set_option_value  output ./reports/tests_output/baseline-compat-2024-09-26T00:33:38/)
P;HTML|
;           (is_cmd_option  execute html --html true)
P;HTML|
;            (set_option_value  html true)
P;HTML|
;           (is_cmd_option  execute test --test true)
P;HTML|
;            (set_option_value  test true)

; (load_metta_file  &self tests/extended_compat/hyperon-pln/metta/pln/dependent-types/DeductionImplicationDirectIntroductionDTLTest.metta)
P;HTML|
;                         (track_load_into_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/pln/dependent-types/DeductionImplicationDirectIntroductionDTLTest.metta)
P;HTML|
;                                          (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/pln/dependent-types/DeductionImplicationDirectIntroductionDTLTest.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/pln/dependent-types/DeductionImplicationDirectIntroductionDTLTest.metta)
P;HTML|
;                                           (= 1  "Doing: timeout --foreground --kill-after=5 --signal=SIGINT 61 time metta /opt/logicmoo_workspace/packs_sys/logicmoo_opencog/MeTTa/hyperon-wam/reports/extended_compat/hyperon-pln/metta/pln/dependent-types/DeductionImplicationDirectIntroductionDTLTest.metta")
P;HTML|
;                                           (= 1  "[()]")
P;HTML|
;                                           (= 2  "[()]")
P;HTML|
;                                           (= 3  "[()]")
P;HTML|
;                                           (= 4  "[deduction_idi_prf]")
P;HTML|
;                                           (= 5  "[(≞ (→ P Q) $tv#1072)]")
P;HTML|
;                                           (= 6  "[\"===== Prove that P→Q based on one piece of evidence =====\"]")
P;HTML|
;                                           (= 7  "[(let* (((: $proof2#6435 (⊷ Q (S (S Z)) True)) (synthesize (: $proof2#6435 (⊷ Q (S (S Z)) True)) kb rb Z)) ((: $proof3#6436 (≞ (→ P Q) (ETV (:: $h#6441 $t#6442) (STV $s#6443 $y#6444)))) (synthesize (: $proof3#6436 (≞ (→ P Q) (ETV (:: $h#6441 $t#6442) (STV $s#6443 $y#6444)))) kb rb Z)) ((: $proof4#6437 (⍃ $h#6441 (S (S Z)))) (synthesize (: $proof4#6437 (⍃ $h#6441 (S (S Z)))) kb rb Z))) (: (IDIRecursive P2 $proof2#6435 $proof3#6436 $proof4#6437) (≞ (→ P Q) (ETV (:: (S (S Z)) (:: $h#6441 $t#6442)) (STV (/ (+ (* $s#6443 (if (<= (if (< (- 1.0 $y#6444) 0) (* -1 (- 1.0 $y#6444)) (- 1.0 $y#6444)) 1e-09) (max-count) (/ (* $y#6444 (lookahead)) (- 1.0 $y#6444)))) 1) (+ (if (<= (if (< (- 1.0 $y#6444) 0) (* -1 (- 1.0 $y#6444)) (- 1.0 $y#6444)) 1e-09) (max-count) (/ (* $y#6444 (lookahead)) (- 1.0 $y#6444))) 1)) (/ (+ (if (<= (if (< (- 1.0 $y#6444) 0) (* -1 (- 1.0 $y#6444)) (- 1.0 $y#6444)) 1e-09) (max-count) (/ (* $y#6444 (lookahead)) (- 1.0 $y#6444))) 1) (+ (+ (if (<= (if (< (- 1.0 $y#6444) 0) (* -1 (- 1.0 $y#6444)) (- 1.0 $y#6444)) 1e-09) (max-count) (/ (* $y#6444 (lookahead)) (- 1.0 $y#6444))) 1) 1.0))))))), (let* (((: $proof3#6436 (≞ (→ P Q) (ETV (:: $h#6441 $t#6442) (STV $s#6443 $y#6444)))) (synthesize (: $proof3#6436 (≞ (→ P Q) (ETV (:: $h#6441 $t#6442) (STV $s#6443 $y#6444)))) kb rb Z)) ((: $proof4#6437 (⍃ $h#6441 (S (S (S (S (S (S (S Z))))))))) (synthesize (: $proof4#6437 (⍃ $h#6441 (S (S (S (S (S (S (S Z))))))))) kb rb Z))) (: (IDIRecursive P7 Q7 $proof3#6436 $proof4#6437) (≞ (→ P Q) (ETV (:: (S (S (S (S (S (S (S Z))))))) (:: $h#6441 $t#6442)) (STV (/ (+ (* $s#6443 (if (<= (if (< (- 1.0 $y#6444) 0) (* -1 (- 1.0 $y#6444)) (- 1.0 $y#6444)) 1e-09) (max-count) (/ (* $y#6444 (lookahead)) (- 1.0 $y#6444)))) 1) (+ (if (<= (if (< (- 1.0 $y#6444) 0) (* -1 (- 1.0 $y#6444)) (- 1.0 $y#6444)) 1e-09) (max-count) (/ (* $y#6444 (lookahead)) (- 1.0 $y#6444))) 1)) (/ (+ (if (<= (if (< (- 1.0 $y#6444) 0) (* -1 (- 1.0 $y#6444)) (- 1.0 $y#6444)) 1e-09) (max-count) (/ (* $y#6444 (lookahead)) (- 1.0 $y#6444))) 1) (+ (+ (if (<= (if (< (- 1.0 $y#6444) 0) (* -1 (- 1.0 $y#6444)) (- 1.0 $y#6444)) 1e-09) (max-count) (/ (* $y#6444 (lookahead)) (- 1.0 $y#6444))) 1) 1.0))))))), (let* (((: $proof3#7166 (≞ (→ P Q) (ETV (:: $h#7171 $t#7172) (STV $s#7173 $PQc#7174)))) (synthesize (: $proof3#7166 (≞ (→ P Q) (ETV (:: $h#7171 $t#7172) (STV $s#7173 $PQc#7174)))) kb rb Z)) ((: $proof4#7167 (⍃ $h#7171 (S (S Z)))) (synthesize (: $proof4#7167 (⍃ $h#7171 (S (S Z)))) kb rb Z))) (: (IDIRecursive P2 Q2 $proof3#7166 $proof4#7167) (≞ (→ P Q) (ETV (:: (S (S Z)) (:: $h#7171 $t#7172)) (STV (/ (* $s#7173 (if (<= (if (< (- 1.0 $PQc#7174) 0) (* -1 (- 1.0 $PQc#7174)) (- 1.0 $PQc#7174)) 1e-09) (max-count) (/ (* $PQc#7174 (lookahead)) (- 1.0 $PQc#7174)))) (+ (if (<= (if (< (- 1.0 $PQc#7174) 0) (* -1 (- 1.0 $PQc#7174)) (- 1.0 $PQc#7174)) 1e-09) (max-count) (/ (* $PQc#7174 (lookahead)) (- 1.0 $PQc#7174))) 1)) (/ (+ (if (<= (if (< (- 1.0 $PQc#7174) 0) (* -1 (- 1.0 $PQc#7174)) (- 1.0 $PQc#7174)) 1e-09) (max-count) (/ (* $PQc#7174 (lookahead)) (- 1.0 $PQc#7174))) 1) (+ (+ (if (<= (if (< (- 1.0 $PQc#7174) 0) (* -1 (- 1.0 $PQc#7174)) (- 1.0 $PQc#7174)) 1e-09) (max-count) (/ (* $PQc#7174 (lookahead)) (- 1.0 $PQc#7174))) 1) 1.0))))))), (let* (((: $proof2#7165 (⊷ Q (S (S (S (S (S (S (S Z))))))) False)) (synthesize (: $proof2#7165 (⊷ Q (S (S (S (S (S (S (S Z))))))) False)) kb rb Z)) ((: $proof3#7166 (≞ (→ P Q) (ETV (:: $h#7171 $t#7172) (STV $s#7173 $PQc#7174)))) (synthesize (: $proof3#7166 (≞ (→ P Q) (ETV (:: $h#7171 $t#7172) (STV $s#7173 $PQc#7174)))) kb rb Z)) ((: $proof4#7167 (⍃ $h#7171 (S (S (S (S (S (S (S Z))))))))) (synthesize (: $proof4#7167 (⍃ $h#7171 (S (S (S (S (S (S (S Z))))))))) kb rb Z))) (: (IDIRecursive P7 $proof2#7165 $proof3#7166 $proof4#7167) (≞ (→ P Q) (ETV (:: (S (S (S (S (S (S (S Z))))))) (:: $h#7171 $t#7172)) (STV (/ (* $s#7173 (if (<= (if (< (- 1.0 $PQc#7174) 0) (* -1 (- 1.0 $PQc#7174)) (- 1.0 $PQc#7174)) 1e-09) (max-count) (/ (* $PQc#7174 (lookahead)) (- 1.0 $PQc#7174)))) (+ (if (<= (if (< (- 1.0 $PQc#7174) 0) (* -1 (- 1.0 $PQc#7174)) (- 1.0 $PQc#7174)) 1e-09) (max-count) (/ (* $PQc#7174 (lookahead)) (- 1.0 $PQc#7174))) 1)) (/ (+ (if (<= (if (< (- 1.0 $PQc#7174) 0) (* -1 (- 1.0 $PQc#7174)) (- 1.0 $PQc#7174)) 1e-09) (max-count) (/ (* $PQc#7174 (lookahead)) (- 1.0 $PQc#7174))) 1) (+ (+ (if (<= (if (< (- 1.0 $PQc#7174) 0) (* -1 (- 1.0 $PQc#7174)) (- 1.0 $PQc#7174)) 1e-09) (max-count) (/ (* $PQc#7174 (lookahead)) (- 1.0 $PQc#7174))) 1) 1.0))))))), (let* (((: $proof#7948 (≞ (→ P Q) (ETV $evidence#7858 $etv))) (synthesize (: $proof#7948 (≞ (→ P Q) (ETV $evidence#7858 $etv))) kb rb Z))) (: (EvidenceElimination $proof#7948) (≞ (→ P Q) $etv))), (let* (((: $proof4#8239 (≞ (→ P P) (STV $ABs#8245 $PQc#8251))) (synthesize (: $proof4#8239 (≞ (→ P P) (STV $ABs#8245 $PQc#8251))) kb rb Z)) ((: $proof5#8240 (≞ (→ P Q) (STV $QRs#8247 $QRc#8252))) (synthesize (: $proof5#8240 (≞ (→ P Q) (STV $QRs#8247 $QRc#8252))) kb rb Z))) (: (Deduction Pm Pm Qm $proof4#8239 $proof5#8240) (≞ (→ P Q) (if (and (and (< 0 0.2) (and (<= (if (> 0 (if (< 1 (/ (- (+ 0.2 0.2) 1) 0.2)) 1 (/ (- (+ 0.2 0.2) 1) 0.2))) 0 (if (< 1 (/ (- (+ 0.2 0.2) 1) 0.2)) 1 (/ (- (+ 0.2 0.2) 1) 0.2))) $ABs#8245) (<= $ABs#8245 (if (> 0 (if (< 1 (/ 0.2 0.2)) 1 (/ 0.2 0.2))) 0 (if (< 1 (/ 0.2 0.2)) 1 (/ 0.2 0.2)))))) (and (< 0 0.2) (and (<= (if (> 0 (if (< 1 (/ (- (+ 0.2 0.3) 1) 0.2)) 1 (/ (- (+ 0.2 0.3) 1) 0.2))) 0 (if (< 1 (/ (- (+ 0.2 0.3) 1) 0.2)) 1 (/ (- (+ 0.2 0.3) 1) 0.2))) $QRs#8247) (<= $QRs#8247 (if (> 0 (if (< 1 (/ 0.3 0.2)) 1 (/ 0.3 0.2))) 0 (if (< 1 (/ 0.3 0.2)) 1 (/ 0.3 0.2))))))) (STV (if (< 0.9999 0.2) 0.3 (+ (* $ABs#8245 $QRs#8247) (/ (* (- 1 $ABs#8245) (- 0.3 (* 0.2 $QRs#8247))) (- 1 0.2)))) (min 0.3 (min 0.3 (min 0.2 (min $PQc#8251 $QRc#8252))))) (STV 1 0))))), (let* (((: $proof4#8239 (≞ (→ P Q) (STV $ABs#8245 $PQc#8251))) (synthesize (: $proof4#8239 (≞ (→ P Q) (STV $ABs#8245 $PQc#8251))) kb rb Z)) ((: $proof5#8240 (≞ (→ Q Q) (STV $QRs#8247 $QRc#8252))) (synthesize (: $proof5#8240 (≞ (→ Q Q) (STV $QRs#8247 $QRc#8252))) kb rb Z))) (: (Deduction Pm Qm Qm $proof4#8239 $proof5#8240) (≞ (→ P Q) (if (and (and (< 0 0.2) (and (<= (if (> 0 (if (< 1 (/ (- (+ 0.2 0.3) 1) 0.2)) 1 (/ (- (+ 0.2 0.3) 1) 0.2))) 0 (if (< 1 (/ (- (+ 0.2 0.3) 1) 0.2)) 1 (/ (- (+ 0.2 0.3) 1) 0.2))) $ABs#8245) (<= $ABs#8245 (if (> 0 (if (< 1 (/ 0.3 0.2)) 1 (/ 0.3 0.2))) 0 (if (< 1 (/ 0.3 0.2)) 1 (/ 0.3 0.2)))))) (and (< 0 0.3) (and (<= (if (> 0 (if (< 1 (/ (- (+ 0.3 0.3) 1) 0.3)) 1 (/ (- (+ 0.3 0.3) 1) 0.3))) 0 (if (< 1 (/ (- (+ 0.3 0.3) 1) 0.3)) 1 (/ (- (+ 0.3 0.3) 1) 0.3))) $QRs#8247) (<= $QRs#8247 (if (> 0 (if (< 1 (/ 0.3 0.3)) 1 (/ 0.3 0.3))) 0 (if (< 1 (/ 0.3 0.3)) 1 (/ 0.3 0.3))))))) (STV (if (< 0.9999 0.3) 0.3 (+ (* $ABs#8245 $QRs#8247) (/ (* (- 1 $ABs#8245) (- 0.3 (* 0.3 $QRs#8247))) (- 1 0.3)))) (min 0.3 (min 0.2 (min 0.2 (min $PQc#8251 $QRc#8252))))) (STV 1 0))))), (let* (((: $proof4#8239 (≞ (→ P R) (STV $ABs#8245 $PQc#8251))) (synthesize (: $proof4#8239 (≞ (→ P R) (STV $ABs#8245 $PQc#8251))) kb rb Z)) ((: $proof5#8240 (≞ (→ R Q) (STV $QRs#8247 $QRc#8252))) (synthesize (: $proof5#8240 (≞ (→ R Q) (STV $QRs#8247 $QRc#8252))) kb rb Z))) (: (Deduction Pm Rm Qm $proof4#8239 $proof5#8240) (≞ (→ P Q) (if (and (and (< 0 0.2) (and (<= (if (> 0 (if (< 1 (/ (- (+ 0.2 0.4) 1) 0.2)) 1 (/ (- (+ 0.2 0.4) 1) 0.2))) 0 (if (< 1 (/ (- (+ 0.2 0.4) 1) 0.2)) 1 (/ (- (+ 0.2 0.4) 1) 0.2))) $ABs#8245) (<= $ABs#8245 (if (> 0 (if (< 1 (/ 0.4 0.2)) 1 (/ 0.4 0.2))) 0 (if (< 1 (/ 0.4 0.2)) 1 (/ 0.4 0.2)))))) (and (< 0 0.4) (and (<= (if (> 0 (if (< 1 (/ (- (+ 0.4 0.3) 1) 0.4)) 1 (/ (- (+ 0.4 0.3) 1) 0.4))) 0 (if (< 1 (/ (- (+ 0.4 0.3) 1) 0.4)) 1 (/ (- (+ 0.4 0.3) 1) 0.4))) $QRs#8247) (<= $QRs#8247 (if (> 0 (if (< 1 (/ 0.3 0.4)) 1 (/ 0.3 0.4))) 0 (if (< 1 (/ 0.3 0.4)) 1 (/ 0.3 0.4))))))) (STV (if (< 0.9999 0.4) 0.3 (+ (* $ABs#8245 $QRs#8247) (/ (* (- 1 $ABs#8245) (- 0.3 (* 0.4 $QRs#8247))) (- 1 0.4)))) (min 0.3 (min 0.1 (min 0.2 (min $PQc#8251 $QRc#8252))))) (STV 1 0))))), (let* (((: $proof4#8239 (≞ (→ P (→ Q R)) (STV $ABs#8245 $PQc#8251))) (synthesize (: $proof4#8239 (≞ (→ P (→ Q R)) (STV $ABs#8245 $PQc#8251))) kb rb Z)) ((: $proof5#8240 (≞ (→ (→ Q R) Q) (STV $QRs#8247 $QRc#8252))) (synthesize (: $proof5#8240 (≞ (→ (→ Q R) Q) (STV $QRs#8247 $QRc#8252))) kb rb Z))) (: (Deduction Pm QRm Qm $proof4#8239 $proof5#8240) (≞ (→ P Q) (if (and (and (< 0 0.2) (and (<= (if (> 0 (if (< 1 (/ (- (+ 0.2 0.9) 1) 0.2)) 1 (/ (- (+ 0.2 0.9) 1) 0.2))) 0 (if (< 1 (/ (- (+ 0.2 0.9) 1) 0.2)) 1 (/ (- (+ 0.2 0.9) 1) 0.2))) $ABs#8245) (<= $ABs#8245 (if (> 0 (if (< 1 (/ 0.9 0.2)) 1 (/ 0.9 0.2))) 0 (if (< 1 (/ 0.9 0.2)) 1 (/ 0.9 0.2)))))) (and (< 0 0.9) (and (<= (if (> 0 (if (< 1 (/ (- (+ 0.9 0.3) 1) 0.9)) 1 (/ (- (+ 0.9 0.3) 1) 0.9))) 0 (if (< 1 (/ (- (+ 0.9 0.3) 1) 0.9)) 1 (/ (- (+ 0.9 0.3) 1) 0.9))) $QRs#8247) (<= $QRs#8247 (if (> 0 (if (< 1 (/ 0.3 0.9)) 1 (/ 0.3 0.9))) 0 (if (< 1 (/ 0.3 0.9)) 1 (/ 0.3 0.9))))))) (STV (if (< 0.9999 0.9) 0.3 (+ (* $ABs#8245 $QRs#8247) (/ (* (- 1 $ABs#8245) (- 0.3 (* 0.9 $QRs#8247))) (- 1 0.9)))) (min 0.3 (min 0.7 (min 0.2 (min $PQc#8251 $QRc#8252))))) (STV 1 0))))), (let* (((: $proof2#9658 (⊷ Q (S (S Z)) True)) (synthesize (: $proof2#9658 (⊷ Q (S (S Z)) True)) kb rb Z))) (: (IDIBase P2 $proof2#9658) (≞ (→ P Q) (ETV (:: (S (S Z)) ∅) (STV 1 0.5))))), (: (IDIBase P7 Q7) (≞ (→ P Q) (ETV (:: (S (S (S (S (S (S (S Z))))))) ∅) (STV 1 0.5)))), (: (IDIBase P2 Q2) (≞ (→ P Q) (ETV (:: (S (S Z)) ∅) (STV 0 0.5)))), (let* (((: $proof2#10369 (⊷ Q (S (S (S (S (S (S (S Z))))))) False)) (synthesize (: $proof2#10369 (⊷ Q (S (S (S (S (S (S (S Z))))))) False)) kb rb Z))) (: (IDIBase P7 $proof2#10369) (≞ (→ P Q) (ETV (:: (S (S (S (S (S (S (S Z))))))) ∅) (STV 0 0.5)))))]")
P;HTML|
;                                           (= 8  "[\"===== Prove that P→Q based on two pieces of evidence =====\"]")
P;HTML|
;                                           (= 9  "[(let* (((: $proof2#16368 (⊷ Q (S (S Z)) True)) (synthesize (: $proof2#16368 (⊷ Q (S (S Z)) True)) kb rb (S (S Z)))) ((: $proof3#16369 (≞ (→ P Q) (ETV (:: $h#16374 $t#16375) (STV $PQs#16376 $conf#16377)))) (synthesize (: $proof3#16369 (≞ (→ P Q) (ETV (:: $h#16374 $t#16375) (STV $PQs#16376 $conf#16377)))) kb rb (S (S Z)))) ((: $proof4#16370 (⍃ $h#16374 (S (S Z)))) (synthesize (: $proof4#16370 (⍃ $h#16374 (S (S Z)))) kb rb (S (S Z))))) (: (IDIRecursive P2 $proof2#16368 $proof3#16369 $proof4#16370) (≞ (→ P Q) (ETV (:: (S (S Z)) (:: $h#16374 $t#16375)) (STV (/ (+ (* $PQs#16376 (if (<= (if (< (- 1.0 $conf#16377) 0) (* -1 (- 1.0 $conf#16377)) (- 1.0 $conf#16377)) 1e-09) (max-count) (/ (* $conf#16377 (lookahead)) (- 1.0 $conf#16377)))) 1) (+ (if (<= (if (< (- 1.0 $conf#16377) 0) (* -1 (- 1.0 $conf#16377)) (- 1.0 $conf#16377)) 1e-09) (max-count) (/ (* $conf#16377 (lookahead)) (- 1.0 $conf#16377))) 1)) (/ (+ (if (<= (if (< (- 1.0 $conf#16377) 0) (* -1 (- 1.0 $conf#16377)) (- 1.0 $conf#16377)) 1e-09) (max-count) (/ (* $conf#16377 (lookahead)) (- 1.0 $conf#16377))) 1) (+ (+ (if (<= (if (< (- 1.0 $conf#16377) 0) (* -1 (- 1.0 $conf#16377)) (- 1.0 $conf#16377)) 1e-09) (max-count) (/ (* $conf#16377 (lookahead)) (- 1.0 $conf#16377))) 1) 1.0))))))), (let* (((: $proof4#16370 (⍃ (S (S (S (S (S (S (S Z))))))) (S (S (S (S (S (S (S Z))))))))) (synthesize (: $proof4#16370 (⍃ (S (S (S (S (S (S (S Z))))))) (S (S (S (S (S (S (S Z))))))))) kb rb (S (S Z))))) (: (IDIRecursive P7 Q7 (IDIBase P7 Q7) $proof4#16370) (≞ (→ P Q) (ETV (:: (S (S (S (S (S (S (S Z))))))) (:: (S (S (S (S (S (S (S Z))))))) ∅)) (STV (/ (+ (* 1 (if (<= (if (< (- 1.0 0.5) 0) (* -1 (- 1.0 0.5)) (- 1.0 0.5)) 1e-09) (max-count) (/ (* 0.5 (lookahead)) (- 1.0 0.5)))) 1) (+ (if (<= (if (< (- 1.0 0.5) 0) (* -1 (- 1.0 0.5)) (- 1.0 0.5)) 1e-09) (max-count) (/ (* 0.5 (lookahead)) (- 1.0 0.5))) 1)) (/ (+ (if (<= (if (< (- 1.0 0.5) 0) (* -1 (- 1.0 0.5)) (- 1.0 0.5)) 1e-09) (max-count) (/ (* 0.5 (lookahead)) (- 1.0 0.5))) 1) (+ (+ (if (<= (if (< (- 1.0 0.5) 0) (* -1 (- 1.0 0.5)) (- 1.0 0.5)) 1e-09) (max-count) (/ (* 0.5 (lookahead)) (- 1.0 0.5))) 1) 1.0))))))), (: (IDIRecursive P7 Q7 (IDIBase P2 Q2) (SuccMonotonicity (SuccMonotonicity ZeroLTSucc))) (≞ (→ P Q) (ETV (:: (S (S (S (S (S (S (S Z))))))) (:: (S (S Z)) ∅)) (STV 0.5 0.6666666666666666)))), (let* (((: $proof4#52079 (⍃ (S (S (S (S (S (S (S Z))))))) (S (S Z)))) (synthesize (: $proof4#52079 (⍃ (S (S (S (S (S (S (S Z))))))) (S (S Z)))) kb rb (S (S Z))))) (: (IDIRecursive P2 Q2 (IDIBase P7 Q7) $proof4#52079) (≞ (→ P Q) (ETV (:: (S (S Z)) (:: (S (S (S (S (S (S (S Z))))))) ∅)) (STV (/ (* 1 (if (<= (if (< (- 1.0 0.5) 0) (* -1 (- 1.0 0.5)) (- 1.0 0.5)) 1e-09) (max-count) (/ (* 0.5 (lookahead)) (- 1.0 0.5)))) (+ (if (<= (if (< (- 1.0 0.5) 0) (* -1 (- 1.0 0.5)) (- 1.0 0.5)) 1e-09) (max-count) (/ (* 0.5 (lookahead)) (- 1.0 0.5))) 1)) (/ (+ (if (<= (if (< (- 1.0 0.5) 0) (* -1 (- 1.0 0.5)) (- 1.0 0.5)) 1e-09) (max-count) (/ (* 0.5 (lookahead)) (- 1.0 0.5))) 1) (+ (+ (if (<= (if (< (- 1.0 0.5) 0) (* -1 (- 1.0 0.5)) (- 1.0 0.5)) 1e-09) (max-count) (/ (* 0.5 (lookahead)) (- 1.0 0.5))) 1) 1.0))))))), (let* (((: $proof4#52079 (⍃ (S (S Z)) (S (S Z)))) (synthesize (: $proof4#52079 (⍃ (S (S Z)) (S (S Z)))) kb rb (S (S Z))))) (: (IDIRecursive P2 Q2 (IDIBase P2 Q2) $proof4#52079) (≞ (→ P Q) (ETV (:: (S (S Z)) (:: (S (S Z)) ∅)) (STV (/ (* 0 (if (<= (if (< (- 1.0 0.5) 0) (* -1 (- 1.0 0.5)) (- 1.0 0.5)) 1e-09) (max-count) (/ (* 0.5 (lookahead)) (- 1.0 0.5)))) (+ (if (<= (if (< (- 1.0 0.5) 0) (* -1 (- 1.0 0.5)) (- 1.0 0.5)) 1e-09) (max-count) (/ (* 0.5 (lookahead)) (- 1.0 0.5))) 1)) (/ (+ (if (<= (if (< (- 1.0 0.5) 0) (* -1 (- 1.0 0.5)) (- 1.0 0.5)) 1e-09) (max-count) (/ (* 0.5 (lookahead)) (- 1.0 0.5))) 1) (+ (+ (if (<= (if (< (- 1.0 0.5) 0) (* -1 (- 1.0 0.5)) (- 1.0 0.5)) 1e-09) (max-count) (/ (* 0.5 (lookahead)) (- 1.0 0.5))) 1) 1.0))))))), (let* (((: $proof2#52077 (⊷ Q (S (S (S (S (S (S (S Z))))))) False)) (synthesize (: $proof2#52077 (⊷ Q (S (S (S (S (S (S (S Z))))))) False)) kb rb (S (S Z)))) ((: $proof3#52078 (≞ (→ P Q) (ETV (:: $h#52083 $t#52084) (STV $PQs#52085 $y#52086)))) (synthesize (: $proof3#52078 (≞ (→ P Q) (ETV (:: $h#52083 $t#52084) (STV $PQs#52085 $y#52086)))) kb rb (S (S Z)))) ((: $proof4#52079 (⍃ $h#52083 (S (S (S (S (S (S (S Z))))))))) (synthesize (: $proof4#52079 (⍃ $h#52083 (S (S (S (S (S (S (S Z))))))))) kb rb (S (S Z))))) (: (IDIRecursive P7 $proof2#52077 $proof3#52078 $proof4#52079) (≞ (→ P Q) (ETV (:: (S (S (S (S (S (S (S Z))))))) (:: $h#52083 $t#52084)) (STV (/ (* $PQs#52085 (if (<= (if (< (- 1.0 $y#52086) 0) (* -1 (- 1.0 $y#52086)) (- 1.0 $y#52086)) 1e-09) (max-count) (/ (* $y#52086 (lookahead)) (- 1.0 $y#52086)))) (+ (if (<= (if (< (- 1.0 $y#52086) 0) (* -1 (- 1.0 $y#52086)) (- 1.0 $y#52086)) 1e-09) (max-count) (/ (* $y#52086 (lookahead)) (- 1.0 $y#52086))) 1)) (/ (+ (if (<= (if (< (- 1.0 $y#52086) 0) (* -1 (- 1.0 $y#52086)) (- 1.0 $y#52086)) 1e-09) (max-count) (/ (* $y#52086 (lookahead)) (- 1.0 $y#52086))) 1) (+ (+ (if (<= (if (< (- 1.0 $y#52086) 0) (* -1 (- 1.0 $y#52086)) (- 1.0 $y#52086)) 1e-09) (max-count) (/ (* $y#52086 (lookahead)) (- 1.0 $y#52086))) 1) 1.0))))))), (: (EvidenceElimination (IDIBase P7 Q7)) (≞ (→ P Q) (STV 1 0.5))), (: (EvidenceElimination (IDIBase P2 Q2)) (≞ (→ P Q) (STV 0 0.5))), (: (Deduction Pm Pm Qm (EvidenceElimination (IDIBase P2 P2)) (EvidenceElimination (IDIBase P7 Q7))) (≞ (→ P Q) (STV 1.0 0.2))), (: (Deduction Pm Pm Qm (EvidenceElimination (IDIBase P2 P2)) (EvidenceElimination (IDIBase P2 Q2))) (≞ (→ P Q) (STV 0.0 0.2))), (: (Deduction Pm Pm Qm (EvidenceElimination (IDIBase P7 P7)) (EvidenceElimination (IDIBase P7 Q7))) (≞ (→ P Q) (STV 1.0 0.2))), (: (Deduction Pm Pm Qm (EvidenceElimination (IDIBase P7 P7)) (EvidenceElimination (IDIBase P2 Q2))) (≞ (→ P Q) (STV 0.0 0.2))), (: (Deduction Pm Qm Qm (EvidenceElimination (IDIBase P7 Q7)) (EvidenceElimination (IDIBase Q7 Q7))) (≞ (→ P Q) (STV 1.0 0.2))), (: (Deduction Pm Qm Qm (EvidenceElimination (IDIBase P2 Q2)) (EvidenceElimination (IDIBase Q7 Q7))) (≞ (→ P Q) (STV 0.0 0.2))), (let* (((: $proof4#111863 (≞ (→ P R) (STV $PQs#111869 $PQc#111875))) (synthesize (: $proof4#111863 (≞ (→ P R) (STV $PQs#111869 $PQc#111875))) kb rb (S (S Z)))) ((: $proof5#111864 (≞ (→ R Q) (STV $QRs#111871 $QRc#111876))) (synthesize (: $proof5#111864 (≞ (→ R Q) (STV $QRs#111871 $QRc#111876))) kb rb (S (S Z))))) (: (Deduction Pm Rm Qm $proof4#111863 $proof5#111864) (≞ (→ P Q) (if (and (and (< 0 0.2) (and (<= (if (> 0 (if (< 1 (/ (- (+ 0.2 0.4) 1) 0.2)) 1 (/ (- (+ 0.2 0.4) 1) 0.2))) 0 (if (< 1 (/ (- (+ 0.2 0.4) 1) 0.2)) 1 (/ (- (+ 0.2 0.4) 1) 0.2))) $PQs#111869) (<= $PQs#111869 (if (> 0 (if (< 1 (/ 0.4 0.2)) 1 (/ 0.4 0.2))) 0 (if (< 1 (/ 0.4 0.2)) 1 (/ 0.4 0.2)))))) (and (< 0 0.4) (and (<= (if (> 0 (if (< 1 (/ (- (+ 0.4 0.3) 1) 0.4)) 1 (/ (- (+ 0.4 0.3) 1) 0.4))) 0 (if (< 1 (/ (- (+ 0.4 0.3) 1) 0.4)) 1 (/ (- (+ 0.4 0.3) 1) 0.4))) $QRs#111871) (<= $QRs#111871 (if (> 0 (if (< 1 (/ 0.3 0.4)) 1 (/ 0.3 0.4))) 0 (if (< 1 (/ 0.3 0.4)) 1 (/ 0.3 0.4))))))) (STV (if (< 0.9999 0.4) 0.3 (+ (* $PQs#111869 $QRs#111871) (/ (* (- 1 $PQs#111869) (- 0.3 (* 0.4 $QRs#111871))) (- 1 0.4)))) (min 0.3 (min 0.1 (min 0.2 (min $PQc#111875 $QRc#111876))))) (STV 1 0))))), (let* (((: $proof4#111863 (≞ (→ P (→ Q R)) (STV $PQs#111869 $PQc#111875))) (synthesize (: $proof4#111863 (≞ (→ P (→ Q R)) (STV $PQs#111869 $PQc#111875))) kb rb (S (S Z)))) ((: $proof5#111864 (≞ (→ (→ Q R) Q) (STV $QRs#111871 $QRc#111876))) (synthesize (: $proof5#111864 (≞ (→ (→ Q R) Q) (STV $QRs#111871 $QRc#111876))) kb rb (S (S Z))))) (: (Deduction Pm QRm Qm $proof4#111863 $proof5#111864) (≞ (→ P Q) (if (and (and (< 0 0.2) (and (<= (if (> 0 (if (< 1 (/ (- (+ 0.2 0.9) 1) 0.2)) 1 (/ (- (+ 0.2 0.9) 1) 0.2))) 0 (if (< 1 (/ (- (+ 0.2 0.9) 1) 0.2)) 1 (/ (- (+ 0.2 0.9) 1) 0.2))) $PQs#111869) (<= $PQs#111869 (if (> 0 (if (< 1 (/ 0.9 0.2)) 1 (/ 0.9 0.2))) 0 (if (< 1 (/ 0.9 0.2)) 1 (/ 0.9 0.2)))))) (and (< 0 0.9) (and (<= (if (> 0 (if (< 1 (/ (- (+ 0.9 0.3) 1) 0.9)) 1 (/ (- (+ 0.9 0.3) 1) 0.9))) 0 (if (< 1 (/ (- (+ 0.9 0.3) 1) 0.9)) 1 (/ (- (+ 0.9 0.3) 1) 0.9))) $QRs#111871) (<= $QRs#111871 (if (> 0 (if (< 1 (/ 0.3 0.9)) 1 (/ 0.3 0.9))) 0 (if (< 1 (/ 0.3 0.9)) 1 (/ 0.3 0.9))))))) (STV (if (< 0.9999 0.9) 0.3 (+ (* $PQs#111869 $QRs#111871) (/ (* (- 1 $PQs#111869) (- 0.3 (* 0.9 $QRs#111871))) (- 1 0.9)))) (min 0.3 (min 0.7 (min 0.2 (min $PQc#111875 $QRc#111876))))) (STV 1 0))))), (let* (((: $proof4#111863 (≞ (→ P (→ P P)) (STV $PQs#111869 $PQc#111875))) (synthesize (: $proof4#111863 (≞ (→ P (→ P P)) (STV $PQs#111869 $PQc#111875))) kb rb (S (S Z)))) ((: $proof5#111864 (≞ (→ (→ P P) Q) (STV $QRs#111871 $QRc#111876))) (synthesize (: $proof5#111864 (≞ (→ (→ P P) Q) (STV $QRs#111871 $QRc#111876))) kb rb (S (S Z))))) (: (Deduction Pm (EvidenceElimination (IDIBase P2 P2)) Qm $proof4#111863 $proof5#111864) (≞ (→ P Q) (if (and (and (< 0 0.2) (and (<= (if (> 0 (if (< 1 (/ (- (+ 0.2 1) 1) 0.2)) 1 (/ (- (+ 0.2 1) 1) 0.2))) 0 (if (< 1 (/ (- (+ 0.2 1) 1) 0.2)) 1 (/ (- (+ 0.2 1) 1) 0.2))) $PQs#111869) (<= $PQs#111869 (if (> 0 (if (< 1 (/ 1 0.2)) 1 (/ 1 0.2))) 0 (if (< 1 (/ 1 0.2)) 1 (/ 1 0.2)))))) (and (< 0 1) (and (<= (if (> 0 (if (< 1 (/ (- (+ 1 0.3) 1) 1)) 1 (/ (- (+ 1 0.3) 1) 1))) 0 (if (< 1 (/ (- (+ 1 0.3) 1) 1)) 1 (/ (- (+ 1 0.3) 1) 1))) $QRs#111871) (<= $QRs#111871 (if (> 0 (if (< 1 (/ 0.3 1)) 1 (/ 0.3 1))) 0 (if (< 1 (/ 0.3 1)) 1 (/ 0.3 1))))))) (STV (if (< 0.9999 1) 0.3 (+ (* $PQs#111869 $QRs#111871) (/ (* (- 1 $PQs#111869) (- 0.3 (* 1 $QRs#111871))) (- 1 1)))) (min 0.3 (min 0.5 (min 0.2 (min $PQc#111875 $QRc#111876))))) (STV 1 0))))), (let* (((: $proof4#111863 (≞ (→ P (→ P P)) (STV $PQs#111869 $PQc#111875))) (synthesize (: $proof4#111863 (≞ (→ P (→ P P)) (STV $PQs#111869 $PQc#111875))) kb rb (S (S Z)))) ((: $proof5#111864 (≞ (→ (→ P P) Q) (STV $QRs#111871 $QRc#111876))) (synthesize (: $proof5#111864 (≞ (→ (→ P P) Q) (STV $QRs#111871 $QRc#111876))) kb rb (S (S Z))))) (: (Deduction Pm (EvidenceElimination (IDIBase P7 P7)) Qm $proof4#111863 $proof5#111864) (≞ (→ P Q) (if (and (and (< 0 0.2) (and (<= (if (> 0 (if (< 1 (/ (- (+ 0.2 1) 1) 0.2)) 1 (/ (- (+ 0.2 1) 1) 0.2))) 0 (if (< 1 (/ (- (+ 0.2 1) 1) 0.2)) 1 (/ (- (+ 0.2 1) 1) 0.2))) $PQs#111869) (<= $PQs#111869 (if (> 0 (if (< 1 (/ 1 0.2)) 1 (/ 1 0.2))) 0 (if (< 1 (/ 1 0.2)) 1 (/ 1 0.2)))))) (and (< 0 1) (and (<= (if (> 0 (if (< 1 (/ (- (+ 1 0.3) 1) 1)) 1 (/ (- (+ 1 0.3) 1) 1))) 0 (if (< 1 (/ (- (+ 1 0.3) 1) 1)) 1 (/ (- (+ 1 0.3) 1) 1))) $QRs#111871) (<= $QRs#111871 (if (> 0 (if (< 1 (/ 0.3 1)) 1 (/ 0.3 1))) 0 (if (< 1 (/ 0.3 1)) 1 (/ 0.3 1))))))) (STV (if (< 0.9999 1) 0.3 (+ (* $PQs#111869 $QRs#111871) (/ (* (- 1 $PQs#111869) (- 0.3 (* 1 $QRs#111871))) (- 1 1)))) (min 0.3 (min 0.5 (min 0.2 (min $PQc#111875 $QRc#111876))))) (STV 1 0))))), (let* (((: $proof4#111863 (≞ (→ P (→ P Q)) (STV $PQs#111869 $PQc#111875))) (synthesize (: $proof4#111863 (≞ (→ P (→ P Q)) (STV $PQs#111869 $PQc#111875))) kb rb (S (S Z)))) ((: $proof5#111864 (≞ (→ (→ P Q) Q) (STV $QRs#111871 $QRc#111876))) (synthesize (: $proof5#111864 (≞ (→ (→ P Q) Q) (STV $QRs#111871 $QRc#111876))) kb rb (S (S Z))))) (: (Deduction Pm (EvidenceElimination (IDIBase P7 Q7)) Qm $proof4#111863 $proof5#111864) (≞ (→ P Q) (if (and (and (< 0 0.2) (and (<= (if (> 0 (if (< 1 (/ (- (+ 0.2 1) 1) 0.2)) 1 (/ (- (+ 0.2 1) 1) 0.2))) 0 (if (< 1 (/ (- (+ 0.2 1) 1) 0.2)) 1 (/ (- (+ 0.2 1) 1) 0.2))) $PQs#111869) (<= $PQs#111869 (if (> 0 (if (< 1 (/ 1 0.2)) 1 (/ 1 0.2))) 0 (if (< 1 (/ 1 0.2)) 1 (/ 1 0.2)))))) (and (< 0 1) (and (<= (if (> 0 (if (< 1 (/ (- (+ 1 0.3) 1) 1)) 1 (/ (- (+ 1 0.3) 1) 1))) 0 (if (< 1 (/ (- (+ 1 0.3) 1) 1)) 1 (/ (- (+ 1 0.3) 1) 1))) $QRs#111871) (<= $QRs#111871 (if (> 0 (if (< 1 (/ 0.3 1)) 1 (/ 0.3 1))) 0 (if (< 1 (/ 0.3 1)) 1 (/ 0.3 1))))))) (STV (if (< 0.9999 1) 0.3 (+ (* $PQs#111869 $QRs#111871) (/ (* (- 1 $PQs#111869) (- 0.3 (* 1 $QRs#111871))) (- 1 1)))) (min 0.3 (min 0.5 (min 0.2 (min $PQc#111875 $QRc#111876))))) (STV 1 0))))), (let* (((: $proof4#111863 (≞ (→ P (→ Q P)) (STV $PQs#111869 $PQc#111875))) (synthesize (: $proof4#111863 (≞ (→ P (→ Q P)) (STV $PQs#111869 $PQc#111875))) kb rb (S (S Z)))) ((: $proof5#111864 (≞ (→ (→ Q P) Q) (STV $QRs#111871 $QRc#111876))) (synthesize (: $proof5#111864 (≞ (→ (→ Q P) Q) (STV $QRs#111871 $QRc#111876))) kb rb (S (S Z))))) (: (Deduction Pm (EvidenceElimination (IDIBase Q7 P7)) Qm $proof4#111863 $proof5#111864) (≞ (→ P Q) (if (and (and (< 0 0.2) (and (<= (if (> 0 (if (< 1 (/ (- (+ 0.2 1) 1) 0.2)) 1 (/ (- (+ 0.2 1) 1) 0.2))) 0 (if (< 1 (/ (- (+ 0.2 1) 1) 0.2)) 1 (/ (- (+ 0.2 1) 1) 0.2))) $PQs#111869) (<= $PQs#111869 (if (> 0 (if (< 1 (/ 1 0.2)) 1 (/ 1 0.2))) 0 (if (< 1 (/ 1 0.2)) 1 (/ 1 0.2)))))) (and (< 0 1) (and (<= (if (> 0 (if (< 1 (/ (- (+ 1 0.3) 1) 1)) 1 (/ (- (+ 1 0.3) 1) 1))) 0 (if (< 1 (/ (- (+ 1 0.3) 1) 1)) 1 (/ (- (+ 1 0.3) 1) 1))) $QRs#111871) (<= $QRs#111871 (if (> 0 (if (< 1 (/ 0.3 1)) 1 (/ 0.3 1))) 0 (if (< 1 (/ 0.3 1)) 1 (/ 0.3 1))))))) (STV (if (< 0.9999 1) 0.3 (+ (* $PQs#111869 $QRs#111871) (/ (* (- 1 $PQs#111869) (- 0.3 (* 1 $QRs#111871))) (- 1 1)))) (min 0.3 (min 0.5 (min 0.2 (min $PQc#111875 $QRc#111876))))) (STV 1 0))))), (let* (((: $proof4#111863 (≞ (→ P (→ Q Q)) (STV $PQs#111869 $PQc#111875))) (synthesize (: $proof4#111863 (≞ (→ P (→ Q Q)) (STV $PQs#111869 $PQc#111875))) kb rb (S (S Z)))) ((: $proof5#111864 (≞ (→ (→ Q Q) Q) (STV $QRs#111871 $QRc#111876))) (synthesize (: $proof5#111864 (≞ (→ (→ Q Q) Q) (STV $QRs#111871 $QRc#111876))) kb rb (S (S Z))))) (: (Deduction Pm (EvidenceElimination (IDIBase Q7 Q7)) Qm $proof4#111863 $proof5#111864) (≞ (→ P Q) (if (and (and (< 0 0.2) (and (<= (if (> 0 (if (< 1 (/ (- (+ 0.2 1) 1) 0.2)) 1 (/ (- (+ 0.2 1) 1) 0.2))) 0 (if (< 1 (/ (- (+ 0.2 1) 1) 0.2)) 1 (/ (- (+ 0.2 1) 1) 0.2))) $PQs#111869) (<= $PQs#111869 (if (> 0 (if (< 1 (/ 1 0.2)) 1 (/ 1 0.2))) 0 (if (< 1 (/ 1 0.2)) 1 (/ 1 0.2)))))) (and (< 0 1) (and (<= (if (> 0 (if (< 1 (/ (- (+ 1 0.3) 1) 1)) 1 (/ (- (+ 1 0.3) 1) 1))) 0 (if (< 1 (/ (- (+ 1 0.3) 1) 1)) 1 (/ (- (+ 1 0.3) 1) 1))) $QRs#111871) (<= $QRs#111871 (if (> 0 (if (< 1 (/ 0.3 1)) 1 (/ 0.3 1))) 0 (if (< 1 (/ 0.3 1)) 1 (/ 0.3 1))))))) (STV (if (< 0.9999 1) 0.3 (+ (* $PQs#111869 $QRs#111871) (/ (* (- 1 $PQs#111869) (- 0.3 (* 1 $QRs#111871))) (- 1 1)))) (min 0.3 (min 0.5 (min 0.2 (min $PQc#111875 $QRc#111876))))) (STV 1 0))))), (let* (((: $proof4#111863 (≞ (→ P (→ P Q)) (STV $PQs#111869 $PQc#111875))) (synthesize (: $proof4#111863 (≞ (→ P (→ P Q)) (STV $PQs#111869 $PQc#111875))) kb rb (S (S Z)))) ((: $proof5#111864 (≞ (→ (→ P Q) Q) (STV $QRs#111871 $QRc#111876))) (synthesize (: $proof5#111864 (≞ (→ (→ P Q) Q) (STV $QRs#111871 $QRc#111876))) kb rb (S (S Z))))) (: (Deduction Pm (EvidenceElimination (IDIBase P2 Q2)) Qm $proof4#111863 $proof5#111864) (≞ (→ P Q) (if (and (and (< 0 0.2) (and (<= (if (> 0 (if (< 1 (/ (- (+ 0.2 0) 1) 0.2)) 1 (/ (- (+ 0.2 0) 1) 0.2))) 0 (if (< 1 (/ (- (+ 0.2 0) 1) 0.2)) 1 (/ (- (+ 0.2 0) 1) 0.2))) $PQs#111869) (<= $PQs#111869 (if (> 0 (if (< 1 (/ 0 0.2)) 1 (/ 0 0.2))) 0 (if (< 1 (/ 0 0.2)) 1 (/ 0 0.2)))))) (and (< 0 0) (and (<= (if (> 0 (if (< 1 (/ (- (+ 0 0.3) 1) 0)) 1 (/ (- (+ 0 0.3) 1) 0))) 0 (if (< 1 (/ (- (+ 0 0.3) 1) 0)) 1 (/ (- (+ 0 0.3) 1) 0))) $QRs#111871) (<= $QRs#111871 (if (> 0 (if (< 1 (/ 0.3 0)) 1 (/ 0.3 0))) 0 (if (< 1 (/ 0.3 0)) 1 (/ 0.3 0))))))) (STV (if (< 0.9999 0) 0.3 (+ (* $PQs#111869 $QRs#111871) (/ (* (- 1 $PQs#111869) (- 0.3 (* 0 $QRs#111871))) (- 1 0)))) (min 0.3 (min 0.5 (min 0.2 (min $PQc#111875 $QRc#111876))))) (STV 1 0))))), (let* (((: $proof2#166826 (⊷ Q (S (S Z)) True)) (synthesize (: $proof2#166826 (⊷ Q (S (S Z)) True)) kb rb (S (S Z))))) (: (IDIBase P2 $proof2#166826) (≞ (→ P Q) (ETV (:: (S (S Z)) ∅) (STV 1 0.5))))), (: (IDIBase P7 Q7) (≞ (→ P Q) (ETV (:: (S (S (S (S (S (S (S Z))))))) ∅) (STV 1 0.5)))), (: (IDIBase P2 Q2) (≞ (→ P Q) (ETV (:: (S (S Z)) ∅) (STV 0 0.5)))), (let* (((: $proof2#169875 (⊷ Q (S (S (S (S (S (S (S Z))))))) False)) (synthesize (: $proof2#169875 (⊷ Q (S (S (S (S (S (S (S Z))))))) False)) kb rb (S (S Z))))) (: (IDIBase P7 $proof2#169875) (≞ (→ P Q) (ETV (:: (S (S (S (S (S (S (S Z))))))) ∅) (STV 0 0.5)))))]")
P;HTML|
;                                           (= 10  "[\"===== Prove that P→R based on one piece of evidence and deduction =====\"]")
P;HTML|
;                                           (= 11  "[(let* (((: $proof2#178212 (⊷ R (S (S Z)) True)) (synthesize (: $proof2#178212 (⊷ R (S (S Z)) True)) kb rb (S (S Z)))) ((: $proof3#178213 (≞ (→ P R) (ETV (:: $h#178218 $t#178219) (STV $PQs#178220 $y#178221)))) (synthesize (: $proof3#178213 (≞ (→ P R) (ETV (:: $h#178218 $t#178219) (STV $PQs#178220 $y#178221)))) kb rb (S (S Z)))) ((: $proof4#178214 (⍃ $h#178218 (S (S Z)))) (synthesize (: $proof4#178214 (⍃ $h#178218 (S (S Z)))) kb rb (S (S Z))))) (: (IDIRecursive P2 $proof2#178212 $proof3#178213 $proof4#178214) (≞ (→ P R) (ETV (:: (S (S Z)) (:: $h#178218 $t#178219)) (STV (/ (+ (* $PQs#178220 (if (<= (if (< (- 1.0 $y#178221) 0) (* -1 (- 1.0 $y#178221)) (- 1.0 $y#178221)) 1e-09) (max-count) (/ (* $y#178221 (lookahead)) (- 1.0 $y#178221)))) 1) (+ (if (<= (if (< (- 1.0 $y#178221) 0) (* -1 (- 1.0 $y#178221)) (- 1.0 $y#178221)) 1e-09) (max-count) (/ (* $y#178221 (lookahead)) (- 1.0 $y#178221))) 1)) (/ (+ (if (<= (if (< (- 1.0 $y#178221) 0) (* -1 (- 1.0 $y#178221)) (- 1.0 $y#178221)) 1e-09) (max-count) (/ (* $y#178221 (lookahead)) (- 1.0 $y#178221))) 1) (+ (+ (if (<= (if (< (- 1.0 $y#178221) 0) (* -1 (- 1.0 $y#178221)) (- 1.0 $y#178221)) 1e-09) (max-count) (/ (* $y#178221 (lookahead)) (- 1.0 $y#178221))) 1) 1.0))))))), (let* (((: $proof2#178212 (⊷ R (S (S (S (S (S (S (S Z))))))) True)) (synthesize (: $proof2#178212 (⊷ R (S (S (S (S (S (S (S Z))))))) True)) kb rb (S (S Z)))) ((: $proof3#178213 (≞ (→ P R) (ETV (:: $h#178218 $t#178219) (STV $PQs#178220 $y#178221)))) (synthesize (: $proof3#178213 (≞ (→ P R) (ETV (:: $h#178218 $t#178219) (STV $PQs#178220 $y#178221)))) kb rb (S (S Z)))) ((: $proof4#178214 (⍃ $h#178218 (S (S (S (S (S (S (S Z))))))))) (synthesize (: $proof4#178214 (⍃ $h#178218 (S (S (S (S (S (S (S Z))))))))) kb rb (S (S Z))))) (: (IDIRecursive P7 $proof2#178212 $proof3#178213 $proof4#178214) (≞ (→ P R) (ETV (:: (S (S (S (S (S (S (S Z))))))) (:: $h#178218 $t#178219)) (STV (/ (+ (* $PQs#178220 (if (<= (if (< (- 1.0 $y#178221) 0) (* -1 (- 1.0 $y#178221)) (- 1.0 $y#178221)) 1e-09) (max-count) (/ (* $y#178221 (lookahead)) (- 1.0 $y#178221)))) 1) (+ (if (<= (if (< (- 1.0 $y#178221) 0) (* -1 (- 1.0 $y#178221)) (- 1.0 $y#178221)) 1e-09) (max-count) (/ (* $y#178221 (lookahead)) (- 1.0 $y#178221))) 1)) (/ (+ (if (<= (if (< (- 1.0 $y#178221) 0) (* -1 (- 1.0 $y#178221)) (- 1.0 $y#178221)) 1e-09) (max-count) (/ (* $y#178221 (lookahead)) (- 1.0 $y#178221))) 1) (+ (+ (if (<= (if (< (- 1.0 $y#178221) 0) (* -1 (- 1.0 $y#178221)) (- 1.0 $y#178221)) 1e-09) (max-count) (/ (* $y#178221 (lookahead)) (- 1.0 $y#178221))) 1) 1.0))))))), (let* (((: $proof2#181052 (⊷ R (S (S Z)) False)) (synthesize (: $proof2#181052 (⊷ R (S (S Z)) False)) kb rb (S (S Z)))) ((: $proof3#181053 (≞ (→ P R) (ETV (:: $h#181058 $t#181059) (STV $PQs#181060 $y#181061)))) (synthesize (: $proof3#181053 (≞ (→ P R) (ETV (:: $h#181058 $t#181059) (STV $PQs#181060 $y#181061)))) kb rb (S (S Z)))) ((: $proof4#181054 (⍃ $h#181058 (S (S Z)))) (synthesize (: $proof4#181054 (⍃ $h#181058 (S (S Z)))) kb rb (S (S Z))))) (: (IDIRecursive P2 $proof2#181052 $proof3#181053 $proof4#181054) (≞ (→ P R) (ETV (:: (S (S Z)) (:: $h#181058 $t#181059)) (STV (/ (* $PQs#181060 (if (<= (if (< (- 1.0 $y#181061) 0) (* -1 (- 1.0 $y#181061)) (- 1.0 $y#181061)) 1e-09) (max-count) (/ (* $y#181061 (lookahead)) (- 1.0 $y#181061)))) (+ (if (<= (if (< (- 1.0 $y#181061) 0) (* -1 (- 1.0 $y#181061)) (- 1.0 $y#181061)) 1e-09) (max-count) (/ (* $y#181061 (lookahead)) (- 1.0 $y#181061))) 1)) (/ (+ (if (<= (if (< (- 1.0 $y#181061) 0) (* -1 (- 1.0 $y#181061)) (- 1.0 $y#181061)) 1e-09) (max-count) (/ (* $y#181061 (lookahead)) (- 1.0 $y#181061))) 1) (+ (+ (if (<= (if (< (- 1.0 $y#181061) 0) (* -1 (- 1.0 $y#181061)) (- 1.0 $y#181061)) 1e-09) (max-count) (/ (* $y#181061 (lookahead)) (- 1.0 $y#181061))) 1) 1.0))))))), (let* (((: $proof2#181052 (⊷ R (S (S (S (S (S (S (S Z))))))) False)) (synthesize (: $proof2#181052 (⊷ R (S (S (S (S (S (S (S Z))))))) False)) kb rb (S (S Z)))) ((: $proof3#181053 (≞ (→ P R) (ETV (:: $h#181058 $t#181059) (STV $PQs#181060 $y#181061)))) (synthesize (: $proof3#181053 (≞ (→ P R) (ETV (:: $h#181058 $t#181059) (STV $PQs#181060 $y#181061)))) kb rb (S (S Z)))) ((: $proof4#181054 (⍃ $h#181058 (S (S (S (S (S (S (S Z))))))))) (synthesize (: $proof4#181054 (⍃ $h#181058 (S (S (S (S (S (S (S Z))))))))) kb rb (S (S Z))))) (: (IDIRecursive P7 $proof2#181052 $proof3#181053 $proof4#181054) (≞ (→ P R) (ETV (:: (S (S (S (S (S (S (S Z))))))) (:: $h#181058 $t#181059)) (STV (/ (* $PQs#181060 (if (<= (if (< (- 1.0 $y#181061) 0) (* -1 (- 1.0 $y#181061)) (- 1.0 $y#181061)) 1e-09) (max-count) (/ (* $y#181061 (lookahead)) (- 1.0 $y#181061)))) (+ (if (<= (if (< (- 1.0 $y#181061) 0) (* -1 (- 1.0 $y#181061)) (- 1.0 $y#181061)) 1e-09) (max-count) (/ (* $y#181061 (lookahead)) (- 1.0 $y#181061))) 1)) (/ (+ (if (<= (if (< (- 1.0 $y#181061) 0) (* -1 (- 1.0 $y#181061)) (- 1.0 $y#181061)) 1e-09) (max-count) (/ (* $y#181061 (lookahead)) (- 1.0 $y#181061))) 1) (+ (+ (if (<= (if (< (- 1.0 $y#181061) 0) (* -1 (- 1.0 $y#181061)) (- 1.0 $y#181061)) 1e-09) (max-count) (/ (* $y#181061 (lookahead)) (- 1.0 $y#181061))) 1) 1.0))))))), (let* (((: $proof5#196218 (≞ (→ P R) (STV $QRs#196225 $QRc#196230))) (synthesize (: $proof5#196218 (≞ (→ P R) (STV $QRs#196225 $QRc#196230))) kb rb (S (S Z))))) (: (Deduction Pm Pm Rm (EvidenceElimination (IDIBase P2 P2)) $proof5#196218) (≞ (→ P R) (if (and (and (< 0 0.2) (and (<= (if (> 0 (if (< 1 (/ (- (+ 0.2 0.2) 1) 0.2)) 1 (/ (- (+ 0.2 0.2) 1) 0.2))) 0 (if (< 1 (/ (- (+ 0.2 0.2) 1) 0.2)) 1 (/ (- (+ 0.2 0.2) 1) 0.2))) 1) (<= 1 (if (> 0 (if (< 1 (/ 0.2 0.2)) 1 (/ 0.2 0.2))) 0 (if (< 1 (/ 0.2 0.2)) 1 (/ 0.2 0.2)))))) (and (< 0 0.2) (and (<= (if (> 0 (if (< 1 (/ (- (+ 0.2 0.4) 1) 0.2)) 1 (/ (- (+ 0.2 0.4) 1) 0.2))) 0 (if (< 1 (/ (- (+ 0.2 0.4) 1) 0.2)) 1 (/ (- (+ 0.2 0.4) 1) 0.2))) $QRs#196225) (<= $QRs#196225 (if (> 0 (if (< 1 (/ 0.4 0.2)) 1 (/ 0.4 0.2))) 0 (if (< 1 (/ 0.4 0.2)) 1 (/ 0.4 0.2))))))) (STV (if (< 0.9999 0.2) 0.4 (+ (* 1 $QRs#196225) (/ (* (- 1 1) (- 0.4 (* 0.2 $QRs#196225))) (- 1 0.2)))) (min 0.3 (min 0.3 (min 0.1 (min 0.5 $QRc#196230))))) (STV 1 0))))), (let* (((: $proof5#196218 (≞ (→ P R) (STV $QRs#196225 $QRc#196230))) (synthesize (: $proof5#196218 (≞ (→ P R) (STV $QRs#196225 $QRc#196230))) kb rb (S (S Z))))) (: (Deduction Pm Pm Rm (EvidenceElimination (IDIBase P7 P7)) $proof5#196218) (≞ (→ P R) (if (and (and (< 0 0.2) (and (<= (if (> 0 (if (< 1 (/ (- (+ 0.2 0.2) 1) 0.2)) 1 (/ (- (+ 0.2 0.2) 1) 0.2))) 0 (if (< 1 (/ (- (+ 0.2 0.2) 1) 0.2)) 1 (/ (- (+ 0.2 0.2) 1) 0.2))) 1) (<= 1 (if (> 0 (if (< 1 (/ 0.2 0.2)) 1 (/ 0.2 0.2))) 0 (if (< 1 (/ 0.2 0.2)) 1 (/ 0.2 0.2)))))) (and (< 0 0.2) (and (<= (if (> 0 (if (< 1 (/ (- (+ 0.2 0.4) 1) 0.2)) 1 (/ (- (+ 0.2 0.4) 1) 0.2))) 0 (if (< 1 (/ (- (+ 0.2 0.4) 1) 0.2)) 1 (/ (- (+ 0.2 0.4) 1) 0.2))) $QRs#196225) (<= $QRs#196225 (if (> 0 (if (< 1 (/ 0.4 0.2)) 1 (/ 0.4 0.2))) 0 (if (< 1 (/ 0.4 0.2)) 1 (/ 0.4 0.2))))))) (STV (if (< 0.9999 0.2) 0.4 (+ (* 1 $QRs#196225) (/ (* (- 1 1) (- 0.4 (* 0.2 $QRs#196225))) (- 1 0.2)))) (min 0.3 (min 0.3 (min 0.1 (min 0.5 $QRc#196230))))) (STV 1 0))))), (: (Deduction Pm Qm Rm (EvidenceElimination (IDIBase P7 Q7)) QRm) (≞ (→ P R) (STV 0.9 0.1))), (: (Deduction Pm Qm Rm (EvidenceElimination (IDIBase P2 Q2)) QRm) (≞ (→ P R) (STV 0.18571428571428572 0.1))), (let* (((: $proof4#196217 (≞ (→ P R) (STV $ABs#196223 $PQc#196229))) (synthesize (: $proof4#196217 (≞ (→ P R) (STV $ABs#196223 $PQc#196229))) kb rb (S (S Z)))) ((: $proof5#196218 (≞ (→ R R) (STV $QRs#196225 $QRc#196230))) (synthesize (: $proof5#196218 (≞ (→ R R) (STV $QRs#196225 $QRc#196230))) kb rb (S (S Z))))) (: (Deduction Pm Rm Rm $proof4#196217 $proof5#196218) (≞ (→ P R) (if (and (and (< 0 0.2) (and (<= (if (> 0 (if (< 1 (/ (- (+ 0.2 0.4) 1) 0.2)) 1 (/ (- (+ 0.2 0.4) 1) 0.2))) 0 (if (< 1 (/ (- (+ 0.2 0.4) 1) 0.2)) 1 (/ (- (+ 0.2 0.4) 1) 0.2))) $ABs#196223) (<= $ABs#196223 (if (> 0 (if (< 1 (/ 0.4 0.2)) 1 (/ 0.4 0.2))) 0 (if (< 1 (/ 0.4 0.2)) 1 (/ 0.4 0.2)))))) (and (< 0 0.4) (and (<= (if (> 0 (if (< 1 (/ (- (+ 0.4 0.4) 1) 0.4)) 1 (/ (- (+ 0.4 0.4) 1) 0.4))) 0 (if (< 1 (/ (- (+ 0.4 0.4) 1) 0.4)) 1 (/ (- (+ 0.4 0.4) 1) 0.4))) $QRs#196225) (<= $QRs#196225 (if (> 0 (if (< 1 (/ 0.4 0.4)) 1 (/ 0.4 0.4))) 0 (if (< 1 (/ 0.4 0.4)) 1 (/ 0.4 0.4))))))) (STV (if (< 0.9999 0.4) 0.4 (+ (* $ABs#196223 $QRs#196225) (/ (* (- 1 $ABs#196223) (- 0.4 (* 0.4 $QRs#196225))) (- 1 0.4)))) (min 0.3 (min 0.1 (min 0.1 (min $PQc#196229 $QRc#196230))))) (STV 1 0))))), (let* (((: $proof4#196217 (≞ (→ P (→ Q R)) (STV $ABs#196223 $PQc#196229))) (synthesize (: $proof4#196217 (≞ (→ P (→ Q R)) (STV $ABs#196223 $PQc#196229))) kb rb (S (S Z)))) ((: $proof5#196218 (≞ (→ (→ Q R) R) (STV $QRs#196225 $QRc#196230))) (synthesize (: $proof5#196218 (≞ (→ (→ Q R) R) (STV $QRs#196225 $QRc#196230))) kb rb (S (S Z))))) (: (Deduction Pm QRm Rm $proof4#196217 $proof5#196218) (≞ (→ P R) (if (and (and (< 0 0.2) (and (<= (if (> 0 (if (< 1 (/ (- (+ 0.2 0.9) 1) 0.2)) 1 (/ (- (+ 0.2 0.9) 1) 0.2))) 0 (if (< 1 (/ (- (+ 0.2 0.9) 1) 0.2)) 1 (/ (- (+ 0.2 0.9) 1) 0.2))) $ABs#196223) (<= $ABs#196223 (if (> 0 (if (< 1 (/ 0.9 0.2)) 1 (/ 0.9 0.2))) 0 (if (< 1 (/ 0.9 0.2)) 1 (/ 0.9 0.2)))))) (and (< 0 0.9) (and (<= (if (> 0 (if (< 1 (/ (- (+ 0.9 0.4) 1) 0.9)) 1 (/ (- (+ 0.9 0.4) 1) 0.9))) 0 (if (< 1 (/ (- (+ 0.9 0.4) 1) 0.9)) 1 (/ (- (+ 0.9 0.4) 1) 0.9))) $QRs#196225) (<= $QRs#196225 (if (> 0 (if (< 1 (/ 0.4 0.9)) 1 (/ 0.4 0.9))) 0 (if (< 1 (/ 0.4 0.9)) 1 (/ 0.4 0.9))))))) (STV (if (< 0.9999 0.9) 0.4 (+ (* $ABs#196223 $QRs#196225) (/ (* (- 1 $ABs#196223) (- 0.4 (* 0.9 $QRs#196225))) (- 1 0.9)))) (min 0.3 (min 0.7 (min 0.1 (min $PQc#196229 $QRc#196230))))) (STV 1 0))))), (let* (((: $proof4#196217 (≞ (→ P (→ P P)) (STV $ABs#196223 $PQc#196229))) (synthesize (: $proof4#196217 (≞ (→ P (→ P P)) (STV $ABs#196223 $PQc#196229))) kb rb (S (S Z)))) ((: $proof5#196218 (≞ (→ (→ P P) R) (STV $QRs#196225 $QRc#196230))) (synthesize (: $proof5#196218 (≞ (→ (→ P P) R) (STV $QRs#196225 $QRc#196230))) kb rb (S (S Z))))) (: (Deduction Pm (EvidenceElimination (IDIBase P2 P2)) Rm $proof4#196217 $proof5#196218) (≞ (→ P R) (if (and (and (< 0 0.2) (and (<= (if (> 0 (if (< 1 (/ (- (+ 0.2 1) 1) 0.2)) 1 (/ (- (+ 0.2 1) 1) 0.2))) 0 (if (< 1 (/ (- (+ 0.2 1) 1) 0.2)) 1 (/ (- (+ 0.2 1) 1) 0.2))) $ABs#196223) (<= $ABs#196223 (if (> 0 (if (< 1 (/ 1 0.2)) 1 (/ 1 0.2))) 0 (if (< 1 (/ 1 0.2)) 1 (/ 1 0.2)))))) (and (< 0 1) (and (<= (if (> 0 (if (< 1 (/ (- (+ 1 0.4) 1) 1)) 1 (/ (- (+ 1 0.4) 1) 1))) 0 (if (< 1 (/ (- (+ 1 0.4) 1) 1)) 1 (/ (- (+ 1 0.4) 1) 1))) $QRs#196225) (<= $QRs#196225 (if (> 0 (if (< 1 (/ 0.4 1)) 1 (/ 0.4 1))) 0 (if (< 1 (/ 0.4 1)) 1 (/ 0.4 1))))))) (STV (if (< 0.9999 1) 0.4 (+ (* $ABs#196223 $QRs#196225) (/ (* (- 1 $ABs#196223) (- 0.4 (* 1 $QRs#196225))) (- 1 1)))) (min 0.3 (min 0.5 (min 0.1 (min $PQc#196229 $QRc#196230))))) (STV 1 0))))), (let* (((: $proof4#196217 (≞ (→ P (→ P P)) (STV $ABs#196223 $PQc#196229))) (synthesize (: $proof4#196217 (≞ (→ P (→ P P)) (STV $ABs#196223 $PQc#196229))) kb rb (S (S Z)))) ((: $proof5#196218 (≞ (→ (→ P P) R) (STV $QRs#196225 $QRc#196230))) (synthesize (: $proof5#196218 (≞ (→ (→ P P) R) (STV $QRs#196225 $QRc#196230))) kb rb (S (S Z))))) (: (Deduction Pm (EvidenceElimination (IDIBase P7 P7)) Rm $proof4#196217 $proof5#196218) (≞ (→ P R) (if (and (and (< 0 0.2) (and (<= (if (> 0 (if (< 1 (/ (- (+ 0.2 1) 1) 0.2)) 1 (/ (- (+ 0.2 1) 1) 0.2))) 0 (if (< 1 (/ (- (+ 0.2 1) 1) 0.2)) 1 (/ (- (+ 0.2 1) 1) 0.2))) $ABs#196223) (<= $ABs#196223 (if (> 0 (if (< 1 (/ 1 0.2)) 1 (/ 1 0.2))) 0 (if (< 1 (/ 1 0.2)) 1 (/ 1 0.2)))))) (and (< 0 1) (and (<= (if (> 0 (if (< 1 (/ (- (+ 1 0.4) 1) 1)) 1 (/ (- (+ 1 0.4) 1) 1))) 0 (if (< 1 (/ (- (+ 1 0.4) 1) 1)) 1 (/ (- (+ 1 0.4) 1) 1))) $QRs#196225) (<= $QRs#196225 (if (> 0 (if (< 1 (/ 0.4 1)) 1 (/ 0.4 1))) 0 (if (< 1 (/ 0.4 1)) 1 (/ 0.4 1))))))) (STV (if (< 0.9999 1) 0.4 (+ (* $ABs#196223 $QRs#196225) (/ (* (- 1 $ABs#196223) (- 0.4 (* 1 $QRs#196225))) (- 1 1)))) (min 0.3 (min 0.5 (min 0.1 (min $PQc#196229 $QRc#196230))))) (STV 1 0))))), (let* (((: $proof4#196217 (≞ (→ P (→ P Q)) (STV $ABs#196223 $PQc#196229))) (synthesize (: $proof4#196217 (≞ (→ P (→ P Q)) (STV $ABs#196223 $PQc#196229))) kb rb (S (S Z)))) ((: $proof5#196218 (≞ (→ (→ P Q) R) (STV $QRs#196225 $QRc#196230))) (synthesize (: $proof5#196218 (≞ (→ (→ P Q) R) (STV $QRs#196225 $QRc#196230))) kb rb (S (S Z))))) (: (Deduction Pm (EvidenceElimination (IDIBase P7 Q7)) Rm $proof4#196217 $proof5#196218) (≞ (→ P R) (if (and (and (< 0 0.2) (and (<= (if (> 0 (if (< 1 (/ (- (+ 0.2 1) 1) 0.2)) 1 (/ (- (+ 0.2 1) 1) 0.2))) 0 (if (< 1 (/ (- (+ 0.2 1) 1) 0.2)) 1 (/ (- (+ 0.2 1) 1) 0.2))) $ABs#196223) (<= $ABs#196223 (if (> 0 (if (< 1 (/ 1 0.2)) 1 (/ 1 0.2))) 0 (if (< 1 (/ 1 0.2)) 1 (/ 1 0.2)))))) (and (< 0 1) (and (<= (if (> 0 (if (< 1 (/ (- (+ 1 0.4) 1) 1)) 1 (/ (- (+ 1 0.4) 1) 1))) 0 (if (< 1 (/ (- (+ 1 0.4) 1) 1)) 1 (/ (- (+ 1 0.4) 1) 1))) $QRs#196225) (<= $QRs#196225 (if (> 0 (if (< 1 (/ 0.4 1)) 1 (/ 0.4 1))) 0 (if (< 1 (/ 0.4 1)) 1 (/ 0.4 1))))))) (STV (if (< 0.9999 1) 0.4 (+ (* $ABs#196223 $QRs#196225) (/ (* (- 1 $ABs#196223) (- 0.4 (* 1 $QRs#196225))) (- 1 1)))) (min 0.3 (min 0.5 (min 0.1 (min $PQc#196229 $QRc#196230))))) (STV 1 0))))), (let* (((: $proof4#196217 (≞ (→ P (→ Q P)) (STV $ABs#196223 $PQc#196229))) (synthesize (: $proof4#196217 (≞ (→ P (→ Q P)) (STV $ABs#196223 $PQc#196229))) kb rb (S (S Z)))) ((: $proof5#196218 (≞ (→ (→ Q P) R) (STV $QRs#196225 $QRc#196230))) (synthesize (: $proof5#196218 (≞ (→ (→ Q P) R) (STV $QRs#196225 $QRc#196230))) kb rb (S (S Z))))) (: (Deduction Pm (EvidenceElimination (IDIBase Q7 P7)) Rm $proof4#196217 $proof5#196218) (≞ (→ P R) (if (and (and (< 0 0.2) (and (<= (if (> 0 (if (< 1 (/ (- (+ 0.2 1) 1) 0.2)) 1 (/ (- (+ 0.2 1) 1) 0.2))) 0 (if (< 1 (/ (- (+ 0.2 1) 1) 0.2)) 1 (/ (- (+ 0.2 1) 1) 0.2))) $ABs#196223) (<= $ABs#196223 (if (> 0 (if (< 1 (/ 1 0.2)) 1 (/ 1 0.2))) 0 (if (< 1 (/ 1 0.2)) 1 (/ 1 0.2)))))) (and (< 0 1) (and (<= (if (> 0 (if (< 1 (/ (- (+ 1 0.4) 1) 1)) 1 (/ (- (+ 1 0.4) 1) 1))) 0 (if (< 1 (/ (- (+ 1 0.4) 1) 1)) 1 (/ (- (+ 1 0.4) 1) 1))) $QRs#196225) (<= $QRs#196225 (if (> 0 (if (< 1 (/ 0.4 1)) 1 (/ 0.4 1))) 0 (if (< 1 (/ 0.4 1)) 1 (/ 0.4 1))))))) (STV (if (< 0.9999 1) 0.4 (+ (* $ABs#196223 $QRs#196225) (/ (* (- 1 $ABs#196223) (- 0.4 (* 1 $QRs#196225))) (- 1 1)))) (min 0.3 (min 0.5 (min 0.1 (min $PQc#196229 $QRc#196230))))) (STV 1 0))))), (let* (((: $proof4#196217 (≞ (→ P (→ Q Q)) (STV $ABs#196223 $PQc#196229))) (synthesize (: $proof4#196217 (≞ (→ P (→ Q Q)) (STV $ABs#196223 $PQc#196229))) kb rb (S (S Z)))) ((: $proof5#196218 (≞ (→ (→ Q Q) R) (STV $QRs#196225 $QRc#196230))) (synthesize (: $proof5#196218 (≞ (→ (→ Q Q) R) (STV $QRs#196225 $QRc#196230))) kb rb (S (S Z))))) (: (Deduction Pm (EvidenceElimination (IDIBase Q7 Q7)) Rm $proof4#196217 $proof5#196218) (≞ (→ P R) (if (and (and (< 0 0.2) (and (<= (if (> 0 (if (< 1 (/ (- (+ 0.2 1) 1) 0.2)) 1 (/ (- (+ 0.2 1) 1) 0.2))) 0 (if (< 1 (/ (- (+ 0.2 1) 1) 0.2)) 1 (/ (- (+ 0.2 1) 1) 0.2))) $ABs#196223) (<= $ABs#196223 (if (> 0 (if (< 1 (/ 1 0.2)) 1 (/ 1 0.2))) 0 (if (< 1 (/ 1 0.2)) 1 (/ 1 0.2)))))) (and (< 0 1) (and (<= (if (> 0 (if (< 1 (/ (- (+ 1 0.4) 1) 1)) 1 (/ (- (+ 1 0.4) 1) 1))) 0 (if (< 1 (/ (- (+ 1 0.4) 1) 1)) 1 (/ (- (+ 1 0.4) 1) 1))) $QRs#196225) (<= $QRs#196225 (if (> 0 (if (< 1 (/ 0.4 1)) 1 (/ 0.4 1))) 0 (if (< 1 (/ 0.4 1)) 1 (/ 0.4 1))))))) (STV (if (< 0.9999 1) 0.4 (+ (* $ABs#196223 $QRs#196225) (/ (* (- 1 $ABs#196223) (- 0.4 (* 1 $QRs#196225))) (- 1 1)))) (min 0.3 (min 0.5 (min 0.1 (min $PQc#196229 $QRc#196230))))) (STV 1 0))))), (let* (((: $proof4#196217 (≞ (→ P (→ P Q)) (STV $ABs#196223 $PQc#196229))) (synthesize (: $proof4#196217 (≞ (→ P (→ P Q)) (STV $ABs#196223 $PQc#196229))) kb rb (S (S Z)))) ((: $proof5#196218 (≞ (→ (→ P Q) R) (STV $QRs#196225 $QRc#196230))) (synthesize (: $proof5#196218 (≞ (→ (→ P Q) R) (STV $QRs#196225 $QRc#196230))) kb rb (S (S Z))))) (: (Deduction Pm (EvidenceElimination (IDIBase P2 Q2)) Rm $proof4#196217 $proof5#196218) (≞ (→ P R) (if (and (and (< 0 0.2) (and (<= (if (> 0 (if (< 1 (/ (- (+ 0.2 0) 1) 0.2)) 1 (/ (- (+ 0.2 0) 1) 0.2))) 0 (if (< 1 (/ (- (+ 0.2 0) 1) 0.2)) 1 (/ (- (+ 0.2 0) 1) 0.2))) $ABs#196223) (<= $ABs#196223 (if (> 0 (if (< 1 (/ 0 0.2)) 1 (/ 0 0.2))) 0 (if (< 1 (/ 0 0.2)) 1 (/ 0 0.2)))))) (and (< 0 0) (and (<= (if (> 0 (if (< 1 (/ (- (+ 0 0.4) 1) 0)) 1 (/ (- (+ 0 0.4) 1) 0))) 0 (if (< 1 (/ (- (+ 0 0.4) 1) 0)) 1 (/ (- (+ 0 0.4) 1) 0))) $QRs#196225) (<= $QRs#196225 (if (> 0 (if (< 1 (/ 0.4 0)) 1 (/ 0.4 0))) 0 (if (< 1 (/ 0.4 0)) 1 (/ 0.4 0))))))) (STV (if (< 0.9999 0) 0.4 (+ (* $ABs#196223 $QRs#196225) (/ (* (- 1 $ABs#196223) (- 0.4 (* 0 $QRs#196225))) (- 1 0)))) (min 0.3 (min 0.5 (min 0.1 (min $PQc#196229 $QRc#196230))))) (STV 1 0))))), (let* (((: $proof2#248446 (⊷ R (S (S Z)) True)) (synthesize (: $proof2#248446 (⊷ R (S (S Z)) True)) kb rb (S (S Z))))) (: (IDIBase P2 $proof2#248446) (≞ (→ P R) (ETV (:: (S (S Z)) ∅) (STV 1 0.5))))), (let* (((: $proof2#248446 (⊷ R (S (S (S (S (S (S (S Z))))))) True)) (synthesize (: $proof2#248446 (⊷ R (S (S (S (S (S (S (S Z))))))) True)) kb rb (S (S Z))))) (: (IDIBase P7 $proof2#248446) (≞ (→ P R) (ETV (:: (S (S (S (S (S (S (S Z))))))) ∅) (STV 1 0.5))))), (let* (((: $proof2#251276 (⊷ R (S (S Z)) False)) (synthesize (: $proof2#251276 (⊷ R (S (S Z)) False)) kb rb (S (S Z))))) (: (IDIBase P2 $proof2#251276) (≞ (→ P R) (ETV (:: (S (S Z)) ∅) (STV 0 0.5))))), (let* (((: $proof2#251276 (⊷ R (S (S (S (S (S (S (S Z))))))) False)) (synthesize (: $proof2#251276 (⊷ R (S (S (S (S (S (S (S Z))))))) False)) kb rb (S (S Z))))) (: (IDIBase P7 $proof2#251276) (≞ (→ P R) (ETV (:: (S (S (S (S (S (S (S Z))))))) ∅) (STV 0 0.5)))))]")
P;HTML|
;                                          (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/pln/dependent-types/DeductionImplicationDirectIntroductionDTLTest.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/pln/dependent-types/DeductionImplicationDirectIntroductionDTLTest.metta)

;;;; Test DeductionDTL and ImplicationDirectionIntroductionDTL rules
;;;; Import the rules
<span class="ansi38-013099040"
>  !(import! &self ImplicationDirectIntroductionDTL.metta)

</span>[P;HTML|
;                                           (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/pln/dependent-types/ImplicationDirectIntroductionDTL.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/pln/dependent-types/ImplicationDirectIntroductionDTL.metta)
P;HTML|
;                                           (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/pln/dependent-types/ImplicationDirectIntroductionDTL.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/pln/dependent-types/ImplicationDirectIntroductionDTL.metta)

;;;; (: (Deduction Pm Qm Rm (EvidenceElimination (IDIBase P2 Q2)) QRm) (≞ (→ P R) (STV 0.18571428571428572 0.1)))
;;;; (: (Deduction Pm Qm Rm (EvidenceElimination (IDIBase P7 Q7)) QRm) (≞ (→ P R) (STV 0.9 0.1)))
;;;; Disabled because it takes to long (over an hour)
;;;; ! "===== Prove that P→R based on two pieces of evidence and deduction ====="
;;;; !(synthesize (: (Deduction Pm Qm Rm $PQ QRm) (≞ (→ P R) $etv)) kb rb (fromNumber 5))
;;;; MeTTa port of the Implication Direct Introduction PLN rule, encoded
;;;; as dependent types, i.e. propositions as types.
;;;;
;;;; See ImplicationDirectIntroductionEntail.metta for more detail on a
;;;; pseudo formal description.
;;;;
;;;; In the case of dependent types, inference rules are constructors of
;;;; the propositions to be proven.  Then a proof is an tree composed of
;;;; calls of such constructors.
;;;;
;;;; For instance assuming two inference rules
;;;;
;;;; ImplicationDirectIntroduction (IDI, for short)
;;;; Deduction (DED, for short)
;;;;
;;;; The following inference tree
;;;;
;;;; ...            ...
;;;; -----(IDI)     -----(IDI)
;;;; P → Q          Q → R
;;;; ---------------------(DED)
;;;;         P → R
;;;;
;;;; is represented by the following MeTTa expression
;;;;
;;;; (Deduction
;;;;    (ImplicationDirectIntroduction ...)
;;;;    (ImplicationDirectIntroduction ...))
;;;;
;;;; where the premises of ImplicationDirectIntroduction are left
;;;; undefined for now.
;;;;
;;;; How such propositions as types can be defined still remains to be
;;;; determined but ideally it may look something like
;;;;
;;;; (: Deduction
;;;;    (-> (≞ (→ $P $Q) $TV1)
;;;;        (≞ (→ $Q $R) $TV2)
;;;;        (≞ (→ $P $R) (deduction-formula $TV1 $TV2))))
;;;;
;;;; where ≞, → are dependent types, and formula is just a regular metta
;;;; function.
;;;; Import modules
<span class="ansi38-013099040"
>  !(import! &self ../../common/truthvalue/EvidentialTruthValue.metta)

</span>P;HTML|
;                                           (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/truthvalue/EvidentialTruthValue.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/truthvalue/EvidentialTruthValue.metta)
P;HTML|
;                                           (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/truthvalue/EvidentialTruthValue.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/truthvalue/EvidentialTruthValue.metta)

;;;; Evidential truth value type. Represent a truth value alongside its
;;;; evidence.
<span class="ansi38-013099040"
>  !(import! &self TruthValue.metta)

</span>P;HTML|
;                                           (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/truthvalue/TruthValue.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/truthvalue/TruthValue.metta)
P;HTML|
;                                           (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/truthvalue/TruthValue.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/truthvalue/TruthValue.metta)

;;;; Truth value type definition
;;;; Import modules
<span class="ansi38-013099040"
>  !(import! &self ../Num.metta)

</span>P;HTML|
;                                           (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/Num.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/Num.metta)
P;HTML|
;                                           (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/Num.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/Num.metta)

;;;; Collection of functions operating on numbers
;;;; Define max
<span class="ansi38-255165000"
>  (: max 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (max $x $y) 
    (if 
      (> $x $y) $x $y))
</span>;;;; Define min
<span class="ansi38-255165000"
>  (: min 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (min $x $y) 
    (if 
      (< $x $y) $x $y))
</span>;;;; Clamp a number to be within a certain range
<span class="ansi38-255165000"
>  (: clamp 
    (-> $a $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (clamp $x $l $u) 
    (max $l 
      (min $u $x)))
</span>;;;; Define abs
<span class="ansi38-255165000"
>  (: abs 
    (-> $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (abs $x) 
    (if 
      (< $x 0) 
      (* -1 $x) $x))
</span>;;;; Define <=
<span class="ansi38-255165000"
>  (: <= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (<= $x $y) 
    (or 
      (< $x $y) 
      (== $x $y)))
</span>;;;; Define >=
<span class="ansi38-255165000"
>  (: >= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (>= $x $y) 
    (or 
      (> $x $y) 
      (== $x $y)))
</span>;;;; Define approximately equal
<span class="ansi38-255165000"
>  (: approxEq 
    (-> $a $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (approxEq $x $y $epsilon) 
    (<= 
      (abs (- $x $y)) $epsilon))
</span>;;;; Define Nat
<span class="ansi38-255165000"
>  (: Nat Type)
</span><span class="ansi38-255165000"
>  (: Z Nat)
</span><span class="ansi38-255165000"
>  (: S 
    (-> Nat Nat))
</span>;;;; Define cast functions between Nat and Number
<span class="ansi38-255165000"
>  (: fromNumber 
    (-> Number Nat))
</span><span class="ansi38-255165000"
>  (= 
    (fromNumber $n) 
    (if 
      (<= $n 0) Z 
      (S (fromNumber (- $n 1)))))
</span><span class="ansi38-255165000"
>  (: fromNat 
    (-> Nat Number))
</span><span class="ansi38-255165000"
>  (= 
    (fromNat Z) 0)
</span><span class="ansi38-255165000"
>  (= 
    (fromNat (S $k)) 
    (+ 1 
      (fromNat $k)))
</span>;;;; Define a generic less than operator, ⩻, for Nat.  < cannot be used
;;;; because it is a built-in, its type is hardwired and cannot be
;;;; overloaded.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Nat Nat Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $ Z) False)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ Z 
      (S $)) True)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ 
      (S $x) 
      (S $y)) 
    (⩻ $x $y))
</span>;;;; Overload ⩻ for Number.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Number Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $x $y) 
    (< $x $y))
</span>;;;; Return the ceiling of a non negative number.  If the number is
;;;; negative it returns 1.
<span class="ansi38-255165000"
>  (: ceil 
    (-> Number Number))
</span><span class="ansi38-255165000"
>  (= 
    (ceil $n) 
    (fromNat (fromNumber $n)))
</span>;;;; Convert Number to Bool.  Anything above 0 converts to True.
<span class="ansi38-255165000"
>  (: number->bool 
    (-> Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (number->bool $x) 
    (< 0 $x))
</span>;;;; Convert Bool to Number.  False converts to 0, True converts to 1.
<span class="ansi38-255165000"
>  (: bool->number 
    (-> Bool Number))
</span><span class="ansi38-255165000"
>  (= 
    (bool->number False) 0)
</span><span class="ansi38-255165000"
>  (= 
    (bool->number True) 1)
</span>;;;; Define a less than type.  Note that it is purposefully different
;;;; than ⩻ as it is a type, not an operator.  Inhabitants of (⍃ x y)
;;;; are proofs that x ⩻ y == True.  For now ⍃ is only axiomatized for
;;;; Nat.
<span class="ansi38-255165000"
>  (: ⍃ 
    (-> $t $t Type))
</span>;;;; Zero is always less than the successor of something
<span class="ansi38-255165000"
>  (: 
    (zero-lt-succ-axiom) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (zero-lt-succ-axiom) 
    (: ZeroLTSucc 
      (⍃ Z 
        (S $k))))
</span>;;;; If x ⍃ y then (S x) ⍃ (S y)
<span class="ansi38-255165000"
>  (: 
    (succ-monotonicity-rule) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (succ-monotonicity-rule) 
    (: SuccMonotonicity 
      (-> 
        (⍃ $x $y) 
        (⍃ 
          (S $x) 
          (S $y)))))
</span>
Deterministic: ()
;;;;;;;;;;;;
;;;; Type ;;
;;;;;;;;;;;;
<span class="ansi38-255165000"
>  (: TruthValue Type)
</span>;;;;;;;;;;;;;;;;;;;;
;;;; Constructors ;;
;;;;;;;;;;;;;;;;;;;;
;;;; Boolean TV constructor
;;;; TODO: alternatively we could have (: ⊤ TruthValue) and (: ⊥ TruthValue)
<span class="ansi38-255165000"
>  (: Bl 
    (-> Bool TruthValue))
</span>;;;; First order probability TV constructor, i.e. mere probability.
<span class="ansi38-255165000"
>  (: Pr 
    (-> Number TruthValue))
</span>;;;; Simple Truth Value.  A Second order probability TV constructor,
;;;; i.e. probability and confidence.  The probability is in fact the
;;;; mode of the corresponding beta distribution.
<span class="ansi38-255165000"
>  (: STV 
    (-> Number Number TruthValue))
</span>;;;;;;;;;;;;;;;;;
;;;; Constants ;;
;;;;;;;;;;;;;;;;;
;;;; For now the underlying beta distributions have a Jeffreys prior,
;;;; i.e. the prior alpha and beta are 0.5.
<span class="ansi38-255165000"
>  (: prior-alpha 
    (-> Number))
</span><span class="ansi38-255165000"
>  (= 
    (prior-alpha) 0.5)
</span><span class="ansi38-255165000"
>  (: prior-beta 
    (-> Number))
</span><span class="ansi38-255165000"
>  (= 
    (prior-beta) 0.5)
</span>;;;; Lookahead
<span class="ansi38-255165000"
>  (: lookahead 
    (-> Number))
</span><span class="ansi38-255165000"
>  (= 
    (lookahead) 1.0)
</span>;;;; Maximum supported count (till +inf is supported, possibly).
<span class="ansi38-255165000"
>  (: max-count 
    (-> Number))
</span><span class="ansi38-255165000"
>  (= 
    (max-count) 1000000000.0)
</span>;;;;;;;;;;;;;;;
;;;; Methods ;;
;;;;;;;;;;;;;;;
;;;; Convert count to confidence using the formula
;;;;
;;;; confidence = count / (count + lookahead)
<span class="ansi38-255165000"
>  (: count->confidence 
    (-> Number Number))
</span><span class="ansi38-255165000"
>  (= 
    (count->confidence $cnt) 
    (/ $cnt 
      (+ $cnt 
        (lookahead))))
</span>;;;; Convert confidence to count using the formula
;;;;
;;;; count = (confidence * lookahead) / (1 - confidence)
<span class="ansi38-255165000"
>  (: confidence->count 
    (-> Number Number))
</span><span class="ansi38-255165000"
>  (= 
    (confidence->count $conf) 
    (if 
      (approxEq 1.0 $conf 1.0e-9) 
      (max-count) 
      (/ 
        (* $conf 
          (lookahead)) 
        (- 1.0 $conf))))
</span>;;;; Increment the negative count of a given truth value, by
;;;; incrementing its total count without incrementing the positive
;;;; count.
<span class="ansi38-255165000"
>  (: inc-neg-count 
    (-> TruthValue TruthValue))
</span><span class="ansi38-255165000"
>  (= 
    (inc-neg-count (STV $s $c)) 
    (let* 
      ( ($tot_cnt (confidence->count $c)) 
        ($pos_cnt (* $s $tot_cnt)) 
        ($new_tot_cnt (+ $tot_cnt 1))) 
      (STV 
        (/ $pos_cnt $new_tot_cnt) 
        (count->confidence $new_tot_cnt))))
</span>;;;; Increment the positive count of a given truth value, by
;;;; incrementing its total count and its positive count.
<span class="ansi38-255165000"
>  (: inc-pos-count 
    (-> TruthValue TruthValue))
</span><span class="ansi38-255165000"
>  (= 
    (inc-pos-count (STV $s $c)) 
    (let* 
      ( ($tot_cnt (confidence->count $c)) 
        ($pos_cnt (* $s $tot_cnt)) 
        ($new_pos_cnt (+ $pos_cnt 1)) 
        ($new_tot_cnt (+ $tot_cnt 1))) 
      (STV 
        (/ $new_pos_cnt $new_tot_cnt) 
        (count->confidence $new_tot_cnt))))
</span>;;;; Return the first order probability mode of the second order
;;;; distribution associated to a truth value.
<span class="ansi38-255165000"
>  (: mode 
    (-> TruthValue Number))
</span><span class="ansi38-255165000"
>  (= 
    (mode (Bl True)) 1.0)
</span><span class="ansi38-255165000"
>  (= 
    (mode (Bl False)) 0.0)
</span><span class="ansi38-255165000"
>  (= 
    (mode (Pr $pr)) $pr)
</span><span class="ansi38-255165000"
>  (= 
    (mode (STV $pr $)) $pr)
</span>;;;; Return the total count of a truth value.  For truth values not
;;;; capturing a notion of confidence, such as Bl or Pr then the count
;;;; is assumed to be a very large number (cause +inf does not seem to
;;;; be supported at the moment).
<span class="ansi38-255165000"
>  (: count 
    (-> TruthValue Number))
</span><span class="ansi38-255165000"
>  (= 
    (count (Bl $)) 
    (max-count))
</span><span class="ansi38-255165000"
>  (= 
    (count (Pr $)) 
    (max-count))
</span><span class="ansi38-255165000"
>  (= 
    (count (STV $ $conf)) 
    (confidence->count $conf))
</span>;;;; Return the confidence of a truth value.  For truth values not
;;;; capturing a notion of confidence, such as Bl or Pr then the
;;;; confidence is assumed to be 1.0.  For truth values capturing a
;;;; notion of confidence, such as STV, the formula to convert a count
;;;; into confidence is as follows
;;;;
;;;; confidence = count / (count + lookahead)
<span class="ansi38-255165000"
>  (: confidence 
    (-> TruthValue Number))
</span><span class="ansi38-255165000"
>  (= 
    (confidence (Bl $)) 1.0)
</span><span class="ansi38-255165000"
>  (= 
    (confidence (Pr $)) 1.0)
</span><span class="ansi38-255165000"
>  (= 
    (confidence (STV $ $conf)) $conf)
</span>;;;; Return the positive count of a truth value.
<span class="ansi38-255165000"
>  (: pos-count 
    (-> TruthValue Number))
</span><span class="ansi38-255165000"
>  (= 
    (pos-count $tv) 
    (* 
      (mode $tv) 
      (count $tv)))
</span>;;;; Return the negative count of a truth value.
<span class="ansi38-255165000"
>  (: neg-count 
    (-> TruthValue Number))
</span><span class="ansi38-255165000"
>  (= 
    (neg-count $tv) 
    (* 
      (- 1 
        (mode $tv)) 
      (count $tv)))
</span>;;;; Return the posterior alpha of a truth value
<span class="ansi38-255165000"
>  (: post-alpha 
    (-> TruthValue Number))
</span><span class="ansi38-255165000"
>  (= 
    (post-alpha $tv) 
    (+ 
      (prior-alpha) 
      (pos-count $tv)))
</span>;;;; Return the posterior beta of a truth value
<span class="ansi38-255165000"
>  (: post-beta 
    (-> TruthValue Number))
</span><span class="ansi38-255165000"
>  (= 
    (post-beta $tv) 
    (+ 
      (prior-beta) 
      (neg-count $tv)))
</span>;;;; Return the first order probability mean of the second order
;;;; distribution associated to a truth value.  For truth values not
;;;; capturing a notion of confidence, such as Bl or Pr then the
;;;; confidence is assumed to be 1.0.  For truth values capturing a
;;;; notion of confidence, such as STV, a beta distribution is assumed.
<span class="ansi38-255165000"
>  (: mean 
    (-> TruthValue Number))
</span><span class="ansi38-255165000"
>  (= 
    (mean (Bl True)) 1.0)
</span><span class="ansi38-255165000"
>  (= 
    (mean (Bl False)) 0.0)
</span><span class="ansi38-255165000"
>  (= 
    (mean (Pr $pr)) $pr)
</span><span class="ansi38-255165000"
>  (= 
    (mean (STV $pr $conf)) 
    (let* 
      ( ($a (post-alpha (STV $pr $conf))) ($b (post-beta (STV $pr $conf)))) 
      (/ $a 
        (+ $a $b))))
</span>
Last Result(2): ()
<span class="ansi38-013099040"
>  !(import! &self ../OrderedSet.metta)

</span>P;HTML|
;                                           (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/OrderedSet.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/OrderedSet.metta)
P;HTML|
;                                           (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/OrderedSet.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/OrderedSet.metta)

;;;; Import modules
<span class="ansi38-013099040"
>  !(import! &self Num.metta)

</span>P;HTML|
;                                           (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/Num.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/Num.metta)
P;HTML|
;                                           (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/Num.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/Num.metta)

;;;; Collection of functions operating on numbers
;;;; Define max
<span class="ansi38-255165000"
>  (: max 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (max $x $y) 
    (if 
      (> $x $y) $x $y))
</span>;;;; Define min
<span class="ansi38-255165000"
>  (: min 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (min $x $y) 
    (if 
      (< $x $y) $x $y))
</span>;;;; Clamp a number to be within a certain range
<span class="ansi38-255165000"
>  (: clamp 
    (-> $a $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (clamp $x $l $u) 
    (max $l 
      (min $u $x)))
</span>;;;; Define abs
<span class="ansi38-255165000"
>  (: abs 
    (-> $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (abs $x) 
    (if 
      (< $x 0) 
      (* -1 $x) $x))
</span>;;;; Define <=
<span class="ansi38-255165000"
>  (: <= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (<= $x $y) 
    (or 
      (< $x $y) 
      (== $x $y)))
</span>;;;; Define >=
<span class="ansi38-255165000"
>  (: >= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (>= $x $y) 
    (or 
      (> $x $y) 
      (== $x $y)))
</span>;;;; Define approximately equal
<span class="ansi38-255165000"
>  (: approxEq 
    (-> $a $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (approxEq $x $y $epsilon) 
    (<= 
      (abs (- $x $y)) $epsilon))
</span>;;;; Define Nat
<span class="ansi38-255165000"
>  (: Nat Type)
</span><span class="ansi38-255165000"
>  (: Z Nat)
</span><span class="ansi38-255165000"
>  (: S 
    (-> Nat Nat))
</span>;;;; Define cast functions between Nat and Number
<span class="ansi38-255165000"
>  (: fromNumber 
    (-> Number Nat))
</span><span class="ansi38-255165000"
>  (= 
    (fromNumber $n) 
    (if 
      (<= $n 0) Z 
      (S (fromNumber (- $n 1)))))
</span><span class="ansi38-255165000"
>  (: fromNat 
    (-> Nat Number))
</span><span class="ansi38-255165000"
>  (= 
    (fromNat Z) 0)
</span><span class="ansi38-255165000"
>  (= 
    (fromNat (S $k)) 
    (+ 1 
      (fromNat $k)))
</span>;;;; Define a generic less than operator, ⩻, for Nat.  < cannot be used
;;;; because it is a built-in, its type is hardwired and cannot be
;;;; overloaded.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Nat Nat Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $ Z) False)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ Z 
      (S $)) True)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ 
      (S $x) 
      (S $y)) 
    (⩻ $x $y))
</span>;;;; Overload ⩻ for Number.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Number Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $x $y) 
    (< $x $y))
</span>;;;; Return the ceiling of a non negative number.  If the number is
;;;; negative it returns 1.
<span class="ansi38-255165000"
>  (: ceil 
    (-> Number Number))
</span><span class="ansi38-255165000"
>  (= 
    (ceil $n) 
    (fromNat (fromNumber $n)))
</span>;;;; Convert Number to Bool.  Anything above 0 converts to True.
<span class="ansi38-255165000"
>  (: number->bool 
    (-> Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (number->bool $x) 
    (< 0 $x))
</span>;;;; Convert Bool to Number.  False converts to 0, True converts to 1.
<span class="ansi38-255165000"
>  (: bool->number 
    (-> Bool Number))
</span><span class="ansi38-255165000"
>  (= 
    (bool->number False) 0)
</span><span class="ansi38-255165000"
>  (= 
    (bool->number True) 1)
</span>;;;; Define a less than type.  Note that it is purposefully different
;;;; than ⩻ as it is a type, not an operator.  Inhabitants of (⍃ x y)
;;;; are proofs that x ⩻ y == True.  For now ⍃ is only axiomatized for
;;;; Nat.
<span class="ansi38-255165000"
>  (: ⍃ 
    (-> $t $t Type))
</span>;;;; Zero is always less than the successor of something
<span class="ansi38-255165000"
>  (: 
    (zero-lt-succ-axiom) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (zero-lt-succ-axiom) 
    (: ZeroLTSucc 
      (⍃ Z 
        (S $k))))
</span>;;;; If x ⍃ y then (S x) ⍃ (S y)
<span class="ansi38-255165000"
>  (: 
    (succ-monotonicity-rule) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (succ-monotonicity-rule) 
    (: SuccMonotonicity 
      (-> 
        (⍃ $x $y) 
        (⍃ 
          (S $x) 
          (S $y)))))
</span>;;;; Collection of functions operating on numbers
;;;; Define max
<span class="ansi38-255165000"
>  (: max 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (max $x $y) 
    (if 
      (> $x $y) $x $y))
</span>;;;; Define min
<span class="ansi38-255165000"
>  (: min 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (min $x $y) 
    (if 
      (< $x $y) $x $y))
</span>;;;; Clamp a number to be within a certain range
<span class="ansi38-255165000"
>  (: clamp 
    (-> $a $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (clamp $x $l $u) 
    (max $l 
      (min $u $x)))
</span>;;;; Define abs
<span class="ansi38-255165000"
>  (: abs 
    (-> $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (abs $x) 
    (if 
      (< $x 0) 
      (* -1 $x) $x))
</span>;;;; Define <=
<span class="ansi38-255165000"
>  (: <= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (<= $x $y) 
    (or 
      (< $x $y) 
      (== $x $y)))
</span>;;;; Define >=
<span class="ansi38-255165000"
>  (: >= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (>= $x $y) 
    (or 
      (> $x $y) 
      (== $x $y)))
</span>;;;; Define approximately equal
<span class="ansi38-255165000"
>  (: approxEq 
    (-> $a $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (approxEq $x $y $epsilon) 
    (<= 
      (abs (- $x $y)) $epsilon))
</span>;;;; Define Nat
<span class="ansi38-255165000"
>  (: Nat Type)
</span><span class="ansi38-255165000"
>  (: Z Nat)
</span><span class="ansi38-255165000"
>  (: S 
    (-> Nat Nat))
</span>;;;; Define cast functions between Nat and Number
<span class="ansi38-255165000"
>  (: fromNumber 
    (-> Number Nat))
</span><span class="ansi38-255165000"
>  (= 
    (fromNumber $n) 
    (if 
      (<= $n 0) Z 
      (S (fromNumber (- $n 1)))))
</span><span class="ansi38-255165000"
>  (: fromNat 
    (-> Nat Number))
</span><span class="ansi38-255165000"
>  (= 
    (fromNat Z) 0)
</span><span class="ansi38-255165000"
>  (= 
    (fromNat (S $k)) 
    (+ 1 
      (fromNat $k)))
</span>;;;; Define a generic less than operator, ⩻, for Nat.  < cannot be used
;;;; because it is a built-in, its type is hardwired and cannot be
;;;; overloaded.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Nat Nat Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $ Z) False)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ Z 
      (S $)) True)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ 
      (S $x) 
      (S $y)) 
    (⩻ $x $y))
</span>;;;; Overload ⩻ for Number.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Number Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $x $y) 
    (< $x $y))
</span>;;;; Return the ceiling of a non negative number.  If the number is
;;;; negative it returns 1.
<span class="ansi38-255165000"
>  (: ceil 
    (-> Number Number))
</span><span class="ansi38-255165000"
>  (= 
    (ceil $n) 
    (fromNat (fromNumber $n)))
</span>;;;; Convert Number to Bool.  Anything above 0 converts to True.
<span class="ansi38-255165000"
>  (: number->bool 
    (-> Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (number->bool $x) 
    (< 0 $x))
</span>;;;; Convert Bool to Number.  False converts to 0, True converts to 1.
<span class="ansi38-255165000"
>  (: bool->number 
    (-> Bool Number))
</span><span class="ansi38-255165000"
>  (= 
    (bool->number False) 0)
</span><span class="ansi38-255165000"
>  (= 
    (bool->number True) 1)
</span>;;;; Define a less than type.  Note that it is purposefully different
;;;; than ⩻ as it is a type, not an operator.  Inhabitants of (⍃ x y)
;;;; are proofs that x ⩻ y == True.  For now ⍃ is only axiomatized for
;;;; Nat.
<span class="ansi38-255165000"
>  (: ⍃ 
    (-> $t $t Type))
</span>;;;; Zero is always less than the successor of something
<span class="ansi38-255165000"
>  (: 
    (zero-lt-succ-axiom) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (zero-lt-succ-axiom) 
    (: ZeroLTSucc 
      (⍃ Z 
        (S $k))))
</span>;;;; If x ⍃ y then (S x) ⍃ (S y)
<span class="ansi38-255165000"
>  (: 
    (succ-monotonicity-rule) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (succ-monotonicity-rule) 
    (: SuccMonotonicity 
      (-> 
        (⍃ $x $y) 
        (⍃ 
          (S $x) 
          (S $y)))))
</span>
Deterministic: ()
;;;; Definition of a set data structure.  Under the hood it is a sorted
;;;; list without duplicates, thus called OrderedSet.  For now its
;;;; constructor :: is unconstrained, meaning it does not guaranty that
;;;; the constructed OrderedSet are sorted and without duplicates.
;;;; Rather this is delegated to the insert function defined below.  In
;;;; order to guaranty that it is sorted without duplicates, the
;;;; constructor :: would need to take an additional argument encoding a
;;;; proof that the element to prepend is less than the head of the set
;;;; to be prepended to.
<span class="ansi38-255165000"
>  (: OrderedSet 
    (-> $a Type))
</span><span class="ansi38-255165000"
>  (: ∅ 
    (OrderedSet $a))
</span><span class="ansi38-255165000"
>  (: :: 
    (-> $a 
      (OrderedSet $a) 
      (OrderedSet $a)))
</span>;;;; Check if an element is in a set.  TODO: optimize assuming it is
;;;; ordered.
<span class="ansi38-255165000"
>  (: elem 
    (-> $a 
      (OrderedSet $a) Bool))
</span><span class="ansi38-255165000"
>  (= 
    (elem $x ∅) False)
</span><span class="ansi38-255165000"
>  (= 
    (elem $x 
      (:: $h $t)) 
    (if 
      (== $x $h) True 
      (elem $x $t)))
</span>;;;; Insert an element into a set.  Only insert if the element is not
;;;; already in the set as to produce an ordered set.
<span class="ansi38-255165000"
>  (: insert 
    (-> $a 
      (OrderedSet $a) 
      (OrderedSet $a)))
</span><span class="ansi38-255165000"
>  (= 
    (insert $x ∅) 
    (:: $x ∅))
</span>;;; Base case
;;; Recursive step
;;; Present, no need to insert
;;; Use generic <
;;; Safely insert since $x < $h
<span class="ansi38-255165000"
>  (= 
    (insert $x 
      (:: $h $t)) 
    (if 
      (== $x $h) 
      (:: $h $t) 
      (if 
        (⩻ $x $h) 
        (:: $x 
          (:: $h $t)) 
        (:: $h 
          (insert $x $t)))))
</span>;;; Recursive call

Last Result(2): ()
;;;;;;;;;;;;
;;;; Type ;;
;;;;;;;;;;;;
<span class="ansi38-255165000"
>  (: EvidentialTruthValue Type)
</span>;;;;;;;;;;;;;;;;;;;;
;;;; Constructor ;;
;;;;;;;;;;;;;;;;;;;;
;;;; Takes an evidence set ascribed to a truth value to form an
;;;; evidential truth value.
<span class="ansi38-255165000"
>  (: ETV 
    (-> 
      (OrderedSet $a) TruthValue EvidentialTruthValue))
</span>;;;;;;;;;;;;;;;
;;;; Methods ;;
;;;;;;;;;;;;;;;
;;;; Access the truth value of an evidential truth value.
<span class="ansi38-255165000"
>  (: tv 
    (-> EvidentialTruthValue TruthValue))
</span><span class="ansi38-255165000"
>  (= 
    (tv (ETV $ev $tv)) $tv)
</span>;;;; Return the first order probability mode of the second order
;;;; distribution associated to an evidential truth value.
<span class="ansi38-255165000"
>  (: mode 
    (-> EvidentialTruthValue Number))
</span><span class="ansi38-255165000"
>  (= 
    (mode (ETV $ev $tv)) 
    (mode $tv))
</span>;;;; Return the total count of an evidential truth value.
<span class="ansi38-255165000"
>  (: count 
    (-> EvidentialTruthValue Number))
</span><span class="ansi38-255165000"
>  (= 
    (count (ETV $ev $tv)) 
    (count $tv))
</span>;;;; Return the positive count of a truth value.
<span class="ansi38-255165000"
>  (: pos_count 
    (-> EvidentialTruthValue Number))
</span><span class="ansi38-255165000"
>  (= 
    (pos_count (ETV $ev $tv)) 
    (* 
      (mode $tv) 
      (count $tv)))
</span>;;;; Return the negative count of a truth value.
<span class="ansi38-255165000"
>  (: neg_count 
    (-> EvidentialTruthValue Number))
</span><span class="ansi38-255165000"
>  (= 
    (neg_count (ETV $ev $tv)) 
    (* 
      (- 1 
        (mode $tv)) 
      (count $tv)))
</span>;;;; Return the posterior alpha of a truth value
<span class="ansi38-255165000"
>  (: post_alpha 
    (-> EvidentialTruthValue Number))
</span><span class="ansi38-255165000"
>  (= 
    (post_alpha (ETV $ev $tv)) 
    (+ 
      (prior_alpha) 
      (pos_count $tv)))
</span>;;;; Return the posterior beta of a truth value
<span class="ansi38-255165000"
>  (: post_beta 
    (-> EvidentialTruthValue Number))
</span><span class="ansi38-255165000"
>  (= 
    (post_beta (ETV $ev $tv)) 
    (+ 
      (prior_beta) 
      (neg_count $tv)))
</span>;;;; Return the first order probability mean of the second order
;;;; distribution associated to an evidential truth value.
<span class="ansi38-255165000"
>  (: mean 
    (-> EvidentialTruthValue Number))
</span><span class="ansi38-255165000"
>  (= 
    (mean (ETV $ev $tv)) 
    (mean $tv))
</span>;;;; Return the confidence of an evidential truth value.
<span class="ansi38-255165000"
>  (: confidence 
    (-> EvidentialTruthValue Number))
</span><span class="ansi38-255165000"
>  (= 
    (confidence (ETV $ev $tv)) 
    (confidence $tv))
</span>
Last Result(3): ()
<span class="ansi38-013099040"
>  !(import! &self ../../common/formula/ImplicationDirectIntroductionFormula.metta)

</span>P;HTML|
;                                           (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/formula/ImplicationDirectIntroductionFormula.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/formula/ImplicationDirectIntroductionFormula.metta)
P;HTML|
;                                           (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/formula/ImplicationDirectIntroductionFormula.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/formula/ImplicationDirectIntroductionFormula.metta)

;;;; Formula for the inductive Implication Direct Introduction rule.
;;;; Import modules
<span class="ansi38-013099040"
>  !(import! &self ../truthvalue/TruthValue.metta)

</span>P;HTML|
;                                           (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/truthvalue/TruthValue.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/truthvalue/TruthValue.metta)
P;HTML|
;                                           (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/truthvalue/TruthValue.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/truthvalue/TruthValue.metta)

;;;; Truth value type definition
;;;; Import modules
<span class="ansi38-013099040"
>  !(import! &self ../Num.metta)

</span>P;HTML|
;                                           (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/Num.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/Num.metta)
P;HTML|
;                                           (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/Num.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/Num.metta)

;;;; Collection of functions operating on numbers
;;;; Define max
<span class="ansi38-255165000"
>  (: max 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (max $x $y) 
    (if 
      (> $x $y) $x $y))
</span>;;;; Define min
<span class="ansi38-255165000"
>  (: min 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (min $x $y) 
    (if 
      (< $x $y) $x $y))
</span>;;;; Clamp a number to be within a certain range
<span class="ansi38-255165000"
>  (: clamp 
    (-> $a $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (clamp $x $l $u) 
    (max $l 
      (min $u $x)))
</span>;;;; Define abs
<span class="ansi38-255165000"
>  (: abs 
    (-> $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (abs $x) 
    (if 
      (< $x 0) 
      (* -1 $x) $x))
</span>;;;; Define <=
<span class="ansi38-255165000"
>  (: <= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (<= $x $y) 
    (or 
      (< $x $y) 
      (== $x $y)))
</span>;;;; Define >=
<span class="ansi38-255165000"
>  (: >= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (>= $x $y) 
    (or 
      (> $x $y) 
      (== $x $y)))
</span>;;;; Define approximately equal
<span class="ansi38-255165000"
>  (: approxEq 
    (-> $a $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (approxEq $x $y $epsilon) 
    (<= 
      (abs (- $x $y)) $epsilon))
</span>;;;; Define Nat
<span class="ansi38-255165000"
>  (: Nat Type)
</span><span class="ansi38-255165000"
>  (: Z Nat)
</span><span class="ansi38-255165000"
>  (: S 
    (-> Nat Nat))
</span>;;;; Define cast functions between Nat and Number
<span class="ansi38-255165000"
>  (: fromNumber 
    (-> Number Nat))
</span><span class="ansi38-255165000"
>  (= 
    (fromNumber $n) 
    (if 
      (<= $n 0) Z 
      (S (fromNumber (- $n 1)))))
</span><span class="ansi38-255165000"
>  (: fromNat 
    (-> Nat Number))
</span><span class="ansi38-255165000"
>  (= 
    (fromNat Z) 0)
</span><span class="ansi38-255165000"
>  (= 
    (fromNat (S $k)) 
    (+ 1 
      (fromNat $k)))
</span>;;;; Define a generic less than operator, ⩻, for Nat.  < cannot be used
;;;; because it is a built-in, its type is hardwired and cannot be
;;;; overloaded.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Nat Nat Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $ Z) False)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ Z 
      (S $)) True)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ 
      (S $x) 
      (S $y)) 
    (⩻ $x $y))
</span>;;;; Overload ⩻ for Number.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Number Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $x $y) 
    (< $x $y))
</span>;;;; Return the ceiling of a non negative number.  If the number is
;;;; negative it returns 1.
<span class="ansi38-255165000"
>  (: ceil 
    (-> Number Number))
</span><span class="ansi38-255165000"
>  (= 
    (ceil $n) 
    (fromNat (fromNumber $n)))
</span>;;;; Convert Number to Bool.  Anything above 0 converts to True.
<span class="ansi38-255165000"
>  (: number->bool 
    (-> Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (number->bool $x) 
    (< 0 $x))
</span>;;;; Convert Bool to Number.  False converts to 0, True converts to 1.
<span class="ansi38-255165000"
>  (: bool->number 
    (-> Bool Number))
</span><span class="ansi38-255165000"
>  (= 
    (bool->number False) 0)
</span><span class="ansi38-255165000"
>  (= 
    (bool->number True) 1)
</span>;;;; Define a less than type.  Note that it is purposefully different
;;;; than ⩻ as it is a type, not an operator.  Inhabitants of (⍃ x y)
;;;; are proofs that x ⩻ y == True.  For now ⍃ is only axiomatized for
;;;; Nat.
<span class="ansi38-255165000"
>  (: ⍃ 
    (-> $t $t Type))
</span>;;;; Zero is always less than the successor of something
<span class="ansi38-255165000"
>  (: 
    (zero-lt-succ-axiom) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (zero-lt-succ-axiom) 
    (: ZeroLTSucc 
      (⍃ Z 
        (S $k))))
</span>;;;; If x ⍃ y then (S x) ⍃ (S y)
<span class="ansi38-255165000"
>  (: 
    (succ-monotonicity-rule) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (succ-monotonicity-rule) 
    (: SuccMonotonicity 
      (-> 
        (⍃ $x $y) 
        (⍃ 
          (S $x) 
          (S $y)))))
</span>;;;; Collection of functions operating on numbers
;;;; Define max
<span class="ansi38-255165000"
>  (: max 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (max $x $y) 
    (if 
      (> $x $y) $x $y))
</span>;;;; Define min
<span class="ansi38-255165000"
>  (: min 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (min $x $y) 
    (if 
      (< $x $y) $x $y))
</span>;;;; Clamp a number to be within a certain range
<span class="ansi38-255165000"
>  (: clamp 
    (-> $a $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (clamp $x $l $u) 
    (max $l 
      (min $u $x)))
</span>;;;; Define abs
<span class="ansi38-255165000"
>  (: abs 
    (-> $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (abs $x) 
    (if 
      (< $x 0) 
      (* -1 $x) $x))
</span>;;;; Define <=
<span class="ansi38-255165000"
>  (: <= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (<= $x $y) 
    (or 
      (< $x $y) 
      (== $x $y)))
</span>;;;; Define >=
<span class="ansi38-255165000"
>  (: >= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (>= $x $y) 
    (or 
      (> $x $y) 
      (== $x $y)))
</span>;;;; Define approximately equal
<span class="ansi38-255165000"
>  (: approxEq 
    (-> $a $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (approxEq $x $y $epsilon) 
    (<= 
      (abs (- $x $y)) $epsilon))
</span>;;;; Define Nat
<span class="ansi38-255165000"
>  (: Nat Type)
</span><span class="ansi38-255165000"
>  (: Z Nat)
</span><span class="ansi38-255165000"
>  (: S 
    (-> Nat Nat))
</span>;;;; Define cast functions between Nat and Number
<span class="ansi38-255165000"
>  (: fromNumber 
    (-> Number Nat))
</span><span class="ansi38-255165000"
>  (= 
    (fromNumber $n) 
    (if 
      (<= $n 0) Z 
      (S (fromNumber (- $n 1)))))
</span><span class="ansi38-255165000"
>  (: fromNat 
    (-> Nat Number))
</span><span class="ansi38-255165000"
>  (= 
    (fromNat Z) 0)
</span><span class="ansi38-255165000"
>  (= 
    (fromNat (S $k)) 
    (+ 1 
      (fromNat $k)))
</span>;;;; Define a generic less than operator, ⩻, for Nat.  < cannot be used
;;;; because it is a built-in, its type is hardwired and cannot be
;;;; overloaded.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Nat Nat Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $ Z) False)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ Z 
      (S $)) True)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ 
      (S $x) 
      (S $y)) 
    (⩻ $x $y))
</span>;;;; Overload ⩻ for Number.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Number Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $x $y) 
    (< $x $y))
</span>;;;; Return the ceiling of a non negative number.  If the number is
;;;; negative it returns 1.
<span class="ansi38-255165000"
>  (: ceil 
    (-> Number Number))
</span><span class="ansi38-255165000"
>  (= 
    (ceil $n) 
    (fromNat (fromNumber $n)))
</span>;;;; Convert Number to Bool.  Anything above 0 converts to True.
<span class="ansi38-255165000"
>  (: number->bool 
    (-> Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (number->bool $x) 
    (< 0 $x))
</span>;;;; Convert Bool to Number.  False converts to 0, True converts to 1.
<span class="ansi38-255165000"
>  (: bool->number 
    (-> Bool Number))
</span><span class="ansi38-255165000"
>  (= 
    (bool->number False) 0)
</span><span class="ansi38-255165000"
>  (= 
    (bool->number True) 1)
</span>;;;; Define a less than type.  Note that it is purposefully different
;;;; than ⩻ as it is a type, not an operator.  Inhabitants of (⍃ x y)
;;;; are proofs that x ⩻ y == True.  For now ⍃ is only axiomatized for
;;;; Nat.
<span class="ansi38-255165000"
>  (: ⍃ 
    (-> $t $t Type))
</span>;;;; Zero is always less than the successor of something
<span class="ansi38-255165000"
>  (: 
    (zero-lt-succ-axiom) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (zero-lt-succ-axiom) 
    (: ZeroLTSucc 
      (⍃ Z 
        (S $k))))
</span>;;;; If x ⍃ y then (S x) ⍃ (S y)
<span class="ansi38-255165000"
>  (: 
    (succ-monotonicity-rule) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (succ-monotonicity-rule) 
    (: SuccMonotonicity 
      (-> 
        (⍃ $x $y) 
        (⍃ 
          (S $x) 
          (S $y)))))
</span>;;;; Collection of functions operating on numbers
;;;; Define max
<span class="ansi38-255165000"
>  (: max 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (max $x $y) 
    (if 
      (> $x $y) $x $y))
</span>;;;; Define min
<span class="ansi38-255165000"
>  (: min 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (min $x $y) 
    (if 
      (< $x $y) $x $y))
</span>;;;; Clamp a number to be within a certain range
<span class="ansi38-255165000"
>  (: clamp 
    (-> $a $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (clamp $x $l $u) 
    (max $l 
      (min $u $x)))
</span>;;;; Define abs
<span class="ansi38-255165000"
>  (: abs 
    (-> $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (abs $x) 
    (if 
      (< $x 0) 
      (* -1 $x) $x))
</span>;;;; Define <=
<span class="ansi38-255165000"
>  (: <= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (<= $x $y) 
    (or 
      (< $x $y) 
      (== $x $y)))
</span>;;;; Define >=
<span class="ansi38-255165000"
>  (: >= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (>= $x $y) 
    (or 
      (> $x $y) 
      (== $x $y)))
</span>;;;; Define approximately equal
<span class="ansi38-255165000"
>  (: approxEq 
    (-> $a $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (approxEq $x $y $epsilon) 
    (<= 
      (abs (- $x $y)) $epsilon))
</span>;;;; Define Nat
<span class="ansi38-255165000"
>  (: Nat Type)
</span><span class="ansi38-255165000"
>  (: Z Nat)
</span><span class="ansi38-255165000"
>  (: S 
    (-> Nat Nat))
</span>;;;; Define cast functions between Nat and Number
<span class="ansi38-255165000"
>  (: fromNumber 
    (-> Number Nat))
</span><span class="ansi38-255165000"
>  (= 
    (fromNumber $n) 
    (if 
      (<= $n 0) Z 
      (S (fromNumber (- $n 1)))))
</span><span class="ansi38-255165000"
>  (: fromNat 
    (-> Nat Number))
</span><span class="ansi38-255165000"
>  (= 
    (fromNat Z) 0)
</span><span class="ansi38-255165000"
>  (= 
    (fromNat (S $k)) 
    (+ 1 
      (fromNat $k)))
</span>;;;; Define a generic less than operator, ⩻, for Nat.  < cannot be used
;;;; because it is a built-in, its type is hardwired and cannot be
;;;; overloaded.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Nat Nat Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $ Z) False)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ Z 
      (S $)) True)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ 
      (S $x) 
      (S $y)) 
    (⩻ $x $y))
</span>;;;; Overload ⩻ for Number.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Number Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $x $y) 
    (< $x $y))
</span>;;;; Return the ceiling of a non negative number.  If the number is
;;;; negative it returns 1.
<span class="ansi38-255165000"
>  (: ceil 
    (-> Number Number))
</span><span class="ansi38-255165000"
>  (= 
    (ceil $n) 
    (fromNat (fromNumber $n)))
</span>;;;; Convert Number to Bool.  Anything above 0 converts to True.
<span class="ansi38-255165000"
>  (: number->bool 
    (-> Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (number->bool $x) 
    (< 0 $x))
</span>;;;; Convert Bool to Number.  False converts to 0, True converts to 1.
<span class="ansi38-255165000"
>  (: bool->number 
    (-> Bool Number))
</span><span class="ansi38-255165000"
>  (= 
    (bool->number False) 0)
</span><span class="ansi38-255165000"
>  (= 
    (bool->number True) 1)
</span>;;;; Define a less than type.  Note that it is purposefully different
;;;; than ⩻ as it is a type, not an operator.  Inhabitants of (⍃ x y)
;;;; are proofs that x ⩻ y == True.  For now ⍃ is only axiomatized for
;;;; Nat.
<span class="ansi38-255165000"
>  (: ⍃ 
    (-> $t $t Type))
</span>;;;; Zero is always less than the successor of something
<span class="ansi38-255165000"
>  (: 
    (zero-lt-succ-axiom) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (zero-lt-succ-axiom) 
    (: ZeroLTSucc 
      (⍃ Z 
        (S $k))))
</span>;;;; If x ⍃ y then (S x) ⍃ (S y)
<span class="ansi38-255165000"
>  (: 
    (succ-monotonicity-rule) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (succ-monotonicity-rule) 
    (: SuccMonotonicity 
      (-> 
        (⍃ $x $y) 
        (⍃ 
          (S $x) 
          (S $y)))))
</span>
Deterministic: ()
;;;;;;;;;;;;
;;;; Type ;;
;;;;;;;;;;;;
<span class="ansi38-255165000"
>  (: TruthValue Type)
</span>;;;;;;;;;;;;;;;;;;;;
;;;; Constructors ;;
;;;;;;;;;;;;;;;;;;;;
;;;; Boolean TV constructor
;;;; TODO: alternatively we could have (: ⊤ TruthValue) and (: ⊥ TruthValue)
<span class="ansi38-255165000"
>  (: Bl 
    (-> Bool TruthValue))
</span>;;;; First order probability TV constructor, i.e. mere probability.
<span class="ansi38-255165000"
>  (: Pr 
    (-> Number TruthValue))
</span>;;;; Simple Truth Value.  A Second order probability TV constructor,
;;;; i.e. probability and confidence.  The probability is in fact the
;;;; mode of the corresponding beta distribution.
<span class="ansi38-255165000"
>  (: STV 
    (-> Number Number TruthValue))
</span>;;;;;;;;;;;;;;;;;
;;;; Constants ;;
;;;;;;;;;;;;;;;;;
;;;; For now the underlying beta distributions have a Jeffreys prior,
;;;; i.e. the prior alpha and beta are 0.5.
<span class="ansi38-255165000"
>  (: prior-alpha 
    (-> Number))
</span><span class="ansi38-255165000"
>  (= 
    (prior-alpha) 0.5)
</span><span class="ansi38-255165000"
>  (: prior-beta 
    (-> Number))
</span><span class="ansi38-255165000"
>  (= 
    (prior-beta) 0.5)
</span>;;;; Lookahead
<span class="ansi38-255165000"
>  (: lookahead 
    (-> Number))
</span><span class="ansi38-255165000"
>  (= 
    (lookahead) 1.0)
</span>;;;; Maximum supported count (till +inf is supported, possibly).
<span class="ansi38-255165000"
>  (: max-count 
    (-> Number))
</span><span class="ansi38-255165000"
>  (= 
    (max-count) 1000000000.0)
</span>;;;;;;;;;;;;;;;
;;;; Methods ;;
;;;;;;;;;;;;;;;
;;;; Convert count to confidence using the formula
;;;;
;;;; confidence = count / (count + lookahead)
<span class="ansi38-255165000"
>  (: count->confidence 
    (-> Number Number))
</span><span class="ansi38-255165000"
>  (= 
    (count->confidence $cnt) 
    (/ $cnt 
      (+ $cnt 
        (lookahead))))
</span>;;;; Convert confidence to count using the formula
;;;;
;;;; count = (confidence * lookahead) / (1 - confidence)
<span class="ansi38-255165000"
>  (: confidence->count 
    (-> Number Number))
</span><span class="ansi38-255165000"
>  (= 
    (confidence->count $conf) 
    (if 
      (approxEq 1.0 $conf 1.0e-9) 
      (max-count) 
      (/ 
        (* $conf 
          (lookahead)) 
        (- 1.0 $conf))))
</span>;;;; Increment the negative count of a given truth value, by
;;;; incrementing its total count without incrementing the positive
;;;; count.
<span class="ansi38-255165000"
>  (: inc-neg-count 
    (-> TruthValue TruthValue))
</span><span class="ansi38-255165000"
>  (= 
    (inc-neg-count (STV $s $c)) 
    (let* 
      ( ($tot_cnt (confidence->count $c)) 
        ($pos_cnt (* $s $tot_cnt)) 
        ($new_tot_cnt (+ $tot_cnt 1))) 
      (STV 
        (/ $pos_cnt $new_tot_cnt) 
        (count->confidence $new_tot_cnt))))
</span>;;;; Increment the positive count of a given truth value, by
;;;; incrementing its total count and its positive count.
<span class="ansi38-255165000"
>  (: inc-pos-count 
    (-> TruthValue TruthValue))
</span><span class="ansi38-255165000"
>  (= 
    (inc-pos-count (STV $s $c)) 
    (let* 
      ( ($tot_cnt (confidence->count $c)) 
        ($pos_cnt (* $s $tot_cnt)) 
        ($new_pos_cnt (+ $pos_cnt 1)) 
        ($new_tot_cnt (+ $tot_cnt 1))) 
      (STV 
        (/ $new_pos_cnt $new_tot_cnt) 
        (count->confidence $new_tot_cnt))))
</span>;;;; Return the first order probability mode of the second order
;;;; distribution associated to a truth value.
<span class="ansi38-255165000"
>  (: mode 
    (-> TruthValue Number))
</span><span class="ansi38-255165000"
>  (= 
    (mode (Bl True)) 1.0)
</span><span class="ansi38-255165000"
>  (= 
    (mode (Bl False)) 0.0)
</span><span class="ansi38-255165000"
>  (= 
    (mode (Pr $pr)) $pr)
</span><span class="ansi38-255165000"
>  (= 
    (mode (STV $pr $)) $pr)
</span>;;;; Return the total count of a truth value.  For truth values not
;;;; capturing a notion of confidence, such as Bl or Pr then the count
;;;; is assumed to be a very large number (cause +inf does not seem to
;;;; be supported at the moment).
<span class="ansi38-255165000"
>  (: count 
    (-> TruthValue Number))
</span><span class="ansi38-255165000"
>  (= 
    (count (Bl $)) 
    (max-count))
</span><span class="ansi38-255165000"
>  (= 
    (count (Pr $)) 
    (max-count))
</span><span class="ansi38-255165000"
>  (= 
    (count (STV $ $conf)) 
    (confidence->count $conf))
</span>;;;; Return the confidence of a truth value.  For truth values not
;;;; capturing a notion of confidence, such as Bl or Pr then the
;;;; confidence is assumed to be 1.0.  For truth values capturing a
;;;; notion of confidence, such as STV, the formula to convert a count
;;;; into confidence is as follows
;;;;
;;;; confidence = count / (count + lookahead)
<span class="ansi38-255165000"
>  (: confidence 
    (-> TruthValue Number))
</span><span class="ansi38-255165000"
>  (= 
    (confidence (Bl $)) 1.0)
</span><span class="ansi38-255165000"
>  (= 
    (confidence (Pr $)) 1.0)
</span><span class="ansi38-255165000"
>  (= 
    (confidence (STV $ $conf)) $conf)
</span>;;;; Return the positive count of a truth value.
<span class="ansi38-255165000"
>  (: pos-count 
    (-> TruthValue Number))
</span><span class="ansi38-255165000"
>  (= 
    (pos-count $tv) 
    (* 
      (mode $tv) 
      (count $tv)))
</span>;;;; Return the negative count of a truth value.
<span class="ansi38-255165000"
>  (: neg-count 
    (-> TruthValue Number))
</span><span class="ansi38-255165000"
>  (= 
    (neg-count $tv) 
    (* 
      (- 1 
        (mode $tv)) 
      (count $tv)))
</span>;;;; Return the posterior alpha of a truth value
<span class="ansi38-255165000"
>  (: post-alpha 
    (-> TruthValue Number))
</span><span class="ansi38-255165000"
>  (= 
    (post-alpha $tv) 
    (+ 
      (prior-alpha) 
      (pos-count $tv)))
</span>;;;; Return the posterior beta of a truth value
<span class="ansi38-255165000"
>  (: post-beta 
    (-> TruthValue Number))
</span><span class="ansi38-255165000"
>  (= 
    (post-beta $tv) 
    (+ 
      (prior-beta) 
      (neg-count $tv)))
</span>;;;; Return the first order probability mean of the second order
;;;; distribution associated to a truth value.  For truth values not
;;;; capturing a notion of confidence, such as Bl or Pr then the
;;;; confidence is assumed to be 1.0.  For truth values capturing a
;;;; notion of confidence, such as STV, a beta distribution is assumed.
<span class="ansi38-255165000"
>  (: mean 
    (-> TruthValue Number))
</span><span class="ansi38-255165000"
>  (= 
    (mean (Bl True)) 1.0)
</span><span class="ansi38-255165000"
>  (= 
    (mean (Bl False)) 0.0)
</span><span class="ansi38-255165000"
>  (= 
    (mean (Pr $pr)) $pr)
</span><span class="ansi38-255165000"
>  (= 
    (mean (STV $pr $conf)) 
    (let* 
      ( ($a (post-alpha (STV $pr $conf))) ($b (post-beta (STV $pr $conf)))) 
      (/ $a 
        (+ $a $b))))
</span>;;;; Truth value type definition
;;;; Import modules
<span class="ansi38-013099040"
>  !(import! &self ../Num.metta)

</span>P;HTML|
;                                           (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/Num.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/Num.metta)
P;HTML|
;                                           (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/Num.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/Num.metta)

;;;; Collection of functions operating on numbers
;;;; Define max
<span class="ansi38-255165000"
>  (: max 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (max $x $y) 
    (if 
      (> $x $y) $x $y))
</span>;;;; Define min
<span class="ansi38-255165000"
>  (: min 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (min $x $y) 
    (if 
      (< $x $y) $x $y))
</span>;;;; Clamp a number to be within a certain range
<span class="ansi38-255165000"
>  (: clamp 
    (-> $a $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (clamp $x $l $u) 
    (max $l 
      (min $u $x)))
</span>;;;; Define abs
<span class="ansi38-255165000"
>  (: abs 
    (-> $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (abs $x) 
    (if 
      (< $x 0) 
      (* -1 $x) $x))
</span>;;;; Define <=
<span class="ansi38-255165000"
>  (: <= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (<= $x $y) 
    (or 
      (< $x $y) 
      (== $x $y)))
</span>;;;; Define >=
<span class="ansi38-255165000"
>  (: >= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (>= $x $y) 
    (or 
      (> $x $y) 
      (== $x $y)))
</span>;;;; Define approximately equal
<span class="ansi38-255165000"
>  (: approxEq 
    (-> $a $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (approxEq $x $y $epsilon) 
    (<= 
      (abs (- $x $y)) $epsilon))
</span>;;;; Define Nat
<span class="ansi38-255165000"
>  (: Nat Type)
</span><span class="ansi38-255165000"
>  (: Z Nat)
</span><span class="ansi38-255165000"
>  (: S 
    (-> Nat Nat))
</span>;;;; Define cast functions between Nat and Number
<span class="ansi38-255165000"
>  (: fromNumber 
    (-> Number Nat))
</span><span class="ansi38-255165000"
>  (= 
    (fromNumber $n) 
    (if 
      (<= $n 0) Z 
      (S (fromNumber (- $n 1)))))
</span><span class="ansi38-255165000"
>  (: fromNat 
    (-> Nat Number))
</span><span class="ansi38-255165000"
>  (= 
    (fromNat Z) 0)
</span><span class="ansi38-255165000"
>  (= 
    (fromNat (S $k)) 
    (+ 1 
      (fromNat $k)))
</span>;;;; Define a generic less than operator, ⩻, for Nat.  < cannot be used
;;;; because it is a built-in, its type is hardwired and cannot be
;;;; overloaded.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Nat Nat Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $ Z) False)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ Z 
      (S $)) True)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ 
      (S $x) 
      (S $y)) 
    (⩻ $x $y))
</span>;;;; Overload ⩻ for Number.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Number Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $x $y) 
    (< $x $y))
</span>;;;; Return the ceiling of a non negative number.  If the number is
;;;; negative it returns 1.
<span class="ansi38-255165000"
>  (: ceil 
    (-> Number Number))
</span><span class="ansi38-255165000"
>  (= 
    (ceil $n) 
    (fromNat (fromNumber $n)))
</span>;;;; Convert Number to Bool.  Anything above 0 converts to True.
<span class="ansi38-255165000"
>  (: number->bool 
    (-> Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (number->bool $x) 
    (< 0 $x))
</span>;;;; Convert Bool to Number.  False converts to 0, True converts to 1.
<span class="ansi38-255165000"
>  (: bool->number 
    (-> Bool Number))
</span><span class="ansi38-255165000"
>  (= 
    (bool->number False) 0)
</span><span class="ansi38-255165000"
>  (= 
    (bool->number True) 1)
</span>;;;; Define a less than type.  Note that it is purposefully different
;;;; than ⩻ as it is a type, not an operator.  Inhabitants of (⍃ x y)
;;;; are proofs that x ⩻ y == True.  For now ⍃ is only axiomatized for
;;;; Nat.
<span class="ansi38-255165000"
>  (: ⍃ 
    (-> $t $t Type))
</span>;;;; Zero is always less than the successor of something
<span class="ansi38-255165000"
>  (: 
    (zero-lt-succ-axiom) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (zero-lt-succ-axiom) 
    (: ZeroLTSucc 
      (⍃ Z 
        (S $k))))
</span>;;;; If x ⍃ y then (S x) ⍃ (S y)
<span class="ansi38-255165000"
>  (: 
    (succ-monotonicity-rule) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (succ-monotonicity-rule) 
    (: SuccMonotonicity 
      (-> 
        (⍃ $x $y) 
        (⍃ 
          (S $x) 
          (S $y)))))
</span>;;;; Collection of functions operating on numbers
;;;; Define max
<span class="ansi38-255165000"
>  (: max 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (max $x $y) 
    (if 
      (> $x $y) $x $y))
</span>;;;; Define min
<span class="ansi38-255165000"
>  (: min 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (min $x $y) 
    (if 
      (< $x $y) $x $y))
</span>;;;; Clamp a number to be within a certain range
<span class="ansi38-255165000"
>  (: clamp 
    (-> $a $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (clamp $x $l $u) 
    (max $l 
      (min $u $x)))
</span>;;;; Define abs
<span class="ansi38-255165000"
>  (: abs 
    (-> $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (abs $x) 
    (if 
      (< $x 0) 
      (* -1 $x) $x))
</span>;;;; Define <=
<span class="ansi38-255165000"
>  (: <= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (<= $x $y) 
    (or 
      (< $x $y) 
      (== $x $y)))
</span>;;;; Define >=
<span class="ansi38-255165000"
>  (: >= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (>= $x $y) 
    (or 
      (> $x $y) 
      (== $x $y)))
</span>;;;; Define approximately equal
<span class="ansi38-255165000"
>  (: approxEq 
    (-> $a $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (approxEq $x $y $epsilon) 
    (<= 
      (abs (- $x $y)) $epsilon))
</span>;;;; Define Nat
<span class="ansi38-255165000"
>  (: Nat Type)
</span><span class="ansi38-255165000"
>  (: Z Nat)
</span><span class="ansi38-255165000"
>  (: S 
    (-> Nat Nat))
</span>;;;; Define cast functions between Nat and Number
<span class="ansi38-255165000"
>  (: fromNumber 
    (-> Number Nat))
</span><span class="ansi38-255165000"
>  (= 
    (fromNumber $n) 
    (if 
      (<= $n 0) Z 
      (S (fromNumber (- $n 1)))))
</span><span class="ansi38-255165000"
>  (: fromNat 
    (-> Nat Number))
</span><span class="ansi38-255165000"
>  (= 
    (fromNat Z) 0)
</span><span class="ansi38-255165000"
>  (= 
    (fromNat (S $k)) 
    (+ 1 
      (fromNat $k)))
</span>;;;; Define a generic less than operator, ⩻, for Nat.  < cannot be used
;;;; because it is a built-in, its type is hardwired and cannot be
;;;; overloaded.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Nat Nat Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $ Z) False)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ Z 
      (S $)) True)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ 
      (S $x) 
      (S $y)) 
    (⩻ $x $y))
</span>;;;; Overload ⩻ for Number.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Number Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $x $y) 
    (< $x $y))
</span>;;;; Return the ceiling of a non negative number.  If the number is
;;;; negative it returns 1.
<span class="ansi38-255165000"
>  (: ceil 
    (-> Number Number))
</span><span class="ansi38-255165000"
>  (= 
    (ceil $n) 
    (fromNat (fromNumber $n)))
</span>;;;; Convert Number to Bool.  Anything above 0 converts to True.
<span class="ansi38-255165000"
>  (: number->bool 
    (-> Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (number->bool $x) 
    (< 0 $x))
</span>;;;; Convert Bool to Number.  False converts to 0, True converts to 1.
<span class="ansi38-255165000"
>  (: bool->number 
    (-> Bool Number))
</span><span class="ansi38-255165000"
>  (= 
    (bool->number False) 0)
</span><span class="ansi38-255165000"
>  (= 
    (bool->number True) 1)
</span>;;;; Define a less than type.  Note that it is purposefully different
;;;; than ⩻ as it is a type, not an operator.  Inhabitants of (⍃ x y)
;;;; are proofs that x ⩻ y == True.  For now ⍃ is only axiomatized for
;;;; Nat.
<span class="ansi38-255165000"
>  (: ⍃ 
    (-> $t $t Type))
</span>;;;; Zero is always less than the successor of something
<span class="ansi38-255165000"
>  (: 
    (zero-lt-succ-axiom) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (zero-lt-succ-axiom) 
    (: ZeroLTSucc 
      (⍃ Z 
        (S $k))))
</span>;;;; If x ⍃ y then (S x) ⍃ (S y)
<span class="ansi38-255165000"
>  (: 
    (succ-monotonicity-rule) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (succ-monotonicity-rule) 
    (: SuccMonotonicity 
      (-> 
        (⍃ $x $y) 
        (⍃ 
          (S $x) 
          (S $y)))))
</span>;;;; Collection of functions operating on numbers
;;;; Define max
<span class="ansi38-255165000"
>  (: max 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (max $x $y) 
    (if 
      (> $x $y) $x $y))
</span>;;;; Define min
<span class="ansi38-255165000"
>  (: min 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (min $x $y) 
    (if 
      (< $x $y) $x $y))
</span>;;;; Clamp a number to be within a certain range
<span class="ansi38-255165000"
>  (: clamp 
    (-> $a $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (clamp $x $l $u) 
    (max $l 
      (min $u $x)))
</span>;;;; Define abs
<span class="ansi38-255165000"
>  (: abs 
    (-> $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (abs $x) 
    (if 
      (< $x 0) 
      (* -1 $x) $x))
</span>;;;; Define <=
<span class="ansi38-255165000"
>  (: <= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (<= $x $y) 
    (or 
      (< $x $y) 
      (== $x $y)))
</span>;;;; Define >=
<span class="ansi38-255165000"
>  (: >= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (>= $x $y) 
    (or 
      (> $x $y) 
      (== $x $y)))
</span>;;;; Define approximately equal
<span class="ansi38-255165000"
>  (: approxEq 
    (-> $a $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (approxEq $x $y $epsilon) 
    (<= 
      (abs (- $x $y)) $epsilon))
</span>;;;; Define Nat
<span class="ansi38-255165000"
>  (: Nat Type)
</span><span class="ansi38-255165000"
>  (: Z Nat)
</span><span class="ansi38-255165000"
>  (: S 
    (-> Nat Nat))
</span>;;;; Define cast functions between Nat and Number
<span class="ansi38-255165000"
>  (: fromNumber 
    (-> Number Nat))
</span><span class="ansi38-255165000"
>  (= 
    (fromNumber $n) 
    (if 
      (<= $n 0) Z 
      (S (fromNumber (- $n 1)))))
</span><span class="ansi38-255165000"
>  (: fromNat 
    (-> Nat Number))
</span><span class="ansi38-255165000"
>  (= 
    (fromNat Z) 0)
</span><span class="ansi38-255165000"
>  (= 
    (fromNat (S $k)) 
    (+ 1 
      (fromNat $k)))
</span>;;;; Define a generic less than operator, ⩻, for Nat.  < cannot be used
;;;; because it is a built-in, its type is hardwired and cannot be
;;;; overloaded.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Nat Nat Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $ Z) False)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ Z 
      (S $)) True)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ 
      (S $x) 
      (S $y)) 
    (⩻ $x $y))
</span>;;;; Overload ⩻ for Number.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Number Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $x $y) 
    (< $x $y))
</span>;;;; Return the ceiling of a non negative number.  If the number is
;;;; negative it returns 1.
<span class="ansi38-255165000"
>  (: ceil 
    (-> Number Number))
</span><span class="ansi38-255165000"
>  (= 
    (ceil $n) 
    (fromNat (fromNumber $n)))
</span>;;;; Convert Number to Bool.  Anything above 0 converts to True.
<span class="ansi38-255165000"
>  (: number->bool 
    (-> Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (number->bool $x) 
    (< 0 $x))
</span>;;;; Convert Bool to Number.  False converts to 0, True converts to 1.
<span class="ansi38-255165000"
>  (: bool->number 
    (-> Bool Number))
</span><span class="ansi38-255165000"
>  (= 
    (bool->number False) 0)
</span><span class="ansi38-255165000"
>  (= 
    (bool->number True) 1)
</span>;;;; Define a less than type.  Note that it is purposefully different
;;;; than ⩻ as it is a type, not an operator.  Inhabitants of (⍃ x y)
;;;; are proofs that x ⩻ y == True.  For now ⍃ is only axiomatized for
;;;; Nat.
<span class="ansi38-255165000"
>  (: ⍃ 
    (-> $t $t Type))
</span>;;;; Zero is always less than the successor of something
<span class="ansi38-255165000"
>  (: 
    (zero-lt-succ-axiom) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (zero-lt-succ-axiom) 
    (: ZeroLTSucc 
      (⍃ Z 
        (S $k))))
</span>;;;; If x ⍃ y then (S x) ⍃ (S y)
<span class="ansi38-255165000"
>  (: 
    (succ-monotonicity-rule) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (succ-monotonicity-rule) 
    (: SuccMonotonicity 
      (-> 
        (⍃ $x $y) 
        (⍃ 
          (S $x) 
          (S $y)))))
</span>;;;; Collection of functions operating on numbers
;;;; Define max
<span class="ansi38-255165000"
>  (: max 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (max $x $y) 
    (if 
      (> $x $y) $x $y))
</span>;;;; Define min
<span class="ansi38-255165000"
>  (: min 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (min $x $y) 
    (if 
      (< $x $y) $x $y))
</span>;;;; Clamp a number to be within a certain range
<span class="ansi38-255165000"
>  (: clamp 
    (-> $a $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (clamp $x $l $u) 
    (max $l 
      (min $u $x)))
</span>;;;; Define abs
<span class="ansi38-255165000"
>  (: abs 
    (-> $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (abs $x) 
    (if 
      (< $x 0) 
      (* -1 $x) $x))
</span>;;;; Define <=
<span class="ansi38-255165000"
>  (: <= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (<= $x $y) 
    (or 
      (< $x $y) 
      (== $x $y)))
</span>;;;; Define >=
<span class="ansi38-255165000"
>  (: >= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (>= $x $y) 
    (or 
      (> $x $y) 
      (== $x $y)))
</span>;;;; Define approximately equal
<span class="ansi38-255165000"
>  (: approxEq 
    (-> $a $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (approxEq $x $y $epsilon) 
    (<= 
      (abs (- $x $y)) $epsilon))
</span>;;;; Define Nat
<span class="ansi38-255165000"
>  (: Nat Type)
</span><span class="ansi38-255165000"
>  (: Z Nat)
</span><span class="ansi38-255165000"
>  (: S 
    (-> Nat Nat))
</span>;;;; Define cast functions between Nat and Number
<span class="ansi38-255165000"
>  (: fromNumber 
    (-> Number Nat))
</span><span class="ansi38-255165000"
>  (= 
    (fromNumber $n) 
    (if 
      (<= $n 0) Z 
      (S (fromNumber (- $n 1)))))
</span><span class="ansi38-255165000"
>  (: fromNat 
    (-> Nat Number))
</span><span class="ansi38-255165000"
>  (= 
    (fromNat Z) 0)
</span><span class="ansi38-255165000"
>  (= 
    (fromNat (S $k)) 
    (+ 1 
      (fromNat $k)))
</span>;;;; Define a generic less than operator, ⩻, for Nat.  < cannot be used
;;;; because it is a built-in, its type is hardwired and cannot be
;;;; overloaded.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Nat Nat Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $ Z) False)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ Z 
      (S $)) True)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ 
      (S $x) 
      (S $y)) 
    (⩻ $x $y))
</span>;;;; Overload ⩻ for Number.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Number Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $x $y) 
    (< $x $y))
</span>;;;; Return the ceiling of a non negative number.  If the number is
;;;; negative it returns 1.
<span class="ansi38-255165000"
>  (: ceil 
    (-> Number Number))
</span><span class="ansi38-255165000"
>  (= 
    (ceil $n) 
    (fromNat (fromNumber $n)))
</span>;;;; Convert Number to Bool.  Anything above 0 converts to True.
<span class="ansi38-255165000"
>  (: number->bool 
    (-> Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (number->bool $x) 
    (< 0 $x))
</span>;;;; Convert Bool to Number.  False converts to 0, True converts to 1.
<span class="ansi38-255165000"
>  (: bool->number 
    (-> Bool Number))
</span><span class="ansi38-255165000"
>  (= 
    (bool->number False) 0)
</span><span class="ansi38-255165000"
>  (= 
    (bool->number True) 1)
</span>;;;; Define a less than type.  Note that it is purposefully different
;;;; than ⩻ as it is a type, not an operator.  Inhabitants of (⍃ x y)
;;;; are proofs that x ⩻ y == True.  For now ⍃ is only axiomatized for
;;;; Nat.
<span class="ansi38-255165000"
>  (: ⍃ 
    (-> $t $t Type))
</span>;;;; Zero is always less than the successor of something
<span class="ansi38-255165000"
>  (: 
    (zero-lt-succ-axiom) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (zero-lt-succ-axiom) 
    (: ZeroLTSucc 
      (⍃ Z 
        (S $k))))
</span>;;;; If x ⍃ y then (S x) ⍃ (S y)
<span class="ansi38-255165000"
>  (: 
    (succ-monotonicity-rule) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (succ-monotonicity-rule) 
    (: SuccMonotonicity 
      (-> 
        (⍃ $x $y) 
        (⍃ 
          (S $x) 
          (S $y)))))
</span>
Deterministic: ()
;;;;;;;;;;;;
;;;; Type ;;
;;;;;;;;;;;;
<span class="ansi38-255165000"
>  (: TruthValue Type)
</span>;;;;;;;;;;;;;;;;;;;;
;;;; Constructors ;;
;;;;;;;;;;;;;;;;;;;;
;;;; Boolean TV constructor
;;;; TODO: alternatively we could have (: ⊤ TruthValue) and (: ⊥ TruthValue)
<span class="ansi38-255165000"
>  (: Bl 
    (-> Bool TruthValue))
</span>;;;; First order probability TV constructor, i.e. mere probability.
<span class="ansi38-255165000"
>  (: Pr 
    (-> Number TruthValue))
</span>;;;; Simple Truth Value.  A Second order probability TV constructor,
;;;; i.e. probability and confidence.  The probability is in fact the
;;;; mode of the corresponding beta distribution.
<span class="ansi38-255165000"
>  (: STV 
    (-> Number Number TruthValue))
</span>;;;;;;;;;;;;;;;;;
;;;; Constants ;;
;;;;;;;;;;;;;;;;;
;;;; For now the underlying beta distributions have a Jeffreys prior,
;;;; i.e. the prior alpha and beta are 0.5.
<span class="ansi38-255165000"
>  (: prior-alpha 
    (-> Number))
</span><span class="ansi38-255165000"
>  (= 
    (prior-alpha) 0.5)
</span><span class="ansi38-255165000"
>  (: prior-beta 
    (-> Number))
</span><span class="ansi38-255165000"
>  (= 
    (prior-beta) 0.5)
</span>;;;; Lookahead
<span class="ansi38-255165000"
>  (: lookahead 
    (-> Number))
</span><span class="ansi38-255165000"
>  (= 
    (lookahead) 1.0)
</span>;;;; Maximum supported count (till +inf is supported, possibly).
<span class="ansi38-255165000"
>  (: max-count 
    (-> Number))
</span><span class="ansi38-255165000"
>  (= 
    (max-count) 1000000000.0)
</span>;;;;;;;;;;;;;;;
;;;; Methods ;;
;;;;;;;;;;;;;;;
;;;; Convert count to confidence using the formula
;;;;
;;;; confidence = count / (count + lookahead)
<span class="ansi38-255165000"
>  (: count->confidence 
    (-> Number Number))
</span><span class="ansi38-255165000"
>  (= 
    (count->confidence $cnt) 
    (/ $cnt 
      (+ $cnt 
        (lookahead))))
</span>;;;; Convert confidence to count using the formula
;;;;
;;;; count = (confidence * lookahead) / (1 - confidence)
<span class="ansi38-255165000"
>  (: confidence->count 
    (-> Number Number))
</span><span class="ansi38-255165000"
>  (= 
    (confidence->count $conf) 
    (if 
      (approxEq 1.0 $conf 1.0e-9) 
      (max-count) 
      (/ 
        (* $conf 
          (lookahead)) 
        (- 1.0 $conf))))
</span>;;;; Increment the negative count of a given truth value, by
;;;; incrementing its total count without incrementing the positive
;;;; count.
<span class="ansi38-255165000"
>  (: inc-neg-count 
    (-> TruthValue TruthValue))
</span><span class="ansi38-255165000"
>  (= 
    (inc-neg-count (STV $s $c)) 
    (let* 
      ( ($tot_cnt (confidence->count $c)) 
        ($pos_cnt (* $s $tot_cnt)) 
        ($new_tot_cnt (+ $tot_cnt 1))) 
      (STV 
        (/ $pos_cnt $new_tot_cnt) 
        (count->confidence $new_tot_cnt))))
</span>;;;; Increment the positive count of a given truth value, by
;;;; incrementing its total count and its positive count.
<span class="ansi38-255165000"
>  (: inc-pos-count 
    (-> TruthValue TruthValue))
</span><span class="ansi38-255165000"
>  (= 
    (inc-pos-count (STV $s $c)) 
    (let* 
      ( ($tot_cnt (confidence->count $c)) 
        ($pos_cnt (* $s $tot_cnt)) 
        ($new_pos_cnt (+ $pos_cnt 1)) 
        ($new_tot_cnt (+ $tot_cnt 1))) 
      (STV 
        (/ $new_pos_cnt $new_tot_cnt) 
        (count->confidence $new_tot_cnt))))
</span>;;;; Return the first order probability mode of the second order
;;;; distribution associated to a truth value.
<span class="ansi38-255165000"
>  (: mode 
    (-> TruthValue Number))
</span><span class="ansi38-255165000"
>  (= 
    (mode (Bl True)) 1.0)
</span><span class="ansi38-255165000"
>  (= 
    (mode (Bl False)) 0.0)
</span><span class="ansi38-255165000"
>  (= 
    (mode (Pr $pr)) $pr)
</span><span class="ansi38-255165000"
>  (= 
    (mode (STV $pr $)) $pr)
</span>;;;; Return the total count of a truth value.  For truth values not
;;;; capturing a notion of confidence, such as Bl or Pr then the count
;;;; is assumed to be a very large number (cause +inf does not seem to
;;;; be supported at the moment).
<span class="ansi38-255165000"
>  (: count 
    (-> TruthValue Number))
</span><span class="ansi38-255165000"
>  (= 
    (count (Bl $)) 
    (max-count))
</span><span class="ansi38-255165000"
>  (= 
    (count (Pr $)) 
    (max-count))
</span><span class="ansi38-255165000"
>  (= 
    (count (STV $ $conf)) 
    (confidence->count $conf))
</span>;;;; Return the confidence of a truth value.  For truth values not
;;;; capturing a notion of confidence, such as Bl or Pr then the
;;;; confidence is assumed to be 1.0.  For truth values capturing a
;;;; notion of confidence, such as STV, the formula to convert a count
;;;; into confidence is as follows
;;;;
;;;; confidence = count / (count + lookahead)
<span class="ansi38-255165000"
>  (: confidence 
    (-> TruthValue Number))
</span><span class="ansi38-255165000"
>  (= 
    (confidence (Bl $)) 1.0)
</span><span class="ansi38-255165000"
>  (= 
    (confidence (Pr $)) 1.0)
</span><span class="ansi38-255165000"
>  (= 
    (confidence (STV $ $conf)) $conf)
</span>;;;; Return the positive count of a truth value.
<span class="ansi38-255165000"
>  (: pos-count 
    (-> TruthValue Number))
</span><span class="ansi38-255165000"
>  (= 
    (pos-count $tv) 
    (* 
      (mode $tv) 
      (count $tv)))
</span>;;;; Return the negative count of a truth value.
<span class="ansi38-255165000"
>  (: neg-count 
    (-> TruthValue Number))
</span><span class="ansi38-255165000"
>  (= 
    (neg-count $tv) 
    (* 
      (- 1 
        (mode $tv)) 
      (count $tv)))
</span>;;;; Return the posterior alpha of a truth value
<span class="ansi38-255165000"
>  (: post-alpha 
    (-> TruthValue Number))
</span><span class="ansi38-255165000"
>  (= 
    (post-alpha $tv) 
    (+ 
      (prior-alpha) 
      (pos-count $tv)))
</span>;;;; Return the posterior beta of a truth value
<span class="ansi38-255165000"
>  (: post-beta 
    (-> TruthValue Number))
</span><span class="ansi38-255165000"
>  (= 
    (post-beta $tv) 
    (+ 
      (prior-beta) 
      (neg-count $tv)))
</span>;;;; Return the first order probability mean of the second order
;;;; distribution associated to a truth value.  For truth values not
;;;; capturing a notion of confidence, such as Bl or Pr then the
;;;; confidence is assumed to be 1.0.  For truth values capturing a
;;;; notion of confidence, such as STV, a beta distribution is assumed.
<span class="ansi38-255165000"
>  (: mean 
    (-> TruthValue Number))
</span><span class="ansi38-255165000"
>  (= 
    (mean (Bl True)) 1.0)
</span><span class="ansi38-255165000"
>  (= 
    (mean (Bl False)) 0.0)
</span><span class="ansi38-255165000"
>  (= 
    (mean (Pr $pr)) $pr)
</span><span class="ansi38-255165000"
>  (= 
    (mean (STV $pr $conf)) 
    (let* 
      ( ($a (post-alpha (STV $pr $conf))) ($b (post-beta (STV $pr $conf)))) 
      (/ $a 
        (+ $a $b))))
</span>
Last Result(2): ()
;;;; Alternate implication direct introduction formula assuming Boolean
;;;; evidence.  Base case, meaning there is only one piece of evidence.
<span class="ansi38-255165000"
>  (: direct-introduction-base-formula 
    (-> Bool TruthValue))
</span><span class="ansi38-255165000"
>  (= 
    (direct-introduction-base-formula $qa) 
    (STV 
      (bool->number $qa) 
      (count->confidence 1)))
</span>;;;; Alternate implication direct introduction formula.  Inductive case,
;;;; meaning the piece of evidence gets aggregated to another truth
;;;; value.
<span class="ansi38-255165000"
>  (: direct-introduction-recursive-formula 
    (-> Bool TruthValue TruthValue))
</span><span class="ansi38-255165000"
>  (= 
    (direct-introduction-recursive-formula False 
      (STV $PQs $PQc)) 
    (inc-neg-count (STV $PQs $PQc)))
</span><span class="ansi38-255165000"
>  (= 
    (direct-introduction-recursive-formula True 
      (STV $PQs $PQc)) 
    (inc-pos-count (STV $PQs $PQc)))
</span>
Last Result(3): ()
;;;;;;;;;;;;;;;;;;;;;;;
;;;; Rule Definition ;;
;;;;;;;;;;;;;;;;;;;;;;;
;;;; All rules are implemented as constructors of propositions encoded
;;;; as types.
;;;; To deal with an abritrary number of pieces of evidence the rule is
;;;; defined inductively.
;;;; Base case (one piece of evidence):
;;;;
;;;; (p a) = True
;;;; (q a) = qa
;;;; ⊢
;;;; p→q ≞ (ETV (:: a ∅) tv)
;;;;
;;;; where tv is calculated according to the direct introduction
;;;; formula.  Note that we don't bother to take into account pieces of
;;;; evidence that is not True on (p a), because it has no impact on the
;;;; resulting truth value otherwise.
;;;;
;;;; To avoid prematurely reducing (p a) = pa to pa = pa, the following
;;;; representation is used instead
;;;;
;;;; (⊷ p a pa)
;;;;
;;;; which can be read as "under p, the image of a is pa".
;;;;
;;;; ⊷ is essentially the Atomese equivalent of ExecutionLink.  It has
;;;; description: IMAGE OF, hexadecimal code: 0x22B7, unicode-math code:
;;;; \imageof and latex code: \multimapdotbothB.
<span class="ansi38-255165000"
>  (: implication-direct-introduction-base-rule 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (implication-direct-introduction-base-rule) 
    (: IDIBase 
      (-> 
        (⊷ $p $a True) 
        (⊷ $q $a $qa) 
        (≞ 
          (→ $p $q) 
          (ETV 
            (:: $a ∅) 
            (direct-introduction-base-formula $qa))))))
</span>;;;; Recursive step (more than one piece of evidence):
;;;;
;;;; (p a) = True
;;;; (q a) = qa
;;;; p→q ≞ (ETV (:: h t) pqtv)
;;;; h < a
;;;; ⊢
;;;; p→q ≞ (ETV (:: a (:: h t)) tv)
;;;;
;;;; where tv is calculated using the direct introduction formula.  Note
;;;; that we don't bother to take into account pieces of evidence that
;;;; is not True on (p a), because it has no impact on the resulting
;;;; truth value otherwise.
;;;;
;;;; To avoid prematurely reducing (p a) = pa to pa = pa, the following
;;;; representation is used instead
;;;;
;;;; (⊷ p a pa)
;;;;
;;;; which can be read as "under p, the image of a is pa".
;;;;
;;;; For a similar reason, the premise h < a is represented as
;;;;
;;;; h ⍃ a
;;;;
;;;; ⍃ is the axiomatized version of <.  It is defined in Num.metta.
;;;; The box around the less than sign is here to manifest its
;;;; axiomatic, as opposed to computational, nature.  It has
;;;; description: APL FUNCTIONAL SYMBOL QUAD LESS-THAN and hexadecimal
;;;; code: 0x2343.
;;;;
;;;; The h ⍃ a premise is there to garanty that evidence is not double
;;;; counted.
;;;;
;;;; Historical note: initially the premise
;;;;
;;;; h ⍃ a
;;;;
;;;; was replaced by
;;;;
;;;; a ∉ (:: h t)
;;;;
;;;; But then it was realized that it is far more efficient to enforce
;;;; the order in which evidence can be pilled up, than to prove that a
;;;; new piece of evidence does not belongs to an existing evidence set.
;;;; And now you know why time is the way it is.
<span class="ansi38-255165000"
>  (: implication-direct-introduction-recursive-rule 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (implication-direct-introduction-recursive-rule) 
    (: IDIRecursive 
      (-> 
        (⊷ $p $a True) 
        (⊷ $q $a $qa) 
        (≞ 
          (→ $p $q) 
          (ETV 
            (:: $h $t) $pqtv)) 
        (⍃ $h $a) 
        (≞ 
          (→ $p $q) 
          (ETV 
            (:: $a 
              (:: $h $t)) 
            (direct-introduction-recursive-formula $qa $pqtv))))))
</span>;;;; Convert an EvidenceTruthValue to a TruthValue (i.e. elimate the
;;;; evidential part).
;;;;
;;;; (ETV evidence tv)
;;;; ⊢
;;;; tv
<span class="ansi38-255165000"
>  (: evidence-elimination-rule 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (evidence-elimination-rule) 
    (: EvidenceElimination 
      (-> 
        (≞ $a 
          (ETV $evidence $tv)) 
        (≞ $a $tv))))
</span>
Last Result(4): ()
()]
<span class="ansi38-013099040"
>  !(import! &self DeductionDTL.metta)

</span>[P;HTML|
;                                           (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/pln/dependent-types/DeductionDTL.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/pln/dependent-types/DeductionDTL.metta)
P;HTML|
;                                           (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/pln/dependent-types/DeductionDTL.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/pln/dependent-types/DeductionDTL.metta)

;;;; MeTTa port for deduction PLN rule
;;;; as DTL (Dependent Type Language)
;;;;
;;;; (≞ P ptv)
;;;; (≞ Q qtv)
;;;; (≞ R rtv)
;;;; (≞ (→ P Q) tv1)
;;;; (≞ (→ Q R) tv2)
;;;; ⊢
;;;; (≞ (→ P R) TV)
;;;;
;;;; where ptv, qtv, rtv, tv1 and tv2 are truth values of the
;;;; premises P, Q, R, (→ P Q) and (→ Q R) respectively.
;;;; TV represents the resulting truth value of the conclusion.
;;;; Import modules
<span class="ansi38-013099040"
>  !(import! &self ../../common/truthvalue/MeasEq.metta)

</span>P;HTML|
;                                           (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/truthvalue/MeasEq.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/truthvalue/MeasEq.metta)
P;HTML|
;                                           (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/truthvalue/MeasEq.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/truthvalue/MeasEq.metta)

;;;; The symbol ≞, called Measured By in Unicode, and \measeq in LaTeX,
;;;; is used to represent the measure of an event.  This measure may be
;;;; boolean, probabilistic first or second order, evidential or
;;;; otherwise.  The idea of using a dedicated equality, as opposed to
;;;; regular definitional equality =, is to not conflate event and
;;;; measure which can lead to contradictions.
;;;; Define ≞ as a dependent type, assigning a truth value to an event.
<span class="ansi38-255165000"
>  (: ≞ 
    (-> $event $tv Type))
</span>
Deterministic: ()
<span class="ansi38-013099040"
>  !(import! &self ../../common/formula/DeductionFormula.metta)

</span>P;HTML|
;                                           (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/formula/DeductionFormula.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/formula/DeductionFormula.metta)
P;HTML|
;                                           (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/formula/DeductionFormula.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/formula/DeductionFormula.metta)

;;;; Formula and other functions used for the deduction rule
;;;; Import modules
<span class="ansi38-013099040"
>  !(import! &self ../truthvalue/TruthValue.metta)

</span>P;HTML|
;                                           (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/truthvalue/TruthValue.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/truthvalue/TruthValue.metta)
P;HTML|
;                                           (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/truthvalue/TruthValue.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/truthvalue/TruthValue.metta)

;;;; Truth value type definition
;;;; Import modules
<span class="ansi38-013099040"
>  !(import! &self ../Num.metta)

</span>P;HTML|
;                                           (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/Num.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/Num.metta)
P;HTML|
;                                           (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/Num.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/Num.metta)

;;;; Collection of functions operating on numbers
;;;; Define max
<span class="ansi38-255165000"
>  (: max 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (max $x $y) 
    (if 
      (> $x $y) $x $y))
</span>;;;; Define min
<span class="ansi38-255165000"
>  (: min 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (min $x $y) 
    (if 
      (< $x $y) $x $y))
</span>;;;; Clamp a number to be within a certain range
<span class="ansi38-255165000"
>  (: clamp 
    (-> $a $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (clamp $x $l $u) 
    (max $l 
      (min $u $x)))
</span>;;;; Define abs
<span class="ansi38-255165000"
>  (: abs 
    (-> $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (abs $x) 
    (if 
      (< $x 0) 
      (* -1 $x) $x))
</span>;;;; Define <=
<span class="ansi38-255165000"
>  (: <= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (<= $x $y) 
    (or 
      (< $x $y) 
      (== $x $y)))
</span>;;;; Define >=
<span class="ansi38-255165000"
>  (: >= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (>= $x $y) 
    (or 
      (> $x $y) 
      (== $x $y)))
</span>;;;; Define approximately equal
<span class="ansi38-255165000"
>  (: approxEq 
    (-> $a $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (approxEq $x $y $epsilon) 
    (<= 
      (abs (- $x $y)) $epsilon))
</span>;;;; Define Nat
<span class="ansi38-255165000"
>  (: Nat Type)
</span><span class="ansi38-255165000"
>  (: Z Nat)
</span><span class="ansi38-255165000"
>  (: S 
    (-> Nat Nat))
</span>;;;; Define cast functions between Nat and Number
<span class="ansi38-255165000"
>  (: fromNumber 
    (-> Number Nat))
</span><span class="ansi38-255165000"
>  (= 
    (fromNumber $n) 
    (if 
      (<= $n 0) Z 
      (S (fromNumber (- $n 1)))))
</span><span class="ansi38-255165000"
>  (: fromNat 
    (-> Nat Number))
</span><span class="ansi38-255165000"
>  (= 
    (fromNat Z) 0)
</span><span class="ansi38-255165000"
>  (= 
    (fromNat (S $k)) 
    (+ 1 
      (fromNat $k)))
</span>;;;; Define a generic less than operator, ⩻, for Nat.  < cannot be used
;;;; because it is a built-in, its type is hardwired and cannot be
;;;; overloaded.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Nat Nat Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $ Z) False)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ Z 
      (S $)) True)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ 
      (S $x) 
      (S $y)) 
    (⩻ $x $y))
</span>;;;; Overload ⩻ for Number.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Number Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $x $y) 
    (< $x $y))
</span>;;;; Return the ceiling of a non negative number.  If the number is
;;;; negative it returns 1.
<span class="ansi38-255165000"
>  (: ceil 
    (-> Number Number))
</span><span class="ansi38-255165000"
>  (= 
    (ceil $n) 
    (fromNat (fromNumber $n)))
</span>;;;; Convert Number to Bool.  Anything above 0 converts to True.
<span class="ansi38-255165000"
>  (: number->bool 
    (-> Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (number->bool $x) 
    (< 0 $x))
</span>;;;; Convert Bool to Number.  False converts to 0, True converts to 1.
<span class="ansi38-255165000"
>  (: bool->number 
    (-> Bool Number))
</span><span class="ansi38-255165000"
>  (= 
    (bool->number False) 0)
</span><span class="ansi38-255165000"
>  (= 
    (bool->number True) 1)
</span>;;;; Define a less than type.  Note that it is purposefully different
;;;; than ⩻ as it is a type, not an operator.  Inhabitants of (⍃ x y)
;;;; are proofs that x ⩻ y == True.  For now ⍃ is only axiomatized for
;;;; Nat.
<span class="ansi38-255165000"
>  (: ⍃ 
    (-> $t $t Type))
</span>;;;; Zero is always less than the successor of something
<span class="ansi38-255165000"
>  (: 
    (zero-lt-succ-axiom) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (zero-lt-succ-axiom) 
    (: ZeroLTSucc 
      (⍃ Z 
        (S $k))))
</span>;;;; If x ⍃ y then (S x) ⍃ (S y)
<span class="ansi38-255165000"
>  (: 
    (succ-monotonicity-rule) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (succ-monotonicity-rule) 
    (: SuccMonotonicity 
      (-> 
        (⍃ $x $y) 
        (⍃ 
          (S $x) 
          (S $y)))))
</span>;;;; Collection of functions operating on numbers
;;;; Define max
<span class="ansi38-255165000"
>  (: max 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (max $x $y) 
    (if 
      (> $x $y) $x $y))
</span>;;;; Define min
<span class="ansi38-255165000"
>  (: min 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (min $x $y) 
    (if 
      (< $x $y) $x $y))
</span>;;;; Clamp a number to be within a certain range
<span class="ansi38-255165000"
>  (: clamp 
    (-> $a $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (clamp $x $l $u) 
    (max $l 
      (min $u $x)))
</span>;;;; Define abs
<span class="ansi38-255165000"
>  (: abs 
    (-> $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (abs $x) 
    (if 
      (< $x 0) 
      (* -1 $x) $x))
</span>;;;; Define <=
<span class="ansi38-255165000"
>  (: <= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (<= $x $y) 
    (or 
      (< $x $y) 
      (== $x $y)))
</span>;;;; Define >=
<span class="ansi38-255165000"
>  (: >= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (>= $x $y) 
    (or 
      (> $x $y) 
      (== $x $y)))
</span>;;;; Define approximately equal
<span class="ansi38-255165000"
>  (: approxEq 
    (-> $a $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (approxEq $x $y $epsilon) 
    (<= 
      (abs (- $x $y)) $epsilon))
</span>;;;; Define Nat
<span class="ansi38-255165000"
>  (: Nat Type)
</span><span class="ansi38-255165000"
>  (: Z Nat)
</span><span class="ansi38-255165000"
>  (: S 
    (-> Nat Nat))
</span>;;;; Define cast functions between Nat and Number
<span class="ansi38-255165000"
>  (: fromNumber 
    (-> Number Nat))
</span><span class="ansi38-255165000"
>  (= 
    (fromNumber $n) 
    (if 
      (<= $n 0) Z 
      (S (fromNumber (- $n 1)))))
</span><span class="ansi38-255165000"
>  (: fromNat 
    (-> Nat Number))
</span><span class="ansi38-255165000"
>  (= 
    (fromNat Z) 0)
</span><span class="ansi38-255165000"
>  (= 
    (fromNat (S $k)) 
    (+ 1 
      (fromNat $k)))
</span>;;;; Define a generic less than operator, ⩻, for Nat.  < cannot be used
;;;; because it is a built-in, its type is hardwired and cannot be
;;;; overloaded.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Nat Nat Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $ Z) False)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ Z 
      (S $)) True)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ 
      (S $x) 
      (S $y)) 
    (⩻ $x $y))
</span>;;;; Overload ⩻ for Number.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Number Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $x $y) 
    (< $x $y))
</span>;;;; Return the ceiling of a non negative number.  If the number is
;;;; negative it returns 1.
<span class="ansi38-255165000"
>  (: ceil 
    (-> Number Number))
</span><span class="ansi38-255165000"
>  (= 
    (ceil $n) 
    (fromNat (fromNumber $n)))
</span>;;;; Convert Number to Bool.  Anything above 0 converts to True.
<span class="ansi38-255165000"
>  (: number->bool 
    (-> Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (number->bool $x) 
    (< 0 $x))
</span>;;;; Convert Bool to Number.  False converts to 0, True converts to 1.
<span class="ansi38-255165000"
>  (: bool->number 
    (-> Bool Number))
</span><span class="ansi38-255165000"
>  (= 
    (bool->number False) 0)
</span><span class="ansi38-255165000"
>  (= 
    (bool->number True) 1)
</span>;;;; Define a less than type.  Note that it is purposefully different
;;;; than ⩻ as it is a type, not an operator.  Inhabitants of (⍃ x y)
;;;; are proofs that x ⩻ y == True.  For now ⍃ is only axiomatized for
;;;; Nat.
<span class="ansi38-255165000"
>  (: ⍃ 
    (-> $t $t Type))
</span>;;;; Zero is always less than the successor of something
<span class="ansi38-255165000"
>  (: 
    (zero-lt-succ-axiom) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (zero-lt-succ-axiom) 
    (: ZeroLTSucc 
      (⍃ Z 
        (S $k))))
</span>;;;; If x ⍃ y then (S x) ⍃ (S y)
<span class="ansi38-255165000"
>  (: 
    (succ-monotonicity-rule) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (succ-monotonicity-rule) 
    (: SuccMonotonicity 
      (-> 
        (⍃ $x $y) 
        (⍃ 
          (S $x) 
          (S $y)))))
</span>;;;; Collection of functions operating on numbers
;;;; Define max
<span class="ansi38-255165000"
>  (: max 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (max $x $y) 
    (if 
      (> $x $y) $x $y))
</span>;;;; Define min
<span class="ansi38-255165000"
>  (: min 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (min $x $y) 
    (if 
      (< $x $y) $x $y))
</span>;;;; Clamp a number to be within a certain range
<span class="ansi38-255165000"
>  (: clamp 
    (-> $a $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (clamp $x $l $u) 
    (max $l 
      (min $u $x)))
</span>;;;; Define abs
<span class="ansi38-255165000"
>  (: abs 
    (-> $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (abs $x) 
    (if 
      (< $x 0) 
      (* -1 $x) $x))
</span>;;;; Define <=
<span class="ansi38-255165000"
>  (: <= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (<= $x $y) 
    (or 
      (< $x $y) 
      (== $x $y)))
</span>;;;; Define >=
<span class="ansi38-255165000"
>  (: >= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (>= $x $y) 
    (or 
      (> $x $y) 
      (== $x $y)))
</span>;;;; Define approximately equal
<span class="ansi38-255165000"
>  (: approxEq 
    (-> $a $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (approxEq $x $y $epsilon) 
    (<= 
      (abs (- $x $y)) $epsilon))
</span>;;;; Define Nat
<span class="ansi38-255165000"
>  (: Nat Type)
</span><span class="ansi38-255165000"
>  (: Z Nat)
</span><span class="ansi38-255165000"
>  (: S 
    (-> Nat Nat))
</span>;;;; Define cast functions between Nat and Number
<span class="ansi38-255165000"
>  (: fromNumber 
    (-> Number Nat))
</span><span class="ansi38-255165000"
>  (= 
    (fromNumber $n) 
    (if 
      (<= $n 0) Z 
      (S (fromNumber (- $n 1)))))
</span><span class="ansi38-255165000"
>  (: fromNat 
    (-> Nat Number))
</span><span class="ansi38-255165000"
>  (= 
    (fromNat Z) 0)
</span><span class="ansi38-255165000"
>  (= 
    (fromNat (S $k)) 
    (+ 1 
      (fromNat $k)))
</span>;;;; Define a generic less than operator, ⩻, for Nat.  < cannot be used
;;;; because it is a built-in, its type is hardwired and cannot be
;;;; overloaded.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Nat Nat Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $ Z) False)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ Z 
      (S $)) True)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ 
      (S $x) 
      (S $y)) 
    (⩻ $x $y))
</span>;;;; Overload ⩻ for Number.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Number Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $x $y) 
    (< $x $y))
</span>;;;; Return the ceiling of a non negative number.  If the number is
;;;; negative it returns 1.
<span class="ansi38-255165000"
>  (: ceil 
    (-> Number Number))
</span><span class="ansi38-255165000"
>  (= 
    (ceil $n) 
    (fromNat (fromNumber $n)))
</span>;;;; Convert Number to Bool.  Anything above 0 converts to True.
<span class="ansi38-255165000"
>  (: number->bool 
    (-> Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (number->bool $x) 
    (< 0 $x))
</span>;;;; Convert Bool to Number.  False converts to 0, True converts to 1.
<span class="ansi38-255165000"
>  (: bool->number 
    (-> Bool Number))
</span><span class="ansi38-255165000"
>  (= 
    (bool->number False) 0)
</span><span class="ansi38-255165000"
>  (= 
    (bool->number True) 1)
</span>;;;; Define a less than type.  Note that it is purposefully different
;;;; than ⩻ as it is a type, not an operator.  Inhabitants of (⍃ x y)
;;;; are proofs that x ⩻ y == True.  For now ⍃ is only axiomatized for
;;;; Nat.
<span class="ansi38-255165000"
>  (: ⍃ 
    (-> $t $t Type))
</span>;;;; Zero is always less than the successor of something
<span class="ansi38-255165000"
>  (: 
    (zero-lt-succ-axiom) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (zero-lt-succ-axiom) 
    (: ZeroLTSucc 
      (⍃ Z 
        (S $k))))
</span>;;;; If x ⍃ y then (S x) ⍃ (S y)
<span class="ansi38-255165000"
>  (: 
    (succ-monotonicity-rule) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (succ-monotonicity-rule) 
    (: SuccMonotonicity 
      (-> 
        (⍃ $x $y) 
        (⍃ 
          (S $x) 
          (S $y)))))
</span>;;;; Collection of functions operating on numbers
;;;; Define max
<span class="ansi38-255165000"
>  (: max 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (max $x $y) 
    (if 
      (> $x $y) $x $y))
</span>;;;; Define min
<span class="ansi38-255165000"
>  (: min 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (min $x $y) 
    (if 
      (< $x $y) $x $y))
</span>;;;; Clamp a number to be within a certain range
<span class="ansi38-255165000"
>  (: clamp 
    (-> $a $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (clamp $x $l $u) 
    (max $l 
      (min $u $x)))
</span>;;;; Define abs
<span class="ansi38-255165000"
>  (: abs 
    (-> $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (abs $x) 
    (if 
      (< $x 0) 
      (* -1 $x) $x))
</span>;;;; Define <=
<span class="ansi38-255165000"
>  (: <= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (<= $x $y) 
    (or 
      (< $x $y) 
      (== $x $y)))
</span>;;;; Define >=
<span class="ansi38-255165000"
>  (: >= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (>= $x $y) 
    (or 
      (> $x $y) 
      (== $x $y)))
</span>;;;; Define approximately equal
<span class="ansi38-255165000"
>  (: approxEq 
    (-> $a $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (approxEq $x $y $epsilon) 
    (<= 
      (abs (- $x $y)) $epsilon))
</span>;;;; Define Nat
<span class="ansi38-255165000"
>  (: Nat Type)
</span><span class="ansi38-255165000"
>  (: Z Nat)
</span><span class="ansi38-255165000"
>  (: S 
    (-> Nat Nat))
</span>;;;; Define cast functions between Nat and Number
<span class="ansi38-255165000"
>  (: fromNumber 
    (-> Number Nat))
</span><span class="ansi38-255165000"
>  (= 
    (fromNumber $n) 
    (if 
      (<= $n 0) Z 
      (S (fromNumber (- $n 1)))))
</span><span class="ansi38-255165000"
>  (: fromNat 
    (-> Nat Number))
</span><span class="ansi38-255165000"
>  (= 
    (fromNat Z) 0)
</span><span class="ansi38-255165000"
>  (= 
    (fromNat (S $k)) 
    (+ 1 
      (fromNat $k)))
</span>;;;; Define a generic less than operator, ⩻, for Nat.  < cannot be used
;;;; because it is a built-in, its type is hardwired and cannot be
;;;; overloaded.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Nat Nat Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $ Z) False)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ Z 
      (S $)) True)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ 
      (S $x) 
      (S $y)) 
    (⩻ $x $y))
</span>;;;; Overload ⩻ for Number.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Number Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $x $y) 
    (< $x $y))
</span>;;;; Return the ceiling of a non negative number.  If the number is
;;;; negative it returns 1.
<span class="ansi38-255165000"
>  (: ceil 
    (-> Number Number))
</span><span class="ansi38-255165000"
>  (= 
    (ceil $n) 
    (fromNat (fromNumber $n)))
</span>;;;; Convert Number to Bool.  Anything above 0 converts to True.
<span class="ansi38-255165000"
>  (: number->bool 
    (-> Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (number->bool $x) 
    (< 0 $x))
</span>;;;; Convert Bool to Number.  False converts to 0, True converts to 1.
<span class="ansi38-255165000"
>  (: bool->number 
    (-> Bool Number))
</span><span class="ansi38-255165000"
>  (= 
    (bool->number False) 0)
</span><span class="ansi38-255165000"
>  (= 
    (bool->number True) 1)
</span>;;;; Define a less than type.  Note that it is purposefully different
;;;; than ⩻ as it is a type, not an operator.  Inhabitants of (⍃ x y)
;;;; are proofs that x ⩻ y == True.  For now ⍃ is only axiomatized for
;;;; Nat.
<span class="ansi38-255165000"
>  (: ⍃ 
    (-> $t $t Type))
</span>;;;; Zero is always less than the successor of something
<span class="ansi38-255165000"
>  (: 
    (zero-lt-succ-axiom) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (zero-lt-succ-axiom) 
    (: ZeroLTSucc 
      (⍃ Z 
        (S $k))))
</span>;;;; If x ⍃ y then (S x) ⍃ (S y)
<span class="ansi38-255165000"
>  (: 
    (succ-monotonicity-rule) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (succ-monotonicity-rule) 
    (: SuccMonotonicity 
      (-> 
        (⍃ $x $y) 
        (⍃ 
          (S $x) 
          (S $y)))))
</span>;;;; Collection of functions operating on numbers
;;;; Define max
<span class="ansi38-255165000"
>  (: max 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (max $x $y) 
    (if 
      (> $x $y) $x $y))
</span>;;;; Define min
<span class="ansi38-255165000"
>  (: min 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (min $x $y) 
    (if 
      (< $x $y) $x $y))
</span>;;;; Clamp a number to be within a certain range
<span class="ansi38-255165000"
>  (: clamp 
    (-> $a $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (clamp $x $l $u) 
    (max $l 
      (min $u $x)))
</span>;;;; Define abs
<span class="ansi38-255165000"
>  (: abs 
    (-> $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (abs $x) 
    (if 
      (< $x 0) 
      (* -1 $x) $x))
</span>;;;; Define <=
<span class="ansi38-255165000"
>  (: <= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (<= $x $y) 
    (or 
      (< $x $y) 
      (== $x $y)))
</span>;;;; Define >=
<span class="ansi38-255165000"
>  (: >= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (>= $x $y) 
    (or 
      (> $x $y) 
      (== $x $y)))
</span>;;;; Define approximately equal
<span class="ansi38-255165000"
>  (: approxEq 
    (-> $a $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (approxEq $x $y $epsilon) 
    (<= 
      (abs (- $x $y)) $epsilon))
</span>;;;; Define Nat
<span class="ansi38-255165000"
>  (: Nat Type)
</span><span class="ansi38-255165000"
>  (: Z Nat)
</span><span class="ansi38-255165000"
>  (: S 
    (-> Nat Nat))
</span>;;;; Define cast functions between Nat and Number
<span class="ansi38-255165000"
>  (: fromNumber 
    (-> Number Nat))
</span><span class="ansi38-255165000"
>  (= 
    (fromNumber $n) 
    (if 
      (<= $n 0) Z 
      (S (fromNumber (- $n 1)))))
</span><span class="ansi38-255165000"
>  (: fromNat 
    (-> Nat Number))
</span><span class="ansi38-255165000"
>  (= 
    (fromNat Z) 0)
</span><span class="ansi38-255165000"
>  (= 
    (fromNat (S $k)) 
    (+ 1 
      (fromNat $k)))
</span>;;;; Define a generic less than operator, ⩻, for Nat.  < cannot be used
;;;; because it is a built-in, its type is hardwired and cannot be
;;;; overloaded.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Nat Nat Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $ Z) False)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ Z 
      (S $)) True)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ 
      (S $x) 
      (S $y)) 
    (⩻ $x $y))
</span>;;;; Overload ⩻ for Number.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Number Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $x $y) 
    (< $x $y))
</span>;;;; Return the ceiling of a non negative number.  If the number is
;;;; negative it returns 1.
<span class="ansi38-255165000"
>  (: ceil 
    (-> Number Number))
</span><span class="ansi38-255165000"
>  (= 
    (ceil $n) 
    (fromNat (fromNumber $n)))
</span>;;;; Convert Number to Bool.  Anything above 0 converts to True.
<span class="ansi38-255165000"
>  (: number->bool 
    (-> Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (number->bool $x) 
    (< 0 $x))
</span>;;;; Convert Bool to Number.  False converts to 0, True converts to 1.
<span class="ansi38-255165000"
>  (: bool->number 
    (-> Bool Number))
</span><span class="ansi38-255165000"
>  (= 
    (bool->number False) 0)
</span><span class="ansi38-255165000"
>  (= 
    (bool->number True) 1)
</span>;;;; Define a less than type.  Note that it is purposefully different
;;;; than ⩻ as it is a type, not an operator.  Inhabitants of (⍃ x y)
;;;; are proofs that x ⩻ y == True.  For now ⍃ is only axiomatized for
;;;; Nat.
<span class="ansi38-255165000"
>  (: ⍃ 
    (-> $t $t Type))
</span>;;;; Zero is always less than the successor of something
<span class="ansi38-255165000"
>  (: 
    (zero-lt-succ-axiom) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (zero-lt-succ-axiom) 
    (: ZeroLTSucc 
      (⍃ Z 
        (S $k))))
</span>;;;; If x ⍃ y then (S x) ⍃ (S y)
<span class="ansi38-255165000"
>  (: 
    (succ-monotonicity-rule) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (succ-monotonicity-rule) 
    (: SuccMonotonicity 
      (-> 
        (⍃ $x $y) 
        (⍃ 
          (S $x) 
          (S $y)))))
</span>
Deterministic: ()
;;;;;;;;;;;;
;;;; Type ;;
;;;;;;;;;;;;
<span class="ansi38-255165000"
>  (: TruthValue Type)
</span>;;;;;;;;;;;;;;;;;;;;
;;;; Constructors ;;
;;;;;;;;;;;;;;;;;;;;
;;;; Boolean TV constructor
;;;; TODO: alternatively we could have (: ⊤ TruthValue) and (: ⊥ TruthValue)
<span class="ansi38-255165000"
>  (: Bl 
    (-> Bool TruthValue))
</span>;;;; First order probability TV constructor, i.e. mere probability.
<span class="ansi38-255165000"
>  (: Pr 
    (-> Number TruthValue))
</span>;;;; Simple Truth Value.  A Second order probability TV constructor,
;;;; i.e. probability and confidence.  The probability is in fact the
;;;; mode of the corresponding beta distribution.
<span class="ansi38-255165000"
>  (: STV 
    (-> Number Number TruthValue))
</span>;;;;;;;;;;;;;;;;;
;;;; Constants ;;
;;;;;;;;;;;;;;;;;
;;;; For now the underlying beta distributions have a Jeffreys prior,
;;;; i.e. the prior alpha and beta are 0.5.
<span class="ansi38-255165000"
>  (: prior-alpha 
    (-> Number))
</span><span class="ansi38-255165000"
>  (= 
    (prior-alpha) 0.5)
</span><span class="ansi38-255165000"
>  (: prior-beta 
    (-> Number))
</span><span class="ansi38-255165000"
>  (= 
    (prior-beta) 0.5)
</span>;;;; Lookahead
<span class="ansi38-255165000"
>  (: lookahead 
    (-> Number))
</span><span class="ansi38-255165000"
>  (= 
    (lookahead) 1.0)
</span>;;;; Maximum supported count (till +inf is supported, possibly).
<span class="ansi38-255165000"
>  (: max-count 
    (-> Number))
</span><span class="ansi38-255165000"
>  (= 
    (max-count) 1000000000.0)
</span>;;;;;;;;;;;;;;;
;;;; Methods ;;
;;;;;;;;;;;;;;;
;;;; Convert count to confidence using the formula
;;;;
;;;; confidence = count / (count + lookahead)
<span class="ansi38-255165000"
>  (: count->confidence 
    (-> Number Number))
</span><span class="ansi38-255165000"
>  (= 
    (count->confidence $cnt) 
    (/ $cnt 
      (+ $cnt 
        (lookahead))))
</span>;;;; Convert confidence to count using the formula
;;;;
;;;; count = (confidence * lookahead) / (1 - confidence)
<span class="ansi38-255165000"
>  (: confidence->count 
    (-> Number Number))
</span><span class="ansi38-255165000"
>  (= 
    (confidence->count $conf) 
    (if 
      (approxEq 1.0 $conf 1.0e-9) 
      (max-count) 
      (/ 
        (* $conf 
          (lookahead)) 
        (- 1.0 $conf))))
</span>;;;; Increment the negative count of a given truth value, by
;;;; incrementing its total count without incrementing the positive
;;;; count.
<span class="ansi38-255165000"
>  (: inc-neg-count 
    (-> TruthValue TruthValue))
</span><span class="ansi38-255165000"
>  (= 
    (inc-neg-count (STV $s $c)) 
    (let* 
      ( ($tot_cnt (confidence->count $c)) 
        ($pos_cnt (* $s $tot_cnt)) 
        ($new_tot_cnt (+ $tot_cnt 1))) 
      (STV 
        (/ $pos_cnt $new_tot_cnt) 
        (count->confidence $new_tot_cnt))))
</span>;;;; Increment the positive count of a given truth value, by
;;;; incrementing its total count and its positive count.
<span class="ansi38-255165000"
>  (: inc-pos-count 
    (-> TruthValue TruthValue))
</span><span class="ansi38-255165000"
>  (= 
    (inc-pos-count (STV $s $c)) 
    (let* 
      ( ($tot_cnt (confidence->count $c)) 
        ($pos_cnt (* $s $tot_cnt)) 
        ($new_pos_cnt (+ $pos_cnt 1)) 
        ($new_tot_cnt (+ $tot_cnt 1))) 
      (STV 
        (/ $new_pos_cnt $new_tot_cnt) 
        (count->confidence $new_tot_cnt))))
</span>;;;; Return the first order probability mode of the second order
;;;; distribution associated to a truth value.
<span class="ansi38-255165000"
>  (: mode 
    (-> TruthValue Number))
</span><span class="ansi38-255165000"
>  (= 
    (mode (Bl True)) 1.0)
</span><span class="ansi38-255165000"
>  (= 
    (mode (Bl False)) 0.0)
</span><span class="ansi38-255165000"
>  (= 
    (mode (Pr $pr)) $pr)
</span><span class="ansi38-255165000"
>  (= 
    (mode (STV $pr $)) $pr)
</span>;;;; Return the total count of a truth value.  For truth values not
;;;; capturing a notion of confidence, such as Bl or Pr then the count
;;;; is assumed to be a very large number (cause +inf does not seem to
;;;; be supported at the moment).
<span class="ansi38-255165000"
>  (: count 
    (-> TruthValue Number))
</span><span class="ansi38-255165000"
>  (= 
    (count (Bl $)) 
    (max-count))
</span><span class="ansi38-255165000"
>  (= 
    (count (Pr $)) 
    (max-count))
</span><span class="ansi38-255165000"
>  (= 
    (count (STV $ $conf)) 
    (confidence->count $conf))
</span>;;;; Return the confidence of a truth value.  For truth values not
;;;; capturing a notion of confidence, such as Bl or Pr then the
;;;; confidence is assumed to be 1.0.  For truth values capturing a
;;;; notion of confidence, such as STV, the formula to convert a count
;;;; into confidence is as follows
;;;;
;;;; confidence = count / (count + lookahead)
<span class="ansi38-255165000"
>  (: confidence 
    (-> TruthValue Number))
</span><span class="ansi38-255165000"
>  (= 
    (confidence (Bl $)) 1.0)
</span><span class="ansi38-255165000"
>  (= 
    (confidence (Pr $)) 1.0)
</span><span class="ansi38-255165000"
>  (= 
    (confidence (STV $ $conf)) $conf)
</span>;;;; Return the positive count of a truth value.
<span class="ansi38-255165000"
>  (: pos-count 
    (-> TruthValue Number))
</span><span class="ansi38-255165000"
>  (= 
    (pos-count $tv) 
    (* 
      (mode $tv) 
      (count $tv)))
</span>;;;; Return the negative count of a truth value.
<span class="ansi38-255165000"
>  (: neg-count 
    (-> TruthValue Number))
</span><span class="ansi38-255165000"
>  (= 
    (neg-count $tv) 
    (* 
      (- 1 
        (mode $tv)) 
      (count $tv)))
</span>;;;; Return the posterior alpha of a truth value
<span class="ansi38-255165000"
>  (: post-alpha 
    (-> TruthValue Number))
</span><span class="ansi38-255165000"
>  (= 
    (post-alpha $tv) 
    (+ 
      (prior-alpha) 
      (pos-count $tv)))
</span>;;;; Return the posterior beta of a truth value
<span class="ansi38-255165000"
>  (: post-beta 
    (-> TruthValue Number))
</span><span class="ansi38-255165000"
>  (= 
    (post-beta $tv) 
    (+ 
      (prior-beta) 
      (neg-count $tv)))
</span>;;;; Return the first order probability mean of the second order
;;;; distribution associated to a truth value.  For truth values not
;;;; capturing a notion of confidence, such as Bl or Pr then the
;;;; confidence is assumed to be 1.0.  For truth values capturing a
;;;; notion of confidence, such as STV, a beta distribution is assumed.
<span class="ansi38-255165000"
>  (: mean 
    (-> TruthValue Number))
</span><span class="ansi38-255165000"
>  (= 
    (mean (Bl True)) 1.0)
</span><span class="ansi38-255165000"
>  (= 
    (mean (Bl False)) 0.0)
</span><span class="ansi38-255165000"
>  (= 
    (mean (Pr $pr)) $pr)
</span><span class="ansi38-255165000"
>  (= 
    (mean (STV $pr $conf)) 
    (let* 
      ( ($a (post-alpha (STV $pr $conf))) ($b (post-beta (STV $pr $conf)))) 
      (/ $a 
        (+ $a $b))))
</span>;;;; Truth value type definition
;;;; Import modules
<span class="ansi38-013099040"
>  !(import! &self ../Num.metta)

</span>P;HTML|
;                                           (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/Num.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/Num.metta)
P;HTML|
;                                           (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/Num.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/Num.metta)

;;;; Collection of functions operating on numbers
;;;; Define max
<span class="ansi38-255165000"
>  (: max 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (max $x $y) 
    (if 
      (> $x $y) $x $y))
</span>;;;; Define min
<span class="ansi38-255165000"
>  (: min 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (min $x $y) 
    (if 
      (< $x $y) $x $y))
</span>;;;; Clamp a number to be within a certain range
<span class="ansi38-255165000"
>  (: clamp 
    (-> $a $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (clamp $x $l $u) 
    (max $l 
      (min $u $x)))
</span>;;;; Define abs
<span class="ansi38-255165000"
>  (: abs 
    (-> $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (abs $x) 
    (if 
      (< $x 0) 
      (* -1 $x) $x))
</span>;;;; Define <=
<span class="ansi38-255165000"
>  (: <= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (<= $x $y) 
    (or 
      (< $x $y) 
      (== $x $y)))
</span>;;;; Define >=
<span class="ansi38-255165000"
>  (: >= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (>= $x $y) 
    (or 
      (> $x $y) 
      (== $x $y)))
</span>;;;; Define approximately equal
<span class="ansi38-255165000"
>  (: approxEq 
    (-> $a $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (approxEq $x $y $epsilon) 
    (<= 
      (abs (- $x $y)) $epsilon))
</span>;;;; Define Nat
<span class="ansi38-255165000"
>  (: Nat Type)
</span><span class="ansi38-255165000"
>  (: Z Nat)
</span><span class="ansi38-255165000"
>  (: S 
    (-> Nat Nat))
</span>;;;; Define cast functions between Nat and Number
<span class="ansi38-255165000"
>  (: fromNumber 
    (-> Number Nat))
</span><span class="ansi38-255165000"
>  (= 
    (fromNumber $n) 
    (if 
      (<= $n 0) Z 
      (S (fromNumber (- $n 1)))))
</span><span class="ansi38-255165000"
>  (: fromNat 
    (-> Nat Number))
</span><span class="ansi38-255165000"
>  (= 
    (fromNat Z) 0)
</span><span class="ansi38-255165000"
>  (= 
    (fromNat (S $k)) 
    (+ 1 
      (fromNat $k)))
</span>;;;; Define a generic less than operator, ⩻, for Nat.  < cannot be used
;;;; because it is a built-in, its type is hardwired and cannot be
;;;; overloaded.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Nat Nat Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $ Z) False)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ Z 
      (S $)) True)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ 
      (S $x) 
      (S $y)) 
    (⩻ $x $y))
</span>;;;; Overload ⩻ for Number.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Number Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $x $y) 
    (< $x $y))
</span>;;;; Return the ceiling of a non negative number.  If the number is
;;;; negative it returns 1.
<span class="ansi38-255165000"
>  (: ceil 
    (-> Number Number))
</span><span class="ansi38-255165000"
>  (= 
    (ceil $n) 
    (fromNat (fromNumber $n)))
</span>;;;; Convert Number to Bool.  Anything above 0 converts to True.
<span class="ansi38-255165000"
>  (: number->bool 
    (-> Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (number->bool $x) 
    (< 0 $x))
</span>;;;; Convert Bool to Number.  False converts to 0, True converts to 1.
<span class="ansi38-255165000"
>  (: bool->number 
    (-> Bool Number))
</span><span class="ansi38-255165000"
>  (= 
    (bool->number False) 0)
</span><span class="ansi38-255165000"
>  (= 
    (bool->number True) 1)
</span>;;;; Define a less than type.  Note that it is purposefully different
;;;; than ⩻ as it is a type, not an operator.  Inhabitants of (⍃ x y)
;;;; are proofs that x ⩻ y == True.  For now ⍃ is only axiomatized for
;;;; Nat.
<span class="ansi38-255165000"
>  (: ⍃ 
    (-> $t $t Type))
</span>;;;; Zero is always less than the successor of something
<span class="ansi38-255165000"
>  (: 
    (zero-lt-succ-axiom) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (zero-lt-succ-axiom) 
    (: ZeroLTSucc 
      (⍃ Z 
        (S $k))))
</span>;;;; If x ⍃ y then (S x) ⍃ (S y)
<span class="ansi38-255165000"
>  (: 
    (succ-monotonicity-rule) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (succ-monotonicity-rule) 
    (: SuccMonotonicity 
      (-> 
        (⍃ $x $y) 
        (⍃ 
          (S $x) 
          (S $y)))))
</span>;;;; Collection of functions operating on numbers
;;;; Define max
<span class="ansi38-255165000"
>  (: max 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (max $x $y) 
    (if 
      (> $x $y) $x $y))
</span>;;;; Define min
<span class="ansi38-255165000"
>  (: min 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (min $x $y) 
    (if 
      (< $x $y) $x $y))
</span>;;;; Clamp a number to be within a certain range
<span class="ansi38-255165000"
>  (: clamp 
    (-> $a $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (clamp $x $l $u) 
    (max $l 
      (min $u $x)))
</span>;;;; Define abs
<span class="ansi38-255165000"
>  (: abs 
    (-> $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (abs $x) 
    (if 
      (< $x 0) 
      (* -1 $x) $x))
</span>;;;; Define <=
<span class="ansi38-255165000"
>  (: <= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (<= $x $y) 
    (or 
      (< $x $y) 
      (== $x $y)))
</span>;;;; Define >=
<span class="ansi38-255165000"
>  (: >= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (>= $x $y) 
    (or 
      (> $x $y) 
      (== $x $y)))
</span>;;;; Define approximately equal
<span class="ansi38-255165000"
>  (: approxEq 
    (-> $a $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (approxEq $x $y $epsilon) 
    (<= 
      (abs (- $x $y)) $epsilon))
</span>;;;; Define Nat
<span class="ansi38-255165000"
>  (: Nat Type)
</span><span class="ansi38-255165000"
>  (: Z Nat)
</span><span class="ansi38-255165000"
>  (: S 
    (-> Nat Nat))
</span>;;;; Define cast functions between Nat and Number
<span class="ansi38-255165000"
>  (: fromNumber 
    (-> Number Nat))
</span><span class="ansi38-255165000"
>  (= 
    (fromNumber $n) 
    (if 
      (<= $n 0) Z 
      (S (fromNumber (- $n 1)))))
</span><span class="ansi38-255165000"
>  (: fromNat 
    (-> Nat Number))
</span><span class="ansi38-255165000"
>  (= 
    (fromNat Z) 0)
</span><span class="ansi38-255165000"
>  (= 
    (fromNat (S $k)) 
    (+ 1 
      (fromNat $k)))
</span>;;;; Define a generic less than operator, ⩻, for Nat.  < cannot be used
;;;; because it is a built-in, its type is hardwired and cannot be
;;;; overloaded.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Nat Nat Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $ Z) False)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ Z 
      (S $)) True)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ 
      (S $x) 
      (S $y)) 
    (⩻ $x $y))
</span>;;;; Overload ⩻ for Number.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Number Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $x $y) 
    (< $x $y))
</span>;;;; Return the ceiling of a non negative number.  If the number is
;;;; negative it returns 1.
<span class="ansi38-255165000"
>  (: ceil 
    (-> Number Number))
</span><span class="ansi38-255165000"
>  (= 
    (ceil $n) 
    (fromNat (fromNumber $n)))
</span>;;;; Convert Number to Bool.  Anything above 0 converts to True.
<span class="ansi38-255165000"
>  (: number->bool 
    (-> Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (number->bool $x) 
    (< 0 $x))
</span>;;;; Convert Bool to Number.  False converts to 0, True converts to 1.
<span class="ansi38-255165000"
>  (: bool->number 
    (-> Bool Number))
</span><span class="ansi38-255165000"
>  (= 
    (bool->number False) 0)
</span><span class="ansi38-255165000"
>  (= 
    (bool->number True) 1)
</span>;;;; Define a less than type.  Note that it is purposefully different
;;;; than ⩻ as it is a type, not an operator.  Inhabitants of (⍃ x y)
;;;; are proofs that x ⩻ y == True.  For now ⍃ is only axiomatized for
;;;; Nat.
<span class="ansi38-255165000"
>  (: ⍃ 
    (-> $t $t Type))
</span>;;;; Zero is always less than the successor of something
<span class="ansi38-255165000"
>  (: 
    (zero-lt-succ-axiom) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (zero-lt-succ-axiom) 
    (: ZeroLTSucc 
      (⍃ Z 
        (S $k))))
</span>;;;; If x ⍃ y then (S x) ⍃ (S y)
<span class="ansi38-255165000"
>  (: 
    (succ-monotonicity-rule) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (succ-monotonicity-rule) 
    (: SuccMonotonicity 
      (-> 
        (⍃ $x $y) 
        (⍃ 
          (S $x) 
          (S $y)))))
</span>;;;; Collection of functions operating on numbers
;;;; Define max
<span class="ansi38-255165000"
>  (: max 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (max $x $y) 
    (if 
      (> $x $y) $x $y))
</span>;;;; Define min
<span class="ansi38-255165000"
>  (: min 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (min $x $y) 
    (if 
      (< $x $y) $x $y))
</span>;;;; Clamp a number to be within a certain range
<span class="ansi38-255165000"
>  (: clamp 
    (-> $a $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (clamp $x $l $u) 
    (max $l 
      (min $u $x)))
</span>;;;; Define abs
<span class="ansi38-255165000"
>  (: abs 
    (-> $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (abs $x) 
    (if 
      (< $x 0) 
      (* -1 $x) $x))
</span>;;;; Define <=
<span class="ansi38-255165000"
>  (: <= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (<= $x $y) 
    (or 
      (< $x $y) 
      (== $x $y)))
</span>;;;; Define >=
<span class="ansi38-255165000"
>  (: >= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (>= $x $y) 
    (or 
      (> $x $y) 
      (== $x $y)))
</span>;;;; Define approximately equal
<span class="ansi38-255165000"
>  (: approxEq 
    (-> $a $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (approxEq $x $y $epsilon) 
    (<= 
      (abs (- $x $y)) $epsilon))
</span>;;;; Define Nat
<span class="ansi38-255165000"
>  (: Nat Type)
</span><span class="ansi38-255165000"
>  (: Z Nat)
</span><span class="ansi38-255165000"
>  (: S 
    (-> Nat Nat))
</span>;;;; Define cast functions between Nat and Number
<span class="ansi38-255165000"
>  (: fromNumber 
    (-> Number Nat))
</span><span class="ansi38-255165000"
>  (= 
    (fromNumber $n) 
    (if 
      (<= $n 0) Z 
      (S (fromNumber (- $n 1)))))
</span><span class="ansi38-255165000"
>  (: fromNat 
    (-> Nat Number))
</span><span class="ansi38-255165000"
>  (= 
    (fromNat Z) 0)
</span><span class="ansi38-255165000"
>  (= 
    (fromNat (S $k)) 
    (+ 1 
      (fromNat $k)))
</span>;;;; Define a generic less than operator, ⩻, for Nat.  < cannot be used
;;;; because it is a built-in, its type is hardwired and cannot be
;;;; overloaded.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Nat Nat Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $ Z) False)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ Z 
      (S $)) True)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ 
      (S $x) 
      (S $y)) 
    (⩻ $x $y))
</span>;;;; Overload ⩻ for Number.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Number Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $x $y) 
    (< $x $y))
</span>;;;; Return the ceiling of a non negative number.  If the number is
;;;; negative it returns 1.
<span class="ansi38-255165000"
>  (: ceil 
    (-> Number Number))
</span><span class="ansi38-255165000"
>  (= 
    (ceil $n) 
    (fromNat (fromNumber $n)))
</span>;;;; Convert Number to Bool.  Anything above 0 converts to True.
<span class="ansi38-255165000"
>  (: number->bool 
    (-> Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (number->bool $x) 
    (< 0 $x))
</span>;;;; Convert Bool to Number.  False converts to 0, True converts to 1.
<span class="ansi38-255165000"
>  (: bool->number 
    (-> Bool Number))
</span><span class="ansi38-255165000"
>  (= 
    (bool->number False) 0)
</span><span class="ansi38-255165000"
>  (= 
    (bool->number True) 1)
</span>;;;; Define a less than type.  Note that it is purposefully different
;;;; than ⩻ as it is a type, not an operator.  Inhabitants of (⍃ x y)
;;;; are proofs that x ⩻ y == True.  For now ⍃ is only axiomatized for
;;;; Nat.
<span class="ansi38-255165000"
>  (: ⍃ 
    (-> $t $t Type))
</span>;;;; Zero is always less than the successor of something
<span class="ansi38-255165000"
>  (: 
    (zero-lt-succ-axiom) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (zero-lt-succ-axiom) 
    (: ZeroLTSucc 
      (⍃ Z 
        (S $k))))
</span>;;;; If x ⍃ y then (S x) ⍃ (S y)
<span class="ansi38-255165000"
>  (: 
    (succ-monotonicity-rule) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (succ-monotonicity-rule) 
    (: SuccMonotonicity 
      (-> 
        (⍃ $x $y) 
        (⍃ 
          (S $x) 
          (S $y)))))
</span>;;;; Collection of functions operating on numbers
;;;; Define max
<span class="ansi38-255165000"
>  (: max 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (max $x $y) 
    (if 
      (> $x $y) $x $y))
</span>;;;; Define min
<span class="ansi38-255165000"
>  (: min 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (min $x $y) 
    (if 
      (< $x $y) $x $y))
</span>;;;; Clamp a number to be within a certain range
<span class="ansi38-255165000"
>  (: clamp 
    (-> $a $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (clamp $x $l $u) 
    (max $l 
      (min $u $x)))
</span>;;;; Define abs
<span class="ansi38-255165000"
>  (: abs 
    (-> $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (abs $x) 
    (if 
      (< $x 0) 
      (* -1 $x) $x))
</span>;;;; Define <=
<span class="ansi38-255165000"
>  (: <= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (<= $x $y) 
    (or 
      (< $x $y) 
      (== $x $y)))
</span>;;;; Define >=
<span class="ansi38-255165000"
>  (: >= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (>= $x $y) 
    (or 
      (> $x $y) 
      (== $x $y)))
</span>;;;; Define approximately equal
<span class="ansi38-255165000"
>  (: approxEq 
    (-> $a $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (approxEq $x $y $epsilon) 
    (<= 
      (abs (- $x $y)) $epsilon))
</span>;;;; Define Nat
<span class="ansi38-255165000"
>  (: Nat Type)
</span><span class="ansi38-255165000"
>  (: Z Nat)
</span><span class="ansi38-255165000"
>  (: S 
    (-> Nat Nat))
</span>;;;; Define cast functions between Nat and Number
<span class="ansi38-255165000"
>  (: fromNumber 
    (-> Number Nat))
</span><span class="ansi38-255165000"
>  (= 
    (fromNumber $n) 
    (if 
      (<= $n 0) Z 
      (S (fromNumber (- $n 1)))))
</span><span class="ansi38-255165000"
>  (: fromNat 
    (-> Nat Number))
</span><span class="ansi38-255165000"
>  (= 
    (fromNat Z) 0)
</span><span class="ansi38-255165000"
>  (= 
    (fromNat (S $k)) 
    (+ 1 
      (fromNat $k)))
</span>;;;; Define a generic less than operator, ⩻, for Nat.  < cannot be used
;;;; because it is a built-in, its type is hardwired and cannot be
;;;; overloaded.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Nat Nat Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $ Z) False)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ Z 
      (S $)) True)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ 
      (S $x) 
      (S $y)) 
    (⩻ $x $y))
</span>;;;; Overload ⩻ for Number.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Number Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $x $y) 
    (< $x $y))
</span>;;;; Return the ceiling of a non negative number.  If the number is
;;;; negative it returns 1.
<span class="ansi38-255165000"
>  (: ceil 
    (-> Number Number))
</span><span class="ansi38-255165000"
>  (= 
    (ceil $n) 
    (fromNat (fromNumber $n)))
</span>;;;; Convert Number to Bool.  Anything above 0 converts to True.
<span class="ansi38-255165000"
>  (: number->bool 
    (-> Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (number->bool $x) 
    (< 0 $x))
</span>;;;; Convert Bool to Number.  False converts to 0, True converts to 1.
<span class="ansi38-255165000"
>  (: bool->number 
    (-> Bool Number))
</span><span class="ansi38-255165000"
>  (= 
    (bool->number False) 0)
</span><span class="ansi38-255165000"
>  (= 
    (bool->number True) 1)
</span>;;;; Define a less than type.  Note that it is purposefully different
;;;; than ⩻ as it is a type, not an operator.  Inhabitants of (⍃ x y)
;;;; are proofs that x ⩻ y == True.  For now ⍃ is only axiomatized for
;;;; Nat.
<span class="ansi38-255165000"
>  (: ⍃ 
    (-> $t $t Type))
</span>;;;; Zero is always less than the successor of something
<span class="ansi38-255165000"
>  (: 
    (zero-lt-succ-axiom) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (zero-lt-succ-axiom) 
    (: ZeroLTSucc 
      (⍃ Z 
        (S $k))))
</span>;;;; If x ⍃ y then (S x) ⍃ (S y)
<span class="ansi38-255165000"
>  (: 
    (succ-monotonicity-rule) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (succ-monotonicity-rule) 
    (: SuccMonotonicity 
      (-> 
        (⍃ $x $y) 
        (⍃ 
          (S $x) 
          (S $y)))))
</span>;;;; Collection of functions operating on numbers
;;;; Define max
<span class="ansi38-255165000"
>  (: max 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (max $x $y) 
    (if 
      (> $x $y) $x $y))
</span>;;;; Define min
<span class="ansi38-255165000"
>  (: min 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (min $x $y) 
    (if 
      (< $x $y) $x $y))
</span>;;;; Clamp a number to be within a certain range
<span class="ansi38-255165000"
>  (: clamp 
    (-> $a $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (clamp $x $l $u) 
    (max $l 
      (min $u $x)))
</span>;;;; Define abs
<span class="ansi38-255165000"
>  (: abs 
    (-> $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (abs $x) 
    (if 
      (< $x 0) 
      (* -1 $x) $x))
</span>;;;; Define <=
<span class="ansi38-255165000"
>  (: <= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (<= $x $y) 
    (or 
      (< $x $y) 
      (== $x $y)))
</span>;;;; Define >=
<span class="ansi38-255165000"
>  (: >= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (>= $x $y) 
    (or 
      (> $x $y) 
      (== $x $y)))
</span>;;;; Define approximately equal
<span class="ansi38-255165000"
>  (: approxEq 
    (-> $a $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (approxEq $x $y $epsilon) 
    (<= 
      (abs (- $x $y)) $epsilon))
</span>;;;; Define Nat
<span class="ansi38-255165000"
>  (: Nat Type)
</span><span class="ansi38-255165000"
>  (: Z Nat)
</span><span class="ansi38-255165000"
>  (: S 
    (-> Nat Nat))
</span>;;;; Define cast functions between Nat and Number
<span class="ansi38-255165000"
>  (: fromNumber 
    (-> Number Nat))
</span><span class="ansi38-255165000"
>  (= 
    (fromNumber $n) 
    (if 
      (<= $n 0) Z 
      (S (fromNumber (- $n 1)))))
</span><span class="ansi38-255165000"
>  (: fromNat 
    (-> Nat Number))
</span><span class="ansi38-255165000"
>  (= 
    (fromNat Z) 0)
</span><span class="ansi38-255165000"
>  (= 
    (fromNat (S $k)) 
    (+ 1 
      (fromNat $k)))
</span>;;;; Define a generic less than operator, ⩻, for Nat.  < cannot be used
;;;; because it is a built-in, its type is hardwired and cannot be
;;;; overloaded.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Nat Nat Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $ Z) False)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ Z 
      (S $)) True)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ 
      (S $x) 
      (S $y)) 
    (⩻ $x $y))
</span>;;;; Overload ⩻ for Number.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Number Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $x $y) 
    (< $x $y))
</span>;;;; Return the ceiling of a non negative number.  If the number is
;;;; negative it returns 1.
<span class="ansi38-255165000"
>  (: ceil 
    (-> Number Number))
</span><span class="ansi38-255165000"
>  (= 
    (ceil $n) 
    (fromNat (fromNumber $n)))
</span>;;;; Convert Number to Bool.  Anything above 0 converts to True.
<span class="ansi38-255165000"
>  (: number->bool 
    (-> Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (number->bool $x) 
    (< 0 $x))
</span>;;;; Convert Bool to Number.  False converts to 0, True converts to 1.
<span class="ansi38-255165000"
>  (: bool->number 
    (-> Bool Number))
</span><span class="ansi38-255165000"
>  (= 
    (bool->number False) 0)
</span><span class="ansi38-255165000"
>  (= 
    (bool->number True) 1)
</span>;;;; Define a less than type.  Note that it is purposefully different
;;;; than ⩻ as it is a type, not an operator.  Inhabitants of (⍃ x y)
;;;; are proofs that x ⩻ y == True.  For now ⍃ is only axiomatized for
;;;; Nat.
<span class="ansi38-255165000"
>  (: ⍃ 
    (-> $t $t Type))
</span>;;;; Zero is always less than the successor of something
<span class="ansi38-255165000"
>  (: 
    (zero-lt-succ-axiom) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (zero-lt-succ-axiom) 
    (: ZeroLTSucc 
      (⍃ Z 
        (S $k))))
</span>;;;; If x ⍃ y then (S x) ⍃ (S y)
<span class="ansi38-255165000"
>  (: 
    (succ-monotonicity-rule) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (succ-monotonicity-rule) 
    (: SuccMonotonicity 
      (-> 
        (⍃ $x $y) 
        (⍃ 
          (S $x) 
          (S $y)))))
</span>;;;; Collection of functions operating on numbers
;;;; Define max
<span class="ansi38-255165000"
>  (: max 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (max $x $y) 
    (if 
      (> $x $y) $x $y))
</span>;;;; Define min
<span class="ansi38-255165000"
>  (: min 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (min $x $y) 
    (if 
      (< $x $y) $x $y))
</span>;;;; Clamp a number to be within a certain range
<span class="ansi38-255165000"
>  (: clamp 
    (-> $a $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (clamp $x $l $u) 
    (max $l 
      (min $u $x)))
</span>;;;; Define abs
<span class="ansi38-255165000"
>  (: abs 
    (-> $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (abs $x) 
    (if 
      (< $x 0) 
      (* -1 $x) $x))
</span>;;;; Define <=
<span class="ansi38-255165000"
>  (: <= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (<= $x $y) 
    (or 
      (< $x $y) 
      (== $x $y)))
</span>;;;; Define >=
<span class="ansi38-255165000"
>  (: >= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (>= $x $y) 
    (or 
      (> $x $y) 
      (== $x $y)))
</span>;;;; Define approximately equal
<span class="ansi38-255165000"
>  (: approxEq 
    (-> $a $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (approxEq $x $y $epsilon) 
    (<= 
      (abs (- $x $y)) $epsilon))
</span>;;;; Define Nat
<span class="ansi38-255165000"
>  (: Nat Type)
</span><span class="ansi38-255165000"
>  (: Z Nat)
</span><span class="ansi38-255165000"
>  (: S 
    (-> Nat Nat))
</span>;;;; Define cast functions between Nat and Number
<span class="ansi38-255165000"
>  (: fromNumber 
    (-> Number Nat))
</span><span class="ansi38-255165000"
>  (= 
    (fromNumber $n) 
    (if 
      (<= $n 0) Z 
      (S (fromNumber (- $n 1)))))
</span><span class="ansi38-255165000"
>  (: fromNat 
    (-> Nat Number))
</span><span class="ansi38-255165000"
>  (= 
    (fromNat Z) 0)
</span><span class="ansi38-255165000"
>  (= 
    (fromNat (S $k)) 
    (+ 1 
      (fromNat $k)))
</span>;;;; Define a generic less than operator, ⩻, for Nat.  < cannot be used
;;;; because it is a built-in, its type is hardwired and cannot be
;;;; overloaded.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Nat Nat Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $ Z) False)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ Z 
      (S $)) True)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ 
      (S $x) 
      (S $y)) 
    (⩻ $x $y))
</span>;;;; Overload ⩻ for Number.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Number Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $x $y) 
    (< $x $y))
</span>;;;; Return the ceiling of a non negative number.  If the number is
;;;; negative it returns 1.
<span class="ansi38-255165000"
>  (: ceil 
    (-> Number Number))
</span><span class="ansi38-255165000"
>  (= 
    (ceil $n) 
    (fromNat (fromNumber $n)))
</span>;;;; Convert Number to Bool.  Anything above 0 converts to True.
<span class="ansi38-255165000"
>  (: number->bool 
    (-> Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (number->bool $x) 
    (< 0 $x))
</span>;;;; Convert Bool to Number.  False converts to 0, True converts to 1.
<span class="ansi38-255165000"
>  (: bool->number 
    (-> Bool Number))
</span><span class="ansi38-255165000"
>  (= 
    (bool->number False) 0)
</span><span class="ansi38-255165000"
>  (= 
    (bool->number True) 1)
</span>;;;; Define a less than type.  Note that it is purposefully different
;;;; than ⩻ as it is a type, not an operator.  Inhabitants of (⍃ x y)
;;;; are proofs that x ⩻ y == True.  For now ⍃ is only axiomatized for
;;;; Nat.
<span class="ansi38-255165000"
>  (: ⍃ 
    (-> $t $t Type))
</span>;;;; Zero is always less than the successor of something
<span class="ansi38-255165000"
>  (: 
    (zero-lt-succ-axiom) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (zero-lt-succ-axiom) 
    (: ZeroLTSucc 
      (⍃ Z 
        (S $k))))
</span>;;;; If x ⍃ y then (S x) ⍃ (S y)
<span class="ansi38-255165000"
>  (: 
    (succ-monotonicity-rule) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (succ-monotonicity-rule) 
    (: SuccMonotonicity 
      (-> 
        (⍃ $x $y) 
        (⍃ 
          (S $x) 
          (S $y)))))
</span>
Deterministic: ()
;;;;;;;;;;;;
;;;; Type ;;
;;;;;;;;;;;;
<span class="ansi38-255165000"
>  (: TruthValue Type)
</span>;;;;;;;;;;;;;;;;;;;;
;;;; Constructors ;;
;;;;;;;;;;;;;;;;;;;;
;;;; Boolean TV constructor
;;;; TODO: alternatively we could have (: ⊤ TruthValue) and (: ⊥ TruthValue)
<span class="ansi38-255165000"
>  (: Bl 
    (-> Bool TruthValue))
</span>;;;; First order probability TV constructor, i.e. mere probability.
<span class="ansi38-255165000"
>  (: Pr 
    (-> Number TruthValue))
</span>;;;; Simple Truth Value.  A Second order probability TV constructor,
;;;; i.e. probability and confidence.  The probability is in fact the
;;;; mode of the corresponding beta distribution.
<span class="ansi38-255165000"
>  (: STV 
    (-> Number Number TruthValue))
</span>;;;;;;;;;;;;;;;;;
;;;; Constants ;;
;;;;;;;;;;;;;;;;;
;;;; For now the underlying beta distributions have a Jeffreys prior,
;;;; i.e. the prior alpha and beta are 0.5.
<span class="ansi38-255165000"
>  (: prior-alpha 
    (-> Number))
</span><span class="ansi38-255165000"
>  (= 
    (prior-alpha) 0.5)
</span><span class="ansi38-255165000"
>  (: prior-beta 
    (-> Number))
</span><span class="ansi38-255165000"
>  (= 
    (prior-beta) 0.5)
</span>;;;; Lookahead
<span class="ansi38-255165000"
>  (: lookahead 
    (-> Number))
</span><span class="ansi38-255165000"
>  (= 
    (lookahead) 1.0)
</span>;;;; Maximum supported count (till +inf is supported, possibly).
<span class="ansi38-255165000"
>  (: max-count 
    (-> Number))
</span><span class="ansi38-255165000"
>  (= 
    (max-count) 1000000000.0)
</span>;;;;;;;;;;;;;;;
;;;; Methods ;;
;;;;;;;;;;;;;;;
;;;; Convert count to confidence using the formula
;;;;
;;;; confidence = count / (count + lookahead)
<span class="ansi38-255165000"
>  (: count->confidence 
    (-> Number Number))
</span><span class="ansi38-255165000"
>  (= 
    (count->confidence $cnt) 
    (/ $cnt 
      (+ $cnt 
        (lookahead))))
</span>;;;; Convert confidence to count using the formula
;;;;
;;;; count = (confidence * lookahead) / (1 - confidence)
<span class="ansi38-255165000"
>  (: confidence->count 
    (-> Number Number))
</span><span class="ansi38-255165000"
>  (= 
    (confidence->count $conf) 
    (if 
      (approxEq 1.0 $conf 1.0e-9) 
      (max-count) 
      (/ 
        (* $conf 
          (lookahead)) 
        (- 1.0 $conf))))
</span>;;;; Increment the negative count of a given truth value, by
;;;; incrementing its total count without incrementing the positive
;;;; count.
<span class="ansi38-255165000"
>  (: inc-neg-count 
    (-> TruthValue TruthValue))
</span><span class="ansi38-255165000"
>  (= 
    (inc-neg-count (STV $s $c)) 
    (let* 
      ( ($tot_cnt (confidence->count $c)) 
        ($pos_cnt (* $s $tot_cnt)) 
        ($new_tot_cnt (+ $tot_cnt 1))) 
      (STV 
        (/ $pos_cnt $new_tot_cnt) 
        (count->confidence $new_tot_cnt))))
</span>;;;; Increment the positive count of a given truth value, by
;;;; incrementing its total count and its positive count.
<span class="ansi38-255165000"
>  (: inc-pos-count 
    (-> TruthValue TruthValue))
</span><span class="ansi38-255165000"
>  (= 
    (inc-pos-count (STV $s $c)) 
    (let* 
      ( ($tot_cnt (confidence->count $c)) 
        ($pos_cnt (* $s $tot_cnt)) 
        ($new_pos_cnt (+ $pos_cnt 1)) 
        ($new_tot_cnt (+ $tot_cnt 1))) 
      (STV 
        (/ $new_pos_cnt $new_tot_cnt) 
        (count->confidence $new_tot_cnt))))
</span>;;;; Return the first order probability mode of the second order
;;;; distribution associated to a truth value.
<span class="ansi38-255165000"
>  (: mode 
    (-> TruthValue Number))
</span><span class="ansi38-255165000"
>  (= 
    (mode (Bl True)) 1.0)
</span><span class="ansi38-255165000"
>  (= 
    (mode (Bl False)) 0.0)
</span><span class="ansi38-255165000"
>  (= 
    (mode (Pr $pr)) $pr)
</span><span class="ansi38-255165000"
>  (= 
    (mode (STV $pr $)) $pr)
</span>;;;; Return the total count of a truth value.  For truth values not
;;;; capturing a notion of confidence, such as Bl or Pr then the count
;;;; is assumed to be a very large number (cause +inf does not seem to
;;;; be supported at the moment).
<span class="ansi38-255165000"
>  (: count 
    (-> TruthValue Number))
</span><span class="ansi38-255165000"
>  (= 
    (count (Bl $)) 
    (max-count))
</span><span class="ansi38-255165000"
>  (= 
    (count (Pr $)) 
    (max-count))
</span><span class="ansi38-255165000"
>  (= 
    (count (STV $ $conf)) 
    (confidence->count $conf))
</span>;;;; Return the confidence of a truth value.  For truth values not
;;;; capturing a notion of confidence, such as Bl or Pr then the
;;;; confidence is assumed to be 1.0.  For truth values capturing a
;;;; notion of confidence, such as STV, the formula to convert a count
;;;; into confidence is as follows
;;;;
;;;; confidence = count / (count + lookahead)
<span class="ansi38-255165000"
>  (: confidence 
    (-> TruthValue Number))
</span><span class="ansi38-255165000"
>  (= 
    (confidence (Bl $)) 1.0)
</span><span class="ansi38-255165000"
>  (= 
    (confidence (Pr $)) 1.0)
</span><span class="ansi38-255165000"
>  (= 
    (confidence (STV $ $conf)) $conf)
</span>;;;; Return the positive count of a truth value.
<span class="ansi38-255165000"
>  (: pos-count 
    (-> TruthValue Number))
</span><span class="ansi38-255165000"
>  (= 
    (pos-count $tv) 
    (* 
      (mode $tv) 
      (count $tv)))
</span>;;;; Return the negative count of a truth value.
<span class="ansi38-255165000"
>  (: neg-count 
    (-> TruthValue Number))
</span><span class="ansi38-255165000"
>  (= 
    (neg-count $tv) 
    (* 
      (- 1 
        (mode $tv)) 
      (count $tv)))
</span>;;;; Return the posterior alpha of a truth value
<span class="ansi38-255165000"
>  (: post-alpha 
    (-> TruthValue Number))
</span><span class="ansi38-255165000"
>  (= 
    (post-alpha $tv) 
    (+ 
      (prior-alpha) 
      (pos-count $tv)))
</span>;;;; Return the posterior beta of a truth value
<span class="ansi38-255165000"
>  (: post-beta 
    (-> TruthValue Number))
</span><span class="ansi38-255165000"
>  (= 
    (post-beta $tv) 
    (+ 
      (prior-beta) 
      (neg-count $tv)))
</span>;;;; Return the first order probability mean of the second order
;;;; distribution associated to a truth value.  For truth values not
;;;; capturing a notion of confidence, such as Bl or Pr then the
;;;; confidence is assumed to be 1.0.  For truth values capturing a
;;;; notion of confidence, such as STV, a beta distribution is assumed.
<span class="ansi38-255165000"
>  (: mean 
    (-> TruthValue Number))
</span><span class="ansi38-255165000"
>  (= 
    (mean (Bl True)) 1.0)
</span><span class="ansi38-255165000"
>  (= 
    (mean (Bl False)) 0.0)
</span><span class="ansi38-255165000"
>  (= 
    (mean (Pr $pr)) $pr)
</span><span class="ansi38-255165000"
>  (= 
    (mean (STV $pr $conf)) 
    (let* 
      ( ($a (post-alpha (STV $pr $conf))) ($b (post-beta (STV $pr $conf)))) 
      (/ $a 
        (+ $a $b))))
</span>;;;; Truth value type definition
;;;; Import modules
<span class="ansi38-013099040"
>  !(import! &self ../Num.metta)

</span>P;HTML|
;                                           (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/Num.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/Num.metta)
P;HTML|
;                                           (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/Num.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/Num.metta)

;;;; Collection of functions operating on numbers
;;;; Define max
<span class="ansi38-255165000"
>  (: max 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (max $x $y) 
    (if 
      (> $x $y) $x $y))
</span>;;;; Define min
<span class="ansi38-255165000"
>  (: min 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (min $x $y) 
    (if 
      (< $x $y) $x $y))
</span>;;;; Clamp a number to be within a certain range
<span class="ansi38-255165000"
>  (: clamp 
    (-> $a $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (clamp $x $l $u) 
    (max $l 
      (min $u $x)))
</span>;;;; Define abs
<span class="ansi38-255165000"
>  (: abs 
    (-> $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (abs $x) 
    (if 
      (< $x 0) 
      (* -1 $x) $x))
</span>;;;; Define <=
<span class="ansi38-255165000"
>  (: <= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (<= $x $y) 
    (or 
      (< $x $y) 
      (== $x $y)))
</span>;;;; Define >=
<span class="ansi38-255165000"
>  (: >= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (>= $x $y) 
    (or 
      (> $x $y) 
      (== $x $y)))
</span>;;;; Define approximately equal
<span class="ansi38-255165000"
>  (: approxEq 
    (-> $a $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (approxEq $x $y $epsilon) 
    (<= 
      (abs (- $x $y)) $epsilon))
</span>;;;; Define Nat
<span class="ansi38-255165000"
>  (: Nat Type)
</span><span class="ansi38-255165000"
>  (: Z Nat)
</span><span class="ansi38-255165000"
>  (: S 
    (-> Nat Nat))
</span>;;;; Define cast functions between Nat and Number
<span class="ansi38-255165000"
>  (: fromNumber 
    (-> Number Nat))
</span><span class="ansi38-255165000"
>  (= 
    (fromNumber $n) 
    (if 
      (<= $n 0) Z 
      (S (fromNumber (- $n 1)))))
</span><span class="ansi38-255165000"
>  (: fromNat 
    (-> Nat Number))
</span><span class="ansi38-255165000"
>  (= 
    (fromNat Z) 0)
</span><span class="ansi38-255165000"
>  (= 
    (fromNat (S $k)) 
    (+ 1 
      (fromNat $k)))
</span>;;;; Define a generic less than operator, ⩻, for Nat.  < cannot be used
;;;; because it is a built-in, its type is hardwired and cannot be
;;;; overloaded.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Nat Nat Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $ Z) False)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ Z 
      (S $)) True)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ 
      (S $x) 
      (S $y)) 
    (⩻ $x $y))
</span>;;;; Overload ⩻ for Number.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Number Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $x $y) 
    (< $x $y))
</span>;;;; Return the ceiling of a non negative number.  If the number is
;;;; negative it returns 1.
<span class="ansi38-255165000"
>  (: ceil 
    (-> Number Number))
</span><span class="ansi38-255165000"
>  (= 
    (ceil $n) 
    (fromNat (fromNumber $n)))
</span>;;;; Convert Number to Bool.  Anything above 0 converts to True.
<span class="ansi38-255165000"
>  (: number->bool 
    (-> Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (number->bool $x) 
    (< 0 $x))
</span>;;;; Convert Bool to Number.  False converts to 0, True converts to 1.
<span class="ansi38-255165000"
>  (: bool->number 
    (-> Bool Number))
</span><span class="ansi38-255165000"
>  (= 
    (bool->number False) 0)
</span><span class="ansi38-255165000"
>  (= 
    (bool->number True) 1)
</span>;;;; Define a less than type.  Note that it is purposefully different
;;;; than ⩻ as it is a type, not an operator.  Inhabitants of (⍃ x y)
;;;; are proofs that x ⩻ y == True.  For now ⍃ is only axiomatized for
;;;; Nat.
<span class="ansi38-255165000"
>  (: ⍃ 
    (-> $t $t Type))
</span>;;;; Zero is always less than the successor of something
<span class="ansi38-255165000"
>  (: 
    (zero-lt-succ-axiom) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (zero-lt-succ-axiom) 
    (: ZeroLTSucc 
      (⍃ Z 
        (S $k))))
</span>;;;; If x ⍃ y then (S x) ⍃ (S y)
<span class="ansi38-255165000"
>  (: 
    (succ-monotonicity-rule) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (succ-monotonicity-rule) 
    (: SuccMonotonicity 
      (-> 
        (⍃ $x $y) 
        (⍃ 
          (S $x) 
          (S $y)))))
</span>;;;; Collection of functions operating on numbers
;;;; Define max
<span class="ansi38-255165000"
>  (: max 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (max $x $y) 
    (if 
      (> $x $y) $x $y))
</span>;;;; Define min
<span class="ansi38-255165000"
>  (: min 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (min $x $y) 
    (if 
      (< $x $y) $x $y))
</span>;;;; Clamp a number to be within a certain range
<span class="ansi38-255165000"
>  (: clamp 
    (-> $a $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (clamp $x $l $u) 
    (max $l 
      (min $u $x)))
</span>;;;; Define abs
<span class="ansi38-255165000"
>  (: abs 
    (-> $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (abs $x) 
    (if 
      (< $x 0) 
      (* -1 $x) $x))
</span>;;;; Define <=
<span class="ansi38-255165000"
>  (: <= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (<= $x $y) 
    (or 
      (< $x $y) 
      (== $x $y)))
</span>;;;; Define >=
<span class="ansi38-255165000"
>  (: >= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (>= $x $y) 
    (or 
      (> $x $y) 
      (== $x $y)))
</span>;;;; Define approximately equal
<span class="ansi38-255165000"
>  (: approxEq 
    (-> $a $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (approxEq $x $y $epsilon) 
    (<= 
      (abs (- $x $y)) $epsilon))
</span>;;;; Define Nat
<span class="ansi38-255165000"
>  (: Nat Type)
</span><span class="ansi38-255165000"
>  (: Z Nat)
</span><span class="ansi38-255165000"
>  (: S 
    (-> Nat Nat))
</span>;;;; Define cast functions between Nat and Number
<span class="ansi38-255165000"
>  (: fromNumber 
    (-> Number Nat))
</span><span class="ansi38-255165000"
>  (= 
    (fromNumber $n) 
    (if 
      (<= $n 0) Z 
      (S (fromNumber (- $n 1)))))
</span><span class="ansi38-255165000"
>  (: fromNat 
    (-> Nat Number))
</span><span class="ansi38-255165000"
>  (= 
    (fromNat Z) 0)
</span><span class="ansi38-255165000"
>  (= 
    (fromNat (S $k)) 
    (+ 1 
      (fromNat $k)))
</span>;;;; Define a generic less than operator, ⩻, for Nat.  < cannot be used
;;;; because it is a built-in, its type is hardwired and cannot be
;;;; overloaded.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Nat Nat Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $ Z) False)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ Z 
      (S $)) True)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ 
      (S $x) 
      (S $y)) 
    (⩻ $x $y))
</span>;;;; Overload ⩻ for Number.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Number Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $x $y) 
    (< $x $y))
</span>;;;; Return the ceiling of a non negative number.  If the number is
;;;; negative it returns 1.
<span class="ansi38-255165000"
>  (: ceil 
    (-> Number Number))
</span><span class="ansi38-255165000"
>  (= 
    (ceil $n) 
    (fromNat (fromNumber $n)))
</span>;;;; Convert Number to Bool.  Anything above 0 converts to True.
<span class="ansi38-255165000"
>  (: number->bool 
    (-> Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (number->bool $x) 
    (< 0 $x))
</span>;;;; Convert Bool to Number.  False converts to 0, True converts to 1.
<span class="ansi38-255165000"
>  (: bool->number 
    (-> Bool Number))
</span><span class="ansi38-255165000"
>  (= 
    (bool->number False) 0)
</span><span class="ansi38-255165000"
>  (= 
    (bool->number True) 1)
</span>;;;; Define a less than type.  Note that it is purposefully different
;;;; than ⩻ as it is a type, not an operator.  Inhabitants of (⍃ x y)
;;;; are proofs that x ⩻ y == True.  For now ⍃ is only axiomatized for
;;;; Nat.
<span class="ansi38-255165000"
>  (: ⍃ 
    (-> $t $t Type))
</span>;;;; Zero is always less than the successor of something
<span class="ansi38-255165000"
>  (: 
    (zero-lt-succ-axiom) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (zero-lt-succ-axiom) 
    (: ZeroLTSucc 
      (⍃ Z 
        (S $k))))
</span>;;;; If x ⍃ y then (S x) ⍃ (S y)
<span class="ansi38-255165000"
>  (: 
    (succ-monotonicity-rule) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (succ-monotonicity-rule) 
    (: SuccMonotonicity 
      (-> 
        (⍃ $x $y) 
        (⍃ 
          (S $x) 
          (S $y)))))
</span>;;;; Collection of functions operating on numbers
;;;; Define max
<span class="ansi38-255165000"
>  (: max 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (max $x $y) 
    (if 
      (> $x $y) $x $y))
</span>;;;; Define min
<span class="ansi38-255165000"
>  (: min 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (min $x $y) 
    (if 
      (< $x $y) $x $y))
</span>;;;; Clamp a number to be within a certain range
<span class="ansi38-255165000"
>  (: clamp 
    (-> $a $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (clamp $x $l $u) 
    (max $l 
      (min $u $x)))
</span>;;;; Define abs
<span class="ansi38-255165000"
>  (: abs 
    (-> $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (abs $x) 
    (if 
      (< $x 0) 
      (* -1 $x) $x))
</span>;;;; Define <=
<span class="ansi38-255165000"
>  (: <= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (<= $x $y) 
    (or 
      (< $x $y) 
      (== $x $y)))
</span>;;;; Define >=
<span class="ansi38-255165000"
>  (: >= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (>= $x $y) 
    (or 
      (> $x $y) 
      (== $x $y)))
</span>;;;; Define approximately equal
<span class="ansi38-255165000"
>  (: approxEq 
    (-> $a $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (approxEq $x $y $epsilon) 
    (<= 
      (abs (- $x $y)) $epsilon))
</span>;;;; Define Nat
<span class="ansi38-255165000"
>  (: Nat Type)
</span><span class="ansi38-255165000"
>  (: Z Nat)
</span><span class="ansi38-255165000"
>  (: S 
    (-> Nat Nat))
</span>;;;; Define cast functions between Nat and Number
<span class="ansi38-255165000"
>  (: fromNumber 
    (-> Number Nat))
</span><span class="ansi38-255165000"
>  (= 
    (fromNumber $n) 
    (if 
      (<= $n 0) Z 
      (S (fromNumber (- $n 1)))))
</span><span class="ansi38-255165000"
>  (: fromNat 
    (-> Nat Number))
</span><span class="ansi38-255165000"
>  (= 
    (fromNat Z) 0)
</span><span class="ansi38-255165000"
>  (= 
    (fromNat (S $k)) 
    (+ 1 
      (fromNat $k)))
</span>;;;; Define a generic less than operator, ⩻, for Nat.  < cannot be used
;;;; because it is a built-in, its type is hardwired and cannot be
;;;; overloaded.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Nat Nat Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $ Z) False)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ Z 
      (S $)) True)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ 
      (S $x) 
      (S $y)) 
    (⩻ $x $y))
</span>;;;; Overload ⩻ for Number.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Number Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $x $y) 
    (< $x $y))
</span>;;;; Return the ceiling of a non negative number.  If the number is
;;;; negative it returns 1.
<span class="ansi38-255165000"
>  (: ceil 
    (-> Number Number))
</span><span class="ansi38-255165000"
>  (= 
    (ceil $n) 
    (fromNat (fromNumber $n)))
</span>;;;; Convert Number to Bool.  Anything above 0 converts to True.
<span class="ansi38-255165000"
>  (: number->bool 
    (-> Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (number->bool $x) 
    (< 0 $x))
</span>;;;; Convert Bool to Number.  False converts to 0, True converts to 1.
<span class="ansi38-255165000"
>  (: bool->number 
    (-> Bool Number))
</span><span class="ansi38-255165000"
>  (= 
    (bool->number False) 0)
</span><span class="ansi38-255165000"
>  (= 
    (bool->number True) 1)
</span>;;;; Define a less than type.  Note that it is purposefully different
;;;; than ⩻ as it is a type, not an operator.  Inhabitants of (⍃ x y)
;;;; are proofs that x ⩻ y == True.  For now ⍃ is only axiomatized for
;;;; Nat.
<span class="ansi38-255165000"
>  (: ⍃ 
    (-> $t $t Type))
</span>;;;; Zero is always less than the successor of something
<span class="ansi38-255165000"
>  (: 
    (zero-lt-succ-axiom) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (zero-lt-succ-axiom) 
    (: ZeroLTSucc 
      (⍃ Z 
        (S $k))))
</span>;;;; If x ⍃ y then (S x) ⍃ (S y)
<span class="ansi38-255165000"
>  (: 
    (succ-monotonicity-rule) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (succ-monotonicity-rule) 
    (: SuccMonotonicity 
      (-> 
        (⍃ $x $y) 
        (⍃ 
          (S $x) 
          (S $y)))))
</span>;;;; Collection of functions operating on numbers
;;;; Define max
<span class="ansi38-255165000"
>  (: max 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (max $x $y) 
    (if 
      (> $x $y) $x $y))
</span>;;;; Define min
<span class="ansi38-255165000"
>  (: min 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (min $x $y) 
    (if 
      (< $x $y) $x $y))
</span>;;;; Clamp a number to be within a certain range
<span class="ansi38-255165000"
>  (: clamp 
    (-> $a $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (clamp $x $l $u) 
    (max $l 
      (min $u $x)))
</span>;;;; Define abs
<span class="ansi38-255165000"
>  (: abs 
    (-> $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (abs $x) 
    (if 
      (< $x 0) 
      (* -1 $x) $x))
</span>;;;; Define <=
<span class="ansi38-255165000"
>  (: <= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (<= $x $y) 
    (or 
      (< $x $y) 
      (== $x $y)))
</span>;;;; Define >=
<span class="ansi38-255165000"
>  (: >= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (>= $x $y) 
    (or 
      (> $x $y) 
      (== $x $y)))
</span>;;;; Define approximately equal
<span class="ansi38-255165000"
>  (: approxEq 
    (-> $a $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (approxEq $x $y $epsilon) 
    (<= 
      (abs (- $x $y)) $epsilon))
</span>;;;; Define Nat
<span class="ansi38-255165000"
>  (: Nat Type)
</span><span class="ansi38-255165000"
>  (: Z Nat)
</span><span class="ansi38-255165000"
>  (: S 
    (-> Nat Nat))
</span>;;;; Define cast functions between Nat and Number
<span class="ansi38-255165000"
>  (: fromNumber 
    (-> Number Nat))
</span><span class="ansi38-255165000"
>  (= 
    (fromNumber $n) 
    (if 
      (<= $n 0) Z 
      (S (fromNumber (- $n 1)))))
</span><span class="ansi38-255165000"
>  (: fromNat 
    (-> Nat Number))
</span><span class="ansi38-255165000"
>  (= 
    (fromNat Z) 0)
</span><span class="ansi38-255165000"
>  (= 
    (fromNat (S $k)) 
    (+ 1 
      (fromNat $k)))
</span>;;;; Define a generic less than operator, ⩻, for Nat.  < cannot be used
;;;; because it is a built-in, its type is hardwired and cannot be
;;;; overloaded.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Nat Nat Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $ Z) False)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ Z 
      (S $)) True)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ 
      (S $x) 
      (S $y)) 
    (⩻ $x $y))
</span>;;;; Overload ⩻ for Number.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Number Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $x $y) 
    (< $x $y))
</span>;;;; Return the ceiling of a non negative number.  If the number is
;;;; negative it returns 1.
<span class="ansi38-255165000"
>  (: ceil 
    (-> Number Number))
</span><span class="ansi38-255165000"
>  (= 
    (ceil $n) 
    (fromNat (fromNumber $n)))
</span>;;;; Convert Number to Bool.  Anything above 0 converts to True.
<span class="ansi38-255165000"
>  (: number->bool 
    (-> Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (number->bool $x) 
    (< 0 $x))
</span>;;;; Convert Bool to Number.  False converts to 0, True converts to 1.
<span class="ansi38-255165000"
>  (: bool->number 
    (-> Bool Number))
</span><span class="ansi38-255165000"
>  (= 
    (bool->number False) 0)
</span><span class="ansi38-255165000"
>  (= 
    (bool->number True) 1)
</span>;;;; Define a less than type.  Note that it is purposefully different
;;;; than ⩻ as it is a type, not an operator.  Inhabitants of (⍃ x y)
;;;; are proofs that x ⩻ y == True.  For now ⍃ is only axiomatized for
;;;; Nat.
<span class="ansi38-255165000"
>  (: ⍃ 
    (-> $t $t Type))
</span>;;;; Zero is always less than the successor of something
<span class="ansi38-255165000"
>  (: 
    (zero-lt-succ-axiom) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (zero-lt-succ-axiom) 
    (: ZeroLTSucc 
      (⍃ Z 
        (S $k))))
</span>;;;; If x ⍃ y then (S x) ⍃ (S y)
<span class="ansi38-255165000"
>  (: 
    (succ-monotonicity-rule) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (succ-monotonicity-rule) 
    (: SuccMonotonicity 
      (-> 
        (⍃ $x $y) 
        (⍃ 
          (S $x) 
          (S $y)))))
</span>;;;; Collection of functions operating on numbers
;;;; Define max
<span class="ansi38-255165000"
>  (: max 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (max $x $y) 
    (if 
      (> $x $y) $x $y))
</span>;;;; Define min
<span class="ansi38-255165000"
>  (: min 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (min $x $y) 
    (if 
      (< $x $y) $x $y))
</span>;;;; Clamp a number to be within a certain range
<span class="ansi38-255165000"
>  (: clamp 
    (-> $a $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (clamp $x $l $u) 
    (max $l 
      (min $u $x)))
</span>;;;; Define abs
<span class="ansi38-255165000"
>  (: abs 
    (-> $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (abs $x) 
    (if 
      (< $x 0) 
      (* -1 $x) $x))
</span>;;;; Define <=
<span class="ansi38-255165000"
>  (: <= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (<= $x $y) 
    (or 
      (< $x $y) 
      (== $x $y)))
</span>;;;; Define >=
<span class="ansi38-255165000"
>  (: >= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (>= $x $y) 
    (or 
      (> $x $y) 
      (== $x $y)))
</span>;;;; Define approximately equal
<span class="ansi38-255165000"
>  (: approxEq 
    (-> $a $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (approxEq $x $y $epsilon) 
    (<= 
      (abs (- $x $y)) $epsilon))
</span>;;;; Define Nat
<span class="ansi38-255165000"
>  (: Nat Type)
</span><span class="ansi38-255165000"
>  (: Z Nat)
</span><span class="ansi38-255165000"
>  (: S 
    (-> Nat Nat))
</span>;;;; Define cast functions between Nat and Number
<span class="ansi38-255165000"
>  (: fromNumber 
    (-> Number Nat))
</span><span class="ansi38-255165000"
>  (= 
    (fromNumber $n) 
    (if 
      (<= $n 0) Z 
      (S (fromNumber (- $n 1)))))
</span><span class="ansi38-255165000"
>  (: fromNat 
    (-> Nat Number))
</span><span class="ansi38-255165000"
>  (= 
    (fromNat Z) 0)
</span><span class="ansi38-255165000"
>  (= 
    (fromNat (S $k)) 
    (+ 1 
      (fromNat $k)))
</span>;;;; Define a generic less than operator, ⩻, for Nat.  < cannot be used
;;;; because it is a built-in, its type is hardwired and cannot be
;;;; overloaded.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Nat Nat Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $ Z) False)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ Z 
      (S $)) True)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ 
      (S $x) 
      (S $y)) 
    (⩻ $x $y))
</span>;;;; Overload ⩻ for Number.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Number Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $x $y) 
    (< $x $y))
</span>;;;; Return the ceiling of a non negative number.  If the number is
;;;; negative it returns 1.
<span class="ansi38-255165000"
>  (: ceil 
    (-> Number Number))
</span><span class="ansi38-255165000"
>  (= 
    (ceil $n) 
    (fromNat (fromNumber $n)))
</span>;;;; Convert Number to Bool.  Anything above 0 converts to True.
<span class="ansi38-255165000"
>  (: number->bool 
    (-> Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (number->bool $x) 
    (< 0 $x))
</span>;;;; Convert Bool to Number.  False converts to 0, True converts to 1.
<span class="ansi38-255165000"
>  (: bool->number 
    (-> Bool Number))
</span><span class="ansi38-255165000"
>  (= 
    (bool->number False) 0)
</span><span class="ansi38-255165000"
>  (= 
    (bool->number True) 1)
</span>;;;; Define a less than type.  Note that it is purposefully different
;;;; than ⩻ as it is a type, not an operator.  Inhabitants of (⍃ x y)
;;;; are proofs that x ⩻ y == True.  For now ⍃ is only axiomatized for
;;;; Nat.
<span class="ansi38-255165000"
>  (: ⍃ 
    (-> $t $t Type))
</span>;;;; Zero is always less than the successor of something
<span class="ansi38-255165000"
>  (: 
    (zero-lt-succ-axiom) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (zero-lt-succ-axiom) 
    (: ZeroLTSucc 
      (⍃ Z 
        (S $k))))
</span>;;;; If x ⍃ y then (S x) ⍃ (S y)
<span class="ansi38-255165000"
>  (: 
    (succ-monotonicity-rule) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (succ-monotonicity-rule) 
    (: SuccMonotonicity 
      (-> 
        (⍃ $x $y) 
        (⍃ 
          (S $x) 
          (S $y)))))
</span>;;;; Collection of functions operating on numbers
;;;; Define max
<span class="ansi38-255165000"
>  (: max 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (max $x $y) 
    (if 
      (> $x $y) $x $y))
</span>;;;; Define min
<span class="ansi38-255165000"
>  (: min 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (min $x $y) 
    (if 
      (< $x $y) $x $y))
</span>;;;; Clamp a number to be within a certain range
<span class="ansi38-255165000"
>  (: clamp 
    (-> $a $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (clamp $x $l $u) 
    (max $l 
      (min $u $x)))
</span>;;;; Define abs
<span class="ansi38-255165000"
>  (: abs 
    (-> $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (abs $x) 
    (if 
      (< $x 0) 
      (* -1 $x) $x))
</span>;;;; Define <=
<span class="ansi38-255165000"
>  (: <= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (<= $x $y) 
    (or 
      (< $x $y) 
      (== $x $y)))
</span>;;;; Define >=
<span class="ansi38-255165000"
>  (: >= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (>= $x $y) 
    (or 
      (> $x $y) 
      (== $x $y)))
</span>;;;; Define approximately equal
<span class="ansi38-255165000"
>  (: approxEq 
    (-> $a $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (approxEq $x $y $epsilon) 
    (<= 
      (abs (- $x $y)) $epsilon))
</span>;;;; Define Nat
<span class="ansi38-255165000"
>  (: Nat Type)
</span><span class="ansi38-255165000"
>  (: Z Nat)
</span><span class="ansi38-255165000"
>  (: S 
    (-> Nat Nat))
</span>;;;; Define cast functions between Nat and Number
<span class="ansi38-255165000"
>  (: fromNumber 
    (-> Number Nat))
</span><span class="ansi38-255165000"
>  (= 
    (fromNumber $n) 
    (if 
      (<= $n 0) Z 
      (S (fromNumber (- $n 1)))))
</span><span class="ansi38-255165000"
>  (: fromNat 
    (-> Nat Number))
</span><span class="ansi38-255165000"
>  (= 
    (fromNat Z) 0)
</span><span class="ansi38-255165000"
>  (= 
    (fromNat (S $k)) 
    (+ 1 
      (fromNat $k)))
</span>;;;; Define a generic less than operator, ⩻, for Nat.  < cannot be used
;;;; because it is a built-in, its type is hardwired and cannot be
;;;; overloaded.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Nat Nat Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $ Z) False)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ Z 
      (S $)) True)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ 
      (S $x) 
      (S $y)) 
    (⩻ $x $y))
</span>;;;; Overload ⩻ for Number.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Number Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $x $y) 
    (< $x $y))
</span>;;;; Return the ceiling of a non negative number.  If the number is
;;;; negative it returns 1.
<span class="ansi38-255165000"
>  (: ceil 
    (-> Number Number))
</span><span class="ansi38-255165000"
>  (= 
    (ceil $n) 
    (fromNat (fromNumber $n)))
</span>;;;; Convert Number to Bool.  Anything above 0 converts to True.
<span class="ansi38-255165000"
>  (: number->bool 
    (-> Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (number->bool $x) 
    (< 0 $x))
</span>;;;; Convert Bool to Number.  False converts to 0, True converts to 1.
<span class="ansi38-255165000"
>  (: bool->number 
    (-> Bool Number))
</span><span class="ansi38-255165000"
>  (= 
    (bool->number False) 0)
</span><span class="ansi38-255165000"
>  (= 
    (bool->number True) 1)
</span>;;;; Define a less than type.  Note that it is purposefully different
;;;; than ⩻ as it is a type, not an operator.  Inhabitants of (⍃ x y)
;;;; are proofs that x ⩻ y == True.  For now ⍃ is only axiomatized for
;;;; Nat.
<span class="ansi38-255165000"
>  (: ⍃ 
    (-> $t $t Type))
</span>;;;; Zero is always less than the successor of something
<span class="ansi38-255165000"
>  (: 
    (zero-lt-succ-axiom) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (zero-lt-succ-axiom) 
    (: ZeroLTSucc 
      (⍃ Z 
        (S $k))))
</span>;;;; If x ⍃ y then (S x) ⍃ (S y)
<span class="ansi38-255165000"
>  (: 
    (succ-monotonicity-rule) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (succ-monotonicity-rule) 
    (: SuccMonotonicity 
      (-> 
        (⍃ $x $y) 
        (⍃ 
          (S $x) 
          (S $y)))))
</span>;;;; Collection of functions operating on numbers
;;;; Define max
<span class="ansi38-255165000"
>  (: max 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (max $x $y) 
    (if 
      (> $x $y) $x $y))
</span>;;;; Define min
<span class="ansi38-255165000"
>  (: min 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (min $x $y) 
    (if 
      (< $x $y) $x $y))
</span>;;;; Clamp a number to be within a certain range
<span class="ansi38-255165000"
>  (: clamp 
    (-> $a $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (clamp $x $l $u) 
    (max $l 
      (min $u $x)))
</span>;;;; Define abs
<span class="ansi38-255165000"
>  (: abs 
    (-> $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (abs $x) 
    (if 
      (< $x 0) 
      (* -1 $x) $x))
</span>;;;; Define <=
<span class="ansi38-255165000"
>  (: <= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (<= $x $y) 
    (or 
      (< $x $y) 
      (== $x $y)))
</span>;;;; Define >=
<span class="ansi38-255165000"
>  (: >= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (>= $x $y) 
    (or 
      (> $x $y) 
      (== $x $y)))
</span>;;;; Define approximately equal
<span class="ansi38-255165000"
>  (: approxEq 
    (-> $a $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (approxEq $x $y $epsilon) 
    (<= 
      (abs (- $x $y)) $epsilon))
</span>;;;; Define Nat
<span class="ansi38-255165000"
>  (: Nat Type)
</span><span class="ansi38-255165000"
>  (: Z Nat)
</span><span class="ansi38-255165000"
>  (: S 
    (-> Nat Nat))
</span>;;;; Define cast functions between Nat and Number
<span class="ansi38-255165000"
>  (: fromNumber 
    (-> Number Nat))
</span><span class="ansi38-255165000"
>  (= 
    (fromNumber $n) 
    (if 
      (<= $n 0) Z 
      (S (fromNumber (- $n 1)))))
</span><span class="ansi38-255165000"
>  (: fromNat 
    (-> Nat Number))
</span><span class="ansi38-255165000"
>  (= 
    (fromNat Z) 0)
</span><span class="ansi38-255165000"
>  (= 
    (fromNat (S $k)) 
    (+ 1 
      (fromNat $k)))
</span>;;;; Define a generic less than operator, ⩻, for Nat.  < cannot be used
;;;; because it is a built-in, its type is hardwired and cannot be
;;;; overloaded.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Nat Nat Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $ Z) False)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ Z 
      (S $)) True)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ 
      (S $x) 
      (S $y)) 
    (⩻ $x $y))
</span>;;;; Overload ⩻ for Number.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Number Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $x $y) 
    (< $x $y))
</span>;;;; Return the ceiling of a non negative number.  If the number is
;;;; negative it returns 1.
<span class="ansi38-255165000"
>  (: ceil 
    (-> Number Number))
</span><span class="ansi38-255165000"
>  (= 
    (ceil $n) 
    (fromNat (fromNumber $n)))
</span>;;;; Convert Number to Bool.  Anything above 0 converts to True.
<span class="ansi38-255165000"
>  (: number->bool 
    (-> Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (number->bool $x) 
    (< 0 $x))
</span>;;;; Convert Bool to Number.  False converts to 0, True converts to 1.
<span class="ansi38-255165000"
>  (: bool->number 
    (-> Bool Number))
</span><span class="ansi38-255165000"
>  (= 
    (bool->number False) 0)
</span><span class="ansi38-255165000"
>  (= 
    (bool->number True) 1)
</span>;;;; Define a less than type.  Note that it is purposefully different
;;;; than ⩻ as it is a type, not an operator.  Inhabitants of (⍃ x y)
;;;; are proofs that x ⩻ y == True.  For now ⍃ is only axiomatized for
;;;; Nat.
<span class="ansi38-255165000"
>  (: ⍃ 
    (-> $t $t Type))
</span>;;;; Zero is always less than the successor of something
<span class="ansi38-255165000"
>  (: 
    (zero-lt-succ-axiom) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (zero-lt-succ-axiom) 
    (: ZeroLTSucc 
      (⍃ Z 
        (S $k))))
</span>;;;; If x ⍃ y then (S x) ⍃ (S y)
<span class="ansi38-255165000"
>  (: 
    (succ-monotonicity-rule) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (succ-monotonicity-rule) 
    (: SuccMonotonicity 
      (-> 
        (⍃ $x $y) 
        (⍃ 
          (S $x) 
          (S $y)))))
</span>
Deterministic: ()
;;;;;;;;;;;;
;;;; Type ;;
;;;;;;;;;;;;
<span class="ansi38-255165000"
>  (: TruthValue Type)
</span>;;;;;;;;;;;;;;;;;;;;
;;;; Constructors ;;
;;;;;;;;;;;;;;;;;;;;
;;;; Boolean TV constructor
;;;; TODO: alternatively we could have (: ⊤ TruthValue) and (: ⊥ TruthValue)
<span class="ansi38-255165000"
>  (: Bl 
    (-> Bool TruthValue))
</span>;;;; First order probability TV constructor, i.e. mere probability.
<span class="ansi38-255165000"
>  (: Pr 
    (-> Number TruthValue))
</span>;;;; Simple Truth Value.  A Second order probability TV constructor,
;;;; i.e. probability and confidence.  The probability is in fact the
;;;; mode of the corresponding beta distribution.
<span class="ansi38-255165000"
>  (: STV 
    (-> Number Number TruthValue))
</span>;;;;;;;;;;;;;;;;;
;;;; Constants ;;
;;;;;;;;;;;;;;;;;
;;;; For now the underlying beta distributions have a Jeffreys prior,
;;;; i.e. the prior alpha and beta are 0.5.
<span class="ansi38-255165000"
>  (: prior-alpha 
    (-> Number))
</span><span class="ansi38-255165000"
>  (= 
    (prior-alpha) 0.5)
</span><span class="ansi38-255165000"
>  (: prior-beta 
    (-> Number))
</span><span class="ansi38-255165000"
>  (= 
    (prior-beta) 0.5)
</span>;;;; Lookahead
<span class="ansi38-255165000"
>  (: lookahead 
    (-> Number))
</span><span class="ansi38-255165000"
>  (= 
    (lookahead) 1.0)
</span>;;;; Maximum supported count (till +inf is supported, possibly).
<span class="ansi38-255165000"
>  (: max-count 
    (-> Number))
</span><span class="ansi38-255165000"
>  (= 
    (max-count) 1000000000.0)
</span>;;;;;;;;;;;;;;;
;;;; Methods ;;
;;;;;;;;;;;;;;;
;;;; Convert count to confidence using the formula
;;;;
;;;; confidence = count / (count + lookahead)
<span class="ansi38-255165000"
>  (: count->confidence 
    (-> Number Number))
</span><span class="ansi38-255165000"
>  (= 
    (count->confidence $cnt) 
    (/ $cnt 
      (+ $cnt 
        (lookahead))))
</span>;;;; Convert confidence to count using the formula
;;;;
;;;; count = (confidence * lookahead) / (1 - confidence)
<span class="ansi38-255165000"
>  (: confidence->count 
    (-> Number Number))
</span><span class="ansi38-255165000"
>  (= 
    (confidence->count $conf) 
    (if 
      (approxEq 1.0 $conf 1.0e-9) 
      (max-count) 
      (/ 
        (* $conf 
          (lookahead)) 
        (- 1.0 $conf))))
</span>;;;; Increment the negative count of a given truth value, by
;;;; incrementing its total count without incrementing the positive
;;;; count.
<span class="ansi38-255165000"
>  (: inc-neg-count 
    (-> TruthValue TruthValue))
</span><span class="ansi38-255165000"
>  (= 
    (inc-neg-count (STV $s $c)) 
    (let* 
      ( ($tot_cnt (confidence->count $c)) 
        ($pos_cnt (* $s $tot_cnt)) 
        ($new_tot_cnt (+ $tot_cnt 1))) 
      (STV 
        (/ $pos_cnt $new_tot_cnt) 
        (count->confidence $new_tot_cnt))))
</span>;;;; Increment the positive count of a given truth value, by
;;;; incrementing its total count and its positive count.
<span class="ansi38-255165000"
>  (: inc-pos-count 
    (-> TruthValue TruthValue))
</span><span class="ansi38-255165000"
>  (= 
    (inc-pos-count (STV $s $c)) 
    (let* 
      ( ($tot_cnt (confidence->count $c)) 
        ($pos_cnt (* $s $tot_cnt)) 
        ($new_pos_cnt (+ $pos_cnt 1)) 
        ($new_tot_cnt (+ $tot_cnt 1))) 
      (STV 
        (/ $new_pos_cnt $new_tot_cnt) 
        (count->confidence $new_tot_cnt))))
</span>;;;; Return the first order probability mode of the second order
;;;; distribution associated to a truth value.
<span class="ansi38-255165000"
>  (: mode 
    (-> TruthValue Number))
</span><span class="ansi38-255165000"
>  (= 
    (mode (Bl True)) 1.0)
</span><span class="ansi38-255165000"
>  (= 
    (mode (Bl False)) 0.0)
</span><span class="ansi38-255165000"
>  (= 
    (mode (Pr $pr)) $pr)
</span><span class="ansi38-255165000"
>  (= 
    (mode (STV $pr $)) $pr)
</span>;;;; Return the total count of a truth value.  For truth values not
;;;; capturing a notion of confidence, such as Bl or Pr then the count
;;;; is assumed to be a very large number (cause +inf does not seem to
;;;; be supported at the moment).
<span class="ansi38-255165000"
>  (: count 
    (-> TruthValue Number))
</span><span class="ansi38-255165000"
>  (= 
    (count (Bl $)) 
    (max-count))
</span><span class="ansi38-255165000"
>  (= 
    (count (Pr $)) 
    (max-count))
</span><span class="ansi38-255165000"
>  (= 
    (count (STV $ $conf)) 
    (confidence->count $conf))
</span>;;;; Return the confidence of a truth value.  For truth values not
;;;; capturing a notion of confidence, such as Bl or Pr then the
;;;; confidence is assumed to be 1.0.  For truth values capturing a
;;;; notion of confidence, such as STV, the formula to convert a count
;;;; into confidence is as follows
;;;;
;;;; confidence = count / (count + lookahead)
<span class="ansi38-255165000"
>  (: confidence 
    (-> TruthValue Number))
</span><span class="ansi38-255165000"
>  (= 
    (confidence (Bl $)) 1.0)
</span><span class="ansi38-255165000"
>  (= 
    (confidence (Pr $)) 1.0)
</span><span class="ansi38-255165000"
>  (= 
    (confidence (STV $ $conf)) $conf)
</span>;;;; Return the positive count of a truth value.
<span class="ansi38-255165000"
>  (: pos-count 
    (-> TruthValue Number))
</span><span class="ansi38-255165000"
>  (= 
    (pos-count $tv) 
    (* 
      (mode $tv) 
      (count $tv)))
</span>;;;; Return the negative count of a truth value.
<span class="ansi38-255165000"
>  (: neg-count 
    (-> TruthValue Number))
</span><span class="ansi38-255165000"
>  (= 
    (neg-count $tv) 
    (* 
      (- 1 
        (mode $tv)) 
      (count $tv)))
</span>;;;; Return the posterior alpha of a truth value
<span class="ansi38-255165000"
>  (: post-alpha 
    (-> TruthValue Number))
</span><span class="ansi38-255165000"
>  (= 
    (post-alpha $tv) 
    (+ 
      (prior-alpha) 
      (pos-count $tv)))
</span>;;;; Return the posterior beta of a truth value
<span class="ansi38-255165000"
>  (: post-beta 
    (-> TruthValue Number))
</span><span class="ansi38-255165000"
>  (= 
    (post-beta $tv) 
    (+ 
      (prior-beta) 
      (neg-count $tv)))
</span>;;;; Return the first order probability mean of the second order
;;;; distribution associated to a truth value.  For truth values not
;;;; capturing a notion of confidence, such as Bl or Pr then the
;;;; confidence is assumed to be 1.0.  For truth values capturing a
;;;; notion of confidence, such as STV, a beta distribution is assumed.
<span class="ansi38-255165000"
>  (: mean 
    (-> TruthValue Number))
</span><span class="ansi38-255165000"
>  (= 
    (mean (Bl True)) 1.0)
</span><span class="ansi38-255165000"
>  (= 
    (mean (Bl False)) 0.0)
</span><span class="ansi38-255165000"
>  (= 
    (mean (Pr $pr)) $pr)
</span><span class="ansi38-255165000"
>  (= 
    (mean (STV $pr $conf)) 
    (let* 
      ( ($a (post-alpha (STV $pr $conf))) ($b (post-beta (STV $pr $conf)))) 
      (/ $a 
        (+ $a $b))))
</span>
Last Result(2): ()
<span class="ansi38-013099040"
>  !(import! &self ../Num.metta)

</span>P;HTML|
;                                           (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/Num.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/Num.metta)
P;HTML|
;                                           (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/Num.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/Num.metta)

;;;; Collection of functions operating on numbers
;;;; Define max
<span class="ansi38-255165000"
>  (: max 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (max $x $y) 
    (if 
      (> $x $y) $x $y))
</span>;;;; Define min
<span class="ansi38-255165000"
>  (: min 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (min $x $y) 
    (if 
      (< $x $y) $x $y))
</span>;;;; Clamp a number to be within a certain range
<span class="ansi38-255165000"
>  (: clamp 
    (-> $a $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (clamp $x $l $u) 
    (max $l 
      (min $u $x)))
</span>;;;; Define abs
<span class="ansi38-255165000"
>  (: abs 
    (-> $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (abs $x) 
    (if 
      (< $x 0) 
      (* -1 $x) $x))
</span>;;;; Define <=
<span class="ansi38-255165000"
>  (: <= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (<= $x $y) 
    (or 
      (< $x $y) 
      (== $x $y)))
</span>;;;; Define >=
<span class="ansi38-255165000"
>  (: >= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (>= $x $y) 
    (or 
      (> $x $y) 
      (== $x $y)))
</span>;;;; Define approximately equal
<span class="ansi38-255165000"
>  (: approxEq 
    (-> $a $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (approxEq $x $y $epsilon) 
    (<= 
      (abs (- $x $y)) $epsilon))
</span>;;;; Define Nat
<span class="ansi38-255165000"
>  (: Nat Type)
</span><span class="ansi38-255165000"
>  (: Z Nat)
</span><span class="ansi38-255165000"
>  (: S 
    (-> Nat Nat))
</span>;;;; Define cast functions between Nat and Number
<span class="ansi38-255165000"
>  (: fromNumber 
    (-> Number Nat))
</span><span class="ansi38-255165000"
>  (= 
    (fromNumber $n) 
    (if 
      (<= $n 0) Z 
      (S (fromNumber (- $n 1)))))
</span><span class="ansi38-255165000"
>  (: fromNat 
    (-> Nat Number))
</span><span class="ansi38-255165000"
>  (= 
    (fromNat Z) 0)
</span><span class="ansi38-255165000"
>  (= 
    (fromNat (S $k)) 
    (+ 1 
      (fromNat $k)))
</span>;;;; Define a generic less than operator, ⩻, for Nat.  < cannot be used
;;;; because it is a built-in, its type is hardwired and cannot be
;;;; overloaded.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Nat Nat Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $ Z) False)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ Z 
      (S $)) True)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ 
      (S $x) 
      (S $y)) 
    (⩻ $x $y))
</span>;;;; Overload ⩻ for Number.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Number Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $x $y) 
    (< $x $y))
</span>;;;; Return the ceiling of a non negative number.  If the number is
;;;; negative it returns 1.
<span class="ansi38-255165000"
>  (: ceil 
    (-> Number Number))
</span><span class="ansi38-255165000"
>  (= 
    (ceil $n) 
    (fromNat (fromNumber $n)))
</span>;;;; Convert Number to Bool.  Anything above 0 converts to True.
<span class="ansi38-255165000"
>  (: number->bool 
    (-> Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (number->bool $x) 
    (< 0 $x))
</span>;;;; Convert Bool to Number.  False converts to 0, True converts to 1.
<span class="ansi38-255165000"
>  (: bool->number 
    (-> Bool Number))
</span><span class="ansi38-255165000"
>  (= 
    (bool->number False) 0)
</span><span class="ansi38-255165000"
>  (= 
    (bool->number True) 1)
</span>;;;; Define a less than type.  Note that it is purposefully different
;;;; than ⩻ as it is a type, not an operator.  Inhabitants of (⍃ x y)
;;;; are proofs that x ⩻ y == True.  For now ⍃ is only axiomatized for
;;;; Nat.
<span class="ansi38-255165000"
>  (: ⍃ 
    (-> $t $t Type))
</span>;;;; Zero is always less than the successor of something
<span class="ansi38-255165000"
>  (: 
    (zero-lt-succ-axiom) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (zero-lt-succ-axiom) 
    (: ZeroLTSucc 
      (⍃ Z 
        (S $k))))
</span>;;;; If x ⍃ y then (S x) ⍃ (S y)
<span class="ansi38-255165000"
>  (: 
    (succ-monotonicity-rule) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (succ-monotonicity-rule) 
    (: SuccMonotonicity 
      (-> 
        (⍃ $x $y) 
        (⍃ 
          (S $x) 
          (S $y)))))
</span>;;;; Collection of functions operating on numbers
;;;; Define max
<span class="ansi38-255165000"
>  (: max 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (max $x $y) 
    (if 
      (> $x $y) $x $y))
</span>;;;; Define min
<span class="ansi38-255165000"
>  (: min 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (min $x $y) 
    (if 
      (< $x $y) $x $y))
</span>;;;; Clamp a number to be within a certain range
<span class="ansi38-255165000"
>  (: clamp 
    (-> $a $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (clamp $x $l $u) 
    (max $l 
      (min $u $x)))
</span>;;;; Define abs
<span class="ansi38-255165000"
>  (: abs 
    (-> $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (abs $x) 
    (if 
      (< $x 0) 
      (* -1 $x) $x))
</span>;;;; Define <=
<span class="ansi38-255165000"
>  (: <= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (<= $x $y) 
    (or 
      (< $x $y) 
      (== $x $y)))
</span>;;;; Define >=
<span class="ansi38-255165000"
>  (: >= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (>= $x $y) 
    (or 
      (> $x $y) 
      (== $x $y)))
</span>;;;; Define approximately equal
<span class="ansi38-255165000"
>  (: approxEq 
    (-> $a $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (approxEq $x $y $epsilon) 
    (<= 
      (abs (- $x $y)) $epsilon))
</span>;;;; Define Nat
<span class="ansi38-255165000"
>  (: Nat Type)
</span><span class="ansi38-255165000"
>  (: Z Nat)
</span><span class="ansi38-255165000"
>  (: S 
    (-> Nat Nat))
</span>;;;; Define cast functions between Nat and Number
<span class="ansi38-255165000"
>  (: fromNumber 
    (-> Number Nat))
</span><span class="ansi38-255165000"
>  (= 
    (fromNumber $n) 
    (if 
      (<= $n 0) Z 
      (S (fromNumber (- $n 1)))))
</span><span class="ansi38-255165000"
>  (: fromNat 
    (-> Nat Number))
</span><span class="ansi38-255165000"
>  (= 
    (fromNat Z) 0)
</span><span class="ansi38-255165000"
>  (= 
    (fromNat (S $k)) 
    (+ 1 
      (fromNat $k)))
</span>;;;; Define a generic less than operator, ⩻, for Nat.  < cannot be used
;;;; because it is a built-in, its type is hardwired and cannot be
;;;; overloaded.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Nat Nat Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $ Z) False)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ Z 
      (S $)) True)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ 
      (S $x) 
      (S $y)) 
    (⩻ $x $y))
</span>;;;; Overload ⩻ for Number.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Number Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $x $y) 
    (< $x $y))
</span>;;;; Return the ceiling of a non negative number.  If the number is
;;;; negative it returns 1.
<span class="ansi38-255165000"
>  (: ceil 
    (-> Number Number))
</span><span class="ansi38-255165000"
>  (= 
    (ceil $n) 
    (fromNat (fromNumber $n)))
</span>;;;; Convert Number to Bool.  Anything above 0 converts to True.
<span class="ansi38-255165000"
>  (: number->bool 
    (-> Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (number->bool $x) 
    (< 0 $x))
</span>;;;; Convert Bool to Number.  False converts to 0, True converts to 1.
<span class="ansi38-255165000"
>  (: bool->number 
    (-> Bool Number))
</span><span class="ansi38-255165000"
>  (= 
    (bool->number False) 0)
</span><span class="ansi38-255165000"
>  (= 
    (bool->number True) 1)
</span>;;;; Define a less than type.  Note that it is purposefully different
;;;; than ⩻ as it is a type, not an operator.  Inhabitants of (⍃ x y)
;;;; are proofs that x ⩻ y == True.  For now ⍃ is only axiomatized for
;;;; Nat.
<span class="ansi38-255165000"
>  (: ⍃ 
    (-> $t $t Type))
</span>;;;; Zero is always less than the successor of something
<span class="ansi38-255165000"
>  (: 
    (zero-lt-succ-axiom) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (zero-lt-succ-axiom) 
    (: ZeroLTSucc 
      (⍃ Z 
        (S $k))))
</span>;;;; If x ⍃ y then (S x) ⍃ (S y)
<span class="ansi38-255165000"
>  (: 
    (succ-monotonicity-rule) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (succ-monotonicity-rule) 
    (: SuccMonotonicity 
      (-> 
        (⍃ $x $y) 
        (⍃ 
          (S $x) 
          (S $y)))))
</span>;;;; Collection of functions operating on numbers
;;;; Define max
<span class="ansi38-255165000"
>  (: max 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (max $x $y) 
    (if 
      (> $x $y) $x $y))
</span>;;;; Define min
<span class="ansi38-255165000"
>  (: min 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (min $x $y) 
    (if 
      (< $x $y) $x $y))
</span>;;;; Clamp a number to be within a certain range
<span class="ansi38-255165000"
>  (: clamp 
    (-> $a $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (clamp $x $l $u) 
    (max $l 
      (min $u $x)))
</span>;;;; Define abs
<span class="ansi38-255165000"
>  (: abs 
    (-> $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (abs $x) 
    (if 
      (< $x 0) 
      (* -1 $x) $x))
</span>;;;; Define <=
<span class="ansi38-255165000"
>  (: <= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (<= $x $y) 
    (or 
      (< $x $y) 
      (== $x $y)))
</span>;;;; Define >=
<span class="ansi38-255165000"
>  (: >= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (>= $x $y) 
    (or 
      (> $x $y) 
      (== $x $y)))
</span>;;;; Define approximately equal
<span class="ansi38-255165000"
>  (: approxEq 
    (-> $a $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (approxEq $x $y $epsilon) 
    (<= 
      (abs (- $x $y)) $epsilon))
</span>;;;; Define Nat
<span class="ansi38-255165000"
>  (: Nat Type)
</span><span class="ansi38-255165000"
>  (: Z Nat)
</span><span class="ansi38-255165000"
>  (: S 
    (-> Nat Nat))
</span>;;;; Define cast functions between Nat and Number
<span class="ansi38-255165000"
>  (: fromNumber 
    (-> Number Nat))
</span><span class="ansi38-255165000"
>  (= 
    (fromNumber $n) 
    (if 
      (<= $n 0) Z 
      (S (fromNumber (- $n 1)))))
</span><span class="ansi38-255165000"
>  (: fromNat 
    (-> Nat Number))
</span><span class="ansi38-255165000"
>  (= 
    (fromNat Z) 0)
</span><span class="ansi38-255165000"
>  (= 
    (fromNat (S $k)) 
    (+ 1 
      (fromNat $k)))
</span>;;;; Define a generic less than operator, ⩻, for Nat.  < cannot be used
;;;; because it is a built-in, its type is hardwired and cannot be
;;;; overloaded.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Nat Nat Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $ Z) False)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ Z 
      (S $)) True)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ 
      (S $x) 
      (S $y)) 
    (⩻ $x $y))
</span>;;;; Overload ⩻ for Number.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Number Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $x $y) 
    (< $x $y))
</span>;;;; Return the ceiling of a non negative number.  If the number is
;;;; negative it returns 1.
<span class="ansi38-255165000"
>  (: ceil 
    (-> Number Number))
</span><span class="ansi38-255165000"
>  (= 
    (ceil $n) 
    (fromNat (fromNumber $n)))
</span>;;;; Convert Number to Bool.  Anything above 0 converts to True.
<span class="ansi38-255165000"
>  (: number->bool 
    (-> Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (number->bool $x) 
    (< 0 $x))
</span>;;;; Convert Bool to Number.  False converts to 0, True converts to 1.
<span class="ansi38-255165000"
>  (: bool->number 
    (-> Bool Number))
</span><span class="ansi38-255165000"
>  (= 
    (bool->number False) 0)
</span><span class="ansi38-255165000"
>  (= 
    (bool->number True) 1)
</span>;;;; Define a less than type.  Note that it is purposefully different
;;;; than ⩻ as it is a type, not an operator.  Inhabitants of (⍃ x y)
;;;; are proofs that x ⩻ y == True.  For now ⍃ is only axiomatized for
;;;; Nat.
<span class="ansi38-255165000"
>  (: ⍃ 
    (-> $t $t Type))
</span>;;;; Zero is always less than the successor of something
<span class="ansi38-255165000"
>  (: 
    (zero-lt-succ-axiom) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (zero-lt-succ-axiom) 
    (: ZeroLTSucc 
      (⍃ Z 
        (S $k))))
</span>;;;; If x ⍃ y then (S x) ⍃ (S y)
<span class="ansi38-255165000"
>  (: 
    (succ-monotonicity-rule) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (succ-monotonicity-rule) 
    (: SuccMonotonicity 
      (-> 
        (⍃ $x $y) 
        (⍃ 
          (S $x) 
          (S $y)))))
</span>;;;; Collection of functions operating on numbers
;;;; Define max
<span class="ansi38-255165000"
>  (: max 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (max $x $y) 
    (if 
      (> $x $y) $x $y))
</span>;;;; Define min
<span class="ansi38-255165000"
>  (: min 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (min $x $y) 
    (if 
      (< $x $y) $x $y))
</span>;;;; Clamp a number to be within a certain range
<span class="ansi38-255165000"
>  (: clamp 
    (-> $a $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (clamp $x $l $u) 
    (max $l 
      (min $u $x)))
</span>;;;; Define abs
<span class="ansi38-255165000"
>  (: abs 
    (-> $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (abs $x) 
    (if 
      (< $x 0) 
      (* -1 $x) $x))
</span>;;;; Define <=
<span class="ansi38-255165000"
>  (: <= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (<= $x $y) 
    (or 
      (< $x $y) 
      (== $x $y)))
</span>;;;; Define >=
<span class="ansi38-255165000"
>  (: >= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (>= $x $y) 
    (or 
      (> $x $y) 
      (== $x $y)))
</span>;;;; Define approximately equal
<span class="ansi38-255165000"
>  (: approxEq 
    (-> $a $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (approxEq $x $y $epsilon) 
    (<= 
      (abs (- $x $y)) $epsilon))
</span>;;;; Define Nat
<span class="ansi38-255165000"
>  (: Nat Type)
</span><span class="ansi38-255165000"
>  (: Z Nat)
</span><span class="ansi38-255165000"
>  (: S 
    (-> Nat Nat))
</span>;;;; Define cast functions between Nat and Number
<span class="ansi38-255165000"
>  (: fromNumber 
    (-> Number Nat))
</span><span class="ansi38-255165000"
>  (= 
    (fromNumber $n) 
    (if 
      (<= $n 0) Z 
      (S (fromNumber (- $n 1)))))
</span><span class="ansi38-255165000"
>  (: fromNat 
    (-> Nat Number))
</span><span class="ansi38-255165000"
>  (= 
    (fromNat Z) 0)
</span><span class="ansi38-255165000"
>  (= 
    (fromNat (S $k)) 
    (+ 1 
      (fromNat $k)))
</span>;;;; Define a generic less than operator, ⩻, for Nat.  < cannot be used
;;;; because it is a built-in, its type is hardwired and cannot be
;;;; overloaded.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Nat Nat Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $ Z) False)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ Z 
      (S $)) True)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ 
      (S $x) 
      (S $y)) 
    (⩻ $x $y))
</span>;;;; Overload ⩻ for Number.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Number Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $x $y) 
    (< $x $y))
</span>;;;; Return the ceiling of a non negative number.  If the number is
;;;; negative it returns 1.
<span class="ansi38-255165000"
>  (: ceil 
    (-> Number Number))
</span><span class="ansi38-255165000"
>  (= 
    (ceil $n) 
    (fromNat (fromNumber $n)))
</span>;;;; Convert Number to Bool.  Anything above 0 converts to True.
<span class="ansi38-255165000"
>  (: number->bool 
    (-> Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (number->bool $x) 
    (< 0 $x))
</span>;;;; Convert Bool to Number.  False converts to 0, True converts to 1.
<span class="ansi38-255165000"
>  (: bool->number 
    (-> Bool Number))
</span><span class="ansi38-255165000"
>  (= 
    (bool->number False) 0)
</span><span class="ansi38-255165000"
>  (= 
    (bool->number True) 1)
</span>;;;; Define a less than type.  Note that it is purposefully different
;;;; than ⩻ as it is a type, not an operator.  Inhabitants of (⍃ x y)
;;;; are proofs that x ⩻ y == True.  For now ⍃ is only axiomatized for
;;;; Nat.
<span class="ansi38-255165000"
>  (: ⍃ 
    (-> $t $t Type))
</span>;;;; Zero is always less than the successor of something
<span class="ansi38-255165000"
>  (: 
    (zero-lt-succ-axiom) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (zero-lt-succ-axiom) 
    (: ZeroLTSucc 
      (⍃ Z 
        (S $k))))
</span>;;;; If x ⍃ y then (S x) ⍃ (S y)
<span class="ansi38-255165000"
>  (: 
    (succ-monotonicity-rule) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (succ-monotonicity-rule) 
    (: SuccMonotonicity 
      (-> 
        (⍃ $x $y) 
        (⍃ 
          (S $x) 
          (S $y)))))
</span>;;;; Collection of functions operating on numbers
;;;; Define max
<span class="ansi38-255165000"
>  (: max 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (max $x $y) 
    (if 
      (> $x $y) $x $y))
</span>;;;; Define min
<span class="ansi38-255165000"
>  (: min 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (min $x $y) 
    (if 
      (< $x $y) $x $y))
</span>;;;; Clamp a number to be within a certain range
<span class="ansi38-255165000"
>  (: clamp 
    (-> $a $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (clamp $x $l $u) 
    (max $l 
      (min $u $x)))
</span>;;;; Define abs
<span class="ansi38-255165000"
>  (: abs 
    (-> $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (abs $x) 
    (if 
      (< $x 0) 
      (* -1 $x) $x))
</span>;;;; Define <=
<span class="ansi38-255165000"
>  (: <= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (<= $x $y) 
    (or 
      (< $x $y) 
      (== $x $y)))
</span>;;;; Define >=
<span class="ansi38-255165000"
>  (: >= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (>= $x $y) 
    (or 
      (> $x $y) 
      (== $x $y)))
</span>;;;; Define approximately equal
<span class="ansi38-255165000"
>  (: approxEq 
    (-> $a $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (approxEq $x $y $epsilon) 
    (<= 
      (abs (- $x $y)) $epsilon))
</span>;;;; Define Nat
<span class="ansi38-255165000"
>  (: Nat Type)
</span><span class="ansi38-255165000"
>  (: Z Nat)
</span><span class="ansi38-255165000"
>  (: S 
    (-> Nat Nat))
</span>;;;; Define cast functions between Nat and Number
<span class="ansi38-255165000"
>  (: fromNumber 
    (-> Number Nat))
</span><span class="ansi38-255165000"
>  (= 
    (fromNumber $n) 
    (if 
      (<= $n 0) Z 
      (S (fromNumber (- $n 1)))))
</span><span class="ansi38-255165000"
>  (: fromNat 
    (-> Nat Number))
</span><span class="ansi38-255165000"
>  (= 
    (fromNat Z) 0)
</span><span class="ansi38-255165000"
>  (= 
    (fromNat (S $k)) 
    (+ 1 
      (fromNat $k)))
</span>;;;; Define a generic less than operator, ⩻, for Nat.  < cannot be used
;;;; because it is a built-in, its type is hardwired and cannot be
;;;; overloaded.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Nat Nat Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $ Z) False)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ Z 
      (S $)) True)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ 
      (S $x) 
      (S $y)) 
    (⩻ $x $y))
</span>;;;; Overload ⩻ for Number.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Number Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $x $y) 
    (< $x $y))
</span>;;;; Return the ceiling of a non negative number.  If the number is
;;;; negative it returns 1.
<span class="ansi38-255165000"
>  (: ceil 
    (-> Number Number))
</span><span class="ansi38-255165000"
>  (= 
    (ceil $n) 
    (fromNat (fromNumber $n)))
</span>;;;; Convert Number to Bool.  Anything above 0 converts to True.
<span class="ansi38-255165000"
>  (: number->bool 
    (-> Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (number->bool $x) 
    (< 0 $x))
</span>;;;; Convert Bool to Number.  False converts to 0, True converts to 1.
<span class="ansi38-255165000"
>  (: bool->number 
    (-> Bool Number))
</span><span class="ansi38-255165000"
>  (= 
    (bool->number False) 0)
</span><span class="ansi38-255165000"
>  (= 
    (bool->number True) 1)
</span>;;;; Define a less than type.  Note that it is purposefully different
;;;; than ⩻ as it is a type, not an operator.  Inhabitants of (⍃ x y)
;;;; are proofs that x ⩻ y == True.  For now ⍃ is only axiomatized for
;;;; Nat.
<span class="ansi38-255165000"
>  (: ⍃ 
    (-> $t $t Type))
</span>;;;; Zero is always less than the successor of something
<span class="ansi38-255165000"
>  (: 
    (zero-lt-succ-axiom) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (zero-lt-succ-axiom) 
    (: ZeroLTSucc 
      (⍃ Z 
        (S $k))))
</span>;;;; If x ⍃ y then (S x) ⍃ (S y)
<span class="ansi38-255165000"
>  (: 
    (succ-monotonicity-rule) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (succ-monotonicity-rule) 
    (: SuccMonotonicity 
      (-> 
        (⍃ $x $y) 
        (⍃ 
          (S $x) 
          (S $y)))))
</span>;;;; Collection of functions operating on numbers
;;;; Define max
<span class="ansi38-255165000"
>  (: max 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (max $x $y) 
    (if 
      (> $x $y) $x $y))
</span>;;;; Define min
<span class="ansi38-255165000"
>  (: min 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (min $x $y) 
    (if 
      (< $x $y) $x $y))
</span>;;;; Clamp a number to be within a certain range
<span class="ansi38-255165000"
>  (: clamp 
    (-> $a $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (clamp $x $l $u) 
    (max $l 
      (min $u $x)))
</span>;;;; Define abs
<span class="ansi38-255165000"
>  (: abs 
    (-> $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (abs $x) 
    (if 
      (< $x 0) 
      (* -1 $x) $x))
</span>;;;; Define <=
<span class="ansi38-255165000"
>  (: <= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (<= $x $y) 
    (or 
      (< $x $y) 
      (== $x $y)))
</span>;;;; Define >=
<span class="ansi38-255165000"
>  (: >= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (>= $x $y) 
    (or 
      (> $x $y) 
      (== $x $y)))
</span>;;;; Define approximately equal
<span class="ansi38-255165000"
>  (: approxEq 
    (-> $a $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (approxEq $x $y $epsilon) 
    (<= 
      (abs (- $x $y)) $epsilon))
</span>;;;; Define Nat
<span class="ansi38-255165000"
>  (: Nat Type)
</span><span class="ansi38-255165000"
>  (: Z Nat)
</span><span class="ansi38-255165000"
>  (: S 
    (-> Nat Nat))
</span>;;;; Define cast functions between Nat and Number
<span class="ansi38-255165000"
>  (: fromNumber 
    (-> Number Nat))
</span><span class="ansi38-255165000"
>  (= 
    (fromNumber $n) 
    (if 
      (<= $n 0) Z 
      (S (fromNumber (- $n 1)))))
</span><span class="ansi38-255165000"
>  (: fromNat 
    (-> Nat Number))
</span><span class="ansi38-255165000"
>  (= 
    (fromNat Z) 0)
</span><span class="ansi38-255165000"
>  (= 
    (fromNat (S $k)) 
    (+ 1 
      (fromNat $k)))
</span>;;;; Define a generic less than operator, ⩻, for Nat.  < cannot be used
;;;; because it is a built-in, its type is hardwired and cannot be
;;;; overloaded.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Nat Nat Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $ Z) False)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ Z 
      (S $)) True)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ 
      (S $x) 
      (S $y)) 
    (⩻ $x $y))
</span>;;;; Overload ⩻ for Number.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Number Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $x $y) 
    (< $x $y))
</span>;;;; Return the ceiling of a non negative number.  If the number is
;;;; negative it returns 1.
<span class="ansi38-255165000"
>  (: ceil 
    (-> Number Number))
</span><span class="ansi38-255165000"
>  (= 
    (ceil $n) 
    (fromNat (fromNumber $n)))
</span>;;;; Convert Number to Bool.  Anything above 0 converts to True.
<span class="ansi38-255165000"
>  (: number->bool 
    (-> Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (number->bool $x) 
    (< 0 $x))
</span>;;;; Convert Bool to Number.  False converts to 0, True converts to 1.
<span class="ansi38-255165000"
>  (: bool->number 
    (-> Bool Number))
</span><span class="ansi38-255165000"
>  (= 
    (bool->number False) 0)
</span><span class="ansi38-255165000"
>  (= 
    (bool->number True) 1)
</span>;;;; Define a less than type.  Note that it is purposefully different
;;;; than ⩻ as it is a type, not an operator.  Inhabitants of (⍃ x y)
;;;; are proofs that x ⩻ y == True.  For now ⍃ is only axiomatized for
;;;; Nat.
<span class="ansi38-255165000"
>  (: ⍃ 
    (-> $t $t Type))
</span>;;;; Zero is always less than the successor of something
<span class="ansi38-255165000"
>  (: 
    (zero-lt-succ-axiom) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (zero-lt-succ-axiom) 
    (: ZeroLTSucc 
      (⍃ Z 
        (S $k))))
</span>;;;; If x ⍃ y then (S x) ⍃ (S y)
<span class="ansi38-255165000"
>  (: 
    (succ-monotonicity-rule) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (succ-monotonicity-rule) 
    (: SuccMonotonicity 
      (-> 
        (⍃ $x $y) 
        (⍃ 
          (S $x) 
          (S $y)))))
</span>;;;; Collection of functions operating on numbers
;;;; Define max
<span class="ansi38-255165000"
>  (: max 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (max $x $y) 
    (if 
      (> $x $y) $x $y))
</span>;;;; Define min
<span class="ansi38-255165000"
>  (: min 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (min $x $y) 
    (if 
      (< $x $y) $x $y))
</span>;;;; Clamp a number to be within a certain range
<span class="ansi38-255165000"
>  (: clamp 
    (-> $a $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (clamp $x $l $u) 
    (max $l 
      (min $u $x)))
</span>;;;; Define abs
<span class="ansi38-255165000"
>  (: abs 
    (-> $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (abs $x) 
    (if 
      (< $x 0) 
      (* -1 $x) $x))
</span>;;;; Define <=
<span class="ansi38-255165000"
>  (: <= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (<= $x $y) 
    (or 
      (< $x $y) 
      (== $x $y)))
</span>;;;; Define >=
<span class="ansi38-255165000"
>  (: >= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (>= $x $y) 
    (or 
      (> $x $y) 
      (== $x $y)))
</span>;;;; Define approximately equal
<span class="ansi38-255165000"
>  (: approxEq 
    (-> $a $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (approxEq $x $y $epsilon) 
    (<= 
      (abs (- $x $y)) $epsilon))
</span>;;;; Define Nat
<span class="ansi38-255165000"
>  (: Nat Type)
</span><span class="ansi38-255165000"
>  (: Z Nat)
</span><span class="ansi38-255165000"
>  (: S 
    (-> Nat Nat))
</span>;;;; Define cast functions between Nat and Number
<span class="ansi38-255165000"
>  (: fromNumber 
    (-> Number Nat))
</span><span class="ansi38-255165000"
>  (= 
    (fromNumber $n) 
    (if 
      (<= $n 0) Z 
      (S (fromNumber (- $n 1)))))
</span><span class="ansi38-255165000"
>  (: fromNat 
    (-> Nat Number))
</span><span class="ansi38-255165000"
>  (= 
    (fromNat Z) 0)
</span><span class="ansi38-255165000"
>  (= 
    (fromNat (S $k)) 
    (+ 1 
      (fromNat $k)))
</span>;;;; Define a generic less than operator, ⩻, for Nat.  < cannot be used
;;;; because it is a built-in, its type is hardwired and cannot be
;;;; overloaded.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Nat Nat Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $ Z) False)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ Z 
      (S $)) True)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ 
      (S $x) 
      (S $y)) 
    (⩻ $x $y))
</span>;;;; Overload ⩻ for Number.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Number Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $x $y) 
    (< $x $y))
</span>;;;; Return the ceiling of a non negative number.  If the number is
;;;; negative it returns 1.
<span class="ansi38-255165000"
>  (: ceil 
    (-> Number Number))
</span><span class="ansi38-255165000"
>  (= 
    (ceil $n) 
    (fromNat (fromNumber $n)))
</span>;;;; Convert Number to Bool.  Anything above 0 converts to True.
<span class="ansi38-255165000"
>  (: number->bool 
    (-> Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (number->bool $x) 
    (< 0 $x))
</span>;;;; Convert Bool to Number.  False converts to 0, True converts to 1.
<span class="ansi38-255165000"
>  (: bool->number 
    (-> Bool Number))
</span><span class="ansi38-255165000"
>  (= 
    (bool->number False) 0)
</span><span class="ansi38-255165000"
>  (= 
    (bool->number True) 1)
</span>;;;; Define a less than type.  Note that it is purposefully different
;;;; than ⩻ as it is a type, not an operator.  Inhabitants of (⍃ x y)
;;;; are proofs that x ⩻ y == True.  For now ⍃ is only axiomatized for
;;;; Nat.
<span class="ansi38-255165000"
>  (: ⍃ 
    (-> $t $t Type))
</span>;;;; Zero is always less than the successor of something
<span class="ansi38-255165000"
>  (: 
    (zero-lt-succ-axiom) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (zero-lt-succ-axiom) 
    (: ZeroLTSucc 
      (⍃ Z 
        (S $k))))
</span>;;;; If x ⍃ y then (S x) ⍃ (S y)
<span class="ansi38-255165000"
>  (: 
    (succ-monotonicity-rule) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (succ-monotonicity-rule) 
    (: SuccMonotonicity 
      (-> 
        (⍃ $x $y) 
        (⍃ 
          (S $x) 
          (S $y)))))
</span>;;;; Collection of functions operating on numbers
;;;; Define max
<span class="ansi38-255165000"
>  (: max 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (max $x $y) 
    (if 
      (> $x $y) $x $y))
</span>;;;; Define min
<span class="ansi38-255165000"
>  (: min 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (min $x $y) 
    (if 
      (< $x $y) $x $y))
</span>;;;; Clamp a number to be within a certain range
<span class="ansi38-255165000"
>  (: clamp 
    (-> $a $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (clamp $x $l $u) 
    (max $l 
      (min $u $x)))
</span>;;;; Define abs
<span class="ansi38-255165000"
>  (: abs 
    (-> $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (abs $x) 
    (if 
      (< $x 0) 
      (* -1 $x) $x))
</span>;;;; Define <=
<span class="ansi38-255165000"
>  (: <= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (<= $x $y) 
    (or 
      (< $x $y) 
      (== $x $y)))
</span>;;;; Define >=
<span class="ansi38-255165000"
>  (: >= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (>= $x $y) 
    (or 
      (> $x $y) 
      (== $x $y)))
</span>;;;; Define approximately equal
<span class="ansi38-255165000"
>  (: approxEq 
    (-> $a $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (approxEq $x $y $epsilon) 
    (<= 
      (abs (- $x $y)) $epsilon))
</span>;;;; Define Nat
<span class="ansi38-255165000"
>  (: Nat Type)
</span><span class="ansi38-255165000"
>  (: Z Nat)
</span><span class="ansi38-255165000"
>  (: S 
    (-> Nat Nat))
</span>;;;; Define cast functions between Nat and Number
<span class="ansi38-255165000"
>  (: fromNumber 
    (-> Number Nat))
</span><span class="ansi38-255165000"
>  (= 
    (fromNumber $n) 
    (if 
      (<= $n 0) Z 
      (S (fromNumber (- $n 1)))))
</span><span class="ansi38-255165000"
>  (: fromNat 
    (-> Nat Number))
</span><span class="ansi38-255165000"
>  (= 
    (fromNat Z) 0)
</span><span class="ansi38-255165000"
>  (= 
    (fromNat (S $k)) 
    (+ 1 
      (fromNat $k)))
</span>;;;; Define a generic less than operator, ⩻, for Nat.  < cannot be used
;;;; because it is a built-in, its type is hardwired and cannot be
;;;; overloaded.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Nat Nat Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $ Z) False)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ Z 
      (S $)) True)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ 
      (S $x) 
      (S $y)) 
    (⩻ $x $y))
</span>;;;; Overload ⩻ for Number.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Number Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $x $y) 
    (< $x $y))
</span>;;;; Return the ceiling of a non negative number.  If the number is
;;;; negative it returns 1.
<span class="ansi38-255165000"
>  (: ceil 
    (-> Number Number))
</span><span class="ansi38-255165000"
>  (= 
    (ceil $n) 
    (fromNat (fromNumber $n)))
</span>;;;; Convert Number to Bool.  Anything above 0 converts to True.
<span class="ansi38-255165000"
>  (: number->bool 
    (-> Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (number->bool $x) 
    (< 0 $x))
</span>;;;; Convert Bool to Number.  False converts to 0, True converts to 1.
<span class="ansi38-255165000"
>  (: bool->number 
    (-> Bool Number))
</span><span class="ansi38-255165000"
>  (= 
    (bool->number False) 0)
</span><span class="ansi38-255165000"
>  (= 
    (bool->number True) 1)
</span>;;;; Define a less than type.  Note that it is purposefully different
;;;; than ⩻ as it is a type, not an operator.  Inhabitants of (⍃ x y)
;;;; are proofs that x ⩻ y == True.  For now ⍃ is only axiomatized for
;;;; Nat.
<span class="ansi38-255165000"
>  (: ⍃ 
    (-> $t $t Type))
</span>;;;; Zero is always less than the successor of something
<span class="ansi38-255165000"
>  (: 
    (zero-lt-succ-axiom) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (zero-lt-succ-axiom) 
    (: ZeroLTSucc 
      (⍃ Z 
        (S $k))))
</span>;;;; If x ⍃ y then (S x) ⍃ (S y)
<span class="ansi38-255165000"
>  (: 
    (succ-monotonicity-rule) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (succ-monotonicity-rule) 
    (: SuccMonotonicity 
      (-> 
        (⍃ $x $y) 
        (⍃ 
          (S $x) 
          (S $y)))))
</span>
Deterministic: ()
;;; Consistency Conditions
<span class="ansi38-255165000"
>  (: smallest-intersection-probability 
    (-> Number Number Number))
</span><span class="ansi38-255165000"
>  (= 
    (smallest-intersection-probability $As $Bs) 
    (clamp 
      (/ 
        (- 
          (+ $As $Bs) 1) $As) 0 1))
</span><span class="ansi38-255165000"
>  (: largest-intersection-probability 
    (-> Number Number Number))
</span><span class="ansi38-255165000"
>  (= 
    (largest-intersection-probability $As $Bs) 
    (clamp 
      (/ $Bs $As) 0 1))
</span><span class="ansi38-255165000"
>  (: conditional-probability-consistency 
    (-> Number Number Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (conditional-probability-consistency $As $Bs $ABs) 
    (and 
      (< 0 $As) 
      (and 
        (<= 
          (smallest-intersection-probability $As $Bs) $ABs) 
        (<= $ABs 
          (largest-intersection-probability $As $Bs)))))
</span>;;;; Main Formula
<span class="ansi38-255165000"
>  (: simple-deduction-strength-formula 
    (-> Number Number Number Number Number Number))
</span>;;;; Preconditions are met
;;;; sB tends to 1
;;;; otherwise
;;;; Preconditions are not met
<span class="ansi38-255165000"
>  (= 
    (simple-deduction-strength-formula $As $Bs $Cs $ABs $BCs) 
    (if 
      (and 
        (conditional-probability-consistency $As $Bs $ABs) 
        (conditional-probability-consistency $Bs $Cs $BCs)) 
      (if 
        (< 0.99 $Bs) $Cs 
        (+ 
          (* $ABs $BCs) 
          (/ 
            (* 
              (- 1 $ABs) 
              (- $Cs 
                (* $Bs $BCs))) 
            (- 1 $Bs)))) 0))
</span>;;;; Alternate deduction formula hardwired for STV to make it faster.
;;;; Preconditions are met
;;; avoid division by 0
;;;; Qs tends to 1
;;;; Otherwise
;;;; Preconditions are not met
<span class="ansi38-255165000"
>  (= 
    (deduction-formula 
      (STV $Ps $Pc) 
      (STV $Qs $Qc) 
      (STV $Rs $Rc) 
      (STV $PQs $PQc) 
      (STV $QRs $QRc)) 
    (if 
      (and 
        (conditional-probability-consistency $Ps $Qs $PQs) 
        (conditional-probability-consistency $Qs $Rs $QRs)) 
      (STV 
        (if 
          (< 0.9999 $Qs) $Rs 
          (+ 
            (* $PQs $QRs) 
            (/ 
              (* 
                (- 1 $PQs) 
                (- $Rs 
                  (* $Qs $QRs))) 
              (- 1 $Qs)))) 
        (min $Pc 
          (min $Qc 
            (min $Rc 
              (min $PQc $QRc))))) 
      (STV 1 0)))
</span>
Last Result(2): ()
;;;; Define deduction rule
<span class="ansi38-255165000"
>  (: deduction-rule 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (deduction-rule) 
    (: Deduction 
      (-> 
        (≞ $p $ptv) 
        (≞ $q $qtv) 
        (≞ $r $rtv) 
        (≞ 
          (→ $p $q) $pqtv) 
        (≞ 
          (→ $q $r) $qrtv) 
        (≞ 
          (→ $p $r) 
          (deduction-formula $ptv $qtv $rtv $pqtv $qrtv)))))
</span>
Last Result(3): ()
()]
<span class="ansi38-013099040"
>  !(import! &self ../../synthesis/Synthesize.metta)

</span>[P;HTML|
;                                           (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/synthesis/Synthesize.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/synthesis/Synthesize.metta)
P;HTML|
;                                           (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/synthesis/Synthesize.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/synthesis/Synthesize.metta)

;;;; Import modules
<span class="ansi38-013099040"
>  !(import! &self ../common/Num.metta)

</span>P;HTML|
;                                           (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/Num.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/Num.metta)
P;HTML|
;                                           (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/Num.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/common/Num.metta)

;;;; Collection of functions operating on numbers
;;;; Define max
<span class="ansi38-255165000"
>  (: max 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (max $x $y) 
    (if 
      (> $x $y) $x $y))
</span>;;;; Define min
<span class="ansi38-255165000"
>  (: min 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (min $x $y) 
    (if 
      (< $x $y) $x $y))
</span>;;;; Clamp a number to be within a certain range
<span class="ansi38-255165000"
>  (: clamp 
    (-> $a $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (clamp $x $l $u) 
    (max $l 
      (min $u $x)))
</span>;;;; Define abs
<span class="ansi38-255165000"
>  (: abs 
    (-> $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (abs $x) 
    (if 
      (< $x 0) 
      (* -1 $x) $x))
</span>;;;; Define <=
<span class="ansi38-255165000"
>  (: <= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (<= $x $y) 
    (or 
      (< $x $y) 
      (== $x $y)))
</span>;;;; Define >=
<span class="ansi38-255165000"
>  (: >= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (>= $x $y) 
    (or 
      (> $x $y) 
      (== $x $y)))
</span>;;;; Define approximately equal
<span class="ansi38-255165000"
>  (: approxEq 
    (-> $a $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (approxEq $x $y $epsilon) 
    (<= 
      (abs (- $x $y)) $epsilon))
</span>;;;; Define Nat
<span class="ansi38-255165000"
>  (: Nat Type)
</span><span class="ansi38-255165000"
>  (: Z Nat)
</span><span class="ansi38-255165000"
>  (: S 
    (-> Nat Nat))
</span>;;;; Define cast functions between Nat and Number
<span class="ansi38-255165000"
>  (: fromNumber 
    (-> Number Nat))
</span><span class="ansi38-255165000"
>  (= 
    (fromNumber $n) 
    (if 
      (<= $n 0) Z 
      (S (fromNumber (- $n 1)))))
</span><span class="ansi38-255165000"
>  (: fromNat 
    (-> Nat Number))
</span><span class="ansi38-255165000"
>  (= 
    (fromNat Z) 0)
</span><span class="ansi38-255165000"
>  (= 
    (fromNat (S $k)) 
    (+ 1 
      (fromNat $k)))
</span>;;;; Define a generic less than operator, ⩻, for Nat.  < cannot be used
;;;; because it is a built-in, its type is hardwired and cannot be
;;;; overloaded.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Nat Nat Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $ Z) False)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ Z 
      (S $)) True)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ 
      (S $x) 
      (S $y)) 
    (⩻ $x $y))
</span>;;;; Overload ⩻ for Number.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Number Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $x $y) 
    (< $x $y))
</span>;;;; Return the ceiling of a non negative number.  If the number is
;;;; negative it returns 1.
<span class="ansi38-255165000"
>  (: ceil 
    (-> Number Number))
</span><span class="ansi38-255165000"
>  (= 
    (ceil $n) 
    (fromNat (fromNumber $n)))
</span>;;;; Convert Number to Bool.  Anything above 0 converts to True.
<span class="ansi38-255165000"
>  (: number->bool 
    (-> Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (number->bool $x) 
    (< 0 $x))
</span>;;;; Convert Bool to Number.  False converts to 0, True converts to 1.
<span class="ansi38-255165000"
>  (: bool->number 
    (-> Bool Number))
</span><span class="ansi38-255165000"
>  (= 
    (bool->number False) 0)
</span><span class="ansi38-255165000"
>  (= 
    (bool->number True) 1)
</span>;;;; Define a less than type.  Note that it is purposefully different
;;;; than ⩻ as it is a type, not an operator.  Inhabitants of (⍃ x y)
;;;; are proofs that x ⩻ y == True.  For now ⍃ is only axiomatized for
;;;; Nat.
<span class="ansi38-255165000"
>  (: ⍃ 
    (-> $t $t Type))
</span>;;;; Zero is always less than the successor of something
<span class="ansi38-255165000"
>  (: 
    (zero-lt-succ-axiom) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (zero-lt-succ-axiom) 
    (: ZeroLTSucc 
      (⍃ Z 
        (S $k))))
</span>;;;; If x ⍃ y then (S x) ⍃ (S y)
<span class="ansi38-255165000"
>  (: 
    (succ-monotonicity-rule) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (succ-monotonicity-rule) 
    (: SuccMonotonicity 
      (-> 
        (⍃ $x $y) 
        (⍃ 
          (S $x) 
          (S $y)))))
</span>;;;; Collection of functions operating on numbers
;;;; Define max
<span class="ansi38-255165000"
>  (: max 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (max $x $y) 
    (if 
      (> $x $y) $x $y))
</span>;;;; Define min
<span class="ansi38-255165000"
>  (: min 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (min $x $y) 
    (if 
      (< $x $y) $x $y))
</span>;;;; Clamp a number to be within a certain range
<span class="ansi38-255165000"
>  (: clamp 
    (-> $a $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (clamp $x $l $u) 
    (max $l 
      (min $u $x)))
</span>;;;; Define abs
<span class="ansi38-255165000"
>  (: abs 
    (-> $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (abs $x) 
    (if 
      (< $x 0) 
      (* -1 $x) $x))
</span>;;;; Define <=
<span class="ansi38-255165000"
>  (: <= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (<= $x $y) 
    (or 
      (< $x $y) 
      (== $x $y)))
</span>;;;; Define >=
<span class="ansi38-255165000"
>  (: >= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (>= $x $y) 
    (or 
      (> $x $y) 
      (== $x $y)))
</span>;;;; Define approximately equal
<span class="ansi38-255165000"
>  (: approxEq 
    (-> $a $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (approxEq $x $y $epsilon) 
    (<= 
      (abs (- $x $y)) $epsilon))
</span>;;;; Define Nat
<span class="ansi38-255165000"
>  (: Nat Type)
</span><span class="ansi38-255165000"
>  (: Z Nat)
</span><span class="ansi38-255165000"
>  (: S 
    (-> Nat Nat))
</span>;;;; Define cast functions between Nat and Number
<span class="ansi38-255165000"
>  (: fromNumber 
    (-> Number Nat))
</span><span class="ansi38-255165000"
>  (= 
    (fromNumber $n) 
    (if 
      (<= $n 0) Z 
      (S (fromNumber (- $n 1)))))
</span><span class="ansi38-255165000"
>  (: fromNat 
    (-> Nat Number))
</span><span class="ansi38-255165000"
>  (= 
    (fromNat Z) 0)
</span><span class="ansi38-255165000"
>  (= 
    (fromNat (S $k)) 
    (+ 1 
      (fromNat $k)))
</span>;;;; Define a generic less than operator, ⩻, for Nat.  < cannot be used
;;;; because it is a built-in, its type is hardwired and cannot be
;;;; overloaded.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Nat Nat Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $ Z) False)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ Z 
      (S $)) True)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ 
      (S $x) 
      (S $y)) 
    (⩻ $x $y))
</span>;;;; Overload ⩻ for Number.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Number Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $x $y) 
    (< $x $y))
</span>;;;; Return the ceiling of a non negative number.  If the number is
;;;; negative it returns 1.
<span class="ansi38-255165000"
>  (: ceil 
    (-> Number Number))
</span><span class="ansi38-255165000"
>  (= 
    (ceil $n) 
    (fromNat (fromNumber $n)))
</span>;;;; Convert Number to Bool.  Anything above 0 converts to True.
<span class="ansi38-255165000"
>  (: number->bool 
    (-> Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (number->bool $x) 
    (< 0 $x))
</span>;;;; Convert Bool to Number.  False converts to 0, True converts to 1.
<span class="ansi38-255165000"
>  (: bool->number 
    (-> Bool Number))
</span><span class="ansi38-255165000"
>  (= 
    (bool->number False) 0)
</span><span class="ansi38-255165000"
>  (= 
    (bool->number True) 1)
</span>;;;; Define a less than type.  Note that it is purposefully different
;;;; than ⩻ as it is a type, not an operator.  Inhabitants of (⍃ x y)
;;;; are proofs that x ⩻ y == True.  For now ⍃ is only axiomatized for
;;;; Nat.
<span class="ansi38-255165000"
>  (: ⍃ 
    (-> $t $t Type))
</span>;;;; Zero is always less than the successor of something
<span class="ansi38-255165000"
>  (: 
    (zero-lt-succ-axiom) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (zero-lt-succ-axiom) 
    (: ZeroLTSucc 
      (⍃ Z 
        (S $k))))
</span>;;;; If x ⍃ y then (S x) ⍃ (S y)
<span class="ansi38-255165000"
>  (: 
    (succ-monotonicity-rule) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (succ-monotonicity-rule) 
    (: SuccMonotonicity 
      (-> 
        (⍃ $x $y) 
        (⍃ 
          (S $x) 
          (S $y)))))
</span>;;;; Collection of functions operating on numbers
;;;; Define max
<span class="ansi38-255165000"
>  (: max 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (max $x $y) 
    (if 
      (> $x $y) $x $y))
</span>;;;; Define min
<span class="ansi38-255165000"
>  (: min 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (min $x $y) 
    (if 
      (< $x $y) $x $y))
</span>;;;; Clamp a number to be within a certain range
<span class="ansi38-255165000"
>  (: clamp 
    (-> $a $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (clamp $x $l $u) 
    (max $l 
      (min $u $x)))
</span>;;;; Define abs
<span class="ansi38-255165000"
>  (: abs 
    (-> $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (abs $x) 
    (if 
      (< $x 0) 
      (* -1 $x) $x))
</span>;;;; Define <=
<span class="ansi38-255165000"
>  (: <= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (<= $x $y) 
    (or 
      (< $x $y) 
      (== $x $y)))
</span>;;;; Define >=
<span class="ansi38-255165000"
>  (: >= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (>= $x $y) 
    (or 
      (> $x $y) 
      (== $x $y)))
</span>;;;; Define approximately equal
<span class="ansi38-255165000"
>  (: approxEq 
    (-> $a $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (approxEq $x $y $epsilon) 
    (<= 
      (abs (- $x $y)) $epsilon))
</span>;;;; Define Nat
<span class="ansi38-255165000"
>  (: Nat Type)
</span><span class="ansi38-255165000"
>  (: Z Nat)
</span><span class="ansi38-255165000"
>  (: S 
    (-> Nat Nat))
</span>;;;; Define cast functions between Nat and Number
<span class="ansi38-255165000"
>  (: fromNumber 
    (-> Number Nat))
</span><span class="ansi38-255165000"
>  (= 
    (fromNumber $n) 
    (if 
      (<= $n 0) Z 
      (S (fromNumber (- $n 1)))))
</span><span class="ansi38-255165000"
>  (: fromNat 
    (-> Nat Number))
</span><span class="ansi38-255165000"
>  (= 
    (fromNat Z) 0)
</span><span class="ansi38-255165000"
>  (= 
    (fromNat (S $k)) 
    (+ 1 
      (fromNat $k)))
</span>;;;; Define a generic less than operator, ⩻, for Nat.  < cannot be used
;;;; because it is a built-in, its type is hardwired and cannot be
;;;; overloaded.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Nat Nat Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $ Z) False)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ Z 
      (S $)) True)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ 
      (S $x) 
      (S $y)) 
    (⩻ $x $y))
</span>;;;; Overload ⩻ for Number.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Number Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $x $y) 
    (< $x $y))
</span>;;;; Return the ceiling of a non negative number.  If the number is
;;;; negative it returns 1.
<span class="ansi38-255165000"
>  (: ceil 
    (-> Number Number))
</span><span class="ansi38-255165000"
>  (= 
    (ceil $n) 
    (fromNat (fromNumber $n)))
</span>;;;; Convert Number to Bool.  Anything above 0 converts to True.
<span class="ansi38-255165000"
>  (: number->bool 
    (-> Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (number->bool $x) 
    (< 0 $x))
</span>;;;; Convert Bool to Number.  False converts to 0, True converts to 1.
<span class="ansi38-255165000"
>  (: bool->number 
    (-> Bool Number))
</span><span class="ansi38-255165000"
>  (= 
    (bool->number False) 0)
</span><span class="ansi38-255165000"
>  (= 
    (bool->number True) 1)
</span>;;;; Define a less than type.  Note that it is purposefully different
;;;; than ⩻ as it is a type, not an operator.  Inhabitants of (⍃ x y)
;;;; are proofs that x ⩻ y == True.  For now ⍃ is only axiomatized for
;;;; Nat.
<span class="ansi38-255165000"
>  (: ⍃ 
    (-> $t $t Type))
</span>;;;; Zero is always less than the successor of something
<span class="ansi38-255165000"
>  (: 
    (zero-lt-succ-axiom) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (zero-lt-succ-axiom) 
    (: ZeroLTSucc 
      (⍃ Z 
        (S $k))))
</span>;;;; If x ⍃ y then (S x) ⍃ (S y)
<span class="ansi38-255165000"
>  (: 
    (succ-monotonicity-rule) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (succ-monotonicity-rule) 
    (: SuccMonotonicity 
      (-> 
        (⍃ $x $y) 
        (⍃ 
          (S $x) 
          (S $y)))))
</span>;;;; Collection of functions operating on numbers
;;;; Define max
<span class="ansi38-255165000"
>  (: max 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (max $x $y) 
    (if 
      (> $x $y) $x $y))
</span>;;;; Define min
<span class="ansi38-255165000"
>  (: min 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (min $x $y) 
    (if 
      (< $x $y) $x $y))
</span>;;;; Clamp a number to be within a certain range
<span class="ansi38-255165000"
>  (: clamp 
    (-> $a $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (clamp $x $l $u) 
    (max $l 
      (min $u $x)))
</span>;;;; Define abs
<span class="ansi38-255165000"
>  (: abs 
    (-> $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (abs $x) 
    (if 
      (< $x 0) 
      (* -1 $x) $x))
</span>;;;; Define <=
<span class="ansi38-255165000"
>  (: <= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (<= $x $y) 
    (or 
      (< $x $y) 
      (== $x $y)))
</span>;;;; Define >=
<span class="ansi38-255165000"
>  (: >= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (>= $x $y) 
    (or 
      (> $x $y) 
      (== $x $y)))
</span>;;;; Define approximately equal
<span class="ansi38-255165000"
>  (: approxEq 
    (-> $a $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (approxEq $x $y $epsilon) 
    (<= 
      (abs (- $x $y)) $epsilon))
</span>;;;; Define Nat
<span class="ansi38-255165000"
>  (: Nat Type)
</span><span class="ansi38-255165000"
>  (: Z Nat)
</span><span class="ansi38-255165000"
>  (: S 
    (-> Nat Nat))
</span>;;;; Define cast functions between Nat and Number
<span class="ansi38-255165000"
>  (: fromNumber 
    (-> Number Nat))
</span><span class="ansi38-255165000"
>  (= 
    (fromNumber $n) 
    (if 
      (<= $n 0) Z 
      (S (fromNumber (- $n 1)))))
</span><span class="ansi38-255165000"
>  (: fromNat 
    (-> Nat Number))
</span><span class="ansi38-255165000"
>  (= 
    (fromNat Z) 0)
</span><span class="ansi38-255165000"
>  (= 
    (fromNat (S $k)) 
    (+ 1 
      (fromNat $k)))
</span>;;;; Define a generic less than operator, ⩻, for Nat.  < cannot be used
;;;; because it is a built-in, its type is hardwired and cannot be
;;;; overloaded.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Nat Nat Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $ Z) False)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ Z 
      (S $)) True)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ 
      (S $x) 
      (S $y)) 
    (⩻ $x $y))
</span>;;;; Overload ⩻ for Number.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Number Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $x $y) 
    (< $x $y))
</span>;;;; Return the ceiling of a non negative number.  If the number is
;;;; negative it returns 1.
<span class="ansi38-255165000"
>  (: ceil 
    (-> Number Number))
</span><span class="ansi38-255165000"
>  (= 
    (ceil $n) 
    (fromNat (fromNumber $n)))
</span>;;;; Convert Number to Bool.  Anything above 0 converts to True.
<span class="ansi38-255165000"
>  (: number->bool 
    (-> Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (number->bool $x) 
    (< 0 $x))
</span>;;;; Convert Bool to Number.  False converts to 0, True converts to 1.
<span class="ansi38-255165000"
>  (: bool->number 
    (-> Bool Number))
</span><span class="ansi38-255165000"
>  (= 
    (bool->number False) 0)
</span><span class="ansi38-255165000"
>  (= 
    (bool->number True) 1)
</span>;;;; Define a less than type.  Note that it is purposefully different
;;;; than ⩻ as it is a type, not an operator.  Inhabitants of (⍃ x y)
;;;; are proofs that x ⩻ y == True.  For now ⍃ is only axiomatized for
;;;; Nat.
<span class="ansi38-255165000"
>  (: ⍃ 
    (-> $t $t Type))
</span>;;;; Zero is always less than the successor of something
<span class="ansi38-255165000"
>  (: 
    (zero-lt-succ-axiom) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (zero-lt-succ-axiom) 
    (: ZeroLTSucc 
      (⍃ Z 
        (S $k))))
</span>;;;; If x ⍃ y then (S x) ⍃ (S y)
<span class="ansi38-255165000"
>  (: 
    (succ-monotonicity-rule) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (succ-monotonicity-rule) 
    (: SuccMonotonicity 
      (-> 
        (⍃ $x $y) 
        (⍃ 
          (S $x) 
          (S $y)))))
</span>;;;; Collection of functions operating on numbers
;;;; Define max
<span class="ansi38-255165000"
>  (: max 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (max $x $y) 
    (if 
      (> $x $y) $x $y))
</span>;;;; Define min
<span class="ansi38-255165000"
>  (: min 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (min $x $y) 
    (if 
      (< $x $y) $x $y))
</span>;;;; Clamp a number to be within a certain range
<span class="ansi38-255165000"
>  (: clamp 
    (-> $a $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (clamp $x $l $u) 
    (max $l 
      (min $u $x)))
</span>;;;; Define abs
<span class="ansi38-255165000"
>  (: abs 
    (-> $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (abs $x) 
    (if 
      (< $x 0) 
      (* -1 $x) $x))
</span>;;;; Define <=
<span class="ansi38-255165000"
>  (: <= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (<= $x $y) 
    (or 
      (< $x $y) 
      (== $x $y)))
</span>;;;; Define >=
<span class="ansi38-255165000"
>  (: >= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (>= $x $y) 
    (or 
      (> $x $y) 
      (== $x $y)))
</span>;;;; Define approximately equal
<span class="ansi38-255165000"
>  (: approxEq 
    (-> $a $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (approxEq $x $y $epsilon) 
    (<= 
      (abs (- $x $y)) $epsilon))
</span>;;;; Define Nat
<span class="ansi38-255165000"
>  (: Nat Type)
</span><span class="ansi38-255165000"
>  (: Z Nat)
</span><span class="ansi38-255165000"
>  (: S 
    (-> Nat Nat))
</span>;;;; Define cast functions between Nat and Number
<span class="ansi38-255165000"
>  (: fromNumber 
    (-> Number Nat))
</span><span class="ansi38-255165000"
>  (= 
    (fromNumber $n) 
    (if 
      (<= $n 0) Z 
      (S (fromNumber (- $n 1)))))
</span><span class="ansi38-255165000"
>  (: fromNat 
    (-> Nat Number))
</span><span class="ansi38-255165000"
>  (= 
    (fromNat Z) 0)
</span><span class="ansi38-255165000"
>  (= 
    (fromNat (S $k)) 
    (+ 1 
      (fromNat $k)))
</span>;;;; Define a generic less than operator, ⩻, for Nat.  < cannot be used
;;;; because it is a built-in, its type is hardwired and cannot be
;;;; overloaded.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Nat Nat Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $ Z) False)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ Z 
      (S $)) True)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ 
      (S $x) 
      (S $y)) 
    (⩻ $x $y))
</span>;;;; Overload ⩻ for Number.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Number Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $x $y) 
    (< $x $y))
</span>;;;; Return the ceiling of a non negative number.  If the number is
;;;; negative it returns 1.
<span class="ansi38-255165000"
>  (: ceil 
    (-> Number Number))
</span><span class="ansi38-255165000"
>  (= 
    (ceil $n) 
    (fromNat (fromNumber $n)))
</span>;;;; Convert Number to Bool.  Anything above 0 converts to True.
<span class="ansi38-255165000"
>  (: number->bool 
    (-> Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (number->bool $x) 
    (< 0 $x))
</span>;;;; Convert Bool to Number.  False converts to 0, True converts to 1.
<span class="ansi38-255165000"
>  (: bool->number 
    (-> Bool Number))
</span><span class="ansi38-255165000"
>  (= 
    (bool->number False) 0)
</span><span class="ansi38-255165000"
>  (= 
    (bool->number True) 1)
</span>;;;; Define a less than type.  Note that it is purposefully different
;;;; than ⩻ as it is a type, not an operator.  Inhabitants of (⍃ x y)
;;;; are proofs that x ⩻ y == True.  For now ⍃ is only axiomatized for
;;;; Nat.
<span class="ansi38-255165000"
>  (: ⍃ 
    (-> $t $t Type))
</span>;;;; Zero is always less than the successor of something
<span class="ansi38-255165000"
>  (: 
    (zero-lt-succ-axiom) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (zero-lt-succ-axiom) 
    (: ZeroLTSucc 
      (⍃ Z 
        (S $k))))
</span>;;;; If x ⍃ y then (S x) ⍃ (S y)
<span class="ansi38-255165000"
>  (: 
    (succ-monotonicity-rule) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (succ-monotonicity-rule) 
    (: SuccMonotonicity 
      (-> 
        (⍃ $x $y) 
        (⍃ 
          (S $x) 
          (S $y)))))
</span>;;;; Collection of functions operating on numbers
;;;; Define max
<span class="ansi38-255165000"
>  (: max 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (max $x $y) 
    (if 
      (> $x $y) $x $y))
</span>;;;; Define min
<span class="ansi38-255165000"
>  (: min 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (min $x $y) 
    (if 
      (< $x $y) $x $y))
</span>;;;; Clamp a number to be within a certain range
<span class="ansi38-255165000"
>  (: clamp 
    (-> $a $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (clamp $x $l $u) 
    (max $l 
      (min $u $x)))
</span>;;;; Define abs
<span class="ansi38-255165000"
>  (: abs 
    (-> $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (abs $x) 
    (if 
      (< $x 0) 
      (* -1 $x) $x))
</span>;;;; Define <=
<span class="ansi38-255165000"
>  (: <= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (<= $x $y) 
    (or 
      (< $x $y) 
      (== $x $y)))
</span>;;;; Define >=
<span class="ansi38-255165000"
>  (: >= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (>= $x $y) 
    (or 
      (> $x $y) 
      (== $x $y)))
</span>;;;; Define approximately equal
<span class="ansi38-255165000"
>  (: approxEq 
    (-> $a $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (approxEq $x $y $epsilon) 
    (<= 
      (abs (- $x $y)) $epsilon))
</span>;;;; Define Nat
<span class="ansi38-255165000"
>  (: Nat Type)
</span><span class="ansi38-255165000"
>  (: Z Nat)
</span><span class="ansi38-255165000"
>  (: S 
    (-> Nat Nat))
</span>;;;; Define cast functions between Nat and Number
<span class="ansi38-255165000"
>  (: fromNumber 
    (-> Number Nat))
</span><span class="ansi38-255165000"
>  (= 
    (fromNumber $n) 
    (if 
      (<= $n 0) Z 
      (S (fromNumber (- $n 1)))))
</span><span class="ansi38-255165000"
>  (: fromNat 
    (-> Nat Number))
</span><span class="ansi38-255165000"
>  (= 
    (fromNat Z) 0)
</span><span class="ansi38-255165000"
>  (= 
    (fromNat (S $k)) 
    (+ 1 
      (fromNat $k)))
</span>;;;; Define a generic less than operator, ⩻, for Nat.  < cannot be used
;;;; because it is a built-in, its type is hardwired and cannot be
;;;; overloaded.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Nat Nat Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $ Z) False)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ Z 
      (S $)) True)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ 
      (S $x) 
      (S $y)) 
    (⩻ $x $y))
</span>;;;; Overload ⩻ for Number.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Number Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $x $y) 
    (< $x $y))
</span>;;;; Return the ceiling of a non negative number.  If the number is
;;;; negative it returns 1.
<span class="ansi38-255165000"
>  (: ceil 
    (-> Number Number))
</span><span class="ansi38-255165000"
>  (= 
    (ceil $n) 
    (fromNat (fromNumber $n)))
</span>;;;; Convert Number to Bool.  Anything above 0 converts to True.
<span class="ansi38-255165000"
>  (: number->bool 
    (-> Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (number->bool $x) 
    (< 0 $x))
</span>;;;; Convert Bool to Number.  False converts to 0, True converts to 1.
<span class="ansi38-255165000"
>  (: bool->number 
    (-> Bool Number))
</span><span class="ansi38-255165000"
>  (= 
    (bool->number False) 0)
</span><span class="ansi38-255165000"
>  (= 
    (bool->number True) 1)
</span>;;;; Define a less than type.  Note that it is purposefully different
;;;; than ⩻ as it is a type, not an operator.  Inhabitants of (⍃ x y)
;;;; are proofs that x ⩻ y == True.  For now ⍃ is only axiomatized for
;;;; Nat.
<span class="ansi38-255165000"
>  (: ⍃ 
    (-> $t $t Type))
</span>;;;; Zero is always less than the successor of something
<span class="ansi38-255165000"
>  (: 
    (zero-lt-succ-axiom) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (zero-lt-succ-axiom) 
    (: ZeroLTSucc 
      (⍃ Z 
        (S $k))))
</span>;;;; If x ⍃ y then (S x) ⍃ (S y)
<span class="ansi38-255165000"
>  (: 
    (succ-monotonicity-rule) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (succ-monotonicity-rule) 
    (: SuccMonotonicity 
      (-> 
        (⍃ $x $y) 
        (⍃ 
          (S $x) 
          (S $y)))))
</span>;;;; Collection of functions operating on numbers
;;;; Define max
<span class="ansi38-255165000"
>  (: max 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (max $x $y) 
    (if 
      (> $x $y) $x $y))
</span>;;;; Define min
<span class="ansi38-255165000"
>  (: min 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (min $x $y) 
    (if 
      (< $x $y) $x $y))
</span>;;;; Clamp a number to be within a certain range
<span class="ansi38-255165000"
>  (: clamp 
    (-> $a $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (clamp $x $l $u) 
    (max $l 
      (min $u $x)))
</span>;;;; Define abs
<span class="ansi38-255165000"
>  (: abs 
    (-> $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (abs $x) 
    (if 
      (< $x 0) 
      (* -1 $x) $x))
</span>;;;; Define <=
<span class="ansi38-255165000"
>  (: <= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (<= $x $y) 
    (or 
      (< $x $y) 
      (== $x $y)))
</span>;;;; Define >=
<span class="ansi38-255165000"
>  (: >= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (>= $x $y) 
    (or 
      (> $x $y) 
      (== $x $y)))
</span>;;;; Define approximately equal
<span class="ansi38-255165000"
>  (: approxEq 
    (-> $a $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (approxEq $x $y $epsilon) 
    (<= 
      (abs (- $x $y)) $epsilon))
</span>;;;; Define Nat
<span class="ansi38-255165000"
>  (: Nat Type)
</span><span class="ansi38-255165000"
>  (: Z Nat)
</span><span class="ansi38-255165000"
>  (: S 
    (-> Nat Nat))
</span>;;;; Define cast functions between Nat and Number
<span class="ansi38-255165000"
>  (: fromNumber 
    (-> Number Nat))
</span><span class="ansi38-255165000"
>  (= 
    (fromNumber $n) 
    (if 
      (<= $n 0) Z 
      (S (fromNumber (- $n 1)))))
</span><span class="ansi38-255165000"
>  (: fromNat 
    (-> Nat Number))
</span><span class="ansi38-255165000"
>  (= 
    (fromNat Z) 0)
</span><span class="ansi38-255165000"
>  (= 
    (fromNat (S $k)) 
    (+ 1 
      (fromNat $k)))
</span>;;;; Define a generic less than operator, ⩻, for Nat.  < cannot be used
;;;; because it is a built-in, its type is hardwired and cannot be
;;;; overloaded.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Nat Nat Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $ Z) False)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ Z 
      (S $)) True)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ 
      (S $x) 
      (S $y)) 
    (⩻ $x $y))
</span>;;;; Overload ⩻ for Number.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Number Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $x $y) 
    (< $x $y))
</span>;;;; Return the ceiling of a non negative number.  If the number is
;;;; negative it returns 1.
<span class="ansi38-255165000"
>  (: ceil 
    (-> Number Number))
</span><span class="ansi38-255165000"
>  (= 
    (ceil $n) 
    (fromNat (fromNumber $n)))
</span>;;;; Convert Number to Bool.  Anything above 0 converts to True.
<span class="ansi38-255165000"
>  (: number->bool 
    (-> Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (number->bool $x) 
    (< 0 $x))
</span>;;;; Convert Bool to Number.  False converts to 0, True converts to 1.
<span class="ansi38-255165000"
>  (: bool->number 
    (-> Bool Number))
</span><span class="ansi38-255165000"
>  (= 
    (bool->number False) 0)
</span><span class="ansi38-255165000"
>  (= 
    (bool->number True) 1)
</span>;;;; Define a less than type.  Note that it is purposefully different
;;;; than ⩻ as it is a type, not an operator.  Inhabitants of (⍃ x y)
;;;; are proofs that x ⩻ y == True.  For now ⍃ is only axiomatized for
;;;; Nat.
<span class="ansi38-255165000"
>  (: ⍃ 
    (-> $t $t Type))
</span>;;;; Zero is always less than the successor of something
<span class="ansi38-255165000"
>  (: 
    (zero-lt-succ-axiom) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (zero-lt-succ-axiom) 
    (: ZeroLTSucc 
      (⍃ Z 
        (S $k))))
</span>;;;; If x ⍃ y then (S x) ⍃ (S y)
<span class="ansi38-255165000"
>  (: 
    (succ-monotonicity-rule) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (succ-monotonicity-rule) 
    (: SuccMonotonicity 
      (-> 
        (⍃ $x $y) 
        (⍃ 
          (S $x) 
          (S $y)))))
</span>;;;; Collection of functions operating on numbers
;;;; Define max
<span class="ansi38-255165000"
>  (: max 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (max $x $y) 
    (if 
      (> $x $y) $x $y))
</span>;;;; Define min
<span class="ansi38-255165000"
>  (: min 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (min $x $y) 
    (if 
      (< $x $y) $x $y))
</span>;;;; Clamp a number to be within a certain range
<span class="ansi38-255165000"
>  (: clamp 
    (-> $a $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (clamp $x $l $u) 
    (max $l 
      (min $u $x)))
</span>;;;; Define abs
<span class="ansi38-255165000"
>  (: abs 
    (-> $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (abs $x) 
    (if 
      (< $x 0) 
      (* -1 $x) $x))
</span>;;;; Define <=
<span class="ansi38-255165000"
>  (: <= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (<= $x $y) 
    (or 
      (< $x $y) 
      (== $x $y)))
</span>;;;; Define >=
<span class="ansi38-255165000"
>  (: >= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (>= $x $y) 
    (or 
      (> $x $y) 
      (== $x $y)))
</span>;;;; Define approximately equal
<span class="ansi38-255165000"
>  (: approxEq 
    (-> $a $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (approxEq $x $y $epsilon) 
    (<= 
      (abs (- $x $y)) $epsilon))
</span>;;;; Define Nat
<span class="ansi38-255165000"
>  (: Nat Type)
</span><span class="ansi38-255165000"
>  (: Z Nat)
</span><span class="ansi38-255165000"
>  (: S 
    (-> Nat Nat))
</span>;;;; Define cast functions between Nat and Number
<span class="ansi38-255165000"
>  (: fromNumber 
    (-> Number Nat))
</span><span class="ansi38-255165000"
>  (= 
    (fromNumber $n) 
    (if 
      (<= $n 0) Z 
      (S (fromNumber (- $n 1)))))
</span><span class="ansi38-255165000"
>  (: fromNat 
    (-> Nat Number))
</span><span class="ansi38-255165000"
>  (= 
    (fromNat Z) 0)
</span><span class="ansi38-255165000"
>  (= 
    (fromNat (S $k)) 
    (+ 1 
      (fromNat $k)))
</span>;;;; Define a generic less than operator, ⩻, for Nat.  < cannot be used
;;;; because it is a built-in, its type is hardwired and cannot be
;;;; overloaded.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Nat Nat Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $ Z) False)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ Z 
      (S $)) True)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ 
      (S $x) 
      (S $y)) 
    (⩻ $x $y))
</span>;;;; Overload ⩻ for Number.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Number Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $x $y) 
    (< $x $y))
</span>;;;; Return the ceiling of a non negative number.  If the number is
;;;; negative it returns 1.
<span class="ansi38-255165000"
>  (: ceil 
    (-> Number Number))
</span><span class="ansi38-255165000"
>  (= 
    (ceil $n) 
    (fromNat (fromNumber $n)))
</span>;;;; Convert Number to Bool.  Anything above 0 converts to True.
<span class="ansi38-255165000"
>  (: number->bool 
    (-> Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (number->bool $x) 
    (< 0 $x))
</span>;;;; Convert Bool to Number.  False converts to 0, True converts to 1.
<span class="ansi38-255165000"
>  (: bool->number 
    (-> Bool Number))
</span><span class="ansi38-255165000"
>  (= 
    (bool->number False) 0)
</span><span class="ansi38-255165000"
>  (= 
    (bool->number True) 1)
</span>;;;; Define a less than type.  Note that it is purposefully different
;;;; than ⩻ as it is a type, not an operator.  Inhabitants of (⍃ x y)
;;;; are proofs that x ⩻ y == True.  For now ⍃ is only axiomatized for
;;;; Nat.
<span class="ansi38-255165000"
>  (: ⍃ 
    (-> $t $t Type))
</span>;;;; Zero is always less than the successor of something
<span class="ansi38-255165000"
>  (: 
    (zero-lt-succ-axiom) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (zero-lt-succ-axiom) 
    (: ZeroLTSucc 
      (⍃ Z 
        (S $k))))
</span>;;;; If x ⍃ y then (S x) ⍃ (S y)
<span class="ansi38-255165000"
>  (: 
    (succ-monotonicity-rule) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (succ-monotonicity-rule) 
    (: SuccMonotonicity 
      (-> 
        (⍃ $x $y) 
        (⍃ 
          (S $x) 
          (S $y)))))
</span>;;;; Collection of functions operating on numbers
;;;; Define max
<span class="ansi38-255165000"
>  (: max 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (max $x $y) 
    (if 
      (> $x $y) $x $y))
</span>;;;; Define min
<span class="ansi38-255165000"
>  (: min 
    (-> $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (min $x $y) 
    (if 
      (< $x $y) $x $y))
</span>;;;; Clamp a number to be within a certain range
<span class="ansi38-255165000"
>  (: clamp 
    (-> $a $a $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (clamp $x $l $u) 
    (max $l 
      (min $u $x)))
</span>;;;; Define abs
<span class="ansi38-255165000"
>  (: abs 
    (-> $a $a))
</span><span class="ansi38-255165000"
>  (= 
    (abs $x) 
    (if 
      (< $x 0) 
      (* -1 $x) $x))
</span>;;;; Define <=
<span class="ansi38-255165000"
>  (: <= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (<= $x $y) 
    (or 
      (< $x $y) 
      (== $x $y)))
</span>;;;; Define >=
<span class="ansi38-255165000"
>  (: >= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (>= $x $y) 
    (or 
      (> $x $y) 
      (== $x $y)))
</span>;;;; Define approximately equal
<span class="ansi38-255165000"
>  (: approxEq 
    (-> $a $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (approxEq $x $y $epsilon) 
    (<= 
      (abs (- $x $y)) $epsilon))
</span>;;;; Define Nat
<span class="ansi38-255165000"
>  (: Nat Type)
</span><span class="ansi38-255165000"
>  (: Z Nat)
</span><span class="ansi38-255165000"
>  (: S 
    (-> Nat Nat))
</span>;;;; Define cast functions between Nat and Number
<span class="ansi38-255165000"
>  (: fromNumber 
    (-> Number Nat))
</span><span class="ansi38-255165000"
>  (= 
    (fromNumber $n) 
    (if 
      (<= $n 0) Z 
      (S (fromNumber (- $n 1)))))
</span><span class="ansi38-255165000"
>  (: fromNat 
    (-> Nat Number))
</span><span class="ansi38-255165000"
>  (= 
    (fromNat Z) 0)
</span><span class="ansi38-255165000"
>  (= 
    (fromNat (S $k)) 
    (+ 1 
      (fromNat $k)))
</span>;;;; Define a generic less than operator, ⩻, for Nat.  < cannot be used
;;;; because it is a built-in, its type is hardwired and cannot be
;;;; overloaded.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Nat Nat Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $ Z) False)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ Z 
      (S $)) True)
</span><span class="ansi38-255165000"
>  (= 
    (⩻ 
      (S $x) 
      (S $y)) 
    (⩻ $x $y))
</span>;;;; Overload ⩻ for Number.
<span class="ansi38-255165000"
>  (: ⩻ 
    (-> Number Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (⩻ $x $y) 
    (< $x $y))
</span>;;;; Return the ceiling of a non negative number.  If the number is
;;;; negative it returns 1.
<span class="ansi38-255165000"
>  (: ceil 
    (-> Number Number))
</span><span class="ansi38-255165000"
>  (= 
    (ceil $n) 
    (fromNat (fromNumber $n)))
</span>;;;; Convert Number to Bool.  Anything above 0 converts to True.
<span class="ansi38-255165000"
>  (: number->bool 
    (-> Number Bool))
</span><span class="ansi38-255165000"
>  (= 
    (number->bool $x) 
    (< 0 $x))
</span>;;;; Convert Bool to Number.  False converts to 0, True converts to 1.
<span class="ansi38-255165000"
>  (: bool->number 
    (-> Bool Number))
</span><span class="ansi38-255165000"
>  (= 
    (bool->number False) 0)
</span><span class="ansi38-255165000"
>  (= 
    (bool->number True) 1)
</span>;;;; Define a less than type.  Note that it is purposefully different
;;;; than ⩻ as it is a type, not an operator.  Inhabitants of (⍃ x y)
;;;; are proofs that x ⩻ y == True.  For now ⍃ is only axiomatized for
;;;; Nat.
<span class="ansi38-255165000"
>  (: ⍃ 
    (-> $t $t Type))
</span>;;;; Zero is always less than the successor of something
<span class="ansi38-255165000"
>  (: 
    (zero-lt-succ-axiom) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (zero-lt-succ-axiom) 
    (: ZeroLTSucc 
      (⍃ Z 
        (S $k))))
</span>;;;; If x ⍃ y then (S x) ⍃ (S y)
<span class="ansi38-255165000"
>  (: 
    (succ-monotonicity-rule) 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (succ-monotonicity-rule) 
    (: SuccMonotonicity 
      (-> 
        (⍃ $x $y) 
        (⍃ 
          (S $x) 
          (S $y)))))
</span>
Deterministic: ()
;;;; !(import! &self Unify.metta)
;;;; Enumerate all programs up to a given depth that are consistent with
;;;; the query, using the given axiom non-deterministic functions and rules.
;;;;
;;;; The arguments are:
;;;;
;;;; $query: an Atom under the form (: TERM TYPE).  The atom may contain
;;;;         free variables within TERM and TYPE to form various sort of
;;;;         queries, such as:
;;;;         1. Backward chaining: (: $term (Inheritance $x Mammal))
;;;;         2. Forward chaining: (: ($rule $premise AXIOM) $type)
;;;;         3. Mixed chaining: (: ($rule $premise AXIOM) (Inheritance $x Mammal))
;;;;         4. Type checking: (: TERM TYPE)
;;;;         5. Type inference: (: TERM $type)
;;;;
;;;; $kb: a nullary function to axiom, to non-deterministically pick up
;;;;      an axiom.  An axiom is an Atom of the form (: TERM TYPE).
;;;;
;;;; $rb: a nullary function to rule, to non-deterministically pick up a
;;;;      rule.  A rule is a function mapping premises to conclusion,
;;;;      where premises and conclusion have the form (: TERM TYPE).
;;;;
;;;; $depth: a Nat representing the maximum depth of the generated
;;;;         programs.
;;;;
;;;; TODO: recurse over curried rules instead of duplicating code over
;;;; tuples.
<span class="ansi38-255165000"
>  (: synthesize 
    (-> $a 
      (-> $kt) 
      (-> $rt) Nat $a))
</span>;;;; Nullary rule (axiom)
<span class="ansi38-255165000"
>  (= 
    (synthesize $query $kb $rb $depth) 
    (let $query 
      ($kb) $query))
</span>;;;; Unary rule
<span class="ansi38-255165000"
>  (= 
    (synthesize $query $kb $rb 
      (S $k)) 
    (let* 
      ( ( (: $ructor 
            (-> $premise $conclusion)) ($rb)) 
        ( (: 
            ($ructor $proof) $conclusion) $query) 
        ( (: $proof $premise) (synthesize (: $proof $premise) $kb $rb $k))) $query))
</span>;;;; Binary rule
<span class="ansi38-255165000"
>  (= 
    (synthesize $query $kb $rb 
      (S $k)) 
    (let* 
      ( ( (: $ructor 
            (-> $premise1 $premise2 $conclusion)) ($rb)) 
        ( (: 
            ($ructor $proof1 $proof2) $conclusion) $query) 
        ( (: $proof1 $premise1) (synthesize (: $proof1 $premise1) $kb $rb $k)) 
        ( (: $proof2 $premise2) (synthesize (: $proof2 $premise2) $kb $rb $k))) $query))
</span>;;;; Trinary rule
<span class="ansi38-255165000"
>  (= 
    (synthesize $query $kb $rb 
      (S $k)) 
    (let* 
      ( ( (: $ructor 
            (-> $premise1 $premise2 $premise3 $conclusion)) ($rb)) 
        ( (: 
            ($ructor $proof1 $proof2 $proof3) $conclusion) $query) 
        ( (: $proof1 $premise1) (synthesize (: $proof1 $premise1) $kb $rb $k)) 
        ( (: $proof2 $premise2) (synthesize (: $proof2 $premise2) $kb $rb $k)) 
        ( (: $proof3 $premise3) (synthesize (: $proof3 $premise3) $kb $rb $k))) $query))
</span>;;;; Quaternary rule
<span class="ansi38-255165000"
>  (= 
    (synthesize $query $kb $rb 
      (S $k)) 
    (let* 
      ( ( (: $ructor 
            (-> $premise1 $premise2 $premise3 $premise4 $conclusion)) ($rb)) 
        ( (: 
            ($ructor $proof1 $proof2 $proof3 $proof4) $conclusion) $query) 
        ( (: $proof1 $premise1) (synthesize (: $proof1 $premise1) $kb $rb $k)) 
        ( (: $proof2 $premise2) (synthesize (: $proof2 $premise2) $kb $rb $k)) 
        ( (: $proof3 $premise3) (synthesize (: $proof3 $premise3) $kb $rb $k)) 
        ( (: $proof4 $premise4) (synthesize (: $proof4 $premise4) $kb $rb $k))) $query))
</span>;;;; Quintenary rule
<span class="ansi38-255165000"
>  (= 
    (synthesize $query $kb $rb 
      (S $k)) 
    (let* 
      ( ( (: $ructor 
            (-> $premise1 $premise2 $premise3 $premise4 $premise5 $conclusion)) ($rb)) 
        ( (: 
            ($ructor $proof1 $proof2 $proof3 $proof4 $proof5) $conclusion) $query) 
        ( (: $proof1 $premise1) (synthesize (: $proof1 $premise1) $kb $rb $k)) 
        ( (: $proof2 $premise2) (synthesize (: $proof2 $premise2) $kb $rb $k)) 
        ( (: $proof3 $premise3) (synthesize (: $proof3 $premise3) $kb $rb $k)) 
        ( (: $proof4 $premise4) (synthesize (: $proof4 $premise4) $kb $rb $k)) 
        ( (: $proof5 $premise5) (synthesize (: $proof5 $premise5) $kb $rb $k))) $query))
</span>
Last Result(2): ()
()]
;;;; Knowledge base
<span class="ansi38-255165000"
>  (: kb 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (kb) 
    (superpose ((: Pm (≞ P (STV 0.2 0.3))) (: Qm (≞ Q (STV 0.3 0.2))) (: Rm (≞ R (STV 0.4 0.1))) (: P2 (⊷ P (fromNumber 2) True)) (: Q2 (⊷ Q (fromNumber 2) False)) (: P7 (⊷ P (fromNumber 7) True)) (: Q7 (⊷ Q (fromNumber 7) True)) (: QRm (≞ (→ Q R) (STV 0.9 0.7))))))
</span>;;;; All axioms are placed in the kb as well
<span class="ansi38-255165000"
>  (= 
    (kb) 
    (zero-lt-succ-axiom))
</span>;;;; Rule base
<span class="ansi38-255165000"
>  (: rb 
    (-> Atom))
</span><span class="ansi38-255165000"
>  (= 
    (rb) 
    (superpose ((succ-monotonicity-rule) (deduction-rule) (implication-direct-introduction-base-rule) (implication-direct-introduction-recursive-rule) (evidence-elimination-rule))))
</span>;;;; Test a combination of deduction and implication direct introduction
;;;;
;;;; Build the following inference tree
;;;;
;;;;                                                                                      -----(ZeroLTSucc)
;;;;                                                                                      0 ⍃ 5
;;;;                                                 --------(P2)     --------(Q2)        -----(SuccMonotonicity)
;;;;                                                 (P 2) = ⊤        (Q 2) = ⊥           1 ⍃ 6
;;;;                     --------(P7)  --------(Q7)  --------------------------(IDIBase)  -----(SuccMonotonicity)
;;;;                     (P 7) = ⊤     (Q 7) = ⊤     P → Q ≞ ((:: 2 ∅), <0 0.5>)          2 ⍃ 7
;;;;                     ---------------------------------------------------------------------(IDIRecursive)
;;;;                                                 P → Q ≞ (ETV (:: 7 (:: 2 ∅)) $pqtv)
;;;;                                                             |
;;;; ------------(Pm)  ------------(Qm)  ------------(Rm)  -------------(EvidenceElimination)  ----------------(QRm)
;;;; P ≞ <0.2 0.3>     Q ≞ <0.3 0.2>     R ≞ <0.4 0.1>     P → Q ≞ $pqtv                       Q → R ≞ <0.9 0.7>
;;;; ----------------------------------------------------------------------------------------------------------(Deduction)
;;;;                                                       P → R ≞ $prtv
<span class="ansi38-255165000"
>  (: deduction_idi_prf 
    (≞ 
      (→ P Q) $tv))
</span><span class="ansi38-255165000"
>  (= deduction_idi_prf 
    (Deduction Pm Qm Rm 
      (IDIBase P2 Q2) QRm))
</span><span class="ansi38-255165009"
>;; In file as:  
</span><span class="ansi1 ansi38-255238088"
>  !deduction_idi_prf
</span>;; To unit test case:
<span class="ansi38-013099040"
>  !(assertEqualToResult deduction_idi_prf 
    (deduction_idi_prf))

</span>[

;<h3 id="DEPENDENT-TYPES.DEDUCTIONIMPLICATIONDIRECTINTRODUCTIONDTLTEST.01"
>;; DEPENDENT-TYPES.DEDUCTIONIMPLICATIONDIRECTINTRODUCTIONDTLTEST.01</h3>
; 
; EVAL TEST
; took 0.000025 secs. (24.68 microseconds) 

  !(assertEqualToResult deduction_idi_prf 
    (deduction_idi_prf))

<span class="ansi36"
>  (loonit_success  
    (equal_enough_for_test  
      (deduction_idi_prf) 
      (deduction_idi_prf)))
</span>
Deterministic: ()
()]
<span class="ansi38-255165009"
>;; In file as:  
</span><span class="ansi1 ansi38-255238088"
>  !(get-type deduction_idi_prf)
</span>;; To unit test case:
<span class="ansi38-013099040"
>  !(assertEqualToResult 
    (get-type deduction_idi_prf) 
    ( (≞ 
        (→ P Q) $tv#1072)))

</span>[

;<h3 id="DEPENDENT-TYPES.DEDUCTIONIMPLICATIONDIRECTINTRODUCTIONDTLTEST.02"
>;; DEPENDENT-TYPES.DEDUCTIONIMPLICATIONDIRECTINTRODUCTIONDTLTEST.02</h3>
; 
; EVAL TEST
; took 0.000769 secs. (768.50 microseconds) 

  !(assertEqualToResult 
    (get-type deduction_idi_prf) 
    ( (≞ 
        (→ P Q) $tv#1072)))

<span class="ansi36"
>  (loonit_success  
    (equal_enough_for_test  
      ( (≞ 
          (→ P Q) $_1567454)) 
      ( (≞ 
          (→ P Q) $_1557144))))
</span>
Deterministic: ()
()]
<span class="ansi38-255165009"
>;; In file as:  
</span><span class="ansi1 ansi38-255238088"
>  !=====
</span>;; To unit test case:
<span class="ansi38-013099040"
>  !(assertEqualToResult ===== 
    ("===== Prove that P→Q based on one piece of evidence ====="))

</span>[

;<h3 id="DEPENDENT-TYPES.DEDUCTIONIMPLICATIONDIRECTINTRODUCTIONDTLTEST.03"
>;; DEPENDENT-TYPES.DEDUCTIONIMPLICATIONDIRECTINTRODUCTIONDTLTEST.03</h3>
; 
; EVAL TEST
; took 0.000022 secs. (21.53 microseconds) 

  !(assertEqualToResult ===== 
    ("===== Prove that P→Q based on one piece of evidence ====="))

<span class="ansi31"
>  (loonit_failureR  
    (equal_enough_for_test  
      (=====) 
      ("===== Prove that P→Q based on one piece of evidence =====")))
</span>
Deterministic: ((Error  (got  (=====)) (expected  ("===== Prove that P→Q based on one piece of evidence ====="))))
((Error  (got  (=====)) (expected  ("===== Prove that P→Q based on one piece of evidence ====="))))]
<span class="ansi38-255165009"
>;; In file as:  
</span><span class="ansi1 ansi38-255238088"
>  !(synthesize 
    (: $proof 
      (≞ 
        (→ P Q) $etv)) kb rb 
    (fromNumber 1))
</span>;; To unit test case:
<span class="ansi38-013099040"
>  !(assertEqualToResult 
    (synthesize 
      (: $proof 
        (≞ 
          (→ P Q) $etv)) kb rb 
      (fromNumber 1)) 
    ( (let* 
        ( ( (: $proof2#6435 
              (⊷ Q 
                (S (S Z)) True)) (synthesize (: $proof2#6435 (⊷ Q (S (S Z)) True)) kb rb Z)) 
          ( (: $proof3#6436 
              (≞ 
                (→ P Q) 
                (ETV 
                  (:: $h#6441 $t#6442) 
                  (STV $s#6443 $y#6444)))) (synthesize (: $proof3#6436 (≞ (→ P Q) (ETV (:: $h#6441 $t#6442) (STV $s#6443 $y#6444)))) kb rb Z)) 
          ( (: $proof4#6437 
              (⍃ $h#6441 
                (S (S Z)))) (synthesize (: $proof4#6437 (⍃ $h#6441 (S (S Z)))) kb rb Z))) 
        (: 
          (IDIRecursive P2 $proof2#6435 $proof3#6436 $proof4#6437) 
          (≞ 
            (→ P Q) 
            (ETV 
              (:: 
                (S (S Z)) 
                (:: $h#6441 $t#6442)) 
              (STV 
                (/ 
                  (+ 
                    (* $s#6443 
                      (if 
                        (<= 
                          (if 
                            (< 
                              (- 1.0 $y#6444) 0) 
                            (* -1 
                              (- 1.0 $y#6444)) 
                            (- 1.0 $y#6444)) 1.0e-9) 
                        (max-count) 
                        (/ 
                          (* $y#6444 
                            (lookahead)) 
                          (- 1.0 $y#6444)))) 1) 
                  (+ 
                    (if 
                      (<= 
                        (if 
                          (< 
                            (- 1.0 $y#6444) 0) 
                          (* -1 
                            (- 1.0 $y#6444)) 
                          (- 1.0 $y#6444)) 1.0e-9) 
                      (max-count) 
                      (/ 
                        (* $y#6444 
                          (lookahead)) 
                        (- 1.0 $y#6444))) 1)) 
                (/ 
                  (+ 
                    (if 
                      (<= 
                        (if 
                          (< 
                            (- 1.0 $y#6444) 0) 
                          (* -1 
                            (- 1.0 $y#6444)) 
                          (- 1.0 $y#6444)) 1.0e-9) 
                      (max-count) 
                      (/ 
                        (* $y#6444 
                          (lookahead)) 
                        (- 1.0 $y#6444))) 1) 
                  (+ 
                    (+ 
                      (if 
                        (<= 
                          (if 
                            (< 
                              (- 1.0 $y#6444) 0) 
                            (* -1 
                              (- 1.0 $y#6444)) 
                            (- 1.0 $y#6444)) 1.0e-9) 
                        (max-count) 
                        (/ 
                          (* $y#6444 
                            (lookahead)) 
                          (- 1.0 $y#6444))) 1) 1.0))))))) 
      (let* 
        ( ( (: $proof3#6436 
              (≞ 
                (→ P Q) 
                (ETV 
                  (:: $h#6441 $t#6442) 
                  (STV $s#6443 $y#6444)))) (synthesize (: $proof3#6436 (≞ (→ P Q) (ETV (:: $h#6441 $t#6442) (STV $s#6443 $y#6444)))) kb rb Z)) ((: $proof4#6437 (⍃ $h#6441 (S (S (S (S (S (S (S Z))))))))) (synthesize (: $proof4#6437 (⍃ $h#6441 (S (S (S (S (S (S (S Z))))))))) kb rb Z))) 
        (: 
          (IDIRecursive P7 Q7 $proof3#6436 $proof4#6437) 
          (≞ 
            (→ P Q) 
            (ETV 
              (:: 
                (S (S (S (S (S (S (S Z))))))) 
                (:: $h#6441 $t#6442)) 
              (STV 
                (/ 
                  (+ 
                    (* $s#6443 
                      (if 
                        (<= 
                          (if 
                            (< 
                              (- 1.0 $y#6444) 0) 
                            (* -1 
                              (- 1.0 $y#6444)) 
                            (- 1.0 $y#6444)) 1.0e-9) 
                        (max-count) 
                        (/ 
                          (* $y#6444 
                            (lookahead)) 
                          (- 1.0 $y#6444)))) 1) 
                  (+ 
                    (if 
                      (<= 
                        (if 
                          (< 
                            (- 1.0 $y#6444) 0) 
                          (* -1 
                            (- 1.0 $y#6444)) 
                          (- 1.0 $y#6444)) 1.0e-9) 
                      (max-count) 
                      (/ 
                        (* $y#6444 
                          (lookahead)) 
                        (- 1.0 $y#6444))) 1)) 
                (/ 
                  (+ 
                    (if 
                      (<= 
                        (if 
                          (< 
                            (- 1.0 $y#6444) 0) 
                          (* -1 
                            (- 1.0 $y#6444)) 
                          (- 1.0 $y#6444)) 1.0e-9) 
                      (max-count) 
                      (/ 
                        (* $y#6444 
                          (lookahead)) 
                        (- 1.0 $y#6444))) 1) 
                  (+ 
                    (+ 
                      (if 
                        (<= 
                          (if 
                            (< 
                              (- 1.0 $y#6444) 0) 
                            (* -1 
                              (- 1.0 $y#6444)) 
                            (- 1.0 $y#6444)) 1.0e-9) 
                        (max-count) 
                        (/ 
                          (* $y#6444 
                            (lookahead)) 
                          (- 1.0 $y#6444))) 1) 1.0))))))) 
      (let* 
        ( ( (: $proof3#7166 
              (≞ 
                (→ P Q) 
                (ETV 
                  (:: $h#7171 $t#7172) 
                  (STV $s#7173 $PQc#7174)))) (synthesize (: $proof3#7166 (≞ (→ P Q) (ETV (:: $h#7171 $t#7172) (STV $s#7173 $PQc#7174)))) kb rb Z)) ((: $proof4#7167 (⍃ $h#7171 (S (S Z)))) (synthesize (: $proof4#7167 (⍃ $h#7171 (S (S Z)))) kb rb Z))) 
        (: 
          (IDIRecursive P2 Q2 $proof3#7166 $proof4#7167) 
          (≞ 
            (→ P Q) 
            (ETV 
              (:: 
                (S (S Z)) 
                (:: $h#7171 $t#7172)) 
              (STV 
                (/ 
                  (* $s#7173 
                    (if 
                      (<= 
                        (if 
                          (< 
                            (- 1.0 $PQc#7174) 0) 
                          (* -1 
                            (- 1.0 $PQc#7174)) 
                          (- 1.0 $PQc#7174)) 1.0e-9) 
                      (max-count) 
                      (/ 
                        (* $PQc#7174 
                          (lookahead)) 
                        (- 1.0 $PQc#7174)))) 
                  (+ 
                    (if 
                      (<= 
                        (if 
                          (< 
                            (- 1.0 $PQc#7174) 0) 
                          (* -1 
                            (- 1.0 $PQc#7174)) 
                          (- 1.0 $PQc#7174)) 1.0e-9) 
                      (max-count) 
                      (/ 
                        (* $PQc#7174 
                          (lookahead)) 
                        (- 1.0 $PQc#7174))) 1)) 
                (/ 
                  (+ 
                    (if 
                      (<= 
                        (if 
                          (< 
                            (- 1.0 $PQc#7174) 0) 
                          (* -1 
                            (- 1.0 $PQc#7174)) 
                          (- 1.0 $PQc#7174)) 1.0e-9) 
                      (max-count) 
                      (/ 
                        (* $PQc#7174 
                          (lookahead)) 
                        (- 1.0 $PQc#7174))) 1) 
                  (+ 
                    (+ 
                      (if 
                        (<= 
                          (if 
                            (< 
                              (- 1.0 $PQc#7174) 0) 
                            (* -1 
                              (- 1.0 $PQc#7174)) 
                            (- 1.0 $PQc#7174)) 1.0e-9) 
                        (max-count) 
                        (/ 
                          (* $PQc#7174 
                            (lookahead)) 
                          (- 1.0 $PQc#7174))) 1) 1.0))))))) 
      (let* 
        ( ( (: $proof2#7165 
              (⊷ Q 
                (S (S (S (S (S (S (S Z))))))) False)) (synthesize (: $proof2#7165 (⊷ Q (S (S (S (S (S (S (S Z))))))) False)) kb rb Z)) 
          ( (: $proof3#7166 
              (≞ 
                (→ P Q) 
                (ETV 
                  (:: $h#7171 $t#7172) 
                  (STV $s#7173 $PQc#7174)))) (synthesize (: $proof3#7166 (≞ (→ P Q) (ETV (:: $h#7171 $t#7172) (STV $s#7173 $PQc#7174)))) kb rb Z)) 
          ( (: $proof4#7167 
              (⍃ $h#7171 
                (S (S (S (S (S (S (S Z))))))))) (synthesize (: $proof4#7167 (⍃ $h#7171 (S (S (S (S (S (S (S Z))))))))) kb rb Z))) 
        (: 
          (IDIRecursive P7 $proof2#7165 $proof3#7166 $proof4#7167) 
          (≞ 
            (→ P Q) 
            (ETV 
              (:: 
                (S (S (S (S (S (S (S Z))))))) 
                (:: $h#7171 $t#7172)) 
              (STV 
                (/ 
                  (* $s#7173 
                    (if 
                      (<= 
                        (if 
                          (< 
                            (- 1.0 $PQc#7174) 0) 
                          (* -1 
                            (- 1.0 $PQc#7174)) 
                          (- 1.0 $PQc#7174)) 1.0e-9) 
                      (max-count) 
                      (/ 
                        (* $PQc#7174 
                          (lookahead)) 
                        (- 1.0 $PQc#7174)))) 
                  (+ 
                    (if 
                      (<= 
                        (if 
                          (< 
                            (- 1.0 $PQc#7174) 0) 
                          (* -1 
                            (- 1.0 $PQc#7174)) 
                          (- 1.0 $PQc#7174)) 1.0e-9) 
                      (max-count) 
                      (/ 
                        (* $PQc#7174 
                          (lookahead)) 
                        (- 1.0 $PQc#7174))) 1)) 
                (/ 
                  (+ 
                    (if 
                      (<= 
                        (if 
                          (< 
                            (- 1.0 $PQc#7174) 0) 
                          (* -1 
                            (- 1.0 $PQc#7174)) 
                          (- 1.0 $PQc#7174)) 1.0e-9) 
                      (max-count) 
                      (/ 
                        (* $PQc#7174 
                          (lookahead)) 
                        (- 1.0 $PQc#7174))) 1) 
                  (+ 
                    (+ 
                      (if 
                        (<= 
                          (if 
                            (< 
                              (- 1.0 $PQc#7174) 0) 
                            (* -1 
                              (- 1.0 $PQc#7174)) 
                            (- 1.0 $PQc#7174)) 1.0e-9) 
                        (max-count) 
                        (/ 
                          (* $PQc#7174 
                            (lookahead)) 
                          (- 1.0 $PQc#7174))) 1) 1.0))))))) 
      (let* 
        ( ( (: $proof#7948 
              (≞ 
                (→ P Q) 
                (ETV $evidence#7858 $etv))) (synthesize (: $proof#7948 (≞ (→ P Q) (ETV $evidence#7858 $etv))) kb rb Z))) 
        (: 
          (EvidenceElimination $proof#7948) 
          (≞ 
            (→ P Q) $etv))) 
      (let* 
        ( ( (: $proof4#8239 
              (≞ 
                (→ P P) 
                (STV $ABs#8245 $PQc#8251))) (synthesize (: $proof4#8239 (≞ (→ P P) (STV $ABs#8245 $PQc#8251))) kb rb Z)) ((: $proof5#8240 (≞ (→ P Q) (STV $QRs#8247 $QRc#8252))) (synthesize (: $proof5#8240 (≞ (→ P Q) (STV $QRs#8247 $QRc#8252))) kb rb Z))) 
        (: 
          (Deduction Pm Pm Qm $proof4#8239 $proof5#8240) 
          (≞ 
            (→ P Q) 
            (if 
              (and 
                (and 
                  (< 0 0.2) 
                  (and 
                    (<= 
                      (if 
                        (> 0 
                          (if 
                            (< 1 
                              (/ 
                                (- 
                                  (+ 0.2 0.2) 1) 0.2)) 1 
                            (/ 
                              (- 
                                (+ 0.2 0.2) 1) 0.2))) 0 
                        (if 
                          (< 1 
                            (/ 
                              (- 
                                (+ 0.2 0.2) 1) 0.2)) 1 
                          (/ 
                            (- 
                              (+ 0.2 0.2) 1) 0.2))) $ABs#8245) 
                    (<= $ABs#8245 
                      (if 
                        (> 0 
                          (if 
                            (< 1 
                              (/ 0.2 0.2)) 1 
                            (/ 0.2 0.2))) 0 
                        (if 
                          (< 1 
                            (/ 0.2 0.2)) 1 
                          (/ 0.2 0.2)))))) 
                (and 
                  (< 0 0.2) 
                  (and 
                    (<= 
                      (if 
                        (> 0 
                          (if 
                            (< 1 
                              (/ 
                                (- 
                                  (+ 0.2 0.3) 1) 0.2)) 1 
                            (/ 
                              (- 
                                (+ 0.2 0.3) 1) 0.2))) 0 
                        (if 
                          (< 1 
                            (/ 
                              (- 
                                (+ 0.2 0.3) 1) 0.2)) 1 
                          (/ 
                            (- 
                              (+ 0.2 0.3) 1) 0.2))) $QRs#8247) 
                    (<= $QRs#8247 
                      (if 
                        (> 0 
                          (if 
                            (< 1 
                              (/ 0.3 0.2)) 1 
                            (/ 0.3 0.2))) 0 
                        (if 
                          (< 1 
                            (/ 0.3 0.2)) 1 
                          (/ 0.3 0.2))))))) 
              (STV 
                (if 
                  (< 0.9999 0.2) 0.3 
                  (+ 
                    (* $ABs#8245 $QRs#8247) 
                    (/ 
                      (* 
                        (- 1 $ABs#8245) 
                        (- 0.3 
                          (* 0.2 $QRs#8247))) 
                      (- 1 0.2)))) 
                (min 0.3 
                  (min 0.3 
                    (min 0.2 
                      (min $PQc#8251 $QRc#8252))))) 
              (STV 1 0))))) 
      (let* 
        ( ( (: $proof4#8239 
              (≞ 
                (→ P Q) 
                (STV $ABs#8245 $PQc#8251))) (synthesize (: $proof4#8239 (≞ (→ P Q) (STV $ABs#8245 $PQc#8251))) kb rb Z)) ((: $proof5#8240 (≞ (→ Q Q) (STV $QRs#8247 $QRc#8252))) (synthesize (: $proof5#8240 (≞ (→ Q Q) (STV $QRs#8247 $QRc#8252))) kb rb Z))) 
        (: 
          (Deduction Pm Qm Qm $proof4#8239 $proof5#8240) 
          (≞ 
            (→ P Q) 
            (if 
              (and 
                (and 
                  (< 0 0.2) 
                  (and 
                    (<= 
                      (if 
                        (> 0 
                          (if 
                            (< 1 
                              (/ 
                                (- 
                                  (+ 0.2 0.3) 1) 0.2)) 1 
                            (/ 
                              (- 
                                (+ 0.2 0.3) 1) 0.2))) 0 
                        (if 
                          (< 1 
                            (/ 
                              (- 
                                (+ 0.2 0.3) 1) 0.2)) 1 
                          (/ 
                            (- 
                              (+ 0.2 0.3) 1) 0.2))) $ABs#8245) 
                    (<= $ABs#8245 
                      (if 
                        (> 0 
                          (if 
                            (< 1 
                              (/ 0.3 0.2)) 1 
                            (/ 0.3 0.2))) 0 
                        (if 
                          (< 1 
                            (/ 0.3 0.2)) 1 
                          (/ 0.3 0.2)))))) 
                (and 
                  (< 0 0.3) 
                  (and 
                    (<= 
                      (if 
                        (> 0 
                          (if 
                            (< 1 
                              (/ 
                                (- 
                                  (+ 0.3 0.3) 1) 0.3)) 1 
                            (/ 
                              (- 
                                (+ 0.3 0.3) 1) 0.3))) 0 
                        (if 
                          (< 1 
                            (/ 
                              (- 
                                (+ 0.3 0.3) 1) 0.3)) 1 
                          (/ 
                            (- 
                              (+ 0.3 0.3) 1) 0.3))) $QRs#8247) 
                    (<= $QRs#8247 
                      (if 
                        (> 0 
                          (if 
                            (< 1 
                              (/ 0.3 0.3)) 1 
                            (/ 0.3 0.3))) 0 
                        (if 
                          (< 1 
                            (/ 0.3 0.3)) 1 
                          (/ 0.3 0.3))))))) 
              (STV 
                (if 
                  (< 0.9999 0.3) 0.3 
                  (+ 
                    (* $ABs#8245 $QRs#8247) 
                    (/ 
                      (* 
                        (- 1 $ABs#8245) 
                        (- 0.3 
                          (* 0.3 $QRs#8247))) 
                      (- 1 0.3)))) 
                (min 0.3 
                  (min 0.2 
                    (min 0.2 
                      (min $PQc#8251 $QRc#8252))))) 
              (STV 1 0))))) 
      (let* 
        ( ( (: $proof4#8239 
              (≞ 
                (→ P R) 
                (STV $ABs#8245 $PQc#8251))) (synthesize (: $proof4#8239 (≞ (→ P R) (STV $ABs#8245 $PQc#8251))) kb rb Z)) ((: $proof5#8240 (≞ (→ R Q) (STV $QRs#8247 $QRc#8252))) (synthesize (: $proof5#8240 (≞ (→ R Q) (STV $QRs#8247 $QRc#8252))) kb rb Z))) 
        (: 
          (Deduction Pm Rm Qm $proof4#8239 $proof5#8240) 
          (≞ 
            (→ P Q) 
            (if 
              (and 
                (and 
                  (< 0 0.2) 
                  (and 
                    (<= 
                      (if 
                        (> 0 
                          (if 
                            (< 1 
                              (/ 
                                (- 
                                  (+ 0.2 0.4) 1) 0.2)) 1 
                            (/ 
                              (- 
                                (+ 0.2 0.4) 1) 0.2))) 0 
                        (if 
                          (< 1 
                            (/ 
                              (- 
                                (+ 0.2 0.4) 1) 0.2)) 1 
                          (/ 
                            (- 
                              (+ 0.2 0.4) 1) 0.2))) $ABs#8245) 
                    (<= $ABs#8245 
                      (if 
                        (> 0 
                          (if 
                            (< 1 
                              (/ 0.4 0.2)) 1 
                            (/ 0.4 0.2))) 0 
                        (if 
                          (< 1 
                            (/ 0.4 0.2)) 1 
                          (/ 0.4 0.2)))))) 
                (and 
                  (< 0 0.4) 
                  (and 
                    (<= 
                      (if 
                        (> 0 
                          (if 
                            (< 1 
                              (/ 
                                (- 
                                  (+ 0.4 0.3) 1) 0.4)) 1 
                            (/ 
                              (- 
                                (+ 0.4 0.3) 1) 0.4))) 0 
                        (if 
                          (< 1 
                            (/ 
                              (- 
                                (+ 0.4 0.3) 1) 0.4)) 1 
                          (/ 
                            (- 
                              (+ 0.4 0.3) 1) 0.4))) $QRs#8247) 
                    (<= $QRs#8247 
                      (if 
                        (> 0 
                          (if 
                            (< 1 
                              (/ 0.3 0.4)) 1 
                            (/ 0.3 0.4))) 0 
                        (if 
                          (< 1 
                            (/ 0.3 0.4)) 1 
                          (/ 0.3 0.4))))))) 
              (STV 
                (if 
                  (< 0.9999 0.4) 0.3 
                  (+ 
                    (* $ABs#8245 $QRs#8247) 
                    (/ 
                      (* 
                        (- 1 $ABs#8245) 
                        (- 0.3 
                          (* 0.4 $QRs#8247))) 
                      (- 1 0.4)))) 
                (min 0.3 
                  (min 0.1 
                    (min 0.2 
                      (min $PQc#8251 $QRc#8252))))) 
              (STV 1 0))))) 
      (let* 
        ( ( (: $proof4#8239 
              (≞ 
                (→ P 
                  (→ Q R)) 
                (STV $ABs#8245 $PQc#8251))) (synthesize (: $proof4#8239 (≞ (→ P (→ Q R)) (STV $ABs#8245 $PQc#8251))) kb rb Z)) ((: $proof5#8240 (≞ (→ (→ Q R) Q) (STV $QRs#8247 $QRc#8252))) (synthesize (: $proof5#8240 (≞ (→ (→ Q R) Q) (STV $QRs#8247 $QRc#8252))) kb rb Z))) 
        (: 
          (Deduction Pm QRm Qm $proof4#8239 $proof5#8240) 
          (≞ 
            (→ P Q) 
            (if 
              (and 
                (and 
                  (< 0 0.2) 
                  (and 
                    (<= 
                      (if 
                        (> 0 
                          (if 
                            (< 1 
                              (/ 
                                (- 
                                  (+ 0.2 0.9) 1) 0.2)) 1 
                            (/ 
                              (- 
                                (+ 0.2 0.9) 1) 0.2))) 0 
                        (if 
                          (< 1 
                            (/ 
                              (- 
                                (+ 0.2 0.9) 1) 0.2)) 1 
                          (/ 
                            (- 
                              (+ 0.2 0.9) 1) 0.2))) $ABs#8245) 
                    (<= $ABs#8245 
                      (if 
                        (> 0 
                          (if 
                            (< 1 
                              (/ 0.9 0.2)) 1 
                            (/ 0.9 0.2))) 0 
                        (if 
                          (< 1 
                            (/ 0.9 0.2)) 1 
                          (/ 0.9 0.2)))))) 
                (and 
                  (< 0 0.9) 
                  (and 
                    (<= 
                      (if 
                        (> 0 
                          (if 
                            (< 1 
                              (/ 
                                (- 
                                  (+ 0.9 0.3) 1) 0.9)) 1 
                            (/ 
                              (- 
                                (+ 0.9 0.3) 1) 0.9))) 0 
                        (if 
                          (< 1 
                            (/ 
                              (- 
                                (+ 0.9 0.3) 1) 0.9)) 1 
                          (/ 
                            (- 
                              (+ 0.9 0.3) 1) 0.9))) $QRs#8247) 
                    (<= $QRs#8247 
                      (if 
                        (> 0 
                          (if 
                            (< 1 
                              (/ 0.3 0.9)) 1 
                            (/ 0.3 0.9))) 0 
                        (if 
                          (< 1 
                            (/ 0.3 0.9)) 1 
                          (/ 0.3 0.9))))))) 
              (STV 
                (if 
                  (< 0.9999 0.9) 0.3 
                  (+ 
                    (* $ABs#8245 $QRs#8247) 
                    (/ 
                      (* 
                        (- 1 $ABs#8245) 
                        (- 0.3 
                          (* 0.9 $QRs#8247))) 
                      (- 1 0.9)))) 
                (min 0.3 
                  (min 0.7 
                    (min 0.2 
                      (min $PQc#8251 $QRc#8252))))) 
              (STV 1 0))))) 
      (let* 
        ( ( (: $proof2#9658 
              (⊷ Q 
                (S (S Z)) True)) (synthesize (: $proof2#9658 (⊷ Q (S (S Z)) True)) kb rb Z))) 
        (: 
          (IDIBase P2 $proof2#9658) 
          (≞ 
            (→ P Q) 
            (ETV 
              (:: 
                (S (S Z)) ∅) 
              (STV 1 0.5))))) 
      (: 
        (IDIBase P7 Q7) 
        (≞ 
          (→ P Q) 
          (ETV 
            (:: 
              (S (S (S (S (S (S (S Z))))))) ∅) 
            (STV 1 0.5)))) 
      (: 
        (IDIBase P2 Q2) 
        (≞ 
          (→ P Q) 
          (ETV 
            (:: 
              (S (S Z)) ∅) 
            (STV 0 0.5)))) 
      (let* 
        ( ( (: $proof2#10369 
              (⊷ Q 
                (S (S (S (S (S (S (S Z))))))) False)) (synthesize (: $proof2#10369 (⊷ Q (S (S (S (S (S (S (S Z))))))) False)) kb rb Z))) 
        (: 
          (IDIBase P7 $proof2#10369) 
          (≞ 
            (→ P Q) 
            (ETV 
              (:: 
                (S (S (S (S (S (S (S Z))))))) ∅) 
              (STV 0 0.5)))))))

</span>[

;<h3 id="DEPENDENT-TYPES.DEDUCTIONIMPLICATIONDIRECTINTRODUCTIONDTLTEST.04"
>;; DEPENDENT-TYPES.DEDUCTIONIMPLICATIONDIRECTINTRODUCTIONDTLTEST.04</h3>
; 
; EVAL TEST
; took 0.844 secs. (844.04 milliseconds) 

  !(assertEqualToResult 
    (synthesize 
      (: $proof 
        (≞ 
          (→ P Q) $etv)) kb rb 
      (fromNumber 1)) 
    ( (let* 
        ( ( (: $proof2#6435 
              (⊷ Q 
                (S (S Z)) True)) (synthesize (: $proof2#6435 (⊷ Q (S (S Z)) True)) kb rb Z)) 
          ( (: $proof3#6436 
              (≞ 
                (→ P Q) 
                (ETV 
                  (:: $h#6441 $t#6442) 
                  (STV $s#6443 $y#6444)))) (synthesize (: $proof3#6436 (≞ (→ P Q) (ETV (:: $h#6441 $t#6442) (STV $s#6443 $y#6444)))) kb rb Z)) 
          ( (: $proof4#6437 
              (⍃ $h#6441 
                (S (S Z)))) (synthesize (: $proof4#6437 (⍃ $h#6441 (S (S Z)))) kb rb Z))) 
        (: 
          (IDIRecursive P2 $proof2#6435 $proof3#6436 $proof4#6437) 
          (≞ 
            (→ P Q) 
            (ETV 
              (:: 
                (S (S Z)) 
                (:: $h#6441 $t#6442)) 
              (STV 
                (/ 
                  (+ 
                    (* $s#6443 
                      (if 
                        (<= 
                          (if 
                            (< 
                              (- 1.0 $y#6444) 0) 
                            (* -1 
                              (- 1.0 $y#6444)) 
                            (- 1.0 $y#6444)) 1.0e-9) 
                        (max-count) 
                        (/ 
                          (* $y#6444 
                            (lookahead)) 
                          (- 1.0 $y#6444)))) 1) 
                  (+ 
                    (if 
                      (<= 
                        (if 
                          (< 
                            (- 1.0 $y#6444) 0) 
                          (* -1 
                            (- 1.0 $y#6444)) 
                          (- 1.0 $y#6444)) 1.0e-9) 
                      (max-count) 
                      (/ 
                        (* $y#6444 
                          (lookahead)) 
                        (- 1.0 $y#6444))) 1)) 
                (/ 
                  (+ 
                    (if 
                      (<= 
                        (if 
                          (< 
                            (- 1.0 $y#6444) 0) 
                          (* -1 
                            (- 1.0 $y#6444)) 
                          (- 1.0 $y#6444)) 1.0e-9) 
                      (max-count) 
                      (/ 
                        (* $y#6444 
                          (lookahead)) 
                        (- 1.0 $y#6444))) 1) 
                  (+ 
                    (+ 
                      (if 
                        (<= 
                          (if 
                            (< 
                              (- 1.0 $y#6444) 0) 
                            (* -1 
                              (- 1.0 $y#6444)) 
                            (- 1.0 $y#6444)) 1.0e-9) 
                        (max-count) 
                        (/ 
                          (* $y#6444 
                            (lookahead)) 
                          (- 1.0 $y#6444))) 1) 1.0))))))) 
      (let* 
        ( ( (: $proof3#6436 
              (≞ 
                (→ P Q) 
                (ETV 
                  (:: $h#6441 $t#6442) 
                  (STV $s#6443 $y#6444)))) (synthesize (: $proof3#6436 (≞ (→ P Q) (ETV (:: $h#6441 $t#6442) (STV $s#6443 $y#6444)))) kb rb Z)) ((: $proof4#6437 (⍃ $h#6441 (S (S (S (S (S (S (S Z))))))))) (synthesize (: $proof4#6437 (⍃ $h#6441 (S (S (S (S (S (S (S Z))))))))) kb rb Z))) 
        (: 
          (IDIRecursive P7 Q7 $proof3#6436 $proof4#6437) 
          (≞ 
            (→ P Q) 
            (ETV 
              (:: 
                (S (S (S (S (S (S (S Z))))))) 
                (:: $h#6441 $t#6442)) 
              (STV 
                (/ 
                  (+ 
                    (* $s#6443 
                      (if 
                        (<= 
                          (if 
                            (< 
                              (- 1.0 $y#6444) 0) 
                            (* -1 
                              (- 1.0 $y#6444)) 
                            (- 1.0 $y#6444)) 1.0e-9) 
                        (max-count) 
                        (/ 
                          (* $y#6444 
                            (lookahead)) 
                          (- 1.0 $y#6444)))) 1) 
                  (+ 
                    (if 
                      (<= 
                        (if 
                          (< 
                            (- 1.0 $y#6444) 0) 
                          (* -1 
                            (- 1.0 $y#6444)) 
                          (- 1.0 $y#6444)) 1.0e-9) 
                      (max-count) 
                      (/ 
                        (* $y#6444 
                          (lookahead)) 
                        (- 1.0 $y#6444))) 1)) 
                (/ 
                  (+ 
                    (if 
                      (<= 
                        (if 
                          (< 
                            (- 1.0 $y#6444) 0) 
                          (* -1 
                            (- 1.0 $y#6444)) 
                          (- 1.0 $y#6444)) 1.0e-9) 
                      (max-count) 
                      (/ 
                        (* $y#6444 
                          (lookahead)) 
                        (- 1.0 $y#6444))) 1) 
                  (+ 
                    (+ 
                      (if 
                        (<= 
                          (if 
                            (< 
                              (- 1.0 $y#6444) 0) 
                            (* -1 
                              (- 1.0 $y#6444)) 
                            (- 1.0 $y#6444)) 1.0e-9) 
                        (max-count) 
                        (/ 
                          (* $y#6444 
                            (lookahead)) 
                          (- 1.0 $y#6444))) 1) 1.0))))))) 
      (let* 
        ( ( (: $proof3#7166 
              (≞ 
                (→ P Q) 
                (ETV 
                  (:: $h#7171 $t#7172) 
                  (STV $s#7173 $PQc#7174)))) (synthesize (: $proof3#7166 (≞ (→ P Q) (ETV (:: $h#7171 $t#7172) (STV $s#7173 $PQc#7174)))) kb rb Z)) ((: $proof4#7167 (⍃ $h#7171 (S (S Z)))) (synthesize (: $proof4#7167 (⍃ $h#7171 (S (S Z)))) kb rb Z))) 
        (: 
          (IDIRecursive P2 Q2 $proof3#7166 $proof4#7167) 
          (≞ 
            (→ P Q) 
            (ETV 
              (:: 
                (S (S Z)) 
                (:: $h#7171 $t#7172)) 
              (STV 
                (/ 
                  (* $s#7173 
                    (if 
                      (<= 
                        (if 
                          (< 
                            (- 1.0 $PQc#7174) 0) 
                          (* -1 
                            (- 1.0 $PQc#7174)) 
                          (- 1.0 $PQc#7174)) 1.0e-9) 
                      (max-count) 
                      (/ 
                        (* $PQc#7174 
                          (lookahead)) 
                        (- 1.0 $PQc#7174)))) 
                  (+ 
                    (if 
                      (<= 
                        (if 
                          (< 
                            (- 1.0 $PQc#7174) 0) 
                          (* -1 
                            (- 1.0 $PQc#7174)) 
                          (- 1.0 $PQc#7174)) 1.0e-9) 
                      (max-count) 
                      (/ 
                        (* $PQc#7174 
                          (lookahead)) 
                        (- 1.0 $PQc#7174))) 1)) 
                (/ 
                  (+ 
                    (if 
                      (<= 
                        (if 
                          (< 
                            (- 1.0 $PQc#7174) 0) 
                          (* -1 
                            (- 1.0 $PQc#7174)) 
                          (- 1.0 $PQc#7174)) 1.0e-9) 
                      (max-count) 
                      (/ 
                        (* $PQc#7174 
                          (lookahead)) 
                        (- 1.0 $PQc#7174))) 1) 
                  (+ 
                    (+ 
                      (if 
                        (<= 
                          (if 
                            (< 
                              (- 1.0 $PQc#7174) 0) 
                            (* -1 
                              (- 1.0 $PQc#7174)) 
                            (- 1.0 $PQc#7174)) 1.0e-9) 
                        (max-count) 
                        (/ 
                          (* $PQc#7174 
                            (lookahead)) 
                          (- 1.0 $PQc#7174))) 1) 1.0))))))) 
      (let* 
        ( ( (: $proof2#7165 
              (⊷ Q 
                (S (S (S (S (S (S (S Z))))))) False)) (synthesize (: $proof2#7165 (⊷ Q (S (S (S (S (S (S (S Z))))))) False)) kb rb Z)) 
          ( (: $proof3#7166 
              (≞ 
                (→ P Q) 
                (ETV 
                  (:: $h#7171 $t#7172) 
                  (STV $s#7173 $PQc#7174)))) (synthesize (: $proof3#7166 (≞ (→ P Q) (ETV (:: $h#7171 $t#7172) (STV $s#7173 $PQc#7174)))) kb rb Z)) 
          ( (: $proof4#7167 
              (⍃ $h#7171 
                (S (S (S (S (S (S (S Z))))))))) (synthesize (: $proof4#7167 (⍃ $h#7171 (S (S (S (S (S (S (S Z))))))))) kb rb Z))) 
        (: 
          (IDIRecursive P7 $proof2#7165 $proof3#7166 $proof4#7167) 
          (≞ 
            (→ P Q) 
            (ETV 
              (:: 
                (S (S (S (S (S (S (S Z))))))) 
                (:: $h#7171 $t#7172)) 
              (STV 
                (/ 
                  (* $s#7173 
                    (if 
                      (<= 
                        (if 
                          (< 
                            (- 1.0 $PQc#7174) 0) 
                          (* -1 
                            (- 1.0 $PQc#7174)) 
                          (- 1.0 $PQc#7174)) 1.0e-9) 
                      (max-count) 
                      (/ 
                        (* $PQc#7174 
                          (lookahead)) 
                        (- 1.0 $PQc#7174)))) 
                  (+ 
                    (if 
                      (<= 
                        (if 
                          (< 
                            (- 1.0 $PQc#7174) 0) 
                          (* -1 
                            (- 1.0 $PQc#7174)) 
                          (- 1.0 $PQc#7174)) 1.0e-9) 
                      (max-count) 
                      (/ 
                        (* $PQc#7174 
                          (lookahead)) 
                        (- 1.0 $PQc#7174))) 1)) 
                (/ 
                  (+ 
                    (if 
                      (<= 
                        (if 
                          (< 
                            (- 1.0 $PQc#7174) 0) 
                          (* -1 
                            (- 1.0 $PQc#7174)) 
                          (- 1.0 $PQc#7174)) 1.0e-9) 
                      (max-count) 
                      (/ 
                        (* $PQc#7174 
                          (lookahead)) 
                        (- 1.0 $PQc#7174))) 1) 
                  (+ 
                    (+ 
                      (if 
                        (<= 
                          (if 
                            (< 
                              (- 1.0 $PQc#7174) 0) 
                            (* -1 
                              (- 1.0 $PQc#7174)) 
                            (- 1.0 $PQc#7174)) 1.0e-9) 
                        (max-count) 
                        (/ 
                          (* $PQc#7174 
                            (lookahead)) 
                          (- 1.0 $PQc#7174))) 1) 1.0))))))) 
      (let* 
        ( ( (: $proof#7948 
              (≞ 
                (→ P Q) 
                (ETV $evidence#7858 $etv))) (synthesize (: $proof#7948 (≞ (→ P Q) (ETV $evidence#7858 $etv))) kb rb Z))) 
        (: 
          (EvidenceElimination $proof#7948) 
          (≞ 
            (→ P Q) $etv))) 
      (let* 
        ( ( (: $proof4#8239 
              (≞ 
                (→ P P) 
                (STV $ABs#8245 $PQc#8251))) (synthesize (: $proof4#8239 (≞ (→ P P) (STV $ABs#8245 $PQc#8251))) kb rb Z)) ((: $proof5#8240 (≞ (→ P Q) (STV $QRs#8247 $QRc#8252))) (synthesize (: $proof5#8240 (≞ (→ P Q) (STV $QRs#8247 $QRc#8252))) kb rb Z))) 
        (: 
          (Deduction Pm Pm Qm $proof4#8239 $proof5#8240) 
          (≞ 
            (→ P Q) 
            (if 
              (and 
                (and 
                  (< 0 0.2) 
                  (and 
                    (<= 
                      (if 
                        (> 0 
                          (if 
                            (< 1 
                              (/ 
                                (- 
                                  (+ 0.2 0.2) 1) 0.2)) 1 
                            (/ 
                              (- 
                                (+ 0.2 0.2) 1) 0.2))) 0 
                        (if 
                          (< 1 
                            (/ 
                              (- 
                                (+ 0.2 0.2) 1) 0.2)) 1 
                          (/ 
                            (- 
                              (+ 0.2 0.2) 1) 0.2))) $ABs#8245) 
                    (<= $ABs#8245 
                      (if 
                        (> 0 
                          (if 
                            (< 1 
                              (/ 0.2 0.2)) 1 
                            (/ 0.2 0.2))) 0 
                        (if 
                          (< 1 
                            (/ 0.2 0.2)) 1 
                          (/ 0.2 0.2)))))) 
                (and 
                  (< 0 0.2) 
                  (and 
                    (<= 
                      (if 
                        (> 0 
                          (if 
                            (< 1 
                              (/ 
                                (- 
                                  (+ 0.2 0.3) 1) 0.2)) 1 
                            (/ 
                              (- 
                                (+ 0.2 0.3) 1) 0.2))) 0 
                        (if 
                          (< 1 
                            (/ 
                              (- 
                                (+ 0.2 0.3) 1) 0.2)) 1 
                          (/ 
                            (- 
                              (+ 0.2 0.3) 1) 0.2))) $QRs#8247) 
                    (<= $QRs#8247 
                      (if 
                        (> 0 
                          (if 
                            (< 1 
                              (/ 0.3 0.2)) 1 
                            (/ 0.3 0.2))) 0 
                        (if 
                          (< 1 
                            (/ 0.3 0.2)) 1 
                          (/ 0.3 0.2))))))) 
              (STV 
                (if 
                  (< 0.9999 0.2) 0.3 
                  (+ 
                    (* $ABs#8245 $QRs#8247) 
                    (/ 
                      (* 
                        (- 1 $ABs#8245) 
                        (- 0.3 
                          (* 0.2 $QRs#8247))) 
                      (- 1 0.2)))) 
                (min 0.3 
                  (min 0.3 
                    (min 0.2 
                      (min $PQc#8251 $QRc#8252))))) 
              (STV 1 0))))) 
      (let* 
        ( ( (: $proof4#8239 
              (≞ 
                (→ P Q) 
                (STV $ABs#8245 $PQc#8251))) (synthesize (: $proof4#8239 (≞ (→ P Q) (STV $ABs#8245 $PQc#8251))) kb rb Z)) ((: $proof5#8240 (≞ (→ Q Q) (STV $QRs#8247 $QRc#8252))) (synthesize (: $proof5#8240 (≞ (→ Q Q) (STV $QRs#8247 $QRc#8252))) kb rb Z))) 
        (: 
          (Deduction Pm Qm Qm $proof4#8239 $proof5#8240) 
          (≞ 
            (→ P Q) 
            (if 
              (and 
                (and 
                  (< 0 0.2) 
                  (and 
                    (<= 
                      (if 
                        (> 0 
                          (if 
                            (< 1 
                              (/ 
                                (- 
                                  (+ 0.2 0.3) 1) 0.2)) 1 
                            (/ 
                              (- 
                                (+ 0.2 0.3) 1) 0.2))) 0 
                        (if 
                          (< 1 
                            (/ 
                              (- 
                                (+ 0.2 0.3) 1) 0.2)) 1 
                          (/ 
                            (- 
                              (+ 0.2 0.3) 1) 0.2))) $ABs#8245) 
                    (<= $ABs#8245 
                      (if 
                        (> 0 
                          (if 
                            (< 1 
                              (/ 0.3 0.2)) 1 
                            (/ 0.3 0.2))) 0 
                        (if 
                          (< 1 
                            (/ 0.3 0.2)) 1 
                          (/ 0.3 0.2)))))) 
                (and 
                  (< 0 0.3) 
                  (and 
                    (<= 
                      (if 
                        (> 0 
                          (if 
                            (< 1 
                              (/ 
                                (- 
                                  (+ 0.3 0.3) 1) 0.3)) 1 
                            (/ 
                              (- 
                                (+ 0.3 0.3) 1) 0.3))) 0 
                        (if 
                          (< 1 
                            (/ 
                              (- 
                                (+ 0.3 0.3) 1) 0.3)) 1 
                          (/ 
                            (- 
                              (+ 0.3 0.3) 1) 0.3))) $QRs#8247) 
                    (<= $QRs#8247 
                      (if 
                        (> 0 
                          (if 
                            (< 1 
                              (/ 0.3 0.3)) 1 
                            (/ 0.3 0.3))) 0 
                        (if 
                          (< 1 
                            (/ 0.3 0.3)) 1 
                          (/ 0.3 0.3))))))) 
              (STV 
                (if 
                  (< 0.9999 0.3) 0.3 
                  (+ 
                    (* $ABs#8245 $QRs#8247) 
                    (/ 
                      (* 
                        (- 1 $ABs#8245) 
                        (- 0.3 
                          (* 0.3 $QRs#8247))) 
                      (- 1 0.3)))) 
                (min 0.3 
                  (min 0.2 
                    (min 0.2 
                      (min $PQc#8251 $QRc#8252))))) 
              (STV 1 0))))) 
      (let* 
        ( ( (: $proof4#8239 
              (≞ 
                (→ P R) 
                (STV $ABs#8245 $PQc#8251))) (synthesize (: $proof4#8239 (≞ (→ P R) (STV $ABs#8245 $PQc#8251))) kb rb Z)) ((: $proof5#8240 (≞ (→ R Q) (STV $QRs#8247 $QRc#8252))) (synthesize (: $proof5#8240 (≞ (→ R Q) (STV $QRs#8247 $QRc#8252))) kb rb Z))) 
        (: 
          (Deduction Pm Rm Qm $proof4#8239 $proof5#8240) 
          (≞ 
            (→ P Q) 
            (if 
              (and 
                (and 
                  (< 0 0.2) 
                  (and 
                    (<= 
                      (if 
                        (> 0 
                          (if 
                            (< 1 
                              (/ 
                                (- 
                                  (+ 0.2 0.4) 1) 0.2)) 1 
                            (/ 
                              (- 
                                (+ 0.2 0.4) 1) 0.2))) 0 
                        (if 
                          (< 1 
                            (/ 
                              (- 
                                (+ 0.2 0.4) 1) 0.2)) 1 
                          (/ 
                            (- 
                              (+ 0.2 0.4) 1) 0.2))) $ABs#8245) 
                    (<= $ABs#8245 
                      (if 
                        (> 0 
                          (if 
                            (< 1 
                              (/ 0.4 0.2)) 1 
                            (/ 0.4 0.2))) 0 
                        (if 
                          (< 1 
                            (/ 0.4 0.2)) 1 
                          (/ 0.4 0.2)))))) 
                (and 
                  (< 0 0.4) 
                  (and 
                    (<= 
                      (if 
                        (> 0 
                          (if 
                            (< 1 
                              (/ 
                                (- 
                                  (+ 0.4 0.3) 1) 0.4)) 1 
                            (/ 
                              (- 
                                (+ 0.4 0.3) 1) 0.4))) 0 
                        (if 
                          (< 1 
                            (/ 
                              (- 
                                (+ 0.4 0.3) 1) 0.4)) 1 
                          (/ 
                            (- 
                              (+ 0.4 0.3) 1) 0.4))) $QRs#8247) 
                    (<= $QRs#8247 
                      (if 
                        (> 0 
                          (if 
                            (< 1 
                              (/ 0.3 0.4)) 1 
                            (/ 0.3 0.4))) 0 
                        (if 
                          (< 1 
                            (/ 0.3 0.4)) 1 
                          (/ 0.3 0.4))))))) 
              (STV 
                (if 
                  (< 0.9999 0.4) 0.3 
                  (+ 
                    (* $ABs#8245 $QRs#8247) 
                    (/ 
                      (* 
                        (- 1 $ABs#8245) 
                        (- 0.3 
                          (* 0.4 $QRs#8247))) 
                      (- 1 0.4)))) 
                (min 0.3 
                  (min 0.1 
                    (min 0.2 
                      (min $PQc#8251 $QRc#8252))))) 
              (STV 1 0))))) 
      (let* 
        ( ( (: $proof4#8239 
              (≞ 
                (→ P 
                  (→ Q R)) 
                (STV $ABs#8245 $PQc#8251))) (synthesize (: $proof4#8239 (≞ (→ P (→ Q R)) (STV $ABs#8245 $PQc#8251))) kb rb Z)) ((: $proof5#8240 (≞ (→ (→ Q R) Q) (STV $QRs#8247 $QRc#8252))) (synthesize (: $proof5#8240 (≞ (→ (→ Q R) Q) (STV $QRs#8247 $QRc#8252))) kb rb Z))) 
        (: 
          (Deduction Pm QRm Qm $proof4#8239 $proof5#8240) 
          (≞ 
            (→ P Q) 
            (if 
              (and 
                (and 
                  (< 0 0.2) 
                  (and 
                    (<= 
                      (if 
                        (> 0 
                          (if 
                            (< 1 
                              (/ 
                                (- 
                                  (+ 0.2 0.9) 1) 0.2)) 1 
                            (/ 
                              (- 
                                (+ 0.2 0.9) 1) 0.2))) 0 
                        (if 
                          (< 1 
                            (/ 
                              (- 
                                (+ 0.2 0.9) 1) 0.2)) 1 
                          (/ 
                            (- 
                              (+ 0.2 0.9) 1) 0.2))) $ABs#8245) 
                    (<= $ABs#8245 
                      (if 
                        (> 0 
                          (if 
                            (< 1 
                              (/ 0.9 0.2)) 1 
                            (/ 0.9 0.2))) 0 
                        (if 
                          (< 1 
                            (/ 0.9 0.2)) 1 
                          (/ 0.9 0.2)))))) 
                (and 
                  (< 0 0.9) 
                  (and 
                    (<= 
                      (if 
                        (> 0 
                          (if 
                            (< 1 
                              (/ 
                                (- 
                                  (+ 0.9 0.3) 1) 0.9)) 1 
                            (/ 
                              (- 
                                (+ 0.9 0.3) 1) 0.9))) 0 
                        (if 
                          (< 1 
                            (/ 
                              (- 
                                (+ 0.9 0.3) 1) 0.9)) 1 
                          (/ 
                            (- 
                              (+ 0.9 0.3) 1) 0.9))) $QRs#8247) 
                    (<= $QRs#8247 
                      (if 
                        (> 0 
                          (if 
                            (< 1 
                              (/ 0.3 0.9)) 1 
                            (/ 0.3 0.9))) 0 
                        (if 
                          (< 1 
                            (/ 0.3 0.9)) 1 
                          (/ 0.3 0.9))))))) 
              (STV 
                (if 
                  (< 0.9999 0.9) 0.3 
                  (+ 
                    (* $ABs#8245 $QRs#8247) 
                    (/ 
                      (* 
                        (- 1 $ABs#8245) 
                        (- 0.3 
                          (* 0.9 $QRs#8247))) 
                      (- 1 0.9)))) 
                (min 0.3 
                  (min 0.7 
                    (min 0.2 
                      (min $PQc#8251 $QRc#8252))))) 
              (STV 1 0))))) 
      (let* 
        ( ( (: $proof2#9658 
              (⊷ Q 
                (S (S Z)) True)) (synthesize (: $proof2#9658 (⊷ Q (S (S Z)) True)) kb rb Z))) 
        (: 
          (IDIBase P2 $proof2#9658) 
          (≞ 
            (→ P Q) 
            (ETV 
              (:: 
                (S (S Z)) ∅) 
              (STV 1 0.5))))) 
      (: 
        (IDIBase P7 Q7) 
        (≞ 
          (→ P Q) 
          (ETV 
            (:: 
              (S (S (S (S (S (S (S Z))))))) ∅) 
            (STV 1 0.5)))) 
      (: 
        (IDIBase P2 Q2) 
        (≞ 
          (→ P Q) 
          (ETV 
            (:: 
              (S (S Z)) ∅) 
            (STV 0 0.5)))) 
      (let* 
        ( ( (: $proof2#10369 
              (⊷ Q 
                (S (S (S (S (S (S (S Z))))))) False)) (synthesize (: $proof2#10369 (⊷ Q (S (S (S (S (S (S (S Z))))))) False)) kb rb Z))) 
        (: 
          (IDIBase P7 $proof2#10369) 
          (≞ 
            (→ P Q) 
            (ETV 
              (:: 
                (S (S (S (S (S (S (S Z))))))) ∅) 
              (STV 0 0.5)))))))

<span class="ansi36"
>  (loonit_success  
    (equal_enough_for_test  
      ( (: 
          (IDIBase P2 Q2) 
          (≞ 
            (→ P Q) 
            (ETV 
              (:: 
                (S (S Z)) ∅) 
              (STV 0 0.5)))) 
        (: 
          (IDIBase P2 Q2) 
          (≞ 
            (→ P Q) 
            (ETV 
              (:: 
                (S (S Z)) ∅) 
              (STV 0 0.5)))) 
        (: 
          (IDIBase P7 Q7) 
          (≞ 
            (→ P Q) 
            (ETV 
              (:: 
                (S (S (S (S (S (S (S Z))))))) ∅) 
              (STV 1 0.5)))) 
        (: 
          (IDIBase P7 Q7) 
          (≞ 
            (→ P Q) 
            (ETV 
              (:: 
                (S (S (S (S (S (S (S Z))))))) ∅) 
              (STV 1 0.5))))) 
      ( (let* 
          ( ( (: $_43244 
                (⊷ Q 
                  (S (S Z)) True)) (synthesize (: $_43244 (⊷ Q (S (S Z)) True)) kb rb Z)) 
            ( (: $_43436 
                (≞ 
                  (→ P Q) 
                  (ETV 
                    (:: $_43514 $_43532) 
                    (STV $_43562 $_43580)))) (synthesize (: $_43436 (≞ (→ P Q) (ETV (:: $_43514 $_43532) (STV $_43562 $_43580)))) kb rb Z)) 
            ( (: $_43760 
                (⍃ $_43514 
                  (S (S Z)))) (synthesize (: $_43760 (⍃ $_43514 (S (S Z)))) kb rb Z))) 
          (: 
            (IDIRecursive P2 $_43244 $_43436 $_43760) 
            (≞ 
              (→ P Q) 
              (ETV 
                (:: 
                  (S (S Z)) 
                  (:: $_43514 $_43532)) 
                (STV 
                  (/ 
                    (+ 
                      (* $_43562 
                        (if 
                          (<= 
                            (if 
                              (< 
                                (- 1.0 $_43580) 0) 
                              (* -1 
                                (- 1.0 $_43580)) 
                              (- 1.0 $_43580)) 1.0e-9) 
                          (max-count) 
                          (/ 
                            (* $_43580 
                              (lookahead)) 
                            (- 1.0 $_43580)))) 1) 
                    (+ 
                      (if 
                        (<= 
                          (if 
                            (< 
                              (- 1.0 $_43580) 0) 
                            (* -1 
                              (- 1.0 $_43580)) 
                            (- 1.0 $_43580)) 1.0e-9) 
                        (max-count) 
                        (/ 
                          (* $_43580 
                            (lookahead)) 
                          (- 1.0 $_43580))) 1)) 
                  (/ 
                    (+ 
                      (if 
                        (<= 
                          (if 
                            (< 
                              (- 1.0 $_43580) 0) 
                            (* -1 
                              (- 1.0 $_43580)) 
                            (- 1.0 $_43580)) 1.0e-9) 
                        (max-count) 
                        (/ 
                          (* $_43580 
                            (lookahead)) 
                          (- 1.0 $_43580))) 1) 
                    (+ 
                      (+ 
                        (if 
                          (<= 
                            (if 
                              (< 
                                (- 1.0 $_43580) 0) 
                              (* -1 
                                (- 1.0 $_43580)) 
                              (- 1.0 $_43580)) 1.0e-9) 
                          (max-count) 
                          (/ 
                            (* $_43580 
                              (lookahead)) 
                            (- 1.0 $_43580))) 1) 1.0))))))) 
        (let 
          (: $_43436 
            (≞ 
              (→ P Q) 
              (ETV 
                (:: $_43514 $_43532) 
                (STV $_43562 $_43580)))) 
          (synthesize 
            (: $_43436 
              (≞ 
                (→ P Q) 
                (ETV 
                  (:: $_43514 $_43532) 
                  (STV $_43562 $_43580)))) kb rb Z) 
          (let 
            (: $_43760 
              (⍃ $_43514 
                (S (S (S (S (S (S (S Z))))))))) 
            (synthesize 
              (: $_43760 
                (⍃ $_43514 
                  (S (S (S (S (S (S (S Z))))))))) kb rb Z) 
            (: 
              (IDIRecursive P7 Q7 $_43436 $_43760) 
              (≞ 
                (→ P Q) 
                (ETV 
                  (:: 
                    (S (S (S (S (S (S (S Z))))))) 
                    (:: $_43514 $_43532)) 
                  (STV 
                    (/ 
                      (+ 
                        (* $_43562 
                          (if 
                            (<= 
                              (if 
                                (< 
                                  (- 1.0 $_43580) 0) 
                                (* -1 
                                  (- 1.0 $_43580)) 
                                (- 1.0 $_43580)) 1.0e-9) 
                            (max-count) 
                            (/ 
                              (* $_43580 
                                (lookahead)) 
                              (- 1.0 $_43580)))) 1) 
                      (+ 
                        (if 
                          (<= 
                            (if 
                              (< 
                                (- 1.0 $_43580) 0) 
                              (* -1 
                                (- 1.0 $_43580)) 
                              (- 1.0 $_43580)) 1.0e-9) 
                          (max-count) 
                          (/ 
                            (* $_43580 
                              (lookahead)) 
                            (- 1.0 $_43580))) 1)) 
                    (/ 
                      (+ 
                        (if 
                          (<= 
                            (if 
                              (< 
                                (- 1.0 $_43580) 0) 
                              (* -1 
                                (- 1.0 $_43580)) 
                              (- 1.0 $_43580)) 1.0e-9) 
                          (max-count) 
                          (/ 
                            (* $_43580 
                              (lookahead)) 
                            (- 1.0 $_43580))) 1) 
                      (+ 
                        (+ 
                          (if 
                            (<= 
                              (if 
                                (< 
                                  (- 1.0 $_43580) 0) 
                                (* -1 
                                  (- 1.0 $_43580)) 
                                (- 1.0 $_43580)) 1.0e-9) 
                            (max-count) 
                            (/ 
                              (* $_43580 
                                (lookahead)) 
                              (- 1.0 $_43580))) 1) 1.0)))))))) 
        (let 
          (: $_47024 
            (≞ 
              (→ P Q) 
              (ETV 
                (:: $_47102 $_47120) 
                (STV $_47150 $_47168)))) 
          (synthesize 
            (: $_47024 
              (≞ 
                (→ P Q) 
                (ETV 
                  (:: $_47102 $_47120) 
                  (STV $_47150 $_47168)))) kb rb Z) 
          (let 
            (: $_47348 
              (⍃ $_47102 
                (S (S Z)))) 
            (synthesize 
              (: $_47348 
                (⍃ $_47102 
                  (S (S Z)))) kb rb Z) 
            (: 
              (IDIRecursive P2 Q2 $_47024 $_47348) 
              (≞ 
                (→ P Q) 
                (ETV 
                  (:: 
                    (S (S Z)) 
                    (:: $_47102 $_47120)) 
                  (STV 
                    (/ 
                      (* $_47150 
                        (if 
                          (<= 
                            (if 
                              (< 
                                (- 1.0 $_47168) 0) 
                              (* -1 
                                (- 1.0 $_47168)) 
                              (- 1.0 $_47168)) 1.0e-9) 
                          (max-count) 
                          (/ 
                            (* $_47168 
                              (lookahead)) 
                            (- 1.0 $_47168)))) 
                      (+ 
                        (if 
                          (<= 
                            (if 
                              (< 
                                (- 1.0 $_47168) 0) 
                              (* -1 
                                (- 1.0 $_47168)) 
                              (- 1.0 $_47168)) 1.0e-9) 
                          (max-count) 
                          (/ 
                            (* $_47168 
                              (lookahead)) 
                            (- 1.0 $_47168))) 1)) 
                    (/ 
                      (+ 
                        (if 
                          (<= 
                            (if 
                              (< 
                                (- 1.0 $_47168) 0) 
                              (* -1 
                                (- 1.0 $_47168)) 
                              (- 1.0 $_47168)) 1.0e-9) 
                          (max-count) 
                          (/ 
                            (* $_47168 
                              (lookahead)) 
                            (- 1.0 $_47168))) 1) 
                      (+ 
                        (+ 
                          (if 
                            (<= 
                              (if 
                                (< 
                                  (- 1.0 $_47168) 0) 
                                (* -1 
                                  (- 1.0 $_47168)) 
                                (- 1.0 $_47168)) 1.0e-9) 
                            (max-count) 
                            (/ 
                              (* $_47168 
                                (lookahead)) 
                              (- 1.0 $_47168))) 1) 1.0)))))))) 
        (let 
          (: $_48746 
            (⊷ Q 
              (S (S (S (S (S (S (S Z))))))) False)) 
          (synthesize 
            (: $_48746 
              (⊷ Q 
                (S (S (S (S (S (S (S Z))))))) False)) kb rb Z) 
          (let 
            (: $_47024 
              (≞ 
                (→ P Q) 
                (ETV 
                  (:: $_47102 $_47120) 
                  (STV $_47150 $_47168)))) 
            (synthesize 
              (: $_47024 
                (≞ 
                  (→ P Q) 
                  (ETV 
                    (:: $_47102 $_47120) 
                    (STV $_47150 $_47168)))) kb rb Z) 
            (let 
              (: $_47348 
                (⍃ $_47102 
                  (S (S (S (S (S (S (S Z))))))))) 
              (synthesize 
                (: $_47348 
                  (⍃ $_47102 
                    (S (S (S (S (S (S (S Z))))))))) kb rb Z) 
              (: 
                (IDIRecursive P7 $_48746 $_47024 $_47348) 
                (≞ 
                  (→ P Q) 
                  (ETV 
                    (:: 
                      (S (S (S (S (S (S (S Z))))))) 
                      (:: $_47102 $_47120)) 
                    (STV 
                      (/ 
                        (* $_47150 
                          (if 
                            (<= 
                              (if 
                                (< 
                                  (- 1.0 $_47168) 0) 
                                (* -1 
                                  (- 1.0 $_47168)) 
                                (- 1.0 $_47168)) 1.0e-9) 
                            (max-count) 
                            (/ 
                              (* $_47168 
                                (lookahead)) 
                              (- 1.0 $_47168)))) 
                        (+ 
                          (if 
                            (<= 
                              (if 
                                (< 
                                  (- 1.0 $_47168) 0) 
                                (* -1 
                                  (- 1.0 $_47168)) 
                                (- 1.0 $_47168)) 1.0e-9) 
                            (max-count) 
                            (/ 
                              (* $_47168 
                                (lookahead)) 
                              (- 1.0 $_47168))) 1)) 
                      (/ 
                        (+ 
                          (if 
                            (<= 
                              (if 
                                (< 
                                  (- 1.0 $_47168) 0) 
                                (* -1 
                                  (- 1.0 $_47168)) 
                                (- 1.0 $_47168)) 1.0e-9) 
                            (max-count) 
                            (/ 
                              (* $_47168 
                                (lookahead)) 
                              (- 1.0 $_47168))) 1) 
                        (+ 
                          (+ 
                            (if 
                              (<= 
                                (if 
                                  (< 
                                    (- 1.0 $_47168) 0) 
                                  (* -1 
                                    (- 1.0 $_47168)) 
                                  (- 1.0 $_47168)) 1.0e-9) 
                              (max-count) 
                              (/ 
                                (* $_47168 
                                  (lookahead)) 
                                (- 1.0 $_47168))) 1) 1.0))))))))) 
        (let 
          (: $_50888 
            (≞ 
              (→ P Q) 
              (ETV $_50954 $_43154))) 
          (synthesize 
            (: $_50888 
              (≞ 
                (→ P Q) 
                (ETV $_50954 $_43154))) kb rb Z) 
          (: 
            (EvidenceElimination $_50888) 
            (≞ 
              (→ P Q) $_43154))) 
        (let 
          (: $_51194 
            (≞ 
              (→ P P) 
              (STV $_51260 $_51278))) 
          (synthesize 
            (: $_51194 
              (≞ 
                (→ P P) 
                (STV $_51260 $_51278))) kb rb Z) 
          (let 
            (: $_51422 
              (≞ 
                (→ P Q) 
                (STV $_51488 $_51506))) 
            (synthesize 
              (: $_51422 
                (≞ 
                  (→ P Q) 
                  (STV $_51488 $_51506))) kb rb Z) 
            (: 
              (Deduction Pm Pm Qm $_51194 $_51422) 
              (≞ 
                (→ P Q) 
                (if 
                  (and 
                    (and 
                      (< 0 0.2) 
                      (and 
                        (<= 
                          (if 
                            (> 0 
                              (if 
                                (< 1 
                                  (/ 
                                    (- 
                                      (+ 0.2 0.2) 1) 0.2)) 1 
                                (/ 
                                  (- 
                                    (+ 0.2 0.2) 1) 0.2))) 0 
                            (if 
                              (< 1 
                                (/ 
                                  (- 
                                    (+ 0.2 0.2) 1) 0.2)) 1 
                              (/ 
                                (- 
                                  (+ 0.2 0.2) 1) 0.2))) $_51260) 
                        (<= $_51260 
                          (if 
                            (> 0 
                              (if 
                                (< 1 
                                  (/ 0.2 0.2)) 1 
                                (/ 0.2 0.2))) 0 
                            (if 
                              (< 1 
                                (/ 0.2 0.2)) 1 
                              (/ 0.2 0.2)))))) 
                    (and 
                      (< 0 0.2) 
                      (and 
                        (<= 
                          (if 
                            (> 0 
                              (if 
                                (< 1 
                                  (/ 
                                    (- 
                                      (+ 0.2 0.3) 1) 0.2)) 1 
                                (/ 
                                  (- 
                                    (+ 0.2 0.3) 1) 0.2))) 0 
                            (if 
                              (< 1 
                                (/ 
                                  (- 
                                    (+ 0.2 0.3) 1) 0.2)) 1 
                              (/ 
                                (- 
                                  (+ 0.2 0.3) 1) 0.2))) $_51488) 
                        (<= $_51488 
                          (if 
                            (> 0 
                              (if 
                                (< 1 
                                  (/ 0.3 0.2)) 1 
                                (/ 0.3 0.2))) 0 
                            (if 
                              (< 1 
                                (/ 0.3 0.2)) 1 
                              (/ 0.3 0.2))))))) 
                  (STV 
                    (if 
                      (< 0.9999 0.2) 0.3 
                      (+ 
                        (* $_51260 $_51488) 
                        (/ 
                          (* 
                            (- 1 $_51260) 
                            (- 0.3 
                              (* 0.2 $_51488))) 
                          (- 1 0.2)))) 
                    (min 0.3 
                      (min 0.3 
                        (min 0.2 
                          (min $_51278 $_51506))))) 
                  (STV 1 0)))))) 
        (let 
          (: $_51194 
            (≞ 
              (→ P Q) 
              (STV $_51260 $_51278))) 
          (synthesize 
            (: $_51194 
              (≞ 
                (→ P Q) 
                (STV $_51260 $_51278))) kb rb Z) 
          (let 
            (: $_51422 
              (≞ 
                (→ Q Q) 
                (STV $_51488 $_51506))) 
            (synthesize 
              (: $_51422 
                (≞ 
                  (→ Q Q) 
                  (STV $_51488 $_51506))) kb rb Z) 
            (: 
              (Deduction Pm Qm Qm $_51194 $_51422) 
              (≞ 
                (→ P Q) 
                (if 
                  (and 
                    (and 
                      (< 0 0.2) 
                      (and 
                        (<= 
                          (if 
                            (> 0 
                              (if 
                                (< 1 
                                  (/ 
                                    (- 
                                      (+ 0.2 0.3) 1) 0.2)) 1 
                                (/ 
                                  (- 
                                    (+ 0.2 0.3) 1) 0.2))) 0 
                            (if 
                              (< 1 
                                (/ 
                                  (- 
                                    (+ 0.2 0.3) 1) 0.2)) 1 
                              (/ 
                                (- 
                                  (+ 0.2 0.3) 1) 0.2))) $_51260) 
                        (<= $_51260 
                          (if 
                            (> 0 
                              (if 
                                (< 1 
                                  (/ 0.3 0.2)) 1 
                                (/ 0.3 0.2))) 0 
                            (if 
                              (< 1 
                                (/ 0.3 0.2)) 1 
                              (/ 0.3 0.2)))))) 
                    (and 
                      (< 0 0.3) 
                      (and 
                        (<= 
                          (if 
                            (> 0 
                              (if 
                                (< 1 
                                  (/ 
                                    (- 
                                      (+ 0.3 0.3) 1) 0.3)) 1 
                                (/ 
                                  (- 
                                    (+ 0.3 0.3) 1) 0.3))) 0 
                            (if 
                              (< 1 
                                (/ 
                                  (- 
                                    (+ 0.3 0.3) 1) 0.3)) 1 
                              (/ 
                                (- 
                                  (+ 0.3 0.3) 1) 0.3))) $_51488) 
                        (<= $_51488 
                          (if 
                            (> 0 
                              (if 
                                (< 1 
                                  (/ 0.3 0.3)) 1 
                                (/ 0.3 0.3))) 0 
                            (if 
                              (< 1 
                                (/ 0.3 0.3)) 1 
                              (/ 0.3 0.3))))))) 
                  (STV 
                    (if 
                      (< 0.9999 0.3) 0.3 
                      (+ 
                        (* $_51260 $_51488) 
                        (/ 
                          (* 
                            (- 1 $_51260) 
                            (- 0.3 
                              (* 0.3 $_51488))) 
                          (- 1 0.3)))) 
                    (min 0.3 
                      (min 0.2 
                        (min 0.2 
                          (min $_51278 $_51506))))) 
                  (STV 1 0)))))) 
        (let 
          (: $_51194 
            (≞ 
              (→ P R) 
              (STV $_51260 $_51278))) 
          (synthesize 
            (: $_51194 
              (≞ 
                (→ P R) 
                (STV $_51260 $_51278))) kb rb Z) 
          (let 
            (: $_51422 
              (≞ 
                (→ R Q) 
                (STV $_51488 $_51506))) 
            (synthesize 
              (: $_51422 
                (≞ 
                  (→ R Q) 
                  (STV $_51488 $_51506))) kb rb Z) 
            (: 
              (Deduction Pm Rm Qm $_51194 $_51422) 
              (≞ 
                (→ P Q) 
                (if 
                  (and 
                    (and 
                      (< 0 0.2) 
                      (and 
                        (<= 
                          (if 
                            (> 0 
                              (if 
                                (< 1 
                                  (/ 
                                    (- 
                                      (+ 0.2 0.4) 1) 0.2)) 1 
                                (/ 
                                  (- 
                                    (+ 0.2 0.4) 1) 0.2))) 0 
                            (if 
                              (< 1 
                                (/ 
                                  (- 
                                    (+ 0.2 0.4) 1) 0.2)) 1 
                              (/ 
                                (- 
                                  (+ 0.2 0.4) 1) 0.2))) $_51260) 
                        (<= $_51260 
                          (if 
                            (> 0 
                              (if 
                                (< 1 
                                  (/ 0.4 0.2)) 1 
                                (/ 0.4 0.2))) 0 
                            (if 
                              (< 1 
                                (/ 0.4 0.2)) 1 
                              (/ 0.4 0.2)))))) 
                    (and 
                      (< 0 0.4) 
                      (and 
                        (<= 
                          (if 
                            (> 0 
                              (if 
                                (< 1 
                                  (/ 
                                    (- 
                                      (+ 0.4 0.3) 1) 0.4)) 1 
                                (/ 
                                  (- 
                                    (+ 0.4 0.3) 1) 0.4))) 0 
                            (if 
                              (< 1 
                                (/ 
                                  (- 
                                    (+ 0.4 0.3) 1) 0.4)) 1 
                              (/ 
                                (- 
                                  (+ 0.4 0.3) 1) 0.4))) $_51488) 
                        (<= $_51488 
                          (if 
                            (> 0 
                              (if 
                                (< 1 
                                  (/ 0.3 0.4)) 1 
                                (/ 0.3 0.4))) 0 
                            (if 
                              (< 1 
                                (/ 0.3 0.4)) 1 
                              (/ 0.3 0.4))))))) 
                  (STV 
                    (if 
                      (< 0.9999 0.4) 0.3 
                      (+ 
                        (* $_51260 $_51488) 
                        (/ 
                          (* 
                            (- 1 $_51260) 
                            (- 0.3 
                              (* 0.4 $_51488))) 
                          (- 1 0.4)))) 
                    (min 0.3 
                      (min 0.1 
                        (min 0.2 
                          (min $_51278 $_51506))))) 
                  (STV 1 0)))))) 
        (let 
          (: $_51194 
            (≞ 
              (→ P 
                (→ Q R)) 
              (STV $_51260 $_51278))) 
          (synthesize 
            (: $_51194 
              (≞ 
                (→ P 
                  (→ Q R)) 
                (STV $_51260 $_51278))) kb rb Z) 
          (let 
            (: $_51422 
              (≞ 
                (→ 
                  (→ Q R) Q) 
                (STV $_51488 $_51506))) 
            (synthesize 
              (: $_51422 
                (≞ 
                  (→ 
                    (→ Q R) Q) 
                  (STV $_51488 $_51506))) kb rb Z) 
            (: 
              (Deduction Pm QRm Qm $_51194 $_51422) 
              (≞ 
                (→ P Q) 
                (if 
                  (and 
                    (and 
                      (< 0 0.2) 
                      (and 
                        (<= 
                          (if 
                            (> 0 
                              (if 
                                (< 1 
                                  (/ 
                                    (- 
                                      (+ 0.2 0.9) 1) 0.2)) 1 
                                (/ 
                                  (- 
                                    (+ 0.2 0.9) 1) 0.2))) 0 
                            (if 
                              (< 1 
                                (/ 
                                  (- 
                                    (+ 0.2 0.9) 1) 0.2)) 1 
                              (/ 
                                (- 
                                  (+ 0.2 0.9) 1) 0.2))) $_51260) 
                        (<= $_51260 
                          (if 
                            (> 0 
                              (if 
                                (< 1 
                                  (/ 0.9 0.2)) 1 
                                (/ 0.9 0.2))) 0 
                            (if 
                              (< 1 
                                (/ 0.9 0.2)) 1 
                              (/ 0.9 0.2)))))) 
                    (and 
                      (< 0 0.9) 
                      (and 
                        (<= 
                          (if 
                            (> 0 
                              (if 
                                (< 1 
                                  (/ 
                                    (- 
                                      (+ 0.9 0.3) 1) 0.9)) 1 
                                (/ 
                                  (- 
                                    (+ 0.9 0.3) 1) 0.9))) 0 
                            (if 
                              (< 1 
                                (/ 
                                  (- 
                                    (+ 0.9 0.3) 1) 0.9)) 1 
                              (/ 
                                (- 
                                  (+ 0.9 0.3) 1) 0.9))) $_51488) 
                        (<= $_51488 
                          (if 
                            (> 0 
                              (if 
                                (< 1 
                                  (/ 0.3 0.9)) 1 
                                (/ 0.3 0.9))) 0 
                            (if 
                              (< 1 
                                (/ 0.3 0.9)) 1 
                              (/ 0.3 0.9))))))) 
                  (STV 
                    (if 
                      (< 0.9999 0.9) 0.3 
                      (+ 
                        (* $_51260 $_51488) 
                        (/ 
                          (* 
                            (- 1 $_51260) 
                            (- 0.3 
                              (* 0.9 $_51488))) 
                          (- 1 0.9)))) 
                    (min 0.3 
                      (min 0.7 
                        (min 0.2 
                          (min $_51278 $_51506))))) 
                  (STV 1 0)))))) 
        (let 
          (: $_59714 
            (⊷ Q 
              (S (S Z)) True)) 
          (synthesize 
            (: $_59714 
              (⊷ Q 
                (S (S Z)) True)) kb rb Z) 
          (: 
            (IDIBase P2 $_59714) 
            (≞ 
              (→ P Q) 
              (ETV 
                (:: 
                  (S (S Z)) ∅) 
                (STV 1 0.5))))) 
        (: 
          (IDIBase P7 Q7) 
          (≞ 
            (→ P Q) 
            (ETV 
              (:: 
                (S (S (S (S (S (S (S Z))))))) ∅) 
              (STV 1 0.5)))) 
        (: 
          (IDIBase P2 Q2) 
          (≞ 
            (→ P Q) 
            (ETV 
              (:: 
                (S (S Z)) ∅) 
              (STV 0 0.5)))) 
        (let 
          (: $_60452 
            (⊷ Q 
              (S (S (S (S (S (S (S Z))))))) False)) 
          (synthesize 
            (: $_60452 
              (⊷ Q 
                (S (S (S (S (S (S (S Z))))))) False)) kb rb Z) 
          (: 
            (IDIBase P7 $_60452) 
            (≞ 
              (→ P Q) 
              (ETV 
                (:: 
                  (S (S (S (S (S (S (S Z))))))) ∅) 
                (STV 0 0.5))))))))
</span>
Deterministic: ()
()]
;;;; Output:
;;;; (: (IDIBase P2 Q2) (≞ (→ P Q) (ETV (:: (S (S Z)) ∅) (STV 0 0.5))))
;;;; (: (IDIBase P7 Q2) (≞ (→ P Q) (ETV (:: (S (S (S (S (S (S (S Z))))))) ∅) (STV 1 0.5))))
<span class="ansi38-255165009"
>;; In file as:  
</span><span class="ansi1 ansi38-255238088"
>  !=====
</span>;; To unit test case:
<span class="ansi38-013099040"
>  !(assertEqualToResult ===== 
    ("===== Prove that P→Q based on two pieces of evidence ====="))

</span>[

;<h3 id="DEPENDENT-TYPES.DEDUCTIONIMPLICATIONDIRECTINTRODUCTIONDTLTEST.05"
>;; DEPENDENT-TYPES.DEDUCTIONIMPLICATIONDIRECTINTRODUCTIONDTLTEST.05</h3>
; 
; EVAL TEST
; took 0.000025 secs. (25.24 microseconds) 

  !(assertEqualToResult ===== 
    ("===== Prove that P→Q based on two pieces of evidence ====="))

<span class="ansi31"
>  (loonit_failureR  
    (equal_enough_for_test  
      (=====) 
      ("===== Prove that P→Q based on two pieces of evidence =====")))
</span>
Deterministic: ((Error  (got  (=====)) (expected  ("===== Prove that P→Q based on two pieces of evidence ====="))))
((Error  (got  (=====)) (expected  ("===== Prove that P→Q based on two pieces of evidence ====="))))]
<span class="ansi38-255165009"
>;; In file as:  
</span><span class="ansi1 ansi38-255238088"
>  !(synthesize 
    (: $proof 
      (≞ 
        (→ P Q) $etv)) kb rb 
    (fromNumber 3))
</span>;; To unit test case:
<span class="ansi38-013099040"
>  !(assertEqualToResult 
    (synthesize 
      (: $proof 
        (≞ 
          (→ P Q) $etv)) kb rb 
      (fromNumber 3)) 
    ( (let* 
        ( ( (: $proof2#16368 
              (⊷ Q 
                (S (S Z)) True)) (synthesize (: $proof2#16368 (⊷ Q (S (S Z)) True)) kb rb (S (S Z)))) 
          ( (: $proof3#16369 
              (≞ 
                (→ P Q) 
                (ETV 
                  (:: $h#16374 $t#16375) 
                  (STV $PQs#16376 $conf#16377)))) (synthesize (: $proof3#16369 (≞ (→ P Q) (ETV (:: $h#16374 $t#16375) (STV $PQs#16376 $conf#16377)))) kb rb (S (S Z)))) 
          ( (: $proof4#16370 
              (⍃ $h#16374 
                (S (S Z)))) (synthesize (: $proof4#16370 (⍃ $h#16374 (S (S Z)))) kb rb (S (S Z))))) 
        (: 
          (IDIRecursive P2 $proof2#16368 $proof3#16369 $proof4#16370) 
          (≞ 
            (→ P Q) 
            (ETV 
              (:: 
                (S (S Z)) 
                (:: $h#16374 $t#16375)) 
              (STV 
                (/ 
                  (+ 
                    (* $PQs#16376 
                      (if 
                        (<= 
                          (if 
                            (< 
                              (- 1.0 $conf#16377) 0) 
                            (* -1 
                              (- 1.0 $conf#16377)) 
                            (- 1.0 $conf#16377)) 1.0e-9) 
                        (max-count) 
                        (/ 
                          (* $conf#16377 
                            (lookahead)) 
                          (- 1.0 $conf#16377)))) 1) 
                  (+ 
                    (if 
                      (<= 
                        (if 
                          (< 
                            (- 1.0 $conf#16377) 0) 
                          (* -1 
                            (- 1.0 $conf#16377)) 
                          (- 1.0 $conf#16377)) 1.0e-9) 
                      (max-count) 
                      (/ 
                        (* $conf#16377 
                          (lookahead)) 
                        (- 1.0 $conf#16377))) 1)) 
                (/ 
                  (+ 
                    (if 
                      (<= 
                        (if 
                          (< 
                            (- 1.0 $conf#16377) 0) 
                          (* -1 
                            (- 1.0 $conf#16377)) 
                          (- 1.0 $conf#16377)) 1.0e-9) 
                      (max-count) 
                      (/ 
                        (* $conf#16377 
                          (lookahead)) 
                        (- 1.0 $conf#16377))) 1) 
                  (+ 
                    (+ 
                      (if 
                        (<= 
                          (if 
                            (< 
                              (- 1.0 $conf#16377) 0) 
                            (* -1 
                              (- 1.0 $conf#16377)) 
                            (- 1.0 $conf#16377)) 1.0e-9) 
                        (max-count) 
                        (/ 
                          (* $conf#16377 
                            (lookahead)) 
                          (- 1.0 $conf#16377))) 1) 1.0))))))) 
      (let* 
        ( ( (: $proof4#16370 
              (⍃ 
                (S (S (S (S (S (S (S Z))))))) 
                (S (S (S (S (S (S (S Z))))))))) (synthesize (: $proof4#16370 (⍃ (S (S (S (S (S (S (S Z))))))) (S (S (S (S (S (S (S Z))))))))) kb rb (S (S Z))))) 
        (: 
          (IDIRecursive P7 Q7 
            (IDIBase P7 Q7) $proof4#16370) 
          (≞ 
            (→ P Q) 
            (ETV 
              (:: 
                (S (S (S (S (S (S (S Z))))))) 
                (:: 
                  (S (S (S (S (S (S (S Z))))))) ∅)) 
              (STV 
                (/ 
                  (+ 
                    (* 1 
                      (if 
                        (<= 
                          (if 
                            (< 
                              (- 1.0 0.5) 0) 
                            (* -1 
                              (- 1.0 0.5)) 
                            (- 1.0 0.5)) 1.0e-9) 
                        (max-count) 
                        (/ 
                          (* 0.5 
                            (lookahead)) 
                          (- 1.0 0.5)))) 1) 
                  (+ 
                    (if 
                      (<= 
                        (if 
                          (< 
                            (- 1.0 0.5) 0) 
                          (* -1 
                            (- 1.0 0.5)) 
                          (- 1.0 0.5)) 1.0e-9) 
                      (max-count) 
                      (/ 
                        (* 0.5 
                          (lookahead)) 
                        (- 1.0 0.5))) 1)) 
                (/ 
                  (+ 
                    (if 
                      (<= 
                        (if 
                          (< 
                            (- 1.0 0.5) 0) 
                          (* -1 
                            (- 1.0 0.5)) 
                          (- 1.0 0.5)) 1.0e-9) 
                      (max-count) 
                      (/ 
                        (* 0.5 
                          (lookahead)) 
                        (- 1.0 0.5))) 1) 
                  (+ 
                    (+ 
                      (if 
                        (<= 
                          (if 
                            (< 
                              (- 1.0 0.5) 0) 
                            (* -1 
                              (- 1.0 0.5)) 
                            (- 1.0 0.5)) 1.0e-9) 
                        (max-count) 
                        (/ 
                          (* 0.5 
                            (lookahead)) 
                          (- 1.0 0.5))) 1) 1.0))))))) 
      (: 
        (IDIRecursive P7 Q7 
          (IDIBase P2 Q2) 
          (SuccMonotonicity (SuccMonotonicity ZeroLTSucc))) 
        (≞ 
          (→ P Q) 
          (ETV 
            (:: 
              (S (S (S (S (S (S (S Z))))))) 
              (:: 
                (S (S Z)) ∅)) 
            (STV 0.5 0.6666666666666666)))) 
      (let* 
        ( ( (: $proof4#52079 
              (⍃ 
                (S (S (S (S (S (S (S Z))))))) 
                (S (S Z)))) (synthesize (: $proof4#52079 (⍃ (S (S (S (S (S (S (S Z))))))) (S (S Z)))) kb rb (S (S Z))))) 
        (: 
          (IDIRecursive P2 Q2 
            (IDIBase P7 Q7) $proof4#52079) 
          (≞ 
            (→ P Q) 
            (ETV 
              (:: 
                (S (S Z)) 
                (:: 
                  (S (S (S (S (S (S (S Z))))))) ∅)) 
              (STV 
                (/ 
                  (* 1 
                    (if 
                      (<= 
                        (if 
                          (< 
                            (- 1.0 0.5) 0) 
                          (* -1 
                            (- 1.0 0.5)) 
                          (- 1.0 0.5)) 1.0e-9) 
                      (max-count) 
                      (/ 
                        (* 0.5 
                          (lookahead)) 
                        (- 1.0 0.5)))) 
                  (+ 
                    (if 
                      (<= 
                        (if 
                          (< 
                            (- 1.0 0.5) 0) 
                          (* -1 
                            (- 1.0 0.5)) 
                          (- 1.0 0.5)) 1.0e-9) 
                      (max-count) 
                      (/ 
                        (* 0.5 
                          (lookahead)) 
                        (- 1.0 0.5))) 1)) 
                (/ 
                  (+ 
                    (if 
                      (<= 
                        (if 
                          (< 
                            (- 1.0 0.5) 0) 
                          (* -1 
                            (- 1.0 0.5)) 
                          (- 1.0 0.5)) 1.0e-9) 
                      (max-count) 
                      (/ 
                        (* 0.5 
                          (lookahead)) 
                        (- 1.0 0.5))) 1) 
                  (+ 
                    (+ 
                      (if 
                        (<= 
                          (if 
                            (< 
                              (- 1.0 0.5) 0) 
                            (* -1 
                              (- 1.0 0.5)) 
                            (- 1.0 0.5)) 1.0e-9) 
                        (max-count) 
                        (/ 
                          (* 0.5 
                            (lookahead)) 
                          (- 1.0 0.5))) 1) 1.0))))))) 
      (let* 
        ( ( (: $proof4#52079 
              (⍃ 
                (S (S Z)) 
                (S (S Z)))) (synthesize (: $proof4#52079 (⍃ (S (S Z)) (S (S Z)))) kb rb (S (S Z))))) 
        (: 
          (IDIRecursive P2 Q2 
            (IDIBase P2 Q2) $proof4#52079) 
          (≞ 
            (→ P Q) 
            (ETV 
              (:: 
                (S (S Z)) 
                (:: 
                  (S (S Z)) ∅)) 
              (STV 
                (/ 
                  (* 0 
                    (if 
                      (<= 
                        (if 
                          (< 
                            (- 1.0 0.5) 0) 
                          (* -1 
                            (- 1.0 0.5)) 
                          (- 1.0 0.5)) 1.0e-9) 
                      (max-count) 
                      (/ 
                        (* 0.5 
                          (lookahead)) 
                        (- 1.0 0.5)))) 
                  (+ 
                    (if 
                      (<= 
                        (if 
                          (< 
                            (- 1.0 0.5) 0) 
                          (* -1 
                            (- 1.0 0.5)) 
                          (- 1.0 0.5)) 1.0e-9) 
                      (max-count) 
                      (/ 
                        (* 0.5 
                          (lookahead)) 
                        (- 1.0 0.5))) 1)) 
                (/ 
                  (+ 
                    (if 
                      (<= 
                        (if 
                          (< 
                            (- 1.0 0.5) 0) 
                          (* -1 
                            (- 1.0 0.5)) 
                          (- 1.0 0.5)) 1.0e-9) 
                      (max-count) 
                      (/ 
                        (* 0.5 
                          (lookahead)) 
                        (- 1.0 0.5))) 1) 
                  (+ 
                    (+ 
                      (if 
                        (<= 
                          (if 
                            (< 
                              (- 1.0 0.5) 0) 
                            (* -1 
                              (- 1.0 0.5)) 
                            (- 1.0 0.5)) 1.0e-9) 
                        (max-count) 
                        (/ 
                          (* 0.5 
                            (lookahead)) 
                          (- 1.0 0.5))) 1) 1.0))))))) 
      (let* 
        ( ( (: $proof2#52077 
              (⊷ Q 
                (S (S (S (S (S (S (S Z))))))) False)) (synthesize (: $proof2#52077 (⊷ Q (S (S (S (S (S (S (S Z))))))) False)) kb rb (S (S Z)))) 
          ( (: $proof3#52078 
              (≞ 
                (→ P Q) 
                (ETV 
                  (:: $h#52083 $t#52084) 
                  (STV $PQs#52085 $y#52086)))) (synthesize (: $proof3#52078 (≞ (→ P Q) (ETV (:: $h#52083 $t#52084) (STV $PQs#52085 $y#52086)))) kb rb (S (S Z)))) 
          ( (: $proof4#52079 
              (⍃ $h#52083 
                (S (S (S (S (S (S (S Z))))))))) (synthesize (: $proof4#52079 (⍃ $h#52083 (S (S (S (S (S (S (S Z))))))))) kb rb (S (S Z))))) 
        (: 
          (IDIRecursive P7 $proof2#52077 $proof3#52078 $proof4#52079) 
          (≞ 
            (→ P Q) 
            (ETV 
              (:: 
                (S (S (S (S (S (S (S Z))))))) 
                (:: $h#52083 $t#52084)) 
              (STV 
                (/ 
                  (* $PQs#52085 
                    (if 
                      (<= 
                        (if 
                          (< 
                            (- 1.0 $y#52086) 0) 
                          (* -1 
                            (- 1.0 $y#52086)) 
                          (- 1.0 $y#52086)) 1.0e-9) 
                      (max-count) 
                      (/ 
                        (* $y#52086 
                          (lookahead)) 
                        (- 1.0 $y#52086)))) 
                  (+ 
                    (if 
                      (<= 
                        (if 
                          (< 
                            (- 1.0 $y#52086) 0) 
                          (* -1 
                            (- 1.0 $y#52086)) 
                          (- 1.0 $y#52086)) 1.0e-9) 
                      (max-count) 
                      (/ 
                        (* $y#52086 
                          (lookahead)) 
                        (- 1.0 $y#52086))) 1)) 
                (/ 
                  (+ 
                    (if 
                      (<= 
                        (if 
                          (< 
                            (- 1.0 $y#52086) 0) 
                          (* -1 
                            (- 1.0 $y#52086)) 
                          (- 1.0 $y#52086)) 1.0e-9) 
                      (max-count) 
                      (/ 
                        (* $y#52086 
                          (lookahead)) 
                        (- 1.0 $y#52086))) 1) 
                  (+ 
                    (+ 
                      (if 
                        (<= 
                          (if 
                            (< 
                              (- 1.0 $y#52086) 0) 
                            (* -1 
                              (- 1.0 $y#52086)) 
                            (- 1.0 $y#52086)) 1.0e-9) 
                        (max-count) 
                        (/ 
                          (* $y#52086 
                            (lookahead)) 
                          (- 1.0 $y#52086))) 1) 1.0))))))) 
      (: 
        (EvidenceElimination (IDIBase P7 Q7)) 
        (≞ 
          (→ P Q) 
          (STV 1 0.5))) 
      (: 
        (EvidenceElimination (IDIBase P2 Q2)) 
        (≞ 
          (→ P Q) 
          (STV 0 0.5))) 
      (: 
        (Deduction Pm Pm Qm 
          (EvidenceElimination (IDIBase P2 P2)) 
          (EvidenceElimination (IDIBase P7 Q7))) 
        (≞ 
          (→ P Q) 
          (STV 1.0 0.2))) 
      (: 
        (Deduction Pm Pm Qm 
          (EvidenceElimination (IDIBase P2 P2)) 
          (EvidenceElimination (IDIBase P2 Q2))) 
        (≞ 
          (→ P Q) 
          (STV 0.0 0.2))) 
      (: 
        (Deduction Pm Pm Qm 
          (EvidenceElimination (IDIBase P7 P7)) 
          (EvidenceElimination (IDIBase P7 Q7))) 
        (≞ 
          (→ P Q) 
          (STV 1.0 0.2))) 
      (: 
        (Deduction Pm Pm Qm 
          (EvidenceElimination (IDIBase P7 P7)) 
          (EvidenceElimination (IDIBase P2 Q2))) 
        (≞ 
          (→ P Q) 
          (STV 0.0 0.2))) 
      (: 
        (Deduction Pm Qm Qm 
          (EvidenceElimination (IDIBase P7 Q7)) 
          (EvidenceElimination (IDIBase Q7 Q7))) 
        (≞ 
          (→ P Q) 
          (STV 1.0 0.2))) 
      (: 
        (Deduction Pm Qm Qm 
          (EvidenceElimination (IDIBase P2 Q2)) 
          (EvidenceElimination (IDIBase Q7 Q7))) 
        (≞ 
          (→ P Q) 
          (STV 0.0 0.2))) 
      (let* 
        ( ( (: $proof4#111863 
              (≞ 
                (→ P R) 
                (STV $PQs#111869 $PQc#111875))) (synthesize (: $proof4#111863 (≞ (→ P R) (STV $PQs#111869 $PQc#111875))) kb rb (S (S Z)))) ((: $proof5#111864 (≞ (→ R Q) (STV $QRs#111871 $QRc#111876))) (synthesize (: $proof5#111864 (≞ (→ R Q) (STV $QRs#111871 $QRc#111876))) kb rb (S (S Z))))) 
        (: 
          (Deduction Pm Rm Qm $proof4#111863 $proof5#111864) 
          (≞ 
            (→ P Q) 
            (if 
              (and 
                (and 
                  (< 0 0.2) 
                  (and 
                    (<= 
                      (if 
                        (> 0 
                          (if 
                            (< 1 
                              (/ 
                                (- 
                                  (+ 0.2 0.4) 1) 0.2)) 1 
                            (/ 
                              (- 
                                (+ 0.2 0.4) 1) 0.2))) 0 
                        (if 
                          (< 1 
                            (/ 
                              (- 
                                (+ 0.2 0.4) 1) 0.2)) 1 
                          (/ 
                            (- 
                              (+ 0.2 0.4) 1) 0.2))) $PQs#111869) 
                    (<= $PQs#111869 
                      (if 
                        (> 0 
                          (if 
                            (< 1 
                              (/ 0.4 0.2)) 1 
                            (/ 0.4 0.2))) 0 
                        (if 
                          (< 1 
                            (/ 0.4 0.2)) 1 
                          (/ 0.4 0.2)))))) 
                (and 
                  (< 0 0.4) 
                  (and 
                    (<= 
                      (if 
                        (> 0 
                          (if 
                            (< 1 
                              (/ 
                                (- 
                                  (+ 0.4 0.3) 1) 0.4)) 1 
                            (/ 
                              (- 
                                (+ 0.4 0.3) 1) 0.4))) 0 
                        (if 
                          (< 1 
                            (/ 
                              (- 
                                (+ 0.4 0.3) 1) 0.4)) 1 
                          (/ 
                            (- 
                              (+ 0.4 0.3) 1) 0.4))) $QRs#111871) 
                    (<= $QRs#111871 
                      (if 
                        (> 0 
                          (if 
                            (< 1 
                              (/ 0.3 0.4)) 1 
                            (/ 0.3 0.4))) 0 
                        (if 
                          (< 1 
                            (/ 0.3 0.4)) 1 
                          (/ 0.3 0.4))))))) 
              (STV 
                (if 
                  (< 0.9999 0.4) 0.3 
                  (+ 
                    (* $PQs#111869 $QRs#111871) 
                    (/ 
                      (* 
                        (- 1 $PQs#111869) 
                        (- 0.3 
                          (* 0.4 $QRs#111871))) 
                      (- 1 0.4)))) 
                (min 0.3 
                  (min 0.1 
                    (min 0.2 
                      (min $PQc#111875 $QRc#111876))))) 
              (STV 1 0))))) 
      (let* 
        ( ( (: $proof4#111863 
              (≞ 
                (→ P 
                  (→ Q R)) 
                (STV $PQs#111869 $PQc#111875))) (synthesize (: $proof4#111863 (≞ (→ P (→ Q R)) (STV $PQs#111869 $PQc#111875))) kb rb (S (S Z)))) ((: $proof5#111864 (≞ (→ (→ Q R) Q) (STV $QRs#111871 $QRc#111876))) (synthesize (: $proof5#111864 (≞ (→ (→ Q R) Q) (STV $QRs#111871 $QRc#111876))) kb rb (S (S Z))))) 
        (: 
          (Deduction Pm QRm Qm $proof4#111863 $proof5#111864) 
          (≞ 
            (→ P Q) 
            (if 
              (and 
                (and 
                  (< 0 0.2) 
                  (and 
                    (<= 
                      (if 
                        (> 0 
                          (if 
                            (< 1 
                              (/ 
                                (- 
                                  (+ 0.2 0.9) 1) 0.2)) 1 
                            (/ 
                              (- 
                                (+ 0.2 0.9) 1) 0.2))) 0 
                        (if 
                          (< 1 
                            (/ 
                              (- 
                                (+ 0.2 0.9) 1) 0.2)) 1 
                          (/ 
                            (- 
                              (+ 0.2 0.9) 1) 0.2))) $PQs#111869) 
                    (<= $PQs#111869 
                      (if 
                        (> 0 
                          (if 
                            (< 1 
                              (/ 0.9 0.2)) 1 
                            (/ 0.9 0.2))) 0 
                        (if 
                          (< 1 
                            (/ 0.9 0.2)) 1 
                          (/ 0.9 0.2)))))) 
                (and 
                  (< 0 0.9) 
                  (and 
                    (<= 
                      (if 
                        (> 0 
                          (if 
                            (< 1 
                              (/ 
                                (- 
                                  (+ 0.9 0.3) 1) 0.9)) 1 
                            (/ 
                              (- 
                                (+ 0.9 0.3) 1) 0.9))) 0 
                        (if 
                          (< 1 
                            (/ 
                              (- 
                                (+ 0.9 0.3) 1) 0.9)) 1 
                          (/ 
                            (- 
                              (+ 0.9 0.3) 1) 0.9))) $QRs#111871) 
                    (<= $QRs#111871 
                      (if 
                        (> 0 
                          (if 
                            (< 1 
                              (/ 0.3 0.9)) 1 
                            (/ 0.3 0.9))) 0 
                        (if 
                          (< 1 
                            (/ 0.3 0.9)) 1 
                          (/ 0.3 0.9))))))) 
              (STV 
                (if 
                  (< 0.9999 0.9) 0.3 
                  (+ 
                    (* $PQs#111869 $QRs#111871) 
                    (/ 
                      (* 
                        (- 1 $PQs#111869) 
                        (- 0.3 
                          (* 0.9 $QRs#111871))) 
                      (- 1 0.9)))) 
                (min 0.3 
                  (min 0.7 
                    (min 0.2 
                      (min $PQc#111875 $QRc#111876))))) 
              (STV 1 0))))) 
      (let* 
        ( ( (: $proof4#111863 
              (≞ 
                (→ P 
                  (→ P P)) 
                (STV $PQs#111869 $PQc#111875))) (synthesize (: $proof4#111863 (≞ (→ P (→ P P)) (STV $PQs#111869 $PQc#111875))) kb rb (S (S Z)))) ((: $proof5#111864 (≞ (→ (→ P P) Q) (STV $QRs#111871 $QRc#111876))) (synthesize (: $proof5#111864 (≞ (→ (→ P P) Q) (STV $QRs#111871 $QRc#111876))) kb rb (S (S Z))))) 
        (: 
          (Deduction Pm 
            (EvidenceElimination (IDIBase P2 P2)) Qm $proof4#111863 $proof5#111864) 
          (≞ 
            (→ P Q) 
            (if 
              (and 
                (and 
                  (< 0 0.2) 
                  (and 
                    (<= 
                      (if 
                        (> 0 
                          (if 
                            (< 1 
                              (/ 
                                (- 
                                  (+ 0.2 1) 1) 0.2)) 1 
                            (/ 
                              (- 
                                (+ 0.2 1) 1) 0.2))) 0 
                        (if 
                          (< 1 
                            (/ 
                              (- 
                                (+ 0.2 1) 1) 0.2)) 1 
                          (/ 
                            (- 
                              (+ 0.2 1) 1) 0.2))) $PQs#111869) 
                    (<= $PQs#111869 
                      (if 
                        (> 0 
                          (if 
                            (< 1 
                              (/ 1 0.2)) 1 
                            (/ 1 0.2))) 0 
                        (if 
                          (< 1 
                            (/ 1 0.2)) 1 
                          (/ 1 0.2)))))) 
                (and 
                  (< 0 1) 
                  (and 
                    (<= 
                      (if 
                        (> 0 
                          (if 
                            (< 1 
                              (/ 
                                (- 
                                  (+ 1 0.3) 1) 1)) 1 
                            (/ 
                              (- 
                                (+ 1 0.3) 1) 1))) 0 
                        (if 
                          (< 1 
                            (/ 
                              (- 
                                (+ 1 0.3) 1) 1)) 1 
                          (/ 
                            (- 
                              (+ 1 0.3) 1) 1))) $QRs#111871) 
                    (<= $QRs#111871 
                      (if 
                        (> 0 
                          (if 
                            (< 1 
                              (/ 0.3 1)) 1 
                            (/ 0.3 1))) 0 
                        (if 
                          (< 1 
                            (/ 0.3 1)) 1 
                          (/ 0.3 1))))))) 
              (STV 
                (if 
                  (< 0.9999 1) 0.3 
                  (+ 
                    (* $PQs#111869 $QRs#111871) 
                    (/ 
                      (* 
                        (- 1 $PQs#111869) 
                        (- 0.3 
                          (* 1 $QRs#111871))) 
                      (- 1 1)))) 
                (min 0.3 
                  (min 0.5 
                    (min 0.2 
                      (min $PQc#111875 $QRc#111876))))) 
              (STV 1 0))))) 
      (let* 
        ( ( (: $proof4#111863 
              (≞ 
                (→ P 
                  (→ P P)) 
                (STV $PQs#111869 $PQc#111875))) (synthesize (: $proof4#111863 (≞ (→ P (→ P P)) (STV $PQs#111869 $PQc#111875))) kb rb (S (S Z)))) ((: $proof5#111864 (≞ (→ (→ P P) Q) (STV $QRs#111871 $QRc#111876))) (synthesize (: $proof5#111864 (≞ (→ (→ P P) Q) (STV $QRs#111871 $QRc#111876))) kb rb (S (S Z))))) 
        (: 
          (Deduction Pm 
            (EvidenceElimination (IDIBase P7 P7)) Qm $proof4#111863 $proof5#111864) 
          (≞ 
            (→ P Q) 
            (if 
              (and 
                (and 
                  (< 0 0.2) 
                  (and 
                    (<= 
                      (if 
                        (> 0 
                          (if 
                            (< 1 
                              (/ 
                                (- 
                                  (+ 0.2 1) 1) 0.2)) 1 
                            (/ 
                              (- 
                                (+ 0.2 1) 1) 0.2))) 0 
                        (if 
                          (< 1 
                            (/ 
                              (- 
                                (+ 0.2 1) 1) 0.2)) 1 
                          (/ 
                            (- 
                              (+ 0.2 1) 1) 0.2))) $PQs#111869) 
                    (<= $PQs#111869 
                      (if 
                        (> 0 
                          (if 
                            (< 1 
                              (/ 1 0.2)) 1 
                            (/ 1 0.2))) 0 
                        (if 
                          (< 1 
                            (/ 1 0.2)) 1 
                          (/ 1 0.2)))))) 
                (and 
                  (< 0 1) 
                  (and 
                    (<= 
                      (if 
                        (> 0 
                          (if 
                            (< 1 
                              (/ 
                                (- 
                                  (+ 1 0.3) 1) 1)) 1 
                            (/ 
                              (- 
                                (+ 1 0.3) 1) 1))) 0 
                        (if 
                          (< 1 
                            (/ 
                              (- 
                                (+ 1 0.3) 1) 1)) 1 
                          (/ 
                            (- 
                              (+ 1 0.3) 1) 1))) $QRs#111871) 
                    (<= $QRs#111871 
                      (if 
                        (> 0 
                          (if 
                            (< 1 
                              (/ 0.3 1)) 1 
                            (/ 0.3 1))) 0 
                        (if 
                          (< 1 
                            (/ 0.3 1)) 1 
                          (/ 0.3 1))))))) 
              (STV 
                (if 
                  (< 0.9999 1) 0.3 
                  (+ 
                    (* $PQs#111869 $QRs#111871) 
                    (/ 
                      (* 
                        (- 1 $PQs#111869) 
                        (- 0.3 
                          (* 1 $QRs#111871))) 
                      (- 1 1)))) 
                (min 0.3 
                  (min 0.5 
                    (min 0.2 
                      (min $PQc#111875 $QRc#111876))))) 
              (STV 1 0))))) 
      (let* 
        ( ( (: $proof4#111863 
              (≞ 
                (→ P 
                  (→ P Q)) 
                (STV $PQs#111869 $PQc#111875))) (synthesize (: $proof4#111863 (≞ (→ P (→ P Q)) (STV $PQs#111869 $PQc#111875))) kb rb (S (S Z)))) ((: $proof5#111864 (≞ (→ (→ P Q) Q) (STV $QRs#111871 $QRc#111876))) (synthesize (: $proof5#111864 (≞ (→ (→ P Q) Q) (STV $QRs#111871 $QRc#111876))) kb rb (S (S Z))))) 
        (: 
          (Deduction Pm 
            (EvidenceElimination (IDIBase P7 Q7)) Qm $proof4#111863 $proof5#111864) 
          (≞ 
            (→ P Q) 
            (if 
              (and 
                (and 
                  (< 0 0.2) 
                  (and 
                    (<= 
                      (if 
                        (> 0 
                          (if 
                            (< 1 
                              (/ 
                                (- 
                                  (+ 0.2 1) 1) 0.2)) 1 
                            (/ 
                              (- 
                                (+ 0.2 1) 1) 0.2))) 0 
                        (if 
                          (< 1 
                            (/ 
                              (- 
                                (+ 0.2 1) 1) 0.2)) 1 
                          (/ 
                            (- 
                              (+ 0.2 1) 1) 0.2))) $PQs#111869) 
                    (<= $PQs#111869 
                      (if 
                        (> 0 
                          (if 
                            (< 1 
                              (/ 1 0.2)) 1 
                            (/ 1 0.2))) 0 
                        (if 
                          (< 1 
                            (/ 1 0.2)) 1 
                          (/ 1 0.2)))))) 
                (and 
                  (< 0 1) 
                  (and 
                    (<= 
                      (if 
                        (> 0 
                          (if 
                            (< 1 
                              (/ 
                                (- 
                                  (+ 1 0.3) 1) 1)) 1 
                            (/ 
                              (- 
                                (+ 1 0.3) 1) 1))) 0 
                        (if 
                          (< 1 
                            (/ 
                              (- 
                                (+ 1 0.3) 1) 1)) 1 
                          (/ 
                            (- 
                              (+ 1 0.3) 1) 1))) $QRs#111871) 
                    (<= $QRs#111871 
                      (if 
                        (> 0 
                          (if 
                            (< 1 
                              (/ 0.3 1)) 1 
                            (/ 0.3 1))) 0 
                        (if 
                          (< 1 
                            (/ 0.3 1)) 1 
                          (/ 0.3 1))))))) 
              (STV 
                (if 
                  (< 0.9999 1) 0.3 
                  (+ 
                    (* $PQs#111869 $QRs#111871) 
                    (/ 
                      (* 
                        (- 1 $PQs#111869) 
                        (- 0.3 
                          (* 1 $QRs#111871))) 
                      (- 1 1)))) 
                (min 0.3 
                  (min 0.5 
                    (min 0.2 
                      (min $PQc#111875 $QRc#111876))))) 
              (STV 1 0))))) 
      (let* 
        ( ( (: $proof4#111863 
              (≞ 
                (→ P 
                  (→ Q P)) 
                (STV $PQs#111869 $PQc#111875))) (synthesize (: $proof4#111863 (≞ (→ P (→ Q P)) (STV $PQs#111869 $PQc#111875))) kb rb (S (S Z)))) ((: $proof5#111864 (≞ (→ (→ Q P) Q) (STV $QRs#111871 $QRc#111876))) (synthesize (: $proof5#111864 (≞ (→ (→ Q P) Q) (STV $QRs#111871 $QRc#111876))) kb rb (S (S Z))))) 
        (: 
          (Deduction Pm 
            (EvidenceElimination (IDIBase Q7 P7)) Qm $proof4#111863 $proof5#111864) 
          (≞ 
            (→ P Q) 
            (if 
              (and 
                (and 
                  (< 0 0.2) 
                  (and 
                    (<= 
                      (if 
                        (> 0 
                          (if 
                            (< 1 
                              (/ 
                                (- 
                                  (+ 0.2 1) 1) 0.2)) 1 
                            (/ 
                              (- 
                                (+ 0.2 1) 1) 0.2))) 0 
                        (if 
                          (< 1 
                            (/ 
                              (- 
                                (+ 0.2 1) 1) 0.2)) 1 
                          (/ 
                            (- 
                              (+ 0.2 1) 1) 0.2))) $PQs#111869) 
                    (<= $PQs#111869 
                      (if 
                        (> 0 
                          (if 
                            (< 1 
                              (/ 1 0.2)) 1 
                            (/ 1 0.2))) 0 
                        (if 
                          (< 1 
                            (/ 1 0.2)) 1 
                          (/ 1 0.2)))))) 
                (and 
                  (< 0 1) 
                  (and 
                    (<= 
                      (if 
                        (> 0 
                          (if 
                            (< 1 
                              (/ 
                                (- 
                                  (+ 1 0.3) 1) 1)) 1 
                            (/ 
                              (- 
                                (+ 1 0.3) 1) 1))) 0 
                        (if 
                          (< 1 
                            (/ 
                              (- 
                                (+ 1 0.3) 1) 1)) 1 
                          (/ 
                            (- 
                              (+ 1 0.3) 1) 1))) $QRs#111871) 
                    (<= $QRs#111871 
                      (if 
                        (> 0 
                          (if 
                            (< 1 
                              (/ 0.3 1)) 1 
                            (/ 0.3 1))) 0 
                        (if 
                          (< 1 
                            (/ 0.3 1)) 1 
                          (/ 0.3 1))))))) 
              (STV 
                (if 
                  (< 0.9999 1) 0.3 
                  (+ 
                    (* $PQs#111869 $QRs#111871) 
                    (/ 
                      (* 
                        (- 1 $PQs#111869) 
                        (- 0.3 
                          (* 1 $QRs#111871))) 
                      (- 1 1)))) 
                (min 0.3 
                  (min 0.5 
                    (min 0.2 
                      (min $PQc#111875 $QRc#111876))))) 
              (STV 1 0))))) 
      (let* 
        ( ( (: $proof4#111863 
              (≞ 
                (→ P 
                  (→ Q Q)) 
                (STV $PQs#111869 $PQc#111875))) (synthesize (: $proof4#111863 (≞ (→ P (→ Q Q)) (STV $PQs#111869 $PQc#111875))) kb rb (S (S Z)))) ((: $proof5#111864 (≞ (→ (→ Q Q) Q) (STV $QRs#111871 $QRc#111876))) (synthesize (: $proof5#111864 (≞ (→ (→ Q Q) Q) (STV $QRs#111871 $QRc#111876))) kb rb (S (S Z))))) 
        (: 
          (Deduction Pm 
            (EvidenceElimination (IDIBase Q7 Q7)) Qm $proof4#111863 $proof5#111864) 
          (≞ 
            (→ P Q) 
            (if 
              (and 
                (and 
                  (< 0 0.2) 
                  (and 
                    (<= 
                      (if 
                        (> 0 
                          (if 
                            (< 1 
                              (/ 
                                (- 
                                  (+ 0.2 1) 1) 0.2)) 1 
                            (/ 
                              (- 
                                (+ 0.2 1) 1) 0.2))) 0 
                        (if 
                          (< 1 
                            (/ 
                              (- 
                                (+ 0.2 1) 1) 0.2)) 1 
                          (/ 
                            (- 
                              (+ 0.2 1) 1) 0.2))) $PQs#111869) 
                    (<= $PQs#111869 
                      (if 
                        (> 0 
                          (if 
                            (< 1 
                              (/ 1 0.2)) 1 
                            (/ 1 0.2))) 0 
                        (if 
                          (< 1 
                            (/ 1 0.2)) 1 
                          (/ 1 0.2)))))) 
                (and 
                  (< 0 1) 
                  (and 
                    (<= 
                      (if 
                        (> 0 
                          (if 
                            (< 1 
                              (/ 
                                (- 
                                  (+ 1 0.3) 1) 1)) 1 
                            (/ 
                              (- 
                                (+ 1 0.3) 1) 1))) 0 
                        (if 
                          (< 1 
                            (/ 
                              (- 
                                (+ 1 0.3) 1) 1)) 1 
                          (/ 
                            (- 
                              (+ 1 0.3) 1) 1))) $QRs#111871) 
                    (<= $QRs#111871 
                      (if 
                        (> 0 
                          (if 
                            (< 1 
                              (/ 0.3 1)) 1 
                            (/ 0.3 1))) 0 
                        (if 
                          (< 1 
                            (/ 0.3 1)) 1 
                          (/ 0.3 1))))))) 
              (STV 
                (if 
                  (< 0.9999 1) 0.3 
                  (+ 
                    (* $PQs#111869 $QRs#111871) 
                    (/ 
                      (* 
                        (- 1 $PQs#111869) 
                        (- 0.3 
                          (* 1 $QRs#111871))) 
                      (- 1 1)))) 
                (min 0.3 
                  (min 0.5 
                    (min 0.2 
                      (min $PQc#111875 $QRc#111876))))) 
              (STV 1 0))))) 
      (let* 
        ( ( (: $proof4#111863 
              (≞ 
                (→ P 
                  (→ P Q)) 
                (STV $PQs#111869 $PQc#111875))) (synthesize (: $proof4#111863 (≞ (→ P (→ P Q)) (STV $PQs#111869 $PQc#111875))) kb rb (S (S Z)))) ((: $proof5#111864 (≞ (→ (→ P Q) Q) (STV $QRs#111871 $QRc#111876))) (synthesize (: $proof5#111864 (≞ (→ (→ P Q) Q) (STV $QRs#111871 $QRc#111876))) kb rb (S (S Z))))) 
        (: 
          (Deduction Pm 
            (EvidenceElimination (IDIBase P2 Q2)) Qm $proof4#111863 $proof5#111864) 
          (≞ 
            (→ P Q) 
            (if 
              (and 
                (and 
                  (< 0 0.2) 
                  (and 
                    (<= 
                      (if 
                        (> 0 
                          (if 
                            (< 1 
                              (/ 
                                (- 
                                  (+ 0.2 0) 1) 0.2)) 1 
                            (/ 
                              (- 
                                (+ 0.2 0) 1) 0.2))) 0 
                        (if 
                          (< 1 
                            (/ 
                              (- 
                                (+ 0.2 0) 1) 0.2)) 1 
                          (/ 
                            (- 
                              (+ 0.2 0) 1) 0.2))) $PQs#111869) 
                    (<= $PQs#111869 
                      (if 
                        (> 0 
                          (if 
                            (< 1 
                              (/ 0 0.2)) 1 
                            (/ 0 0.2))) 0 
                        (if 
                          (< 1 
                            (/ 0 0.2)) 1 
                          (/ 0 0.2)))))) 
                (and 
                  (< 0 0) 
                  (and 
                    (<= 
                      (if 
                        (> 0 
                          (if 
                            (< 1 
                              (/ 
                                (- 
                                  (+ 0 0.3) 1) 0)) 1 
                            (/ 
                              (- 
                                (+ 0 0.3) 1) 0))) 0 
                        (if 
                          (< 1 
                            (/ 
                              (- 
                                (+ 0 0.3) 1) 0)) 1 
                          (/ 
                            (- 
                              (+ 0 0.3) 1) 0))) $QRs#111871) 
                    (<= $QRs#111871 
                      (if 
                        (> 0 
                          (if 
                            (< 1 
                              (/ 0.3 0)) 1 
                            (/ 0.3 0))) 0 
                        (if 
                          (< 1 
                            (/ 0.3 0)) 1 
                          (/ 0.3 0))))))) 
              (STV 
                (if 
                  (< 0.9999 0) 0.3 
                  (+ 
                    (* $PQs#111869 $QRs#111871) 
                    (/ 
                      (* 
                        (- 1 $PQs#111869) 
                        (- 0.3 
                          (* 0 $QRs#111871))) 
                      (- 1 0)))) 
                (min 0.3 
                  (min 0.5 
                    (min 0.2 
                      (min $PQc#111875 $QRc#111876))))) 
              (STV 1 0))))) 
      (let* 
        ( ( (: $proof2#166826 
              (⊷ Q 
                (S (S Z)) True)) (synthesize (: $proof2#166826 (⊷ Q (S (S Z)) True)) kb rb (S (S Z))))) 
        (: 
          (IDIBase P2 $proof2#166826) 
          (≞ 
            (→ P Q) 
            (ETV 
              (:: 
                (S (S Z)) ∅) 
              (STV 1 0.5))))) 
      (: 
        (IDIBase P7 Q7) 
        (≞ 
          (→ P Q) 
          (ETV 
            (:: 
              (S (S (S (S (S (S (S Z))))))) ∅) 
            (STV 1 0.5)))) 
      (: 
        (IDIBase P2 Q2) 
        (≞ 
          (→ P Q) 
          (ETV 
            (:: 
              (S (S Z)) ∅) 
            (STV 0 0.5)))) 
      (let* 
        ( ( (: $proof2#169875 
              (⊷ Q 
                (S (S (S (S (S (S (S Z))))))) False)) (synthesize (: $proof2#169875 (⊷ Q (S (S (S (S (S (S (S Z))))))) False)) kb rb (S (S Z))))) 
        (: 
          (IDIBase P7 $proof2#169875) 
          (≞ 
            (→ P Q) 
            (ETV 
              (:: 
                (S (S (S (S (S (S (S Z))))))) ∅) 
              (STV 0 0.5)))))))

</span>[

;<h3 id="DEPENDENT-TYPES.DEDUCTIONIMPLICATIONDIRECTINTRODUCTIONDTLTEST.06"
>;; DEPENDENT-TYPES.DEDUCTIONIMPLICATIONDIRECTINTRODUCTIONDTLTEST.06</h3>

Script done on 2024-09-26 01:20:24+00:00 [COMMAND_EXIT_CODE="143"]

</pre>
</body>

</html>
\033[1;33mCompleted (EXITCODE=143) Under 40 seconds: ./mettalog '--output=./reports/tests_output/baseline-compat-2024-09-26T00:33:38/' --timeout=40 --html --repl=false  --test "tests/extended_compat/hyperon-pln/metta/pln/dependent-types/DeductionImplicationDirectIntroductionDTLTest.metta" --halt=true\033[0m

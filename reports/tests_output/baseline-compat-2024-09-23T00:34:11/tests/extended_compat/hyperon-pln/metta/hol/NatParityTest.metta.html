<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"
>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"
>
<title></title>
<style type="text/css"
>
.ansi2html-content { display: inline; white-space: pre-wrap; word-wrap: break-word; }
.body_foreground { color: #AAAAAA; }
.body_background { background-color: #000000; }
.inv_foreground { color: #000000; }
.inv_background { background-color: #AAAAAA; }
.ansi1 { font-weight: bold; }
.ansi32 { color: #00aa00; }
.ansi36 { color: #00aaaa; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165009 { color: #FFA509; }
.ansi38-255238088 { color: #FFEE58; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165009 { color: #FFA509; }
.ansi38-255238088 { color: #FFEE58; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165009 { color: #FFA509; }
.ansi38-255238088 { color: #FFEE58; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165009 { color: #FFA509; }
.ansi38-255238088 { color: #FFEE58; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165009 { color: #FFA509; }
.ansi38-255238088 { color: #FFEE58; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165009 { color: #FFA509; }
.ansi38-255238088 { color: #FFEE58; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165009 { color: #FFA509; }
.ansi38-255238088 { color: #FFEE58; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165009 { color: #FFA509; }
.ansi38-255238088 { color: #FFEE58; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165009 { color: #FFA509; }
.ansi38-255238088 { color: #FFEE58; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165009 { color: #FFA509; }
.ansi38-255238088 { color: #FFEE58; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165009 { color: #FFA509; }
.ansi38-255238088 { color: #FFEE58; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165009 { color: #FFA509; }
.ansi38-255238088 { color: #FFEE58; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165009 { color: #FFA509; }
.ansi38-255238088 { color: #FFEE58; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165009 { color: #FFA509; }
.ansi38-255238088 { color: #FFEE58; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165009 { color: #FFA509; }
.ansi38-255238088 { color: #FFEE58; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165009 { color: #FFA509; }
.ansi38-255238088 { color: #FFEE58; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165009 { color: #FFA509; }
.ansi38-255238088 { color: #FFEE58; }
.ansi38-013099040 { color: #0D6328; }
</style>
</head>
<body class="body_foreground body_background" style="font-size: normal;" >
<pre class="ansi2html-content"
>
Script started on 2024-09-23 01:16:39+00:00 [TERM="xterm-256color" TTY="/dev/pts/0" COLUMNS="-1" LINES="-1"]
P;HTML|
;           (set_option_value  prolog false)

P;HTML|
;           (set_option_value  compat auto)

P;HTML|
;           (set_option_value  compatio true)
P;HTML|
;            (is_cmd_option  prescan halt --halt=true true)
P;HTML|
;            (set_option_value  halt true)
P;HTML|
;            (is_cmd_option  prescan stdin --stdin=tty tty)
P;HTML|
;             (set_option_value  stdin tty)
P;HTML|
;            (is_cmd_option  prescan stdout --stdout=tty tty)
P;HTML|
;             (set_option_value  stdout tty)
P;HTML|
;            (is_cmd_option  prescan stderr --stderr=tty tty)
P;HTML|
;             (set_option_value  stderr tty)
P;HTML|
;            (set_option_value  prolog false)
P;HTML|
;            (set_option_value  compat auto)
P;HTML|
;            (set_option_value  compatio true)
P;HTML|
;          (is_cmd_option  execute python --python=enable enable)
P;HTML|
;           (set_option_value  python enable)
P;HTML|
;          (is_cmd_option  execute timeout --timeout=40 40)
P;HTML|
;           (set_option_value  timeout 40)
P;HTML|
;           (is_cmd_option  execute output --output=./reports/tests_output/baseline-compat-2024-09-23T00:34:11/ ./reports/tests_output/baseline-compat-2024-09-23T00:34:11/)
P;HTML|
;           (set_option_value  output ./reports/tests_output/baseline-compat-2024-09-23T00:34:11/)
P;HTML|
;           (is_cmd_option  execute html --html true)
P;HTML|
;            (set_option_value  html true)
P;HTML|
;           (is_cmd_option  execute test --test true)
P;HTML|
;            (set_option_value  test true)

; (load_metta_file  &self tests/extended_compat/hyperon-pln/metta/hol/NatParityTest.metta)
P;HTML|
;                         (track_load_into_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/hol/NatParityTest.metta)
P;HTML|
;                                          (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/hol/NatParityTest.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/hol/NatParityTest.metta)
P;HTML|
;                                           (= 1  "Doing: timeout --foreground --kill-after=5 --signal=SIGINT 61 time metta /opt/logicmoo_opencog/hyperon-wam/examples/extended_compat/hyperon-pln/metta/hol/NatParityTest.metta")
P;HTML|
;                                           (= 1  "[()]")
P;HTML|
;                                           (= 2  "[()]")
P;HTML|
;                                           (= 3  "[()]")
P;HTML|
;                                           (= 4  "[()]")
P;HTML|
;                                           (= 5  "[()]")
P;HTML|
;                                           (= 6  "[()]")
P;HTML|
;                                           (= 7  "[()]")
P;HTML|
;                                           (= 8  "[()]")
P;HTML|
;                                           (= 9  "[()]")
P;HTML|
;                                           (= 10  "[()]")
P;HTML|
;                                           (= 11  "[()]")
P;HTML|
;                                           (= 12  "[()]")
P;HTML|
;                                           (= 13  "[()]")
P;HTML|
;                                           (= 14  "[()]")
P;HTML|
;                                           (= 15  "[()]")
P;HTML|
;                                           (= 16  "[()]")
P;HTML|
;                                           (= 17  "[()]")
P;HTML|
;                                           (= 18  "[(let* (((: $prfarg#193 (=== Nat Nat)) (bc (: $prfarg#193 (=== Nat Nat)) (S (S Z))))) (: (((. Replace) Sym) $prfarg#193) (-> (: $k Nat) Nat))), (: ((. S) ((. S) S)) (-> (: $k Nat) Nat)), (: ((. S) ((. S) double)) (-> (: $k Nat) Nat)), (: ((. S) ((. double) S)) (-> (: $k Nat) Nat)), (: ((. S) ((. double) double)) (-> (: $k Nat) Nat)), (: ((. S) S) (-> (: $k Nat) Nat)), (: ((. S) double) (-> (: $k Nat) Nat)), (: ((. double) ((. S) S)) (-> (: $k Nat) Nat)), (: ((. double) ((. S) double)) (-> (: $k Nat) Nat)), (: ((. double) ((. double) S)) (-> (: $k Nat) Nat)), (: ((. double) ((. double) double)) (-> (: $k Nat) Nat)), (: ((. double) S) (-> (: $k Nat) Nat)), (: ((. double) double) (-> (: $k Nat) Nat)), (let* (((: $prfarg#193 (=== Nat Nat)) (bc (: $prfarg#193 (=== Nat Nat)) (S (S Z))))) (: (Replace $prfarg#193) (-> (: $k Nat) Nat))), (: S (-> (: $k Nat) Nat)), (: double (-> (: $k Nat) Nat))]")
P;HTML|
;                                           (= 19  "3.65user 0.00system 0:03.66elapsed 100%CPU (0avgtext+0avgdata 37560maxresident)k")
P;HTML|
;                                           (= 19  "0inputs+0outputs (0major+4675minor)pagefaults 0swaps")
P;HTML|
;                                          (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/hol/NatParityTest.metta.answers /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/hol/NatParityTest.metta)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; Definition of a chainer, Nat, plus and some proofs about the
;;;; existance of the parity properties of Nat such as Even and Odd.
;;;;
;;;; Implement a sigma type, take example from
;;;;
;;;; https://idris2.readthedocs.io/en/latest/tutorial/typesfuns.html#dependent-pairs
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;
;;;; Nat ;;
;;;;;;;;;;;
;;;; Define Nat
<span class="ansi38-255165000"
>  (: Nat Type)
</span><span class="ansi38-255165000"
>  (: Z Nat)
</span><span class="ansi38-255165000"
>  (: S 
    (-> Nat Nat))
</span>;;;; Define <=
<span class="ansi38-255165000"
>  (: <= 
    (-> $a $a Bool))
</span><span class="ansi38-255165000"
>  (= 
    (<= $x $y) 
    (or 
      (< $x $y) 
      (== $x $y)))
</span>;;;; Define cast functions between Nat and Number
<span class="ansi38-255165000"
>  (: fromNumber 
    (-> Number Nat))
</span><span class="ansi38-255165000"
>  (= 
    (fromNumber $n) 
    (if 
      (<= $n 0) Z 
      (S (fromNumber (- $n 1)))))
</span><span class="ansi38-255165000"
>  (: fromNat 
    (-> Nat Number))
</span><span class="ansi38-255165000"
>  (= 
    (fromNat Z) 0)
</span><span class="ansi38-255165000"
>  (= 
    (fromNat (S $k)) 
    (+ 1 
      (fromNat $k)))
</span>;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; Knowledge/rule base ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;
<span class="ansi38-013099040"
>  !(bind! &kb 
    (new-space))

</span>

Deterministic: ()
[()]
;;;; The following code is translated into axioms and rules to handled
;;;; by the backward chainer.
;;;;
;;;; ;; Define Î£ type (called DPair in Idris)
;;;; (: Î£ (-> (: $a Type) (-> $a Type) Type))
;;;;
;;;; ;; Define DPair constructor
;;;; (: MkÎ£ (-> (: $p (-> $a Type)) (: $x $a) ($p $x) (Î£ $a $p)))
;;;;
;;;; ;; Define the even property
;;;; (: Even (-> Nat Type))
;;;; (: MkEvenZ (Even Z))
;;;; (: MkEvenSS (-> (Even $k) (Even (S (S $k)))))
;;;;
;;;; ;; Define examples of even numbers (0 and 2)
;;;; (: (MkÎ£ Even Z MkEvenZ) (Î£ Nat Even))
;;;; (: (MkÎ£ Even (S (S Z)) (MkEvenSS MkEvenZ)) (Î£ Nat Even))
;;;; (: $prf (Î£ Nat Even))
;;;;
;;;; ;; Define double function
;;;; (: double (-> Nat Nat))
;;;; (= (double Z) Z)
;;;; (= (double (S $k)) (S (S (double $k))))
;;;;
;;;; ;; Î£ access functions
;;;; (: Î£.val (-> (Î£ $a $p) $a))
;;;; (= (Î£.val (MkÎ£ $prop $val $prf)) $val)
;;;; (: Î£.prf (-> (Î£ $a $p) $p))
;;;; (= (Î£.prf (MkÎ£ $prop $val $prf)) $prf)
;;;;
;;;; ;; Define double function, with the guaranty that the output is even
;;;; (: doubleÎ£ (-> Nat (Î£ Nat Even)))
;;;; (= (doubleÎ£ Z) (MkÎ£ Even Z MkEvenZ))
;;;; (= (doubleÎ£ (S $k)) (MkÎ£ Even
;;;;                          (S (S (Î£.val (doubleÎ£ $k))))
;;;;                          (MkEvenSS (Î£.prf (doubleÎ£ $k)))))
;;;;
;;;; ;; For all x, (double x) is even
;;;; ;; âˆ€x (Even (double x))
;;;; (: double-even-prf (-> (: $x Nat) (Even (double $x))))
;;;;
;;;; ;; Independent product type (i.e. conjunction)
;;;; (: âŠ— (-> Type Type Type))
;;;;
;;;; ;; Equality
;;;; (: === (-> $a $a Type))
;;;;
;;;; ;; ;; NEXT
;;;;
;;;; ;; ;; For all x, there exists k such that k = (double x) and k is even
;;;; ;; ;; âˆ€x âˆƒk k=(double x) âˆ§ (Even k)
;;;; ;; (: double-Î£-even-prf (-> ($x : Nat)
;;;; ;;                          (Î£ Nat (Î» $k (âŠ— (=== $k (double $x)) (Even $k))))))
;;;;
;;;; ;; (: double-Î£-even-prf (-> ($x : Nat) (Î£ Nat (EqualDoubleAndEven $x))))
;;;; ;; (: EqualDoubleAndEven (-> Nat (-> Nat Type)))
;;;; ;; (= ((EqualDoubleAndEven $x) $k) (âŠ— (=== $k (double $x)) (Even $k)))
;;;; ;; ;; Or, alternatively
;;;; ;; ;; (= (EqualDoubleAndEven $x) (Î» $k (Ã— (=== $k (double $x)) (Even $k))))
;;;; Define Nat
<span class="ansi38-255165009"
>;; In file as:  
</span><span class="ansi1 ansi38-255238088"
>  !(add-atom &kb 
    (: Nat Type))
</span>;; To unit test case:
<span class="ansi38-013099040"
>  !(assertEqualToResult 
    (add-atom &kb 
      (: Nat Type)) 
    (()))

</span>[

;<h3 id="HOL.NATPARITYTEST.01"
>;; HOL.NATPARITYTEST.01</h3>
<span class="ansi38-255165000"
>  (: Nat Type)
</span>; 
; EVAL TEST
; took 0.002 secs. (1.82 milliseconds) 

  !(assertEqualToResult 
    (add-atom &kb 
      (: Nat Type)) 
    (()))

<span class="ansi36"
>  (loonit_success  
    (equal_enough_for_test  
      (()) 
      (())))
</span>
Deterministic: ()
()]
<span class="ansi38-255165009"
>;; In file as:  
</span><span class="ansi1 ansi38-255238088"
>  !(add-atom &kb 
    (: Z Nat))
</span>;; To unit test case:
<span class="ansi38-013099040"
>  !(assertEqualToResult 
    (add-atom &kb 
      (: Z Nat)) 
    (()))

</span>[

;<h3 id="HOL.NATPARITYTEST.02"
>;; HOL.NATPARITYTEST.02</h3>
<span class="ansi38-255165000"
>  (: Z Nat)
</span>; 
; EVAL TEST
; took 0.002 secs. (1.78 milliseconds) 

  !(assertEqualToResult 
    (add-atom &kb 
      (: Z Nat)) 
    (()))

<span class="ansi36"
>  (loonit_success  
    (equal_enough_for_test  
      (()) 
      (())))
</span>
Deterministic: ()
()]
<span class="ansi38-255165009"
>;; In file as:  
</span><span class="ansi1 ansi38-255238088"
>  !(add-atom &kb 
    (: S 
      (-> 
        (: $x Nat) Nat)))
</span>;; To unit test case:
<span class="ansi38-013099040"
>  !(assertEqualToResult 
    (add-atom &kb 
      (: S 
        (-> 
          (: $x Nat) Nat))) 
    (()))

</span>[

;<h3 id="HOL.NATPARITYTEST.03"
>;; HOL.NATPARITYTEST.03</h3>
<span class="ansi38-255165000"
>  (: S 
    (-> 
      (: $_196546 Nat) Nat))
</span>; 
; EVAL TEST
; took 0.003 secs. (2.82 milliseconds) 

  !(assertEqualToResult 
    (add-atom &kb 
      (: S 
        (-> 
          (: $x Nat) Nat))) 
    (()))

<span class="ansi36"
>  (loonit_success  
    (equal_enough_for_test  
      (()) 
      (())))
</span>
Deterministic: ()
()]
;;;; NEXT: deal with asummptions like (: $k Nat)
;;;; !(add-atom &kb (: $k
;;;; Define Even
<span class="ansi38-255165009"
>;; In file as:  
</span><span class="ansi1 ansi38-255238088"
>  !(add-atom &kb 
    (: Even 
      (-> 
        (: $x Nat) Type)))
</span>;; To unit test case:
<span class="ansi38-013099040"
>  !(assertEqualToResult 
    (add-atom &kb 
      (: Even 
        (-> 
          (: $x Nat) Type))) 
    (()))

</span>[

;<h3 id="HOL.NATPARITYTEST.04"
>;; HOL.NATPARITYTEST.04</h3>
<span class="ansi38-255165000"
>  (: Even 
    (-> 
      (: $_226882 Nat) Type))
</span>; 
; EVAL TEST
; took 0.003 secs. (2.80 milliseconds) 

  !(assertEqualToResult 
    (add-atom &kb 
      (: Even 
        (-> 
          (: $x Nat) Type))) 
    (()))

<span class="ansi36"
>  (loonit_success  
    (equal_enough_for_test  
      (()) 
      (())))
</span>
Deterministic: ()
()]
<span class="ansi38-255165009"
>;; In file as:  
</span><span class="ansi1 ansi38-255238088"
>  !(add-atom &kb 
    (: MkEvenZ 
      (Even Z)))
</span>;; To unit test case:
<span class="ansi38-013099040"
>  !(assertEqualToResult 
    (add-atom &kb 
      (: MkEvenZ 
        (Even Z))) 
    (()))

</span>[

;<h3 id="HOL.NATPARITYTEST.05"
>;; HOL.NATPARITYTEST.05</h3>
<span class="ansi38-255165000"
>  (: MkEvenZ 
    (Even Z))
</span>; 
; EVAL TEST
; took 0.002 secs. (1.89 milliseconds) 

  !(assertEqualToResult 
    (add-atom &kb 
      (: MkEvenZ 
        (Even Z))) 
    (()))

<span class="ansi36"
>  (loonit_success  
    (equal_enough_for_test  
      (()) 
      (())))
</span>
Deterministic: ()
()]
;;; Premise
<span class="ansi38-255165009"
>;; In file as:  
</span><span class="ansi1 ansi38-255238088"
>  !(add-atom &kb 
    (: MkEvenSS 
      (-> 
        (: $prf 
          (Even $k)) 
        (Even (S (S $k))))))
</span>;; To unit test case:
<span class="ansi38-013099040"
>  !(assertEqualToResult 
    (add-atom &kb 
      (: MkEvenSS 
        (-> 
          (: $prf 
            (Even $k)) 
          (Even (S (S $k)))))) 
    (()))

</span>[

;<h3 id="HOL.NATPARITYTEST.06"
>;; HOL.NATPARITYTEST.06</h3>
<span class="ansi38-255165000"
>  (: MkEvenSS 
    (-> 
      (: $_287236 
        (Even $_287274)) 
      (Even (S (S $_287274)))))
</span>; 
; EVAL TEST
; took 0.005 secs. (4.72 milliseconds) 

  !(assertEqualToResult 
    (add-atom &kb 
      (: MkEvenSS 
        (-> 
          (: $prf 
            (Even $k)) 
          (Even (S (S $k)))))) 
    (()))

<span class="ansi36"
>  (loonit_success  
    (equal_enough_for_test  
      (()) 
      (())))
</span>
Deterministic: ()
()]
;;; Conclusion
;;;; Define Î£
;;; Premise 1.  We
;;; need to use (: $_ $a)
;;; as opposed to just $a
;;; to be fully consistent with
;;; The (: PROOF PREMISE)
;;; notation, till it becomes
;;; optional.
;;; Premise 2
;;; Premise 3
<span class="ansi38-255165009"
>;; In file as:  
</span><span class="ansi1 ansi38-255238088"
>  !(add-atom &kb 
    (: MkÎ£ 
      (-> 
        (: $p 
          (-> 
            (: $ $a) Type)) 
        (-> 
          (: $x $a) 
          (-> 
            (: $prf 
              ($p $x)) 
            (Î£ $a $p))))))
</span>;; To unit test case:
<span class="ansi38-013099040"
>  !(assertEqualToResult 
    (add-atom &kb 
      (: MkÎ£ 
        (-> 
          (: $p 
            (-> 
              (: $ $a) Type)) 
          (-> 
            (: $x $a) 
            (-> 
              (: $prf 
                ($p $x)) 
              (Î£ $a $p)))))) 
    (()))

</span>[

;<h3 id="HOL.NATPARITYTEST.07"
>;; HOL.NATPARITYTEST.07</h3>
<span class="ansi38-255165000"
>  (: MkÎ£ 
    (-> 
      (: $_319414 
        (-> 
          (: $_319468 $_319490) Type)) 
      (-> 
        (: $_319552 $_319490) 
        (-> 
          (: $_319624 
            ($_319414 $_319552)) 
          (Î£ $_319490 $_319414)))))
</span>; 
; EVAL TEST
; took 0.012 secs. (12.24 milliseconds) 

  !(assertEqualToResult 
    (add-atom &kb 
      (: MkÎ£ 
        (-> 
          (: $p 
            (-> 
              (: $ $a) Type)) 
          (-> 
            (: $x $a) 
            (-> 
              (: $prf 
                ($p $x)) 
              (Î£ $a $p)))))) 
    (()))

<span class="ansi36"
>  (loonit_success  
    (equal_enough_for_test  
      (()) 
      (())))
</span>
Deterministic: ()
()]
;;; Conclusion
;;;; Equality is transitive
;;; Premise 1
;;; Premise 2
<span class="ansi38-255165009"
>;; In file as:  
</span><span class="ansi1 ansi38-255238088"
>  !(add-atom &kb 
    (: Trans 
      (-> 
        (: $prf1 
          (=== $x $y)) 
        (-> 
          (: $prf2 
            (=== $y $z)) 
          (=== $x $z)))))
</span>;; To unit test case:
<span class="ansi38-013099040"
>  !(assertEqualToResult 
    (add-atom &kb 
      (: Trans 
        (-> 
          (: $prf1 
            (=== $x $y)) 
          (-> 
            (: $prf2 
              (=== $y $z)) 
            (=== $x $z))))) 
    (()))

</span>[

;<h3 id="HOL.NATPARITYTEST.08"
>;; HOL.NATPARITYTEST.08</h3>
<span class="ansi38-255165000"
>  (: Trans 
    (-> 
      (: $_351634 
        (=== $_351672 $_351694)) 
      (-> 
        (: $_351748 
          (=== $_351694 $_351804)) 
        (=== $_351672 $_351804))))
</span>; 
; EVAL TEST
; took 0.010 secs. (9.52 milliseconds) 

  !(assertEqualToResult 
    (add-atom &kb 
      (: Trans 
        (-> 
          (: $prf1 
            (=== $x $y)) 
          (-> 
            (: $prf2 
              (=== $y $z)) 
            (=== $x $z))))) 
    (()))

<span class="ansi36"
>  (loonit_success  
    (equal_enough_for_test  
      (()) 
      (())))
</span>
Deterministic: ()
()]
;;; Conclusion
;;;; Equality is symmetric
;;; Premise
<span class="ansi38-255165009"
>;; In file as:  
</span><span class="ansi1 ansi38-255238088"
>  !(add-atom &kb 
    (: Sym 
      (-> 
        (: $prf 
          (=== $x $y)) 
        (=== $y $x))))
</span>;; To unit test case:
<span class="ansi38-013099040"
>  !(assertEqualToResult 
    (add-atom &kb 
      (: Sym 
        (-> 
          (: $prf 
            (=== $x $y)) 
          (=== $y $x)))) 
    (()))

</span>[

;<h3 id="HOL.NATPARITYTEST.09"
>;; HOL.NATPARITYTEST.09</h3>
<span class="ansi38-255165000"
>  (: Sym 
    (-> 
      (: $_383064 
        (=== $_383102 $_383124)) 
      (=== $_383124 $_383102)))
</span>; 
; EVAL TEST
; took 0.006 secs. (6.29 milliseconds) 

  !(assertEqualToResult 
    (add-atom &kb 
      (: Sym 
        (-> 
          (: $prf 
            (=== $x $y)) 
          (=== $y $x)))) 
    (()))

<span class="ansi36"
>  (loonit_success  
    (equal_enough_for_test  
      (()) 
      (())))
</span>
Deterministic: ()
()]
;;; Conclusion
;;;; Equality respects function application
;;; Premise 1
;;; Premise 2
;;; Premise 3
;;; Premise 4
<span class="ansi38-255165009"
>;; In file as:  
</span><span class="ansi1 ansi38-255238088"
>  !(add-atom &kb 
    (: Cong 
      (-> 
        (: $f 
          (-> 
            (: $ $a) $b)) 
        (-> 
          (: $x $a) 
          (-> 
            (: $x' $a) 
            (-> 
              (: $prf 
                (=== $x $x')) 
              (=== 
                ($f $x) 
                ($f $x'))))))))
</span>;; To unit test case:
<span class="ansi38-013099040"
>  !(assertEqualToResult 
    (add-atom &kb 
      (: Cong 
        (-> 
          (: $f 
            (-> 
              (: $ $a) $b)) 
          (-> 
            (: $x $a) 
            (-> 
              (: $x' $a) 
              (-> 
                (: $prf 
                  (=== $x $x')) 
                (=== 
                  ($f $x) 
                  ($f $x')))))))) 
    (()))

</span>[

;<h3 id="HOL.NATPARITYTEST.10"
>;; HOL.NATPARITYTEST.10</h3>
<span class="ansi38-255165000"
>  (: Cong 
    (-> 
      (: $_414686 
        (-> 
          (: $_414740 $_414762) $_414784)) 
      (-> 
        (: $_414838 $_414762) 
        (-> 
          (: $_414910 $_414762) 
          (-> 
            (: $_414982 
              (=== $_414838 $_414910)) 
            (=== 
              ($_414686 $_414838) 
              ($_414686 $_414910)))))))
</span>; 
; EVAL TEST
; took 0.019 secs. (18.97 milliseconds) 

  !(assertEqualToResult 
    (add-atom &kb 
      (: Cong 
        (-> 
          (: $f 
            (-> 
              (: $ $a) $b)) 
          (-> 
            (: $x $a) 
            (-> 
              (: $x' $a) 
              (-> 
                (: $prf 
                  (=== $x $x')) 
                (=== 
                  ($f $x) 
                  ($f $x')))))))) 
    (()))

<span class="ansi36"
>  (loonit_success  
    (equal_enough_for_test  
      (()) 
      (())))
</span>
Deterministic: ()
()]
;;; Conclusion
;;;; Rule of replacement
;;; Premise 1
;;; Premise 2
<span class="ansi38-255165009"
>;; In file as:  
</span><span class="ansi1 ansi38-255238088"
>  !(add-atom &kb 
    (: Replace 
      (-> 
        (: $prf1 
          (=== $x $x')) 
        (-> 
          (: $prf2 $x) $x'))))
</span>;; To unit test case:
<span class="ansi38-013099040"
>  !(assertEqualToResult 
    (add-atom &kb 
      (: Replace 
        (-> 
          (: $prf1 
            (=== $x $x')) 
          (-> 
            (: $prf2 $x) $x')))) 
    (()))

</span>[

;<h3 id="HOL.NATPARITYTEST.11"
>;; HOL.NATPARITYTEST.11</h3>
<span class="ansi38-255165000"
>  (: Replace 
    (-> 
      (: $_447228 
        (=== $_447266 $_447288)) 
      (-> 
        (: $_447342 $_447266) $_447288)))
</span>; 
; EVAL TEST
; took 0.008 secs. (7.58 milliseconds) 

  !(assertEqualToResult 
    (add-atom &kb 
      (: Replace 
        (-> 
          (: $prf1 
            (=== $x $x')) 
          (-> 
            (: $prf2 $x) $x')))) 
    (()))

<span class="ansi36"
>  (loonit_success  
    (equal_enough_for_test  
      (()) 
      (())))
</span>
Deterministic: ()
()]
;;; Conclusion
;;;; ;; Modus Ponens (application)
;;;; !(add-atom &kb (: ModusPonens (-> (: $f (-> (: $x $a) $b)) ; Premise 1
;;;;                                   (-> (: $x $a)            ; Premise 2
;;;;                                       $b))))               ; Conclusion
;;;; Define double
<span class="ansi38-255165009"
>;; In file as:  
</span><span class="ansi1 ansi38-255238088"
>  !(add-atom &kb 
    (: double 
      (-> 
        (: $k Nat) Nat)))
</span>;; To unit test case:
<span class="ansi38-013099040"
>  !(assertEqualToResult 
    (add-atom &kb 
      (: double 
        (-> 
          (: $k Nat) Nat))) 
    (()))

</span>[

;<h3 id="HOL.NATPARITYTEST.12"
>;; HOL.NATPARITYTEST.12</h3>
<span class="ansi38-255165000"
>  (: double 
    (-> 
      (: $_478158 Nat) Nat))
</span>; 
; EVAL TEST
; took 0.003 secs. (2.82 milliseconds) 

  !(assertEqualToResult 
    (add-atom &kb 
      (: double 
        (-> 
          (: $k Nat) Nat))) 
    (()))

<span class="ansi36"
>  (loonit_success  
    (equal_enough_for_test  
      (()) 
      (())))
</span>
Deterministic: ()
()]
<span class="ansi38-255165009"
>;; In file as:  
</span><span class="ansi1 ansi38-255238088"
>  !(add-atom &kb 
    (: double_base 
      (=== 
        (double Z) Z)))
</span>;; To unit test case:
<span class="ansi38-013099040"
>  !(assertEqualToResult 
    (add-atom &kb 
      (: double_base 
        (=== 
          (double Z) Z))) 
    (()))

</span>[

;<h3 id="HOL.NATPARITYTEST.13"
>;; HOL.NATPARITYTEST.13</h3>
<span class="ansi38-255165000"
>  (: double_base 
    (=== 
      (double Z) Z))
</span>; 
; EVAL TEST
; took 0.002 secs. (1.95 milliseconds) 

  !(assertEqualToResult 
    (add-atom &kb 
      (: double_base 
        (=== 
          (double Z) Z))) 
    (()))

<span class="ansi36"
>  (loonit_success  
    (equal_enough_for_test  
      (()) 
      (())))
</span>
Deterministic: ()
()]
<span class="ansi38-255165009"
>;; In file as:  
</span><span class="ansi1 ansi38-255238088"
>  !(add-atom &kb 
    (: double_rec 
      (-> 
        (: $k Nat) 
        (=== 
          (double (S $k)) 
          (S (S (double $k)))))))
</span>;; To unit test case:
<span class="ansi38-013099040"
>  !(assertEqualToResult 
    (add-atom &kb 
      (: double_rec 
        (-> 
          (: $k Nat) 
          (=== 
            (double (S $k)) 
            (S (S (double $k))))))) 
    (()))

</span>[

;<h3 id="HOL.NATPARITYTEST.14"
>;; HOL.NATPARITYTEST.14</h3>
<span class="ansi38-255165000"
>  (: double_rec 
    (-> 
      (: $_21232 Nat) 
      (=== 
        (double (S $_21232)) 
        (S (S (double $_21232))))))
</span>; 
; EVAL TEST
; took 0.005 secs. (4.96 milliseconds) 

  !(assertEqualToResult 
    (add-atom &kb 
      (: double_rec 
        (-> 
          (: $k Nat) 
          (=== 
            (double (S $k)) 
            (S (S (double $k))))))) 
    (()))

<span class="ansi36"
>  (loonit_success  
    (equal_enough_for_test  
      (()) 
      (())))
</span>
Deterministic: ()
()]
;;;; Composition operator
;;; Premise 1
;;; Premise 2
<span class="ansi38-255165009"
>;; In file as:  
</span><span class="ansi1 ansi38-255238088"
>  !(add-atom &kb 
    (: . 
      (-> 
        (: $g 
          (-> 
            (: $y $b) $c)) 
        (-> 
          (: $f 
            (-> 
              (: $x $a) $b)) 
          (-> 
            (: $x $a) $c)))))
</span>;; To unit test case:
<span class="ansi38-013099040"
>  !(assertEqualToResult 
    (add-atom &kb 
      (: . 
        (-> 
          (: $g 
            (-> 
              (: $y $b) $c)) 
          (-> 
            (: $f 
              (-> 
                (: $x $a) $b)) 
            (-> 
              (: $x $a) $c))))) 
    (()))

</span>[

;<h3 id="HOL.NATPARITYTEST.15"
>;; HOL.NATPARITYTEST.15</h3>
<span class="ansi38-255165000"
>  (: . 
    (-> 
      (: $_52872 
        (-> 
          (: $_52926 $_52948) $_52970)) 
      (-> 
        (: $_53024 
          (-> 
            (: $_53078 $_53100) $_52948)) 
        (-> 
          (: $_53078 $_53100) $_52970))))
</span>; 
; EVAL TEST
; took 0.013 secs. (13.36 milliseconds) 

  !(assertEqualToResult 
    (add-atom &kb 
      (: . 
        (-> 
          (: $g 
            (-> 
              (: $y $b) $c)) 
          (-> 
            (: $f 
              (-> 
                (: $x $a) $b)) 
            (-> 
              (: $x $a) $c))))) 
    (()))

<span class="ansi36"
>  (loonit_success  
    (equal_enough_for_test  
      (()) 
      (())))
</span>
Deterministic: ()
()]
;;; Conclusion
;;;; Flip operator
;;; Premise
<span class="ansi38-255165009"
>;; In file as:  
</span><span class="ansi1 ansi38-255238088"
>  !(add-atom &kb 
    (: flip 
      (-> 
        (: $f 
          (-> 
            (: $x $a) 
            (-> 
              (: $y $b) $c))) 
        (-> 
          (: $y $b) 
          (-> 
            (: $x $a) $c)))))
</span>;; To unit test case:
<span class="ansi38-013099040"
>  !(assertEqualToResult 
    (add-atom &kb 
      (: flip 
        (-> 
          (: $f 
            (-> 
              (: $x $a) 
              (-> 
                (: $y $b) $c))) 
          (-> 
            (: $y $b) 
            (-> 
              (: $x $a) $c))))) 
    (()))

</span>[

;<h3 id="HOL.NATPARITYTEST.16"
>;; HOL.NATPARITYTEST.16</h3>
<span class="ansi38-255165000"
>  (: flip 
    (-> 
      (: $_85224 
        (-> 
          (: $_85278 $_85300) 
          (-> 
            (: $_85354 $_85376) $_85398))) 
      (-> 
        (: $_85354 $_85376) 
        (-> 
          (: $_85278 $_85300) $_85398))))
</span>; 
; EVAL TEST
; took 0.013 secs. (13.09 milliseconds) 

  !(assertEqualToResult 
    (add-atom &kb 
      (: flip 
        (-> 
          (: $f 
            (-> 
              (: $x $a) 
              (-> 
                (: $y $b) $c))) 
          (-> 
            (: $y $b) 
            (-> 
              (: $x $a) $c))))) 
    (()))

<span class="ansi36"
>  (loonit_success  
    (equal_enough_for_test  
      (()) 
      (())))
</span>
Deterministic: ()
()]
;;; Conclusion
;;;; ;; Anything can serve as a variable.  Even a closed term, it simply
;;;; ;; will not unify with any other closed term than itself, which makes
;;;; ;; for a very specific, yet valid, abstraction.
;;;; !(add-atom &kb (: $x Variable))
;;;; ;; Lambda abstraction
;;;; !(add-atom &kb (: Î» (-> (: $x Variable)           ; Premise 1
;;;;                         (-> (: $y $b)             ; Premise 2
;;;;                             (-> (: $x $a) $b))))) ; Conclusion
;;;;;;;;;;;;;;;;;;;;;;;;
;;;; Backward chainer ;;
;;;;;;;;;;;;;;;;;;;;;;;;
;;;; Similar to the backward chainer in NatDTLTest but rules are
;;;; optionally represented as dependent products.  Meaning rule
;;;; premises may contain type-of relationships.  That is, instead of
;;;;
;;;; (: RULE_CONSTRUCTOR (-> PREMISE CONCLUSION))
;;;;
;;;; it must be
;;;;
;;;; (: RULE_CONSTRUCTOR (-> (: PROOF PREMISE) CONCLUSION))
;;;;
;;;; Typically PROOF will be a variable, but it can also be a term
;;;; containing variables, in which case CONCLUSION may contain that
;;;; term, or variables of that term.
;;;;
;;;; Unlike for the backward chainer in NatDTLTest, the non-dependent
;;;; format is supported as well.  EDIT: not yet!
;;;; Base case
<span class="ansi38-255165000"
>  (: bc 
    (-> $a Nat $a))
</span>;;;; Query the knowledge for a rule or a fact
<span class="ansi38-255165000"
>  (= 
    (bc 
      (: $prf $ccln) $) 
    (match &kb 
      (: $prf $ccln) 
      (: $prf $ccln)))
</span>;;;; Recursive step
;;;; Recurse on proof abstraction
;;;; Recurse on proof argument
<span class="ansi38-255165000"
>  (= 
    (bc 
      (: 
        ($prfabs $prfarg) $ccln) 
      (S $k)) 
    (let* 
      ( ( (: $prfabs 
            (-> 
              (: $prfarg $prms) $ccln)) (bc (: $prfabs (-> (: $prfarg $prms) $ccln)) $k)) ((: $prfarg $prms) (bc (: $prfarg $prms) $k))) 
      (: 
        ($prfabs $prfarg) $ccln)))
</span>;;;;;;;;;;;;;;;;;
;;;; Reduction ;;
;;;;;;;;;;;;;;;;;
;;;; Reduction rules to simplify proofs and reduce redundancy
;;;; TODO: these rules should be proven first.  Then they could
;;;; automatically be inserted.
;;;; Involution of symmetry
<span class="ansi38-255165000"
>  (= 
    (Sym (Sym $f)) $f)
</span>;;;; Composition to application
<span class="ansi38-255165000"
>  (= 
    ( ( (. $g) $f) $x) 
    ($g ($f $x)))
</span>;;;; Involution of flip
<span class="ansi38-255165000"
>  (= 
    (flip (flip $f)) $f)
</span>;;;;;;;;;;;;;
;;;; Tests ;;
;;;;;;;;;;;;;
;;;; ;; Synthesize natural numbers
;;;; !(bc (: $prf Nat) (fromNumber 3))
;;;; Synthesize unary functions over natural numbers, that is
;;;; prove (-> (: $k Nat) Nat).
;;;; NEXT: explore lambda abstraction once the PANIC bug is fixed
<span class="ansi38-255165009"
>;; In file as:  
</span><span class="ansi1 ansi38-255238088"
>  !(bc 
    (: $prf 
      (-> 
        (: $k Nat) Nat)) 
    (fromNumber 3))
</span>;; To unit test case:
<span class="ansi38-013099040"
>  !(assertEqualToResult 
    (bc 
      (: $prf 
        (-> 
          (: $k Nat) Nat)) 
      (fromNumber 3)) 
    ( (let* 
        ( ( (: $prfarg#193 
              (=== Nat Nat)) (bc (: $prfarg#193 (=== Nat Nat)) (S (S Z))))) 
        (: 
          ( ( (. Replace) Sym) $prfarg#193) 
          (-> 
            (: $k Nat) Nat))) 
      (: 
        ( (. S) ((. S) S)) 
        (-> 
          (: $k Nat) Nat)) 
      (: 
        ( (. S) ((. S) double)) 
        (-> 
          (: $k Nat) Nat)) 
      (: 
        ( (. S) ((. double) S)) 
        (-> 
          (: $k Nat) Nat)) 
      (: 
        ( (. S) ((. double) double)) 
        (-> 
          (: $k Nat) Nat)) 
      (: 
        ( (. S) S) 
        (-> 
          (: $k Nat) Nat)) 
      (: 
        ( (. S) double) 
        (-> 
          (: $k Nat) Nat)) 
      (: 
        ( (. double) ((. S) S)) 
        (-> 
          (: $k Nat) Nat)) 
      (: 
        ( (. double) ((. S) double)) 
        (-> 
          (: $k Nat) Nat)) 
      (: 
        ( (. double) ((. double) S)) 
        (-> 
          (: $k Nat) Nat)) 
      (: 
        ( (. double) ((. double) double)) 
        (-> 
          (: $k Nat) Nat)) 
      (: 
        ( (. double) S) 
        (-> 
          (: $k Nat) Nat)) 
      (: 
        ( (. double) double) 
        (-> 
          (: $k Nat) Nat)) 
      (let* 
        ( ( (: $prfarg#193 
              (=== Nat Nat)) (bc (: $prfarg#193 (=== Nat Nat)) (S (S Z))))) 
        (: 
          (Replace $prfarg#193) 
          (-> 
            (: $k Nat) Nat))) 
      (: S 
        (-> 
          (: $k Nat) Nat)) 
      (: double 
        (-> 
          (: $k Nat) Nat))))

</span>[

;<h3 id="HOL.NATPARITYTEST.17"
>;; HOL.NATPARITYTEST.17</h3>
; 
; EVAL TEST
; took 1.423 secs. (1423.32 milliseconds) 

  !(assertEqualToResult 
    (bc 
      (: $prf 
        (-> 
          (: $k Nat) Nat)) 
      (fromNumber 3)) 
    ( (let* 
        ( ( (: $prfarg#193 
              (=== Nat Nat)) (bc (: $prfarg#193 (=== Nat Nat)) (S (S Z))))) 
        (: 
          ( ( (. Replace) Sym) $prfarg#193) 
          (-> 
            (: $k Nat) Nat))) 
      (: 
        ( (. S) ((. S) S)) 
        (-> 
          (: $k Nat) Nat)) 
      (: 
        ( (. S) ((. S) double)) 
        (-> 
          (: $k Nat) Nat)) 
      (: 
        ( (. S) ((. double) S)) 
        (-> 
          (: $k Nat) Nat)) 
      (: 
        ( (. S) ((. double) double)) 
        (-> 
          (: $k Nat) Nat)) 
      (: 
        ( (. S) S) 
        (-> 
          (: $k Nat) Nat)) 
      (: 
        ( (. S) double) 
        (-> 
          (: $k Nat) Nat)) 
      (: 
        ( (. double) ((. S) S)) 
        (-> 
          (: $k Nat) Nat)) 
      (: 
        ( (. double) ((. S) double)) 
        (-> 
          (: $k Nat) Nat)) 
      (: 
        ( (. double) ((. double) S)) 
        (-> 
          (: $k Nat) Nat)) 
      (: 
        ( (. double) ((. double) double)) 
        (-> 
          (: $k Nat) Nat)) 
      (: 
        ( (. double) S) 
        (-> 
          (: $k Nat) Nat)) 
      (: 
        ( (. double) double) 
        (-> 
          (: $k Nat) Nat)) 
      (let* 
        ( ( (: $prfarg#193 
              (=== Nat Nat)) (bc (: $prfarg#193 (=== Nat Nat)) (S (S Z))))) 
        (: 
          (Replace $prfarg#193) 
          (-> 
            (: $k Nat) Nat))) 
      (: S 
        (-> 
          (: $k Nat) Nat)) 
      (: double 
        (-> 
          (: $k Nat) Nat))))

<span class="ansi36"
>  (loonit_success  
    (equal_enough_for_test  
      ( (: S 
          (-> 
            (: $_19100 Nat) Nat)) 
        (: double 
          (-> 
            (: $_19040 Nat) Nat)) 
        (: 
          ( (. S) S) 
          (-> 
            (: $_18980 Nat) Nat)) 
        (: 
          ( (. S) double) 
          (-> 
            (: $_18896 Nat) Nat)) 
        (: 
          ( (. S) ((. S) S)) 
          (-> 
            (: $_18812 Nat) Nat)) 
        (: 
          ( (. S) ((. S) double)) 
          (-> 
            (: $_18704 Nat) Nat)) 
        (: 
          ( (. S) ((. double) S)) 
          (-> 
            (: $_18596 Nat) Nat)) 
        (: 
          ( (. S) ((. double) double)) 
          (-> 
            (: $_18488 Nat) Nat)) 
        (: 
          ( (. double) S) 
          (-> 
            (: $_18380 Nat) Nat)) 
        (: 
          ( (. double) double) 
          (-> 
            (: $_18296 Nat) Nat)) 
        (: 
          ( (. double) ((. S) S)) 
          (-> 
            (: $_18212 Nat) Nat)) 
        (: 
          ( (. double) ((. S) double)) 
          (-> 
            (: $_18104 Nat) Nat)) 
        (: 
          ( (. double) ((. double) S)) 
          (-> 
            (: $_17996 Nat) Nat)) 
        (: 
          ( (. double) ((. double) double)) 
          (-> 
            (: $_17888 Nat) Nat)) 
        (: 
          ( ( (flip .) S) S) 
          (-> 
            (: $_17780 Nat) Nat)) 
        (: 
          ( ( (flip .) S) double) 
          (-> 
            (: $_17684 Nat) Nat)) 
        (: 
          ( ( (flip .) S) ((. S) S)) 
          (-> 
            (: $_17588 Nat) Nat)) 
        (: 
          ( ( (flip .) S) ((. S) double)) 
          (-> 
            (: $_17468 Nat) Nat)) 
        (: 
          ( ( (flip .) S) ((. double) S)) 
          (-> 
            (: $_17348 Nat) Nat)) 
        (: 
          ( ( (flip .) S) ((. double) double)) 
          (-> 
            (: $_17228 Nat) Nat)) 
        (: 
          ( ( (flip .) double) S) 
          (-> 
            (: $_17108 Nat) Nat)) 
        (: 
          ( ( (flip .) double) double) 
          (-> 
            (: $_17012 Nat) Nat)) 
        (: 
          ( ( (flip .) double) ((. S) S)) 
          (-> 
            (: $_16916 Nat) Nat)) 
        (: 
          ( ( (flip .) double) ((. S) double)) 
          (-> 
            (: $_16796 Nat) Nat)) 
        (: 
          ( ( (flip .) double) ((. double) S)) 
          (-> 
            (: $_16676 Nat) Nat)) 
        (: 
          ( ( (flip .) double) ((. double) double)) 
          (-> 
            (: $_16556 Nat) Nat)) 
        (: 
          ( ( (flip flip) S) (flip (. S))) 
          (-> 
            (: $_16436 Nat) Nat)) 
        (: 
          ( ( (flip flip) S) (flip (. double))) 
          (-> 
            (: $_16316 Nat) Nat)) 
        (: 
          ( ( (flip flip) double) (flip (. S))) 
          (-> 
            (: $_16196 Nat) Nat)) 
        (: 
          ( ( (flip flip) double) (flip (. double))) 
          (-> 
            (: $_16076 Nat) Nat))) 
      ( (let* 
          ( ( (: $_8114 
                (=== Nat Nat)) (bc (: $_8114 (=== Nat Nat)) (S (S Z))))) 
          (: 
            ( ( (. Replace) Sym) $_8114) 
            (-> 
              (: $_8024 Nat) Nat))) 
        (: 
          ( (. S) ((. S) S)) 
          (-> 
            (: $_8024 Nat) Nat)) 
        (: 
          ( (. S) ((. S) double)) 
          (-> 
            (: $_8024 Nat) Nat)) 
        (: 
          ( (. S) ((. double) S)) 
          (-> 
            (: $_8024 Nat) Nat)) 
        (: 
          ( (. S) ((. double) double)) 
          (-> 
            (: $_8024 Nat) Nat)) 
        (: 
          ( (. S) S) 
          (-> 
            (: $_8024 Nat) Nat)) 
        (: 
          ( (. S) double) 
          (-> 
            (: $_8024 Nat) Nat)) 
        (: 
          ( (. double) ((. S) S)) 
          (-> 
            (: $_8024 Nat) Nat)) 
        (: 
          ( (. double) ((. S) double)) 
          (-> 
            (: $_8024 Nat) Nat)) 
        (: 
          ( (. double) ((. double) S)) 
          (-> 
            (: $_8024 Nat) Nat)) 
        (: 
          ( (. double) ((. double) double)) 
          (-> 
            (: $_8024 Nat) Nat)) 
        (: 
          ( (. double) S) 
          (-> 
            (: $_8024 Nat) Nat)) 
        (: 
          ( (. double) double) 
          (-> 
            (: $_8024 Nat) Nat)) 
        (let 
          (: $_8114 
            (=== Nat Nat)) 
          (bc 
            (: $_8114 
              (=== Nat Nat)) 
            (S (S Z))) 
          (: 
            (Replace $_8114) 
            (-> 
              (: $_8024 Nat) Nat))) 
        (: S 
          (-> 
            (: $_8024 Nat) Nat)) 
        (: double 
          (-> 
            (: $_8024 Nat) Nat)))))
</span>
Deterministic: ()
()]
;;;; ;; Prove that 0 is even
<span class="ansi32"
>% 10,488,080 inferences, 1.982 CPU in 1.982 seconds (100% CPU, 5291744 Lips)
</span>P;HTML|
;                         (= /home/runner/work/metta-wam/metta-wam/tests/extended_compat/hyperon-pln/metta/hol/NatParityTest.metta  0)
<span class="ansi1"
>LoonIt Report
</span>------------
<span class="ansi32"
>Successes: 17
</span><span class="ansi32"
>Failures: 0
</span><br/> <a href="#" onclick="window.history.back(); return false;"
>Return to summaries</a><br/>
P;HTML|
;           (is_cmd_option  execute halt --halt=true true)
P;HTML|
;            (set_option_value  halt true)
P;HTML|
;            (is_cmd_option  execute stdin --stdin=tty tty)
P;HTML|
;            (set_option_value  stdin tty)
P;HTML|
;            (is_cmd_option  execute stdout --stdout=tty tty)
P;HTML|
;             (set_option_value  stdout tty)
P;HTML|
;            (is_cmd_option  execute stderr --stderr=tty tty)
P;HTML|
;             (set_option_value  stderr tty)
P;HTML|
;           (set_option_value  prolog false)
P;HTML|
;           (set_option_value  compat auto)
P;HTML|
;           (set_option_value  compatio true)

Script done on 2024-09-23 01:16:45+00:00 [COMMAND_EXIT_CODE="7"]

</pre>
</body>

</html>
\033[0;32mCompleted successfully (EXITCODE=7) Under 40 seconds: ./mettalog '--output=./reports/tests_output/baseline-compat-2024-09-23T00:34:11/' --timeout=40 --html --repl=false  --test "tests/extended_compat/hyperon-pln/metta/hol/NatParityTest.metta" --halt=true\033[0m
